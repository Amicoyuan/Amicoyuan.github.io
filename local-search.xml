<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CUDA线程管理</title>
    <link href="/2023/01/28/cuda006/"/>
    <url>/2023/01/28/cuda006/</url>
    
    <content type="html"><![CDATA[<h3 id="1-线程管理"><a href="#1-线程管理" class="headerlink" title="1.线程管理"></a>1.线程管理</h3><p>当核函数在主机端启动时，它的执行会移动到设备上，此时设备中会产生大量的线程并且每个线程都执行由核函数指定的语句。了解如何组织线程是CUDA编程的一个关键部分。CUDA明确了线程层次抽象的概念以便于你组织线程。这是一个两层的线程层次结构，由线程块和线程块网格构成，如图2-5所示。</p><p><img src="/2023/01/28/cuda006/image-20230128160011560.png" alt="image-20230128160011560"></p><p>由一个内核启动所产生的所有线程统称为一个网格。同一网格中的所有线程共享相同的全局内存空间。一个网格由多个线程块构成，一个线程块包含一组线程，同一线程块内的线程协作可以通过以下方式来实现。</p><p>​-同步</p><p>​-共享内存</p><p>不同块内的线程不能协作。</p><p>线程依靠以下两个坐标变量来区分彼此。</p><p>​-blockIdx(线程块在线程格内的索引)</p><p>​-threadIdx(块内的线程索引)</p><p>这些变量是核函数中需要预初始化的内置变量。当执行一个核函数时，CUDA运行时为每个线程分配坐标变量blockIdx和threadIdx。基于这些坐标，你可以将部分数据分配给不同的线程。</p><p>该坐标变量是基于uint3定义的CUDA内置的向量类型，是一个包含3个无符号整数的结构，可以通过x,y,z三个字段来指定。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">blockIdx.x<br>blockIdx.y<br>blockIdx.z<br>threadIdx.x<br>threadIdx.y<br>threadIdx.z<br></code></pre></div></td></tr></table></figure><p>CUDA可以组织三维的网格和块。图2-5展示了一个线程层次结构的示例，其结构是一个包含二维块的二维网格。网格和块的维度由下列两个内置变量指定。</p><p>​-blockDim(线程块的维度，用每个线程块中的线程数来表示)</p><p>​-gridDim(线程格的维度，用每个线程格中的线程数来表示)</p><p>它们是dim3类型的变量，是基于uint3定义的整数型向量，用来表示维度。当定义一个dim3类型的变量时，所有未指定的元素都被初始化为1。dim3类型变量中的每个组件可以通过它的x,y,z字段获得。如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">blockDim.x<br>blockDim.y<br>blockDim.z<br></code></pre></div></td></tr></table></figure><h3 id="2-网格和线程块的维度"><a href="#2-网格和线程块的维度" class="headerlink" title="2.网格和线程块的维度"></a>2.网格和线程块的维度</h3><p>通常，一个线程格会被组织成线程块的二维数组形式，一个线程块会被组织成线程的三维数组形式。</p><p>线程格和线程块均使用3个dim3类型的无符号整型字段，而未使用的字段将被初始化为1且忽略不计。</p><p>在CUDA程序中有两组不同的网格和块变量：手动定义的dim3数据类型和预定义的uint3数据类型。在主机端，作为内核调用的一部分，你可以使用dim3数据类型定义一个网格和块的维度。当执行核函数时，CUDA运行时会生成相应的内置预初始化的网格，块和线程变量，它们在核函数内均可被访问到且为unit3类型。手动定义的dim3类型的网络和块变量仅在主机端可见，而unit3类型的内置预初始化的网格和块变量仅在设备端可见。</p><p>你可以通过代码清单2-2来验证这些变量如何使用。首先，定义程序所用的数据大小，为了对此进行说明，我们定义一个较小的数据。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> nElem = <span class="hljs-number">6</span>;<br></code></pre></div></td></tr></table></figure><p>接下来，定义块的尺寸并基于块和数据的大小计算网格尺寸。在下面例子中，定义了一个包含3个线程的一维线程块，以及一个基于块和数据大小定义的一定数量线程块的一维线程网格。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">((nElem+block.x<span class="hljs-number">-1</span>)/block.x)</span></span>;<br></code></pre></div></td></tr></table></figure><p>你会发现网格大小是块大小的倍数。以下主机端上的程序段用来检查网格和块维度。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d grid.y %d grid.z %d\n&quot;</span>,grid.x,grid.y,grid.z);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;block.x %d block.y %d block.z %d\n&quot;</span>,block.x,block.y,block.z);<br></code></pre></div></td></tr></table></figure><p>在核函数中，每个线程都输出自己的线程索引，块索引，块维度和网格维度。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;threadIdx:(%d, %d, %d) blockIdx:(%d, %d, %d) blockDim:(%d, %d, %d) &quot;</span> <span class="hljs-string">&quot;gridDim:(%d, %d, %d)\n&quot;</span>, threadIdx.x, threadIdx,y, threadIdz.z,blockIdx.x, blockIdx.y, blockIdx.z, blockDim.x, blockDim.y, blockDim.z, gridDim.x,gridDim.y,gridDim.z);<br></code></pre></div></td></tr></table></figure><p>把代码合并保存成名为checkDimension.cu的文件，如代码清单2-2所示。</p><p><strong>代码清单2-2     检查网络和块的索引和维度（checkDimension.cu）</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">checkIndex</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;threadIdx:(%d, %d, %d) blockIdx:(%d, %d, %d) blockDim:(%d, %d, %d) &quot;</span> <span class="hljs-string">&quot;gridDim:(%d, %d, %d)\n&quot;</span>, threadIdx.x, threadIdx,y, threadIdz.z, blockIdx.x, blockIdx.y, blockIdx.z, blockDim.x, blockDim.y, blockDim.z, gridDim.x,gridDim.y,gridDim.z);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-comment">//define total data element</span><br>    <span class="hljs-keyword">int</span> nElem = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">//define grid and block structure</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">((nElem+block.x<span class="hljs-number">-1</span>)/block.x)</span></span>;<br>    <br>    <span class="hljs-comment">//check grid and block dimension from host side</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d grid.y %d grid.z %d\n&quot;</span>,grid.x,grid.y,grid.z);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;block.x %d block.y %d block.z %d\n&quot;</span>,block.x,block.y,block.z);<br><br>    <span class="hljs-comment">//check grid and block dimension from device side</span><br>    checkIndex&lt;&lt;&lt;grid, block&gt;&gt;&gt;();<br>    <br>    <span class="hljs-comment">//reset device before you leave</span><br>    <span class="hljs-built_in">cudaDeviceReset</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在开始编译和运行这段程序：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc -arch=sm_20 checkDimension.cu -o check<br>./check<br></code></pre></div></td></tr></table></figure><p>因为printf函数只支持Fermi及以上版本的GPU架构，所以必须添加-arch&#x3D;sm_20编译器选项。默认情况下，nvcc会产生支持最低版本GPU架构的代码。这个应用程序的运行结果如下。可以看到，每个线程都有自己的坐标，所有的线程都有相同的块维度和网格维度。</p><p><img src="/2023/01/28/cuda006/image-20230129172501750.png" alt="image-20230129172501750"></p><h3 id="3-从主机端和设备端访问网格-x2F-块变量"><a href="#3-从主机端和设备端访问网格-x2F-块变量" class="headerlink" title="3.从主机端和设备端访问网格&#x2F;块变量"></a>3.从主机端和设备端访问网格&#x2F;块变量</h3><p>区别主机端和设备端的网格和块变量的访问是很重要的。例如，声明一个主机端的块变量，你按如下定义它的坐标并对其进行访问：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">block.x,block.y,block.z<br></code></pre></div></td></tr></table></figure><p>在设备端，你已经预定义了内置块变量的大小：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">blockDim.x,blockDim.y,blockDim.z<br></code></pre></div></td></tr></table></figure><p>总之，在启动内核之前就定义了主机端的网格和块变量，并从主机端通过由x,y,z三个字段决定的矢量结构来访问它们。当内核启动时，可以使用内核中预初始化的内置变量。</p><p>对于一个给定的数据大小，确定网格和块尺寸的一般步骤为：</p><p>​-确定块的大小</p><p>​-在已知数据大小和块大小的基础上计算网格维度</p><p>要确定块尺寸，通常需要考虑：</p><p>​-内核的性能特性</p><p>​-GPU资源的限制</p><p>代码清单2-3使用了一个一维网格和一个一维块来说明当块的大小改变时，网格的尺寸也会随之改变。</p><p><strong>代码清单2-3 在主机上定义网格和块的大小（defineGridBlock.cu）</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-comment">//define total data element</span><br>    <span class="hljs-keyword">int</span> nElem = <span class="hljs-number">1024</span>;<br>    <br>    <span class="hljs-comment">//define grid and block structure</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">1024</span>)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span> <span class="hljs-params">((nElem+block.x<span class="hljs-number">-1</span>)/block.x)</span></span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d block.x %d \n&quot;</span>,grid.x, block.x);<br>    <br>    <span class="hljs-comment">//reset block</span><br>    block.x = <span class="hljs-number">512</span>;<br>    grid.x = (nElem+block.x<span class="hljs-number">-1</span>)/block.x;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d block.x %d \n&quot;</span>,grid.x, block.x);<br>    <br>    <span class="hljs-comment">//reset block</span><br>    block.x = <span class="hljs-number">256</span>;<br>    grid.x = (nElem+block.x<span class="hljs-number">-1</span>)/block.x;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d block.x %d \n&quot;</span>,grid.x, block.x);<br>    <br>    <span class="hljs-comment">//reset block</span><br>    block.x = <span class="hljs-number">128</span>;<br>    grid.x = (nElem+block.x<span class="hljs-number">-1</span>)/block.x;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d block.x %d \n&quot;</span>,grid.x, block.x);<br>    <br>    <span class="hljs-comment">//reset device before you leave</span><br>    <span class="hljs-built_in">cudaDeviceReset</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>用下列命令编译和运行这段程序：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc defineGridBlock.cu-o block<br>./block<br></code></pre></div></td></tr></table></figure><p>下面是一个输出示例。由于应用程序中的数据大小是固定的，因此当块的大小发生改变时，相应的网格尺寸也会发生改变。</p><p><img src="/2023/01/28/cuda006/image-20230129174300533.png" alt="image-20230129174300533"></p><h3 id="4-线程层次结构"><a href="#4-线程层次结构" class="headerlink" title="4.线程层次结构"></a>4.线程层次结构</h3><p>CUDA的特点之一就是通过编程模型揭示了一个两层的线程层次结构。由于一个内核启动的网格和块的维数会影响性能，这一结构为程序员优化程序提供了一个额外的途径。</p><p>网格和块的维度存在几个限制因素，对于块大小的一个主要限制因素就是可利用的计算资源，如寄存器，共享内存等。某些限制可以通过查询GPU设备撤回。</p><p>网格和块从逻辑上代表了一个核函数的线程层次结构。</p><h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用AVX和AVX2处理数据(个人翻译)[未完成]</title>
    <link href="/2023/01/28/avx006/"/>
    <url>/2023/01/28/avx006/</url>
    
    <content type="html"><![CDATA[<h2 id="1-文章来源"><a href="#1-文章来源" class="headerlink" title="1.文章来源"></a>1.文章来源</h2><p><strong>Matt Scarpino</strong></p><p><a href="https://www.codeproject.com/Articles/874396/Crunching-Numbers-with-AVX-and-AVX">Crunching Numbers with AVX and AVX2 - CodeProject</a></p><h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h2><p>在2003年，<a href="https://www.codeproject.com/script/Membership/View.aspx?mid=22834">Alex Fr</a>写了一篇优秀的<a href="https://www.codeproject.com/Articles/4522/Introduction-to-SSE-Programming">文章</a>[该文章现在已经被原作者删除]，解释了如何使用Intel的流式SIMD扩展(SSE)执行SIMD(单指令，多数据)处理。SSE是英特尔处理器支持的一组指令，可对大量数据执行高速运算。</p><p>2008年，英特尔推出了一套新的高性能指令，称为高级向量扩展(AVX)。AVX执行许多与SSE指令相同的操作，但以更快的速度对更大的数据块进行操作。最近，英特尔在AVX2和AVX512系列中发布了额外的指令。本文的重点是通过称为intrinsic funtions的特殊C函数访问AVX和AVX2指令。</p><p>本文不介绍整个AVX&#x2F;AVX2 intrinsics，而是侧重于数学计算。特别地，目标是复数相乘。要使用AVX&#x2F;AVX2执行此操作，需要三种类型的intrinsic:</p><ol><li>Initialization intrinscis</li><li>Arithmetic intrinsics</li><li>Permute&#x2F;shuffle intrinsics</li></ol><p></p><p>本文讨论每个类别中的intrinsics，并解释如何在代码中使用它们。本文的最后将展示如何用这些intrinsic进行乘法复数运算。</p><p>理解处理器指令和intrinsic function之间的区别是很重要的。AVX指令是执行不可分割操作的汇编命令。例如，AVX指令vaddps添加了两个操作数，并将结果放在第三个操作数中。</p><p>要在C&#x2F;C++中执行操作，the intrinsic funtion _mm256_add_ps()直接映射到vaddps，将汇编的性能与高级函数的便利性结合起来。An intrinsic funtion不一定映射到单个指令，但与其他C&#x2F; C++函数相比，AVX&#x2F;AVX2 intrinsics提供了可靠的高性能。</p><h2 id="3-基本要求"><a href="#3-基本要求" class="headerlink" title="3.基本要求"></a>3.基本要求</h2><p>要理解本文的内容，您需要基本熟悉C语言和SIMD处理。要执行代码，您需要一个支持AVX或AVX&#x2F;AVX2的CPU。以下是支持AVX的cpu:</p><ul><li>Intel’s Sandy Bridge&#x2F;Sandy Bridge E&#x2F;Ivy Bridge&#x2F;Ivy Bridge E</li><li>Intel’s Haswell&#x2F;Haswell E&#x2F;Broadwell&#x2F;Broadwell E</li><li>AMD’s Bulldozer&#x2F;Piledriver&#x2F;Steamroller&#x2F;Excavator</li></ul><p>支持AVX2的CPU也支持AVX。以下是这些设备:</p><ul><li>Intel’s Haswell&#x2F;Haswell E&#x2F;Broadwell&#x2F;Broadwell E</li><li>AMD’s Excavator</li></ul><p>本文中讨论的大多数函数都是由AVX提供的。但也有一些是AVX2特有的。为了区分它们，在本文的表中，我在AVX2 intrinsic的名称前面加上(2)。</p><p>[个人补充]</p><p>判断自己电脑CPU是否支持AVX和AVX2，最简单的就是在命令行执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">lscpu<br></code></pre></div></td></tr></table></figure><p>你会得到以下结果：</p><p><img src="/2023/01/28/avx006/image-20230129153048825.png" alt="image-20230129153048825"></p><p>在Flags里面你可以清楚的看到你的电脑是否支持AVX以及AVX2。</p><h2 id="4-向量化概述"><a href="#4-向量化概述" class="headerlink" title="4.向量化概述"></a>4.向量化概述</h2><p>AVX指令通过同时处理大块值而不是单独处理值来提高应用程序的性能。这些值块称为向量，AVX向量最多可以包含256位数据。</p><p>常见的AVX向量包含4个double (4 x 64位&#x3D; 256)，8个float (8 x 32位&#x3D; 256)或8个int (8 x 32位&#x3D; 256)。[double 8B, flout 4B, int 4B]</p><p>一个示例将演示AVX&#x2F;AVX2处理的强大功能。假设一个函数需要将一个数组的8个浮点数乘以第二个数组的8个浮点数，并将结果添加到第三个数组。如果没有向量化，函数可能是这样的:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">multiply_and_add</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>* a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>* b, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>* c, <span class="hljs-keyword">float</span>* d) &#123;  <br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++) &#123;<br>    d[i] = a[i] * b[i];<br>    d[i] = d[i] + c[i];<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是使用AVX2函数的例子:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__m256 <span class="hljs-title">multiply_and_add</span><span class="hljs-params">(__m256 a, __m256 b, __m256 c)</span> </span>&#123;<br><br>  <span class="hljs-keyword">return</span> _mm256_fmadd_ps(a, b, c);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>This AVX2 intrinsic funtion _mm256_fmadd_ps处理24个floats，但它不映射到单个指令。相反，它执行三个指令:vfmadd132ps、vfmadd213ps和vfmadd231ps。尽管如此，它执行得很快，比遍历单个元素快得多。尽管英特尔的intrinsics功能强大，但它们还是让许多程序员感到紧张。这通常有两个原因。首先，数据类型有奇怪的名字，比如__m256。其次，函数有奇怪的名称，如_mm256_fmadd_ps。因此，在详细讨论intrinsic funtions之前，我想先讨论一下Intel的数据类型和命名约定。</p><h2 id="5-AVX编程基础"><a href="#5-AVX编程基础" class="headerlink" title="5.AVX编程基础"></a>5.AVX编程基础</h2><p>本文主要关注AVX和AVX2提供的与数学相关的intrinsic functions。但在看函数之前，有三点很重要:</p><ul><li>Data types</li><li>Function naming conventions</li><li>Compiling AVX applications</li></ul><p>本节涉及这些要点，并提供一个简单的应用程序，用于从一个向量减去另一个向量。</p><h3 id="5-1数据类型"><a href="#5-1数据类型" class="headerlink" title="5.1数据类型"></a>5.1数据类型</h3><p>少数intrinsic接受传统的数据类型，如ints或floats，但大多数intrinsic操作有特定的AVX和AVX2的数据类型。有六种主要的向量类型，表1列出了它们。</p><p><strong>Table 1:AVX&#x2F;AVX2 Data Types</strong></p><table><thead><tr><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td><code>__m128</code></td><td>128-bit vector containing 4 <code>float</code>s</td></tr><tr><td><code>__m128d</code></td><td>128-bit vector containing 2 <code>double</code>s</td></tr><tr><td><code>__m128i</code></td><td>128-bit vector containing integers</td></tr><tr><td><code>__m256</code></td><td>256-bit vector containing 8 <code>float</code>s</td></tr><tr><td><code>__m256d</code></td><td>256-bit vector containing 4 <code>double</code>s</td></tr><tr><td><code>__m256i</code></td><td>256-bit vector containing integers</td></tr></tbody></table><p>每种类型都以两个下划线、一个m和向量的宽度(以位为单位)开始。AVX512支持以_m512开头的512位向量类型，但AVX&#x2F;AVX2向量不超过256位。如果向量类型以d结尾，则代表double，如果没有后缀，则代表float。看起来_m128i和_m256i向量必须包含int型，但事实并非如此。整数向量类型可以包含任何类型的整数，from chars to shorts to unsigned long longs.That is, an _m256i may contain 32 chars, 16 shorts, 8 ints, or 4 longs.  These integers can be signed or unsigned.</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
      <tag>AVX2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA内存管理</title>
    <link href="/2023/01/17/cuda005/"/>
    <url>/2023/01/17/cuda005/</url>
    
    <content type="html"><![CDATA[<h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1.内存管理"></a>1.内存管理</h3><p>CUDA编程模型假设系统是由一个主机和一个设备组成的，而且各自拥有独立的内存。核函数是在设备上运行的。为使你拥有充分的控制权并使系统达到最佳性能，CUDA运行时负责分配与释放设备内存，并且在主机内存和设备内存之间传输数据。表2-1列出了标准的C函数以及相应地针对内存操作的CUDA C函数。</p><p>用于执行GPU内存分配的是cudaMalloc函数，其函数原型为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">cudaError_t <span class="hljs-title">cudaMalloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>** devPtr, <span class="hljs-keyword">size_t</span> size)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/2023/01/17/cuda005/image-20230117223254853.png" alt="image-20230117223254853"></p><p>该函数负责向设备分配一定字节的线性内存，并以devPtr的形式返回指向所分配内存的指针。cudaMalloc与标准C语言中的malloc函数几乎一样，只是此函数在GPU的内存里分配内存。通过充分保持与标准C语言运行库中的接口一致性，可以实现CUDA应用程序的轻松接入。</p><p>cudaMemcpy函数负责主机和设备之间的数据传输，其函数原型为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">cudaError_t <span class="hljs-title">cudaMencpy</span><span class="hljs-params">( <span class="hljs-keyword">void</span>* dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* src, <span class="hljs-keyword">size_t</span> count, cudaMemcpyKind kind)</span></span><br></code></pre></div></td></tr></table></figure><p>此函数从src指向的源存储区复制一定数量的字节到dst指向的目标存储区。复制方向由kind指定，其中的kind有以下几种。</p><ol><li>cudaMemcpyHostToHost</li><li>cudaMemcpyHostToDevice</li><li>cudaMemcpyDeviceToHost</li><li>cudaMemcpyDeviceToDevice</li></ol><p>这个函数以同步方式执行，因为在cudaMemcpy函数返回以及传输操作完成之前主机应用程序是阻塞的。除了内核启动之外的CUDA调用都会返回一个错误的枚举类型cudaError_t。如果GPU内存分配成功，函数返回：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">cudaSuccess<br></code></pre></div></td></tr></table></figure><p>否则返回：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">cudaErrorMemoryAllocation<br></code></pre></div></td></tr></table></figure><p>可以使用以下CUDA运行时函数将错误代码转化为可读的错误消息：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">cudaGetErroeString</span><span class="hljs-params">(cudaError_t error)</span></span><br></code></pre></div></td></tr></table></figure><p>cudaGetErrorString函数和C语言中的strerror函数类似。</p><p>CUDA编程模型从GPU架构中抽象出一个内存层次结构，图2-3所示的是一个简化的GPU内存结构，它主要包含两部分：全局内存和共享内存。</p><h3 id="2-内存层次结构"><a href="#2-内存层次结构" class="headerlink" title="2.内存层次结构"></a>2.内存层次结构</h3><p>CUDA编程模型最显著的一个特点就是揭示了内存层次结构。每一个GPU设备都有用于不同用途的存储类型。</p><p>在GPU内存层次结构中，最主要的两种内存是全局内存和共享内存。全局类似于CPU的系统内存，而共享内存类似于CPU的缓存。然而GPU的共享内存可以由CUDA C的内核直接控制。</p><p><img src="/2023/01/17/cuda005/image-20230128140743600.png" alt="image-20230128140743600"></p><p>下面，我们将通过一个简单的两个数组相加的例子来学习如何在主机和设备之间进行数据传输，以及如何使用CUDA C编程。如图2-4所示，数组a的第一个元素与数组b的第一个元素相加，得到的结果作为数组c的第一个元素，重复这个过程直到数组中的所有元素都进行了一次运算。‘</p><p><img src="/2023/01/17/cuda005/image-20230128141008674.png" alt="image-20230128141008674"></p><p>首先，执行主机端代码使两个数组相加（如代码清单2-1所示）。</p><h4 id="代码清单2-1-sumArraysOnHost-c"><a href="#代码清单2-1-sumArraysOnHost-c" class="headerlink" title="代码清单2-1 sumArraysOnHost.c"></a>代码清单2-1 sumArraysOnHost.c</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sumArraysOnHost</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, <span class="hljs-keyword">float</span> *C, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> idx=<span class="hljs-number">0</span>;idx&lt;n;idx++)<br>        C[idx]=A[idx]+B[idx];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialData</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *ip,<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>    <span class="hljs-comment">//generate different seed for random number time_t t;</span><br>    <span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) <span class="hljs-built_in">time</span> (&amp;t));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        ip[i]=(<span class="hljs-keyword">float</span>)(<span class="hljs-built_in">rand</span>() &amp; OxFF)/<span class="hljs-number">10.0f</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> nElem =<span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">size_t</span> nBytes = nElem *<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>);<br>    <br>    <span class="hljs-keyword">float</span> *h_A, *h_B, *h_C;<br>    h_A = (<span class="hljs-keyword">float</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    h_B = (<span class="hljs-keyword">float</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    h_C = (<span class="hljs-keyword">float</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    <br>    <span class="hljs-built_in">initialData</span>(h_A, nElem);<br>    <span class="hljs-built_in">initialData</span>(h_B, nElem);<br>    <br>    <span class="hljs-built_in">sumArraysOnHost</span>(h_A, h_B, h_C, nElem);<br>    <br>    <span class="hljs-built_in">free</span>(h_A);<br>    <span class="hljs-built_in">free</span>(h_B);<br>    <span class="hljs-built_in">free</span>(h_C);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>这是一个纯C语言编写的程序，你可以用C语言编译器进行编译，也可以像下面这样用nvcc进行编译。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc -Xcompiler -std=c99 sumArraysOnHost.c -o sum<br>./sum<br></code></pre></div></td></tr></table></figure><p>nvcc封装了几种内部编译工具，CUDA编译器允许通过命令行选项在不同阶段启动不同的工具完成编译工作。-Xcompiler用于指定命令行选项是指向C编译器还是预处理器。在前面的例子中，将-std&#x3D;c99传递给编译器，因为这里的C程序是按照C99标准编写的。</p><p>现在，你可以在GPU上修改代码来进行数组加法运算，用cudaMalloc在GPU上申请内存。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">float</span> *h_A, *h_B, *h_C;<br><span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_A, nBytes);<br><span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_B, nBytes);<br><span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_C, nBytes);<br></code></pre></div></td></tr></table></figure><p>使用cudaMemcpy函数把数据从主机内存拷贝到GPU的全局内存中，参考cudaMemcpyHostToDevice指定数据拷贝方向。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">cudaMemcpy</span>(d_A, h_A, nBytes, cudaMemcpyHostToDevice);<br><span class="hljs-built_in">cudaMemcpy</span>(d_B, h_B, nBytes, cudaMemcpyHostToDevice);<br></code></pre></div></td></tr></table></figure><p>当数据被转移到GPU的全局内存后，主机端调用核函数在GPU上进行数组求和。一旦内核被调用，控制权立刻被传回主机，这样的话，当核函数在GPU上运行时，主机可以执行其他函数。因此，内核与主机是异步的。</p><p>当内核在GPU上完成了对所有数组元素的处理后，其结果将以数组d_C的形式存储在GPU的全局内存中，然后用cudaMemcpy函数把结果从GPU复制回到主机的数组gpuRef中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">cudaMemcpy</span>(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost);<br></code></pre></div></td></tr></table></figure><p>cudaMemcpy的调用会导致主机运行阻塞。cudaMemcpyDeviceToHost的作用就是将存储在GPU上的数组d_C中的结果复制到gpuRef中。最后，调用cudaFree释放GPU的内存。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">cudaFree</span>(d_A);<br><span class="hljs-built_in">cudaFree</span>(d_B);<br><span class="hljs-built_in">cudaFree</span>(d_C);<br></code></pre></div></td></tr></table></figure><h3 id="3-不同的存储空间"><a href="#3-不同的存储空间" class="headerlink" title="3.不同的存储空间"></a>3.不同的存储空间</h3><p>使用CUDA C进行编程的人最常犯的错误就是对不同内存空间的不恰当引用。对于在GPU上被分配的内存来说，设备指针在主机代码中可能并没有被引用。如果你执行了错误的内存分配，如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">gpuRef = d_C<br></code></pre></div></td></tr></table></figure><p>而不是用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">cudaMemcpy</span>(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost);<br></code></pre></div></td></tr></table></figure><p>应用程序在运行时将会崩溃。</p><p>为了避免这类错误，CUDA6.0提出了统一寻址，使用一个指针来访问CPU和GPU的内存</p><h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4.参考资料"></a>4.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA编程结构</title>
    <link href="/2023/01/17/cuda004/"/>
    <url>/2023/01/17/cuda004/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA编程结构"><a href="#CUDA编程结构" class="headerlink" title="CUDA编程结构"></a>CUDA编程结构</h2><p>CUDA编程模型使用由C语言扩展生成的注释代码在异构计算系统中执行应用程序。</p><p>在一个异构环境中包含多个CPU和GPU，每个GPU和CPU的内存都由一条PCI-Express总线分隔开。因此，需要注意区别以下内容。</p><ol><li>主机：CPU及其内存（主机内存）</li><li>设备：GPU及其内存（设备内存）</li></ol><p>为了清楚地指明不同的内存空间，在本书的示例代码中，主机内存中的变量名以h__为前缀，设备内存中的变量名以d__为前缀。</p><p>从CUDA6.0开始，NVDIA提出了名为“统一寻址”（Unified Memory）的编程模型的改进，它连接了主机内存和设备内存空间，可使用单个指针访问CPU和GPU内存，无须彼此之间手动拷贝数据。现在，重要的是应学会如何为主机和设备分配内存空间以及如何在CPU和GPU之间拷贝共享数据。这种程序员管理模式控制下的内存和数据可以优化应用程序并实现硬件系统利用率的最大化。</p><p>内核（kernel）是CUDA编程模型的一个重要组成部分，其代码在GPU上运行。作为一个开发人员，你可以串行的执行核函数。在此背景下，CUDA的调度管理程序员在GPU线程上编写核函数。在主机上，基于应用程序数据以及GPU的性能定义如何让设备实现算法功能。这样做的目的是使你专注于算法的逻辑（通过编写串行代码），且在创建和管理大量的GPU线程时不必拘泥于细节。</p><p>多数情况下，主机可以独立地对设备进行操作。内核一旦被启动，端粒权立刻返回给主机，释放CPU来执行由设备上运行的并行代码实现的额外的任务。CUDA编程模型主要是异步的，因此在GPU上进行的运算可以与主机-设备通信重叠。一个典型的CUDA程序包括由并行代码互补的串行代码。如图2-2所示，串行代码（及任务并行代码）在主机CPU上执行，而并行代码在GPU上执行。主机代码按照ANSI C标准进行编写，而设备代码使用CUDA C进行编写。你可以将所有的代码统一放在一个源文件中，也可以使用多个源文件来构建应用程序和库。NVIDIA的C编译器(nvcc)为主机和设备生成可执行代码。</p><p>一个典型的CUDA程序实现流程遵循以下模式</p><ol><li>把数据从CPU内存拷贝到GPU内存</li><li>调用核函数对存储在GPU内存中的数据进行操作</li><li>将数据从GPU内存传送回到CPU内存</li></ol><p>首先，你要学习的是内存管理及主机和设备之间的数据传输。</p><p><img src="/2023/01/17/cuda004/image-20230117220146068.png" alt="image-20230117220146068"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA编程模型概述</title>
    <link href="/2023/01/17/cuda003/"/>
    <url>/2023/01/17/cuda003/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA编程模型概述"><a href="#CUDA编程模型概述" class="headerlink" title="CUDA编程模型概述"></a>CUDA编程模型概述</h2><p>CUDA编程模型提供了一个计算机架构抽象作为应用程序和其可用硬件之间的桥梁。图2-1说明了程序和编程模型实现之间的抽象结构的重要。通信抽象是程序与编程模型实现之间的分界线，它通过专业的硬件原语和操作系统的编译器或库来实现。利用编程模型所编写的程序指定了程序的各组成部分是如何共享信息及相互协作的。编程模型从逻辑上提供了一个特定的计算机架构，通常它体现在编程语言或编程环境中。</p><p><img src="/2023/01/17/cuda003/image-20230117203406633.png" alt="image-20230117203406633"></p><p>除了与其他并行编程模型共有的抽象外，CUDA编程模型还利用GPU架构的计算能力提供了以下几个特有功能。</p><ol><li>一种通过层次结构在GPU中组织线程的方法</li><li>一种通过层次结构在GPU中访问内存的方法</li></ol><p>以程序员的角度可以从以下几个不同的层面来看待并行计算。</p><ol><li>领域层</li><li>逻辑层</li><li>硬件层</li></ol><p>在编程与算法设计的过程中，你最关心的应是在领域层如何解析数据和函数，以便在并行环境中能正确，高效地解决问题。当进入编程阶段，你的关注点应转向如何组织并发线程。在这个阶段，你需要从逻辑层面来思考，以确保你的线程和计算能正确地解决问题。在C语言并行编程中，需要使用pthreads或OpenMP技术来显式地管理线程。CUDA提出了一个线程层次结构抽象的概念，以允许控制线程行为。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA:一种异构计算平台</title>
    <link href="/2023/01/16/cuda002/"/>
    <url>/2023/01/16/cuda002/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA-一种异构计算平台"><a href="#CUDA-一种异构计算平台" class="headerlink" title="CUDA:一种异构计算平台"></a>CUDA:一种异构计算平台</h2><h3 id="1-CUDA的简单介绍"><a href="#1-CUDA的简单介绍" class="headerlink" title="1.CUDA的简单介绍"></a>1.CUDA的简单介绍</h3><p>CUDA是一种通用的并行计算平台和编程模型，它利用NVIDIA GPU中的并行计算引擎能够有效地解决复杂的计算问题。通过使用CUDA，你可以像在CPU上，通过GPU来进行计算。</p><p>CUDA平台可以通过CUDA加速库，编译器指令，应用编程接口以及行业标准程序语言的扩展（包括C,C++,Fortran，Python，如图1-12所示）来使用。</p><p>CUDA C是标准ANSI C语言的一个扩展，它带有的少数语言扩展功能使异构编程成为可能，同时也能通过API来管理设备，内存和其他任务。CUDA还是一个可扩展的编程模型，它使程序能对有不同数量核的GPU明显地扩展其并行性，同时对熟悉C编程语言的程序员来说也比较容易上手。</p><p><img src="/2023/01/16/cuda002/image-20230116175503342.png" alt="image-20230116175503342"></p><p>CUDA提供了两层API来管理GPU设备和组织线程，如图1-13所示。</p><p><img src="/2023/01/16/cuda002/image-20230116175610403.png" alt="image-20230116175610403"></p><p>-CUDA驱动API</p><p>-CUDA运行时API</p><p>驱动API是一种低级API，它相对来说较难编程，但是它对于在GPU设备使用上提供了更多的控制。运行时API是一个高级API，他在驱动API的上层实现。每个运行时API函数都被分解为更多传给驱动API的基本运算。</p><h3 id="2-运行时API与驱动API"><a href="#2-运行时API与驱动API" class="headerlink" title="2.运行时API与驱动API"></a>2.运行时API与驱动API</h3><p>运行时API和驱动API之间没有明显的性能差异。在设备端，内核是如何使用内存以及你是如何组织线程的，对性能有更显著的影响。</p><p>这两种API是相互排斥的，你必须使用两者之一，从两者中混合函数调用是不可能的。本书中所有例子都使用运行时API。</p><p>一个CUDA程序包含了以下两个部分的混合。</p><p>-在CPU上运行的主机代码</p><p>-在GPU上运行的设备代码</p><p>NVIDIA的CUDA nvcc编译器在编译过程中将设备代码从主机代码中分离出来。如图1-14所示，主机代码是标准的C代码，使用C编译器进行编译。设备代码，也就是核函数，是用扩展的带有标记数据并行函数关键字的CUDA C语言编写的。设备代码通过nvcc进行编译。在链接阶段，在内核程序调用和显示GPU设备操作中添加CUDA运行时库。</p><p><img src="/2023/01/16/cuda002/image-20230116180725596.png" alt="image-20230116180725596"></p><p>CUDA nvcc编译器是以广泛使用LLVM开源编译系统为基础的。在GPU加速器的支持下，通过使用CUDA编译器SDK，你可以创建或扩展编程语言，如图1-15所示。</p><p>CUDA平台也是支持多样化并行计算生态系统的基础，如图1-26所示。现在，随着越来越多的公司可以提供全球性的工具，服务和解决方案，CUDA生态系统迅速成长。如果你想在GPU上建立你的应用程序，强化GPU性能最简单方式是使用CUDA工具包（cuda-toolkit），它为C和C++开发人员提供了一个综合的开发环境。CUDA工具包包括编译器，数学库，以及调式和优化应用程序性能的工具。同时提供了代码样例，编程指南，用户手册，API参考文档和其他帮助你入门的文档。</p><p><img src="/2023/01/16/cuda002/image-20230116181439404.png" alt="image-20230116181439404"></p><p><img src="/2023/01/16/cuda002/image-20230116181447616.png" alt="image-20230116181447616"></p><h3 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.参考资料"></a>3.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA用GPU输出Hello World</title>
    <link href="/2023/01/16/cuda001/"/>
    <url>/2023/01/16/cuda001/</url>
    
    <content type="html"><![CDATA[<h2 id="用GPU输出Hello-World"><a href="#用GPU输出Hello-World" class="headerlink" title="用GPU输出Hello World"></a>用GPU输出Hello World</h2><h3 id="1-检查环境"><a href="#1-检查环境" class="headerlink" title="1.检查环境"></a>1.检查环境</h3><p>学习一个新编程语言的最好方式就是使用这种语言来编写程序。在本节，你将开始编写在GPU上运行的第一个内核代码。像其他任何编程语言一样编写GPU上的第一个程序是输出字符串“Hello World”。</p><p>如果这是你第一次使用CUDA,在Linux系统中，你可以想使用以下命令来检查CUDA编译器是否正确安装：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">which nvcc<br></code></pre></div></td></tr></table></figure><p>通常的结果可能是</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">/usr/local/cuda/bin/nvcc<br></code></pre></div></td></tr></table></figure><p>你还需要检查你的机器上是否安装了GPU加速卡。对吃你可以在Linux系统上使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ls -l /dev/nv*<br></code></pre></div></td></tr></table></figure><p>通常的结果是：</p><p><img src="/2023/01/16/cuda001/image-20230116170920773.png" alt="image-20230116170920773"></p><p>在这个例子中，你发现了两个GPU卡（不同的用户配置可能有所不同，因此显示结果会有所差异）。</p><h3 id="2-第一个CUDA-C程序"><a href="#2-第一个CUDA-C程序" class="headerlink" title="2.第一个CUDA C程序"></a>2.第一个CUDA C程序</h3><p>现在你要准备好写你的第一个CUDA C程序。写一个CUDA C程序，你需要以下几个步骤：</p><ol><li>用专用扩展名.cu来创建一个源文件。</li><li>使用CUDA nvcc编译器来编译程序。</li><li>从命令行运行可执行文件，这个文件有可在GPU上运行的内核代码。</li></ol><p>首先，我们编写一个C语言程序来输出“Hello World”,如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World from CPU!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>把代码保存到hello.cu中，然后使用nvcc编译器来编译。CUDA nvcc编译器和gcc编译器及其他编译器有相似的语义</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc hello.cu -o hello<br></code></pre></div></td></tr></table></figure><p>如果你运行可执行文件hello，将会输出：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Hello World <span class="hljs-keyword">from</span> CPU!<br></code></pre></div></td></tr></table></figure><p>接下来，编写一个内核函数，命名为helloFromGPU，用它来输出字符串“Hello World from GPU!”。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">helloFromGPU</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World from GPU!\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>修饰符__global__告诉编译器这个函数将会从CPU中调用，然后在GPU上执行。用下面代码启用内核函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">helloFromGPU&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">10</span>&gt;&gt;&gt;();<br></code></pre></div></td></tr></table></figure><p>三重尖括号意味着从主线程到设备端代码的调用。一个内核函数通过一组线程来执行，所有线程执行相同的代码。三重尖括号里面的参数是执行配置，用来说明使用多少线程来执行内核函数。在这个例子中，有10个GPU线程被调用。综上所述，得到代码清单1-1所示的程序。</p><h3 id="3-代码清单1-1Hello-World-from-GPU-hello-cu"><a href="#3-代码清单1-1Hello-World-from-GPU-hello-cu" class="headerlink" title="3.代码清单1-1Hello World from GPU! (hello.cu)"></a>3.代码清单1-1Hello World from GPU! (hello.cu)</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">helloFromGPU</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World from GPU!\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//hello from cpu</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World from CPU!\n&quot;</span>);<br>    <br>    <br>    helloFromGPU&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">10</span>&gt;&gt;&gt;();<br>    <span class="hljs-built_in">cudaDeviceReset</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>函数cudaDeviceRest（）用来显式地释放和清空当前进程中与当前设别有关的所有资源。如下所示，在nvcc命令行中使用-arch sm_20进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc -arch sm_20 hello.cu -o hello<br></code></pre></div></td></tr></table></figure><p>开关语句-arch sm_20使编译器为Fermi架构生成设备代码。运行这个可执行文件，它将输出10条字符串“Hello World from CPU!”，每个线程输出一条。</p><p><img src="/2023/01/16/cuda001/image-20230116173446169.png" alt="image-20230116173446169"></p><h3 id="4-一个典型的CUDA编程结构包括5个主要步骤"><a href="#4-一个典型的CUDA编程结构包括5个主要步骤" class="headerlink" title="4.一个典型的CUDA编程结构包括5个主要步骤"></a>4.一个典型的CUDA编程结构包括5个主要步骤</h3><ol><li>分配GPU内存</li><li>从CPU内存中拷贝数据到GPU内存</li><li>调用CUDA内核函数来完成程序指定的运算</li><li>将数据从GPU拷回CPU内存</li><li>释放GPU内存空间</li></ol><p>在hello.cu中，你只看到了第三步：调用内核。</p><h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP生产者消费者问题(未完结)</title>
    <link href="/2023/01/14/openmp006/"/>
    <url>/2023/01/14/openmp006/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenMP生产者消费者问题"><a href="#OpenMP生产者消费者问题" class="headerlink" title="OpenMP生产者消费者问题"></a>OpenMP生产者消费者问题</h2><p><strong>本节将讨论一个不适合用parallel for指令或者for指令来并行化的问题。</strong></p><h3 id="1-队列"><a href="#1-队列" class="headerlink" title="1.队列"></a>1.队列</h3><p>队列是一种抽象的数据结构，插入元素时将元素插入到队列“尾部”，而读取元素时，队列“头部”的元素被返回并从队列中被移除。队列可以看做是在超市中等待付款的消费者的抽象，队列中的元素是消费者。新的消费者到达时排在等待队列的尾部，下一个付款离开等待队列的是排在队列头部的消费者。</p><p>当一个新的元素插入到队列的尾部时，通常称这个新的元素“入队”了；当一个元素从队列的头部被移除时，通常称这个元素“出队”了。</p><p>队列在计算机科学中随处可见。例如，如果有多个进程，每个进程都试图向硬盘写入数据，为了确保每次只有一个进程在写硬盘，一种自然而然的方法是将进程组织为队列。换句话说，排在队列第一个的进程在当前进程结束对硬盘的使用后，第一个获得硬盘的访问权限；排在队列第二个的进程在排在队列第一个的进程使用完硬盘后获得硬盘的访问权限，依此类推。</p><p>队列也是在多线程应用程序中经常使用到的数据结构。例如，我们有几个“生产者”线程和几个“消费者”线程。生产者线程“产生”对服务器数据的请求———例如当前股票的价格，而消费者线程通过发现和生成数据（例如，当前股票的价格）来“消费”请求。生产者线程将请求入队，而消费者线程将请求从队列中移除。在这个例子中，只有当消费者线程将请求的数据发送给生产者线程时，进程才会结束。</p><h3 id="2-消息传递"><a href="#2-消息传递" class="headerlink" title="2.消息传递"></a>2.消息传递</h3><p>生产者和消费者问题模型的另外一个应用是在共享内存系统上实现消息传递。每一个线程有一个消息共享队列，当一个线程要向另一个线程“发送消息“时，他将消息放入目标线程的消息队列中。一个线程接受消息时只需从它的消息队列的头部取出消息。</p><p>这里我们将实现一个简单的消息传递程序，在这个程序中，每个线程随机产生整数”消息“和消息的日志目标线程。当创建一条消息后，线程将消息加入到合适的消息队列中。当发送消息之后，该线程查看它自己的消息队列以获知它是否收到了消息，如果它收到了消息，它将从队首的消息出队并打印该消息。每个线程交替发送和接受消息，用户需要指定每个线程发送消息的数目。当一个线程发送完所有消息后，该线程不断接受消息直到所有的线程都已完成，此时所有的线程都结束了。每个线程的伪代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(send_msgs = <span class="hljs-number">0</span>; sent_msgs &lt; send_max ;sent_msgs++)&#123;<br>    <span class="hljs-built_in">Send_msg</span>();<br>    <span class="hljs-built_in">Try_receive</span>();<br>&#125;<br><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">Done</span>())<br>    <span class="hljs-built_in">Try_receive</span>();<br></code></pre></div></td></tr></table></figure><h3 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3.发送消息"></a>3.发送消息</h3><p>需要注意的是，访问消息队列并将消息入队，可能是一个临界区。尽管我们还没有深入地研究如何实现消息队列，但我们很有可能需要用一个变量来跟踪队列的尾部。例如，使用一个单链表来实现消息队列，链表的尾部对应着队列的尾部。然后，为了有效地进行入队操作，需要存储指向链表尾部的指针，当一条新消息入队时，需要检查和更新这个队尾指针。如果两个线程试图同时进行这些操作，那么可能会丢失一条已经由其中一个线程入队的消息.（画张图能够有助于理解这种情况！）两个操作的结果会发生冲突，因此入队操作形成了临界区。</p><p>Send_msg()函数的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">mesg = <span class="hljs-built_in">random</span>();<br>dest = <span class="hljs-built_in">random</span>() % thread_count;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical</span><br><span class="hljs-built_in">Enqueue</span>(queue,dest,my_rank.mesg);<br></code></pre></div></td></tr></table></figure><p>注意在上面的实现中，允许线程向它自己发送消息。</p><h3 id="4-接受消息"><a href="#4-接受消息" class="headerlink" title="4.接受消息"></a>4.接受消息</h3><p>接受消息的同步问题与发送消息有些不同。只有消息队列的拥有者（即目标线程）可以从给定的消息队列中获取消息。如果消息队列中至少有两条消息，那么只要每次只出队一条消息，那么出队操作和入队操作就不可能冲突。因此如果队列中至少有两条消息，通过跟踪队列的大小就可以避免任何同步（例如critical指令）</p><p>现在的问题是如何存储队列大小。如果只使用一个变量来存储队列的大小，那么对该变量的操作会形成临界区。然而可以使用两个变量：enqueued和dequeued，那么队列中消息的个数（队列的大小）就为</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue_size = enqueued - dequeued<br></code></pre></div></td></tr></table></figure><p>并且，唯一能够更新dequeued的线程是消息队列的拥有者。可以看到在一个线程使用enqueued计算队列大小queue_size的同时，另外一个线程可以更新enqueued。为了解释这种情况，假如进程q正在计算queue_size，那么它将可能得到enqueued新的或者旧的值。当queue_size实际值是1或者2时，线程q可能会得到queue_size是0或者1。但这只会引起程序一定的延迟，而不会引起程序错误。如果queue_size本应该是1，却误计算为0，那么线程q延迟一段时间后会试图重新计算队列的大小；如果queue_size本应该是2，却误计算为1，那么线程q将执行临界区指令，虽然这本来是不必要的。</p><p>因此，可以按照如下的方式实现Try_receive:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue_size = enqueued - dequeued;<br><span class="hljs-keyword">if</span>(queue_size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(queue_size == <span class="hljs-number">1</span>)<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical</span><br>    <span class="hljs-built_in">Dequeue</span>(queue,&amp;src,&amp;mesg);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">Dequeue</span>(queue,&amp;src,&amp;mesg);<br><span class="hljs-built_in">Print_message</span>(src,mesg);<br></code></pre></div></td></tr></table></figure><h3 id="5-终止检测"><a href="#5-终止检测" class="headerlink" title="5.终止检测"></a>5.终止检测</h3><p>接下来，我们探讨如何实现Done函数。首先，我们给出一个”直接“的实现，但这个实现隐藏着问题：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue_size = enqueued - dequeued;<br><span class="hljs-keyword">if</span>(queue_size == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> True;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> False;<br></code></pre></div></td></tr></table></figure><p>如果线程u执行这段代码，那么很有可能有些线程，如线程v，在线程u计算出queue_size &#x3D; 0后向线程u发送一条消息。当然，线程u在得出queue_size &#x3D; 0后将终止，那么线程v发送给它的消息就永远不会被接受到。</p><p>然而，在我们程序中，每个线程在执行完for循环后将不再发送任何消息。因此可以增加一个计数器done_sending，每个线程在for循环结束后将该计数器加1，Done的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue_size = enqueued - dequeued;<br><span class="hljs-keyword">if</span>(queue_size == <span class="hljs-number">0</span> &amp;&amp; done_sending == thread_count)<br>    <span class="hljs-keyword">return</span> TRUE;<br><span class="hljs-keyword">else</span><br>    rerun FALSE;<br></code></pre></div></td></tr></table></figure><h3 id="6-启动"><a href="#6-启动" class="headerlink" title="6.启动"></a>6.启动</h3><p>当程序开始执行时，主线程将得到命令行参数并且分配一个数组空间给消息队列，每个线程对应着一个消息队列。由于每个线程可以向其他任意的下次线程发送消息，所以这个数组应该被所有线程共享，而且每个线程可以向任何一个消息队列插入一条消息。消息队列（至少）可以存储：</p><ol><li>消息列表</li><li>队尾指针或索引</li><li>队首指针或索引</li><li>入队消息的数目</li><li>出队消息的数目</li></ol><p>最好将队列存在消息队列的结构体中，为了减少参数传递时复制的开销，最好用指向结构体的指针数组来实现消息队列。因此，一旦主线程分配了队列数组，就可以使用parallel指令开始执行线程，每个线程可以为自己的队列分配存储空间。</p><p>这里一个重要的问题是：一个或者多个线程可能在其他线程之前完成它的队列分配。如果这种情况出现了，那么完成分配的线程可能会试图开始向那些还没有完成队列分配的线程发送消息，这将导致程序崩溃。因此，我们必须确保任何一个线程都必须在所有的线程都完成了队列分配后才开始发送消息。回想一下，之前我们见过一些OpenMP指令在结束时提供隐式路障，即任何一个线程都必须等到组中所有的线程完成了某个程序块后才可以接着执行后续代码。然而，在这个例子中，我们处于parallel块的中间，所以我们不能依赖于OpenMP提供的隐式路障——我们应当使用显式路障。幸运的是，OpenMP提供了相应的指令：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp barrier</span><br></code></pre></div></td></tr></table></figure><p>当线程遇到路障时，它将被阻塞，直到组中所有的线程都到达了这个路障。当组中所有的线程都到达了这个路障时，这些线程就可以接着往下执行。</p><h3 id="7-atomic指令"><a href="#7-atomic指令" class="headerlink" title="7.atomic指令"></a>7.atomic指令</h3><p>发送完所有的消息后，每个线程在执行最后的循环以便接受消息之前，需要对done_sending加1.显然，对done_sending的增量操作是临界区，可以通过critical指令来保护它。然后，OpenMP提供了另外一种可能更加高效的指令：atomic指令：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp atomic</span><br></code></pre></div></td></tr></table></figure><p>与critical指令不同，它只能保护由一条C语言赋值语句所形成的临界区。此外，语句必须是一下几种形式之一：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">x &lt;op&gt; = &lt;expression&gt;<br>x++;<br>++x;<br>x--;<br>--x;<br></code></pre></div></td></tr></table></figure><p><op>可以是以下任意的二元操作符：</op></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">+,*,-,/,&amp;,|,^,&lt;&lt;,<span class="hljs-keyword">or</span> &gt;&gt;<br></code></pre></div></td></tr></table></figure><p>这里要记住，<expression>不能引用x。</expression></p><p>需要注意的是，只有x的装载和存储可以确保是受保护的，例如在下面的代码中：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp atomic</span><br>x += y++;<br></code></pre></div></td></tr></table></figure><p>其他线程对x的更新必须等到该线程对x的更新结束之后。但是对y的更新不受保护，因此程序的结果是不可预测的。</p><p>atomic指令的思想是许多处理器提供专门的装载-修改-存储(load-modify-store)指令。使用这种专门的指令而不使用保护临界区的通用结构，可以更高效地保护临界区。</p><h3 id="8-临界区和锁"><a href="#8-临界区和锁" class="headerlink" title="8.临界区和锁"></a>8.临界区和锁</h3><p>为了完成对消息传递程序的讨论，我们需要进一步仔细研究OpenMP critical指令的规范。在更早的例子中，程序最多只有一个临界区，critical指令强制所有的线程对该区域进行互斥访问。在这个程序中，临界区的使用将更加复杂。我们将在源代码中看到3个在critical或atomic指令后面的代码块：</p><ol><li>done_sending++</li><li>Enqueue(q_p,my_rank,mesg);</li><li>Dequeue(q_p,&amp;src,&amp;mesg);</li></ol><p>然而，我们不需要强制对3个代码块都进行互斥访问，甚至不需要强制对第二个和第三个代码块进行完全的互斥访问。例如，线程0在向线程1的消息队列写消息的同时，线程1可以向线程2的消息队列写消息。但是OpenMP的规定第二个和第三个代码块是被critical指令保护的代码块。在OpenMP看来，我们的程序有两个不同的临界区；被atomic指令保护的done_sending++和“复合”临界区。在“复合”临界区中，程序读取和发送消息。</p><p>强制线程间的互斥会使程序的执行串行化。OpenMP默认的做法是将所有的临界区代码块作为复合临界区的一部分，这可能非常不利于程序的性能。OpenMP提供了向critical指令添加名字的选项：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical(name)</span><br></code></pre></div></td></tr></table></figure><p>采取这种方式，两个用不同名字的critical指令保护的代码块就可以同时执行。我们想为每一个线程的消息队列的临界区提供不同的名字，但是临界区的名字是在程序编译过程中设置的。因此，我们需要在程序执行的过程中设置临界区的名字。但是按照为我们的设置，当我们想让访问不同队列的线程可以同时访问相同的代码块时，被命名的critical指令就不能满足我们的要求了。</p><p>解决方案是使用锁（lock）。锁由一个数据结构和定义在这个数据结构上的函数组成，这些函数使得程序员可以显式地强制对临界区进行互斥访问。锁的使用可以大概用下面的伪代码描述：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*Executed by one thread*/</span><br>initialize the lock data structure;<br>...<br><span class="hljs-comment">/*Executed by multiple threads*/</span><br>Attempt to lock <span class="hljs-keyword">or</span> set the lock data structure;<br>Critical section;<br>Unlock <span class="hljs-keyword">or</span> unset the lock data structure;<br>...<br><span class="hljs-comment">/*Executed by one thread*/</span><br>Destory the lock data structure;<br></code></pre></div></td></tr></table></figure><p>锁的数据结构被执行临界区的线程所共享，这些线程中的某个线程（如主线程）会初始化锁。而当所有的线程都使用完锁后，某个线程应当负责销毁锁。</p><p>在一个线程进入临界区前，它尝试通过调用锁函数来上锁（set）。如果没有其他的线程正在执行临界区代码，那么它将获得锁并进入临界区。当该线程执行完临界区代码后，它调用解锁函数释放（relinquish或者unset）锁，以便其他线程可以获得锁。</p><p>当一个线程拥有锁时，其他线程都不能进入该临界区。其他线程尝试通过调用锁函数进入该临界区时会阻塞。如果有多个线程被锁函数阻塞，则当临界区的线程释放锁时，这些线程中的某个线程会获得锁，而其他线程仍被阻塞。</p><p>OpenMP有两种锁：简单（simple）锁和嵌套（nested）锁。简单锁在被释放前只能获得一次，而一个嵌套锁在被释放前可以被同一个线程获得多次。OpenMP简单锁的类型是omp_lock_t，定义简单锁的函数包括：</p><p><img src="/2023/01/14/openmp006/image-20230116165204803.png" alt="image-20230116165204803"></p><p>相关的类型和函数在头文件omp.h中声明。第一个函数的作为是初始化锁，所以此时锁处于解锁状态，换句话说，此时没有线程拥有这个锁。第二个函数尝试获得锁，如果成功，调用该函数的线程可以继续执行；如果失败，调用该函数的线程将被阻塞，直到锁被其他线程释放。第三个函数释放锁，以便其他线程可以获得该锁。第四个函数销毁锁。</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP循环调度</title>
    <link href="/2023/01/14/openmp005/"/>
    <url>/2023/01/14/openmp005/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenMP循环调度"><a href="#OpenMP循环调度" class="headerlink" title="OpenMP循环调度"></a>OpenMP循环调度</h2><h3 id="1-循环调度"><a href="#1-循环调度" class="headerlink" title="1.循环调度"></a>1.循环调度</h3><p>当第一次遇到parallel for指令时，我们看到将各次循环分配给线程的操作是由系统完成的。然而，大部分OpenMP实现只是粗略地使用块分割：如果在串行循环中有n次迭代，那么在并行循环中，前n&#x2F;thread_count个迭代分配给线程0，接下来的n&#x2F;thread_count个迭代分配给线程1，依此类推。不难想到，这种分配方式肯定不是最优的。例如，假如我们想要并行化循环：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sum = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>    sum+=<span class="hljs-built_in">f</span>(i);<br></code></pre></div></td></tr></table></figure><p>同时，假设对f函数调用所需要的时间与参数i的大小成正比，那么与分配给线程0的工作相比，分配给线程thread_count-1的工作量相对较大。一个更好的分配方案是轮流分配线程的工作（循环划分）。在循环划分中，各次迭代被“轮流”地一次一个地分配给线程。假如 t&#x3D;thread_count。那么一个循环划分将如下分配各次迭代：</p><p><img src="/2023/01/14/openmp005/image-20230114132246596.png" alt="image-20230114132246596"></p><p>为了了解这样分配是如何影响性能的，我们编写了如下程序。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j,start=i*(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>,finish=start+i;<br>    <span class="hljs-keyword">double</span> return_val = <span class="hljs-number">0.0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(j = start; j&lt;=finish; j++)&#123;<br>        return_val += <span class="hljs-built_in">sin</span>(j);<br>    &#125;<br>    <span class="hljs-keyword">return</span> return_val;<br>    <span class="hljs-comment">/* f */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>每当函数f（i）调用i次sin函数。例如，执行f（2i）的时间几乎是执行f（i）的时间的两倍。</p><p>当n&#x3D;10000并且只用一个线程运行程序时，运行时间是3.67秒。当用两个线程和缺省分配方式（第0-5000次迭代分配给线程0，第5001-10000次迭代分配给线程1），运行程序时，运行时间为2.76秒。加速比仅为1.33.然而，当运行两个线程并采用循环划分时，运行时间减少到1.84秒。与单线程运行相比，加速比为1.99；与双线程，块分割相比，加速比为1.5！</p><p>我们看到一个好的迭代分配能够对性能有很大的影响。再OpenMP中，将循环分配给线程称为调度，schedule子句用于在parallel for或者for指令中进行迭代分配。</p><h3 id="2-schedule子句"><a href="#2-schedule子句" class="headerlink" title="2.schedule子句"></a>2.schedule子句</h3><p>在例子中，我们已经知道如何乎获取缺省调度：只需要添加parallel for指令和reduction子句：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sum=<span class="hljs-number">0.0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    sum+=<span class="hljs-built_in">f</span>(i);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>为了对线程进行调度，可以添加一个schedule子句到parallel for指令中：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sum=<span class="hljs-number">0.0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)schedule(static,1)</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    sum+=<span class="hljs-built_in">f</span>(i);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一般而言，schedule子句有如下形式：</p><p>schedule（<type>[.<chunksize>]）</chunksize></type></p><p>type可以是下列任意一个：</p><ol><li>static：迭代能够在循环执行前分配给线程</li><li>dynamic或guided：迭代在循环执行时被分配给线程，因此在一个线程完成了它的当前迭代集合后，它能从运行时系统中请求更多</li><li>auto：编译器和运行时系统决定调度方式</li><li>runtime：调度在运行时决定</li></ol><p>chunksize是一个正整数。在OpenMP中，迭代块是在顺序循环中连续执行的一块迭代语句，块中的迭代次数是chunksize。只有static，dynamic和guided调度有chunksize。这虽然决定了调度的细节，但准确的解释还是依赖于type。</p><h3 id="3-stastic调度类型"><a href="#3-stastic调度类型" class="headerlink" title="3.stastic调度类型"></a>3.stastic调度类型</h3><p>对于static调度，系统以轮转的方式分配chunksize块个迭代给每个线程。例如，假如有12个迭代，0，1，—，11和3个线程，如果在parallel for或for指令中使用schedule（static，1）迭代将如下分配：</p><p><img src="/2023/01/14/openmp005/image-20230114141741424.png" alt="image-20230114141741424"></p><p>如果使用schedule（static，2），迭代将如下进行分配：</p><p><img src="/2023/01/14/openmp005/image-20230114141830866.png" alt="image-20230114141830866"></p><p>如果使用schedule（static，4），迭代将如下分配：</p><p><img src="/2023/01/14/openmp005/image-20230114141909092.png" alt="image-20230114141909092"></p><p>因此，子句schedule（static,total_iterations&#x2F;thread_count）就相当于被大部分OpenMP实现所使用的缺省调度。</p><p>这里，chunksize可以被忽略。如果他被忽略了，chunksize就近似等于total_iterations&#x2F;thread_count。</p><h3 id="4-dynamic和guided调度类型"><a href="#4-dynamic和guided调度类型" class="headerlink" title="4.dynamic和guided调度类型"></a>4.dynamic和guided调度类型</h3><p>在dynamic调度中，迭代也被分成chunksize个连续迭代的块。每个线程执行一块，并且当一个线程完成一块时，它将从运行时系统请求另一块，直到所有的迭代完成。chunksize可以被忽略。当它被忽略时，chunksize为1。</p><p>在guided调度中，每个线程也执行一块，并且当一个线程完成一块时，将请求另一块。然而，在guided调度中，当块完成后，新块的大小会变小。例如，在我们的系统中，如果用parallel for指令和schedule（guided）子句来运行梯形积分法程序，那么当n&#x3D;10000并且thread_count&#x3D;2时。迭代将如表5-3那样分配。块的大小近似等于剩下的迭代数除以线程数。第一个块的大小9999&#x2F;2≈5000，因为有9999个迭代未被分配的迭代。第二个块的大小为4999&#x2F;2≈2500，一次类推。</p><p><img src="/2023/01/14/openmp005/image-20230114143233692.png" alt="image-20230114143233692"></p><p>在guided调度中，如果没有指定chunksize，那么块的大小为1；如果指定了chunksize，那么块的大小就是chunksize，除了最后一块的大小可以比chunksize小。</p><h3 id="5-runtime调度类型"><a href="#5-runtime调度类型" class="headerlink" title="5.runtime调度类型"></a>5.runtime调度类型</h3><p>为了理解schedule（runtime），我们需要离题一会儿，讨论一下环境变量。正如名字所暗示的，环境变量是能够被运行时系统所访问的命名值，即它们在程序的环境中是可得的。一些经常被使用的环境变量是PATH,HOME和SHELL。PATH变量明确了当寻找一个可执行文件时shell应该搜索哪些目录。它通常在UNIX和Windows系统中定义。HOME变量指定用户主目录的位置，而SHELL变量指定用户shell的可执行位置。这样通常在UNIX系统中。在类UNIX系统（例如Linux和Mac OS X）和Windows，环境变量能够在命令行中检查和指定。在类UNIX系统中，能使用shell命令行；在windows中，能使用集成开发环境的命令行。</p><p>例如，如果我们正使用bash shell，要检查一个环境变量的值只需要输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span></span><br></code></pre></div></td></tr></table></figure><p>我们能够使用export命令来设置一个环境变量的值</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"><span class="hljs-built_in">export</span> TEST_VAR = <span class="hljs-string">&quot;hello&quot;</span></span><br></code></pre></div></td></tr></table></figure><p>如何检查和设置特定系统的环境变量，请咨询本地系统的专家。</p><p>当schedule（runtime）指定时，系统使用环境变量OMP_SCHEDULE在运行时来决定如何调度循环。OMP_SCHEDULE环境变量会呈现任何能够被static，dynamic或guided调度所使用的值。例如，假设在程序中有一条parallel for指令，并且它已经被schedule（runtime）修改了。那么如果使用bash shell，就能通过执行以下命令将一个循环分配所得到的迭代分配给线程：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"><span class="hljs-built_in">export</span> OMP_SCHEDULE=<span class="hljs-string">&quot;static,1&quot;</span></span><br></code></pre></div></td></tr></table></figure><p>现在，当开始执行程序时，系统将调度for循环的迭代，就如同使用子句schedule（static，1）修改了parallel for指令那样。</p><h3 id="6-调度选择"><a href="#6-调度选择" class="headerlink" title="6.调度选择"></a>6.调度选择</h3><p>如果需要并行化一个for循环，那么我们如何决定使用哪一种电镀和chuncksize的大小？实际上，每一中schedule子句有不同的系统开销。dynamic调度的系统开销要大于static调度，而guided调度的系统开销是三种方式中最大的。因此，如果不使用schedule子句就已经达到了令人满意的性能，就不需要进行多余的工作。但是，如果我们怀疑调度的性能可以提升，那么我们可以对各种调度进行试验。</p><p>在本节开始提供的例子中，在程序使用两个线程的情况下，使用schedule（static，1）代替默认调度时，加速比从1.33提升到1.99。因为在两个线程的条件下，加速比几乎不可能比1.99更好，所以我们可以不用再尝试其他的调度方式，至少在只用两个线程并且迭代数为10000的情况下是这样。如果做更多的试验，改变线程的个数和迭代的次数，我们可能会发现：最优的调度方式是由线程的个数和迭代的次数共同决定的。</p><p>如果我们断定默认的调度方式性能低下，那么我们会做大量的实验来寻找最优的调度方式和迭代次数。在进行了大量的工作以后，我们可能发现，这些循环没有得到很好的并行化，没有哪一种调度可以带来比较显著的性能提升。编程作业5.4就是这样一个例子。</p><p>但在某些情况下，应该优先考虑有些调度：</p><ol><li>如果循环的每次迭代需要几乎相同的计算量，那么可能默认的调度方式能提供最好的性能</li><li>如果随着循环的进行，迭代的计算量线性猛增（或递减），那么采用比较小的chuncksize的static调度可能会提供最好的性能</li><li>如果每次迭代的开销事先不能确定，那么就可能需要尝试使用多种不同的调度策略。在这种情况下，应当使用schedule（runtime）子句，通过富裕环境变量OMP_SCHEDULE不同的值来比较不同调度策略下程序的性能</li></ol><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><ol><li>调度方式对加速效果的重要性</li><li>合理分析任务特性，选择最适合的调度方式</li></ol><h3 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8.参考资料"></a>8.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP排序</title>
    <link href="/2023/01/13/openmp004/"/>
    <url>/2023/01/13/openmp004/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenMP排序"><a href="#OpenMP排序" class="headerlink" title="OpenMP排序"></a>OpenMP排序</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(list_length = n; list.length &gt;= <span class="hljs-number">2</span>; list_length--)<span class="hljs-comment">//升序排列</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; list_length<span class="hljs-number">-1</span>; i++)<br>        <span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br>            tmp = a[i];<br>            a[i] = a[i+<span class="hljs-number">1</span>];<br>            a[i+<span class="hljs-number">1</span>] = tmp;<br>        &#125;<br></code></pre></div></td></tr></table></figure><p>​显然，在外部循环中有一个循环依赖，在外部循环的任何一次迭代中，当前列表的内容依赖于外部循环的前一次迭代。例如，如果在算法开始时，a&#x3D;3,4,1,2，那么外部循环的第二次迭代将对列表3，1，2进行操作，因为4在第一次迭代中应该已经被移动到列表的最后了。但如果前两次迭代同时执行，则可能第二次迭代的有效列表包含4。</p><p>​内部循环的循环依赖也很容易发现。在第i次迭代中，被比较的元素依赖于第i-1次迭代。如果在第i-1次迭代中a[i-1]和a[i]没有交换，那么第i次迭代将比较a[i]和a[i+1]。另一方面，如果第i-1次迭代交换了a[i-1]和a[i]，那么第i次迭代将比较原始的a[i-1] (现在是a[i]和a[i+1])。例如，假如当前列表是{3，1，2}。那么当i&#x3D;1时，我们将比较3和2，但如果i&#x3D;0和i&#x3D;1次迭代同时发生，则完全有可能i&#x3D;1次迭代回比较1和2。</p><p>​我们完全不清楚怎样在不完全重写算法的情况下一处任何一个循环依赖。记住。即使我们总能找到循环依赖，但可能很难甚至不可能移除它。对于并行化for循环而言，parallel for指令不是一个通用的解决方法。</p><h3 id="2-奇偶交换排序"><a href="#2-奇偶交换排序" class="headerlink" title="2.奇偶交换排序"></a>2.奇偶交换排序</h3><p>​奇偶交换排序是一个与冒泡排序相似的算法，但它相对来说更容易并行化。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(phase = <span class="hljs-number">0</span>;phase &lt; n ; phase++)<br>    <span class="hljs-keyword">if</span>(phase % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n ;i += <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>] &gt; a[i]) <span class="hljs-built_in">swap</span>(a[i<span class="hljs-number">-1</span>],a[i]);<br><span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt; n<span class="hljs-number">-1</span> ;i += <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>]) <span class="hljs-built_in">swap</span>(a[i],a[i+<span class="hljs-number">1</span>]);<br></code></pre></div></td></tr></table></figure><p>列表a存储n个整数，算法对他们进行升序排列。在一个“偶阶段”（phase %2 &#x3D;&#x3D;0 ）里，每个偶下标元素a[i]与它左边的元素a[i-1]相比较。如果他们是没有排好序的，就交换它们。在一个“奇阶段”里，每个奇下标元素与它右边的元素相比较。如果他们是没有排好序的，则交换他们。有定理证明：在n个阶段后，列表可以完成排序。</p><p>​作为一个简单的例子，假设a&#x3D;{9,7,8,6}。表5-1显示了各个阶段的情况。在这个例子中，最后的阶段不是必要的，但算法并不在执行每个阶段前检查列表是否已经有序。</p><p><img src="/2023/01/13/openmp004/image-20230113174202896.png" alt="image-20230113174202896"></p><p>​不难看到外部循环有一个循环依赖。例如在a &#x3D; {9，7，8，6}之前。在阶段0中，内部循环将比较（9，7）和（8，6）这两对中的元素，这两对都会被交换。因此对于阶段1，列表将是{7，9，6，8}，并在阶段1中（9，6）中的元素被比较并交换。然而，如果阶段0和阶段1同时执行，则在阶段1中被检查可能是（7，8），是有序的。此外，我们尚不清楚如何消除这个循环依赖，因此并行化外部for循环不是一个好的选择。</p><p>​但是，内部for循环并没有任何循环依赖。例如，在偶阶段循环中，变量i是奇数，所以对于两个不同的i值，例如，i&#x3D;j和i&#x3D;k，{j-1,j}和{k-1,k}将是不同的。（a[j-1],a[j]）和（a[k-1],a[k]）所产生的比较和可能的交换能够同时进行。</p><p>​所以，我们试图使用程序5-4的代码并行化奇偶变化排序，但还是会有一些潜在的问题，首先，尽管任何一个偶阶段迭代并不依赖任何这个阶段的其他迭代，但是还需要注意，对p阶段和p+1阶段却并不是这样的。我们需要确定在任何一个线程开始p+1阶段之前，所有的线程必须先完成p阶段。然而，像parallel指令那样，parallel for指令在循环结束处有一个隐式的路障，因此，在所有的线程完成当前阶段（即阶段P之前），没有线程能够进入下一阶段，即p+1阶段。【这里需要注意在MPI中并没有隐式的路障来实现这个功能，需要程序员手动设置路障点】</p><p>​其次，是创建和合并线程的开销。OpenMP实现可能会在每一遍外部循环都创建和合并thread__count个线程。表5-2的第一行显示了当输入列表包含20000个元素时，在我们系统上运行1，2，3，4个线程的运行时间。</p><h3 id="3-程序5-4奇偶排序的第一个OpenMP实现"><a href="#3-程序5-4奇偶排序的第一个OpenMP实现" class="headerlink" title="3.程序5-4奇偶排序的第一个OpenMP实现"></a>3.程序5-4奇偶排序的第一个OpenMP实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(phase = <span class="hljs-number">0</span>;phase &lt; n; phase++)&#123;<br>    <span class="hljs-keyword">if</span>(phase %<span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp)</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i+=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]&gt;a[i])&#123;<br>                tmp = a[i<span class="hljs-number">-1</span>];<br>                a[i<span class="hljs-number">-1</span>] = a[i];<br>                a[i] =tmp;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp)</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i+=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br>                tmp = a[i+<span class="hljs-number">1</span>];<br>                a[i+<span class="hljs-number">1</span>] = a[i];<br>                a[i] = tmp;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/01/13/openmp004/image-20230113225724364.png" alt="image-20230113225724364"></p><p>​这些时间耗费并不非常糟糕，但是我们想看看是否能做得更好。每次执行内部循环时，使用同样数量的线程。因此只创建一次线程，并在每次内部循环的执行中重用它们，这样做可能更好。幸运的是，OpenMP提供了允许这样做的指令。用parallel指令在外部循环前创建thread__count个线程的集合。然后，我们不在每次内部循环执行时创建一组新的线程，而是使用一个for指令，告诉OpenMP用已有的线程组来并行化for循环，对原有OpenMP实现的改动显示在程序5-5中。</p><h3 id="4-程序5-5奇偶排序的第二个OpenMP实现"><a href="#4-程序5-5奇偶排序的第二个OpenMP实现" class="headerlink" title="4.程序5-5奇偶排序的第二个OpenMP实现"></a>4.程序5-5奇偶排序的第二个OpenMP实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp,phase)</span><br><span class="hljs-keyword">for</span>(phase = <span class="hljs-number">0</span>;phase &lt; n; phase++)&#123;<br>    <span class="hljs-keyword">if</span>(phase %<span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp for</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i+=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]&gt;a[i])&#123;<br>                tmp = a[i<span class="hljs-number">-1</span>];<br>                a[i<span class="hljs-number">-1</span>] = a[i];<br>                a[i] =tmp;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp for</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i+=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br>                tmp = a[i+<span class="hljs-number">1</span>];<br>                a[i+<span class="hljs-number">1</span>] = a[i];<br>                a[i] = tmp;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>与parallel for指令不同的是，for指令并不创建任何线程。它使用已经在parallel块中创建的线程。在循环的末尾有一个隐式的路障。代码的结果（最终列表）将因此与原有的并行化代码所取得到的结果一样。</p><p>​奇偶排序的第二个版本的运行时间显示在表5-2的第二行。当使用两个或更多线程时，使用两条for指令的版本要比使用两条parallel for指令的版本快17%。因此对于这个系统而言，为这点改变所做的小小努力是值得的。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ol><li>循环依赖总会出现，我们可能会很难去解决它甚至根本无法解决。</li><li>在构造并行区时要尽量减少创建和合并线程的开销</li></ol><h3 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6.参考文献"></a>6.参考文献</h3><p>并行程序导论 （美）Peter S.Pacheco</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP π值估计</title>
    <link href="/2023/01/09/openmp003/"/>
    <url>/2023/01/09/openmp003/</url>
    
    <content type="html"><![CDATA[<h2 id="π值估计"><a href="#π值估计" class="headerlink" title="π值估计"></a>π值估计</h2><h3 id="1-数学背景"><a href="#1-数学背景" class="headerlink" title="1.数学背景"></a>1.数学背景</h3><p><img src="/2023/01/09/openmp003/image-20230109150836877.png" alt="image-20230109150836877"></p><p>我们能够在串行代码下实行这个公式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> factor = <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span> ; k &lt; n; k++)&#123;<br>    sum += factor /(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br>    factor = - factor;<br>&#125;<br>pi_approx = <span class="hljs-number">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure><h3 id="2-OpenMP并行化"><a href="#2-OpenMP并行化" class="headerlink" title="2.OpenMP并行化"></a>2.OpenMP并行化</h3><p>为了使用OpenMP来并行化，可以首先倾向于这样做：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span> <span class="hljs-keyword">double</span> factor = <span class="hljs-number">1.0</span>;<br><span class="hljs-number">2</span> <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br><span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)  <span class="hljs-comment">//对sum进行求和归约</span></span><br><span class="hljs-number">4</span> <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span> ; k &lt; n; k++)&#123;<br><span class="hljs-number">5</span>     sum += factor /(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br><span class="hljs-number">6</span>     factor = - factor;<br><span class="hljs-number">7</span> &#125;<br><span class="hljs-number">8</span> pi_approx = <span class="hljs-number">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure><p>然而，第k次迭代中对第6行的factor的更新和接下来的第k + 1次迭代中对第5行的sum的累加是一个循环依赖（数据依赖）。如果第k次迭代被分配·到一个线程，而第k + 1次迭代被分配给另一个线程，则我们不能保证第6行中factor的值是正确的。</p><p>在这种情况下我们能通过检查系数来解决这个问题：</p><p><img src="/2023/01/09/openmp003/image-20230109161031989.png" alt="image-20230109161031989"></p><p>可以看到：在第k次迭代，factor的值应该是<img src="/2023/01/09/openmp003/image-20230109161206995.png" alt="image-20230109161206995">。如果k是偶数，那么值是+1；如果k是奇数，值是-1。</p><h3 id="3-消除循环依赖（数据依赖）"><a href="#3-消除循环依赖（数据依赖）" class="headerlink" title="3.消除循环依赖（数据依赖）"></a>3.消除循环依赖（数据依赖）</h3><p>因此，如果将下述代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sum += factor /(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br>factor = - factor;<br></code></pre></div></td></tr></table></figure><p>替换为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)<span class="hljs-comment">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    factor = <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">else</span><br>    factor = <span class="hljs-number">-1.0</span>;<br>sum += factor/(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure><p>这样就消除了循环依赖（数据依赖）。</p><h3 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4.作用域"></a>4.作用域</h3><p>​然而，事情仍然不是完全正确的。如果在我们的系统上使用两个线程运行程序，并设n&#x3D;1000，那么结果仍然是错误的。例如，</p><p><img src="/2023/01/09/openmp003/image-20230109164120205.png" alt="image-20230109164120205"></p><p>另一方面，如果只有一个线程运行程序，我们总是得到：</p><p><img src="/2023/01/09/openmp003/image-20230109164204808.png" alt="image-20230109164204808"></p><p>为什么会有这种错误。在一个已经被parallel for指令并行化的块中，缺省情况下任何在循环前声明的变量（唯一的例外是循环变量）在线程间都是共享的。因此factor被共享（被所有线程所共享）。例如，线程0可能会给他赋值1，但在它能用这个值更新sum前，线程1可能又给他赋值为-1了。因此，除了消除计算factor时的循环依赖（数据依赖）外，我们还需要保证每个线程有它自己的factor副本，就是说，为了使代码正确，我们需要保证factor有私有作用域（简单来说就是保证当前线程的factor的值不能被其他线程修改，也只有当前线程能更新和使用factor）。通过添加一个private子句到parallel指令中来实现这一目标。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"> <span class="hljs-keyword">double</span> factor = <span class="hljs-number">1.0</span>;<br> <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum) private(factor)  <span class="hljs-comment">//对sum进行求和归约</span></span><br> <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span> ; k &lt; n; k++)&#123;<br>     <span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)<span class="hljs-comment">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    factor = <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">else</span><br>    factor = <span class="hljs-number">-1.0</span>;<br>     sum += factor /(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br> &#125;<br> pi_approx = <span class="hljs-number">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure><p>在private子句内列举的变量，在每个线程上都有一个私有副本被创建。因此，在我们的例子中，thread_count个线程中的每一个都有它自己的factor变量的副本，因此一个线程对factor的更新不会影响另一个线程的factor值。</p><p>​要记住的重要的一点是，一个有私有作用域的变量的值在parallel块或者parallel for块的开始处是未指定的。它的值在parallel或parallel for块完成之后也是未指定的。例如，下列代码中的第一个printf语句的输出是非确定的，因为在它被现实初始化之前就打印了私有变量x。类似地，最终的printf输出也是非确定的，因为他在parallel块完成之后打印x。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel num_threads(thread_count) private(x)</span><br>&#123;<br>    <span class="hljs-keyword">int</span> my_rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d &gt; before initialization,x = %d\n&quot;</span>,myrank,x);<br>    x = <span class="hljs-number">2</span>*my_rank + <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d &gt; after initialization,x = %d\n&quot;</span>,my_rank,x);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After parallel block, x = %d\n&quot;</span>,x);<br></code></pre></div></td></tr></table></figure><h3 id="5-关于作用域的更多问题"><a href="#5-关于作用域的更多问题" class="headerlink" title="5.关于作用域的更多问题"></a>5.关于作用域的更多问题</h3><p>​关于变量factor的问题是常见问题中的一个。我们通常需要考虑在parallel块或parallel for块中的每个变量的作用域。因此，与其让OpenMP决定每个变量的作用域，还不如让程序员明确块中每个变量的作用域。事实上，OpenMP提供了一个子句default，该子句显示地要求我们这样做。如果我们添加子句：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in"><span class="hljs-keyword">default</span></span>(none)<br></code></pre></div></td></tr></table></figure><p>到parallel或parallel for指令中，那么编译器将要求我们明确在这个块中使用的每个变量和已经在块之外声明的变量的作用域。（在一个块中声明的变量都是私有的，因为它们会被分配给线程的栈。）</p><p>​例如，使用一个default（none）子句，对π的计算将如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) default(none) reduction(+:sum) private(k,factor)  <span class="hljs-comment">//对sum进行求和归约</span></span><br> <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span> ; k &lt; n; k++)&#123;<br>     <span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)<span class="hljs-comment">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    factor = <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">else</span><br>    factor = <span class="hljs-number">-1.0</span>;<br>     sum += factor /(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br> &#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，我们在for循环中使用4个变量。由于default子句，我们需要明确每个变量的作用域。正如我们已经注意到的，sum是一个归约变量（同时拥有私有和共享作用域的属性）。我们也已经注意到factor和循环变量中k应该有私有作用域。从未在parallel或parallel for块中更新的变量，如这个例子中的n，能够被安全的共享。与私有变量不同，共享变量在块内具有在parallel或parallel for块之前的值，在块之后的值与块内的最后一个值相同。因此，如果n在块之前被初始化为1000，则在parallel for语句中他将保持这个值。因为在for循环中值没有改变，所有在循环结束后它将保持这个值。</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><ol><li>分析数学背景，解决循环依赖（数据依赖）</li><li>判断变量的作用域</li></ol><h3 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7.参考资料"></a>7.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP寻找循环依赖</title>
    <link href="/2023/01/06/openmp002/"/>
    <url>/2023/01/06/openmp002/</url>
    
    <content type="html"><![CDATA[<h3 id="1-OpenMP寻找循环依赖"><a href="#1-OpenMP寻找循环依赖" class="headerlink" title="1.OpenMP寻找循环依赖"></a>1.OpenMP寻找循环依赖</h3><p>​当我们试图使用一个parallel for指令时，首先应该注意的是：要小心发现循环依赖。我们不需要担心一般的数据依赖。例如，在下面循环中：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    x[i] = a + i*h;<span class="hljs-comment">//2</span><br>    y[i] = <span class="hljs-built_in">exp</span>(x[i]);<span class="hljs-comment">//3</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在第二行和第三行之间有一个数据依赖。然而，如下的并行化没有问题。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    x[i] = a + i*h;<span class="hljs-comment">//3</span><br>    y[i] = <span class="hljs-built_in">exp</span>(x[i]);<span class="hljs-comment">//4</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>因为x[ i ]的计算与它接下来的使用总是被分配给同一个进程。</p><p>​我们也应该观察到，有依赖关系的语句，其中至少一条语句会有序地写或更新变量。因此为了检测循环依赖，我们只需要重点观察被循环体更新的变量，即我们应该寻找在一个迭代中被读或被写，而在另一个迭代中被写的变量。</p><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h3><ol><li>数据依赖在优化过程中非常常见</li><li>如何解决数据依赖对提升并行化的效果影响很大</li></ol><h3 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.参考资料"></a>3.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP梯度积分法</title>
    <link href="/2023/01/03/openmp001/"/>
    <url>/2023/01/03/openmp001/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenMP梯度积分法"><a href="#OpenMP梯度积分法" class="headerlink" title="OpenMP梯度积分法"></a>OpenMP梯度积分法</h2><h3 id="1-梯度积分法"><a href="#1-梯度积分法" class="headerlink" title="1.梯度积分法"></a>1.梯度积分法</h3><p><img src="/2023/01/03/openmp001/image-20230106165434252.png" alt="001"></p><p><img src="/2023/01/03/openmp001/image-20230106165507737.png" alt="image-20230106165507737"></p><h3 id="2-识别两类任务"><a href="#2-识别两类任务" class="headerlink" title="2.识别两类任务"></a>2.识别两类任务</h3><p><img src="/2023/01/03/openmp001/image-20230106164847677.png" alt="image-20230106164847677"></p><ol><li>单个梯形的面积计算</li><li>梯形面积求和</li></ol><p>在2.1的任务中，没有任务间的通信，但这一组任务中的每一组任务都与2.2的任务通信</p><h3 id="3-累加线程结果"><a href="#3-累加线程结果" class="headerlink" title="3.累加线程结果"></a>3.累加线程结果</h3><p>​使用一个共享变量作为所有线程的和 ，每个线程可以将它计算的部分结果累加到共享变量中，让每个线程执行类似下面的语句：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical</span><br>global_result += myresult;                <span class="hljs-comment">//需要互斥访问</span><br></code></pre></div></td></tr></table></figure><p>竞争条件，使用临界区解决。保证每次只有一个线程执行这段结构性代码。</p><h3 id="4-程序完整代码"><a href="#4-程序完整代码" class="headerlink" title="4.程序完整代码"></a>4.程序完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Trap</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">double</span> *global_result_p)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>&#123;<br><span class="hljs-keyword">double</span> global_result = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">double</span> a,b;<span class="hljs-comment">//为了区分local_a,local_b</span><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> thread_count;<br><br>thread_count = <span class="hljs-number">8</span>;                                      <span class="hljs-comment">//指定你的线程数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter a,b, and n\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf %d&quot;</span>,&amp;a,&amp;b,&amp;n);<br>    <br>    <span class="hljs-comment">//并行区开始</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel num_threads(thread_count)<span class="hljs-comment">//指定Trap函数由thread_count个线程执行</span></span><br><span class="hljs-built_in">Trap</span>(a,b,n,&amp;global_result);<br><span class="hljs-comment">//并行区结束</span><br>    <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;With n = %d trapezoids, our estimate\n&quot;</span>,n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;of the integral from %f to %f = %.4lf\n&quot;</span>,a,b,global_result);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Trap</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">double</span> *global_result_p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> h,x,my_result;<br><span class="hljs-keyword">double</span> local_a,local_b;<br><span class="hljs-keyword">int</span> i,local_n;<span class="hljs-comment">//local_n代表本进程被分配了多少个任务</span><br><span class="hljs-keyword">int</span> my_rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br><span class="hljs-keyword">int</span> thread_count = <span class="hljs-built_in">omp_get_num_threads</span>();<br><br>h = (b-a)/n;<span class="hljs-comment">//梯形底的长度</span><br>local_n = n/thread_count;<span class="hljs-comment">//每个线程分配的梯形数，保证能整除</span><br>local_a = a + my_rank*local_n*h;<span class="hljs-comment">//区间的左端点</span><br>local_b = local_a + local_n*h;<span class="hljs-comment">//区间的右端点</span><br><span class="hljs-comment">//对global_result共享部分和</span><br>    my_result = (<span class="hljs-built_in">f</span>(local_a) + <span class="hljs-built_in">f</span>(local_b))/<span class="hljs-number">2.0</span>;<span class="hljs-comment">//f(x)是目标函数</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span> ; i&lt;=local_n<span class="hljs-number">-1</span>; i++)&#123;<br>x = local_a + i*h;<br>my_result += <span class="hljs-built_in">f</span>(x);<br>&#125;<br>my_result = my_result*h;<br>    <span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical<span class="hljs-comment">//临界区，这里可以直接使用OpenMP提供的reduction</span></span><br>*global_result_p += my_result;<span class="hljs-comment">//线程将部分和结果累加到共享变量</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ol><li>核心是拆分任务区域，把子任务分配到个个线程</li><li>共享变量的选取决定了可并行度</li><li>通过共享变量实现了归约的操作(这里使用到了临界区)</li></ol><h3 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6.参考资料"></a>6.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国内常用镜像源</title>
    <link href="/2022/06/22/mirror001/"/>
    <url>/2022/06/22/mirror001/</url>
    
    <content type="html"><![CDATA[<h2 id="国内常用镜像源"><a href="#国内常用镜像源" class="headerlink" title="国内常用镜像源"></a>国内常用镜像源</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">清华大学： https:<span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple/</span><br>阿里云： https:<span class="hljs-comment">//mirrors.aliyun.com/pypi/simple/</span><br>豆瓣： http:<span class="hljs-comment">//pypi.douban.com/simple/</span><br>中国科学技术大学： http:<span class="hljs-comment">//pypi.mirrors.ustc.edu.cn/simple/</span><br>华中科技大学：http:<span class="hljs-comment">//pypi.hustunique.com/simple/</span><br>山东理工大学：http:<span class="hljs-comment">//pypi.sdutlinux.org/simple/</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mirror</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐</title>
    <link href="/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><h2 id="CPU读取内存的方式"><a href="#CPU读取内存的方式" class="headerlink" title="CPU读取内存的方式"></a>CPU读取内存的方式</h2><p>CPU读取内存的方式其实非常复杂，为了更进一步的了解相关的原理，需要对计算机组成原理进行深度学习。</p><h3 id="Memory-access-granularity-内存读取粒度"><a href="#Memory-access-granularity-内存读取粒度" class="headerlink" title="Memory access granularity(内存读取粒度)"></a>Memory access granularity(内存读取粒度)</h3><p>However, your computer’s processor does not read from and write to memory in byte-sized chunks. Instead, it accesses memory in two-, four-, eight- 16- or even 32-byte chunks. We’ll call the size in which a processor accesses memory its memory access granularity.</p><p>CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为<em>memory access granularity（粒度）</em> 本人把它翻译为“内存读取粒度” 。</p><p><a href="https://www.cnblogs.com/feng9exe/p/10059543.html">https://www.cnblogs.com/feng9exe/p/10059543.html</a> ”内存对齐“</p><h2 id="内存对齐举例"><a href="#内存对齐举例" class="headerlink" title="内存对齐举例"></a>内存对齐举例</h2><p>假设此计算机的内存读取粒度是4。</p><h3 id="如果内存对齐时"><a href="#如果内存对齐时" class="headerlink" title="如果内存对齐时"></a>如果内存对齐时</h3><p>前提知识：</p><p>1 Byte &#x3D; 8bit </p><p>1 int8 占用 1 Byte</p><p>1 int16 占用 2 Byte</p><p>1 int32 占用 4 Byte</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//一个结构体的定义如下</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span></span><br><span class="hljs-class">&#123;</span><br>    int8 a;<br>    int32 b;<br>&#125;<br></code></pre></div></td></tr></table></figure><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th align="center">4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>int8 a</td><td></td><td></td><td></td><td align="center">int32 b</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>我们可以发现int8 a储存在0号内存上，占用1个Byte，1-3号内存空下了3个Byte。int32 b储存在了4-7号内存，一共4个Byte。</p><p>由于此计算机的内存读取粒度时是4</p><p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p><p>当需要读取b(4-7号内存时)，计算机会读取4-7号内存，访问次数1次。</p><h3 id="如果内存没有对齐时"><a href="#如果内存没有对齐时" class="headerlink" title="如果内存没有对齐时"></a>如果内存没有对齐时</h3><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>int8 a</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>我们可以发现int8 a储存在0号内存上，占用了1个Byte。int32 b储存在1-4号内存上，一共4个Byte。</p><p>由于此计算机的内存读取粒度时是4</p><p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p><p>当需要读取b(1-4号内存)时，计算机会先读取0-3号一组内存，去掉0号内存，再读取4-7号一组内存，去掉5-7号内存，随后再拼接1-3号内存和4号内存组成完整的b。访问次数2次。</p><h2 id="内存对齐的目的"><a href="#内存对齐的目的" class="headerlink" title="内存对齐的目的"></a>内存对齐的目的</h2><p>合理的内存对齐可以高效的利用硬件性能，减少处理器内存访问次数。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0</a> “内存对齐”</p><p><a href="https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0</a> “内存对齐对程序性能的影响”</p>]]></content>
    
    
    <categories>
      
      <category>Computer Organization</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(一)-简单的发送接收</title>
    <link href="/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/"/>
    <url>/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-简单的发送接收"><a href="#MPI-简单的发送接收" class="headerlink" title="MPI-简单的发送接收"></a>MPI-简单的发送接收</h1><p>打印来自进程问候语句的MPI程序</p><h2 id="所使用的MPI原语"><a href="#所使用的MPI原语" class="headerlink" title="所使用的MPI原语"></a>所使用的MPI原语</h2><p><img src="/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi001.png"></p><p><img src="/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi002.png"></p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpicc  3.1.cpp -o 3.1</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>mpirun -np 4 .&#x2F;3.1(本地提交,采取4个进程)</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span>   <span class="hljs-comment">//头文件</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_STRING = <span class="hljs-number">100</span> ;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> greeting[MAX_STRING];<br><span class="hljs-keyword">int</span> comm_sz;<br><span class="hljs-keyword">int</span> my_rank;<br>MPI_Status status;<br><br><span class="hljs-built_in">MPI_Init</span>(&amp;argc,&amp;argv);<br><br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;comm_sz);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;my_rank);<br><br><span class="hljs-keyword">if</span>(my_rank != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//其他进程向0号进程发消息</span><br><span class="hljs-built_in">sprintf</span>(greeting,<span class="hljs-string">&quot;Greetings from process %d of %d!&quot;</span>,my_rank,comm_sz);<br><span class="hljs-built_in">MPI_Send</span>(greeting,<span class="hljs-built_in">strlen</span>(greeting)+<span class="hljs-number">1</span>,MPI_CHAR,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,MPI_COMM_WORLD); <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Greetings from process %d of %d!\n&quot;</span>,my_rank,comm_sz);<br><span class="hljs-comment">//0号进程接受来自其他进程的消息并输出</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=<span class="hljs-number">1</span>;q&lt;comm_sz;q++)<br>&#123;<br><span class="hljs-built_in">MPI_Recv</span>(greeting,MAX_STRING,MPI_CHAR,q,<span class="hljs-number">0</span>,MPI_COMM_WORLD,&amp;status);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,greeting);<br>&#125;<br>&#125;<br><span class="hljs-built_in">MPI_Finalize</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Greetings from process <span class="hljs-number">0</span> of <span class="hljs-number">4</span>!<br>Greetings from process <span class="hljs-number">1</span> of <span class="hljs-number">4</span>!<br>Greetings from process <span class="hljs-number">2</span> of <span class="hljs-number">4</span>!<br>Greetings from process <span class="hljs-number">3</span> of <span class="hljs-number">4</span>!<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(二)-内存对齐的应用</title>
    <link href="/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX指令集的简单操作-内存对齐版"><a href="#AVX指令集的简单操作-内存对齐版" class="headerlink" title="AVX指令集的简单操作(内存对齐版)"></a>AVX指令集的简单操作(内存对齐版)</h1><p>使用AVX指令集进行2个double型的数组相加操作</p><h2 id="常用的内存对齐函数"><a href="#常用的内存对齐函数" class="headerlink" title="常用的内存对齐函数"></a>常用的内存对齐函数</h2><p>因为AVX中要求mem__addr必须在32字节边界上对齐，否则可能会产生通用保护异常。  </p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br></code></pre></div></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)_mm_malloc(<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>),<span class="hljs-number">32</span>);<br></code></pre></div></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">aligned_alloc</span>(<span class="hljs-number">32</span>,<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br></code></pre></div></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__attribute__ ((<span class="hljs-built_in">aligned</span>(<span class="hljs-number">32</span>)))<span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>]  =&#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256d _mm256_load_pd (<span class="hljs-keyword">double</span> <span class="hljs-keyword">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure><p><strong>Description</strong></p><p>Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">dst[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>] := MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr]<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256 _mm256_add_ps (__m256 a, __m256 b)<br></code></pre></div></td></tr></table></figure><p><strong>Description</strong></p><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">FOR</span> j := <span class="hljs-number">0</span> to <span class="hljs-number">7</span><br><span class="hljs-attribute">i</span> := j*<span class="hljs-number">32</span><br><span class="hljs-attribute">dst</span>[i+<span class="hljs-number">31</span>:i] := a[i+<span class="hljs-number">31</span>:i] + b[i+<span class="hljs-number">31</span>:i]<br><span class="hljs-attribute">ENDFOR</span><br><span class="hljs-attribute">dst</span>[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="3-stream的作用：绕过缓存直接写入内存"><a href="#3-stream的作用：绕过缓存直接写入内存" class="headerlink" title="3.stream的作用：绕过缓存直接写入内存"></a>3.stream的作用：绕过缓存直接写入内存</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> _mm256_stream_pd (<span class="hljs-keyword">double</span> * mem_addr, __m256d a)<br></code></pre></div></td></tr></table></figure><p><strong>Description</strong></p><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr] := a[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><h2 id="样例程序举例："><a href="#样例程序举例：" class="headerlink" title="样例程序举例："></a>样例程序举例：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br><span class="hljs-keyword">double</span>*b =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">4</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br><span class="hljs-keyword">double</span> af[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125; ;<br><span class="hljs-keyword">double</span> bf[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span>*c =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">4</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>a[i]=af[i];<br>b[i]=bf[i];<br>&#125;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>__m256d v0;<br>__m256d v1;<br>__m256d v2;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span><span class="hljs-number">-4</span>;i+=<span class="hljs-number">4</span>)<br>&#123;<br>v0 = _mm256_load_pd(a+i);<br>v1 = _mm256_load_pd(b+i);<br>v2=_mm256_add_pd(v0,v1);<br> _mm256_stream_pd(c+i,v2);<br><br>&#125;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>c[i]=a[i]+b[i];<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is c.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,c[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure><h2 id="样例程序输出："><a href="#样例程序输出：" class="headerlink" title="样例程序输出："></a>样例程序输出：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is c.<br><span class="hljs-number">3.200000</span><br><span class="hljs-number">5.400000</span><br><span class="hljs-number">9.700000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">9.200000</span><br><span class="hljs-number">16.500000</span><br><span class="hljs-number">12.800000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">8.700000</span><br></code></pre></div></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(一)</title>
    <link href="/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX指令集的简单操作"><a href="#AVX指令集的简单操作" class="headerlink" title="AVX指令集的简单操作"></a>AVX指令集的简单操作</h1><p>使用AVX指令集进行2个double型的数组相加操作</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256 _mm256_loadu_ps (<span class="hljs-keyword">float</span> <span class="hljs-keyword">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p><h3 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">dst[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>] := MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr]<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256d _mm256_add_pd (__m256d a, __m256d b)<br></code></pre></div></td></tr></table></figure><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p><h3 id="Operation-1"><a href="#Operation-1" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span><br>i := j*<span class="hljs-number">64</span><br>dst[i+<span class="hljs-number">63</span>:i] := a[i+<span class="hljs-number">63</span>:i] + b[i+<span class="hljs-number">63</span>:i]<br>ENDFOR<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> _mm256_storeu_pd (<span class="hljs-keyword">double</span> * mem_addr, __m256d a)<br></code></pre></div></td></tr></table></figure><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p><h3 id="Operation-2"><a href="#Operation-2" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr] := a[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><h2 id="未进行AVX向量化的情况"><a href="#未进行AVX向量化的情况" class="headerlink" title="未进行AVX向量化的情况"></a>未进行AVX向量化的情况</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span> c[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>c[i]=a[i]+b[i];<br><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is c.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,c[i]);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is c.<br><span class="hljs-number">3.200000</span><br><span class="hljs-number">5.400000</span><br><span class="hljs-number">9.700000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">9.200000</span><br><span class="hljs-number">16.500000</span><br><span class="hljs-number">12.800000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">8.700000</span><br></code></pre></div></td></tr></table></figure><h2 id="进行AVX向量化的情况"><a href="#进行AVX向量化的情况" class="headerlink" title="进行AVX向量化的情况"></a>进行AVX向量化的情况</h2><h3 id="程序源代码-1"><a href="#程序源代码-1" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span> c[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>__m256d v0;<br>__m256d v1;<br>__m256d v2;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span><span class="hljs-number">-4</span>;i+=<span class="hljs-number">4</span>)<br>&#123;<br>v0 = _mm256_loadu_pd(a+i);<br>v1 = _mm256_loadu_pd(b+i);<br>v2=_mm256_add_pd(v0,v1);<br> _mm256_storeu_pd(c+i,v2);<br><br>&#125;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>c[i]=a[i]+b[i];<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is c with AVX.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,c[i]);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure><h3 id="程序输出-1"><a href="#程序输出-1" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is c with AVX.<br><span class="hljs-number">3.200000</span><br><span class="hljs-number">5.400000</span><br><span class="hljs-number">9.700000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">9.200000</span><br><span class="hljs-number">16.500000</span><br><span class="hljs-number">12.800000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">8.700000</span><br></code></pre></div></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slurm</title>
    <link href="/2022/05/20/slurm001/"/>
    <url>/2022/05/20/slurm001/</url>
    
    <content type="html"><![CDATA[<h2 id="Slurm"><a href="#Slurm" class="headerlink" title="Slurm"></a>Slurm</h2><h4 id="1-sstat-查看RUNNING作业"><a href="#1-sstat-查看RUNNING作业" class="headerlink" title="1.sstat 查看RUNNING作业"></a>1.sstat 查看RUNNING作业</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sstat -e<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/slurm001/image-20220520174453969.png" alt="image-20220520174453969"></p><p><strong>使用举例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sstat -a --format=&quot;JobId,Pids,AveCPU,AveRSS,MaxRSS&quot;  1755818<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/slurm001/image-20220520175001331.png" alt="image-20220520175001331"></p><h4 id="2-sacct-查看FINISHED作业"><a href="#2-sacct-查看FINISHED作业" class="headerlink" title="2.sacct 查看FINISHED作业"></a>2.sacct 查看FINISHED作业</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sacct -e<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/slurm001/image-20220520174622868.png" alt="image-20220520174622868"></p><p><strong>使用举例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sacct --format=&quot;JobId,Elapsed,CPUTime,CPUTimeRAW,AveCPU,TotalCPU,UserCPU,SystemCPU,AveRSS,MaxRSS&quot; -j 1754217<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/slurm001/image-20220520174807162.png" alt="image-20220520174807162"></p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://blog.csdn.net/kongxx/article/details/52556943">(28条消息) Slurm查看作业CPU和MEM_kongxx的博客-CSDN博客_slurm 查看节点</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Slurm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numactl</title>
    <link href="/2022/05/20/numactl001/"/>
    <url>/2022/05/20/numactl001/</url>
    
    <content type="html"><![CDATA[<ol><li></li></ol><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">numactl --hardware<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/numactl001/image-20220520173911653.png" alt="image-20220520173911653"></p><ol start="2"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shelll">numastat<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/numactl001/image-20220520174030171.png" alt="image-20220520174030171"></p><ol start="3"><li></li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">numactl --show<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/numactl001/image-20220520174148487.png" alt="image-20220520174148487"></p><h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p><a href="https://blog.csdn.net/qccz123456/article/details/81979819">(28条消息) Linux工具之numactl_qccz123456的博客-CSDN博客_numactl</a></p><p><a href="https://baijiahao.baidu.com/s?id=1699088343604813491&wfr=spider&for=pc&searchword=numactl">宋宝华：为什么numactl内存绑定对代码段不起作用 (baidu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Numactl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux的jobs,fg,bg命令</title>
    <link href="/2022/05/20/Linux002/"/>
    <url>/2022/05/20/Linux002/</url>
    
    <content type="html"><![CDATA[<h3 id="linux让前台程序脱离终端运行"><a href="#linux让前台程序脱离终端运行" class="headerlink" title="linux让前台程序脱离终端运行"></a>linux让前台程序脱离终端运行</h3><p>1.首先运行你的程序</p><p><img src="/2022/05/20/Linux002/image-20220520171436032.png" alt="image-20220520171436032"></p><p>2.随后使用Ctrl + z，挂起你的进程</p><p><img src="/2022/05/20/Linux002/image-20220520171510946.png" alt="image-20220520171510946"></p><p>3.然后使用jobs查看所有的进程</p><p><img src="/2022/05/20/Linux002/image-20220520171913979.png" alt="image-20220520171913979"></p><p>4.随后使用bg+id，表示该任务为后台1号任务</p><p>bg命令用于将作业放到后台运行，使前台可以执行其他任务</p><p><img src="/2022/05/20/Linux002/image-20220520172110992.png" alt="image-20220520172110992"></p><h3 id="linux让后台程序移动到前台终端"><a href="#linux让后台程序移动到前台终端" class="headerlink" title="linux让后台程序移动到前台终端"></a>linux让后台程序移动到前台终端</h3><p>Linux常用命令fg主要用于将后台作业移动到前台终端运行</p><p><img src="/2022/05/20/Linux002/image-20220520172358345.png" alt="image-20220520172358345"></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用指令</title>
    <link href="/2022/05/20/Linux001/"/>
    <url>/2022/05/20/Linux001/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h2><h4 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">kill <span class="hljs-number">-9</span> id<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/Linux001/image-20220520171246860.png" alt="image-20220520171246860"></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcov代码覆盖率测试-完整样例-SLIC</title>
    <link href="/2022/05/08/tool004/"/>
    <url>/2022/05/08/tool004/</url>
    
    <content type="html"><![CDATA[<h2 id="gcov代码覆盖率测试-完整样例-SLIC"><a href="#gcov代码覆盖率测试-完整样例-SLIC" class="headerlink" title="gcov代码覆盖率测试-完整样例-SLIC"></a>gcov代码覆盖率测试-完整样例-SLIC</h2><h3 id="gcov代码覆盖率测试介绍："><a href="#gcov代码覆盖率测试介绍：" class="headerlink" title="gcov代码覆盖率测试介绍："></a>gcov代码覆盖率测试介绍：</h3><p><a href="https://xingyuanjie.top/2022/01/18/tool002/">gcov代码覆盖率测试 - 计算机奇妙之旅 (xingyuanjie.top)</a></p><h3 id="完整样例-SLIC："><a href="#完整样例-SLIC：" class="headerlink" title="完整样例-SLIC："></a>完整样例-SLIC：</h3><p><a href="https://xingyuanjie.top/2022/05/08/tool004/result.zip">https://xingyuanjie.top/2022/05/08/tool004/result.zip</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
      <tag>gcov</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-036 网红点打卡攻略 (25 分)</title>
    <link href="/2022/04/23/Algorithm032/"/>
    <url>/2022/04/23/Algorithm032/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-036-网红点打卡攻略-25-分"><a href="#L2-036-网红点打卡攻略-25-分" class="headerlink" title="L2-036 网红点打卡攻略 (25 分)"></a>L2-036 网红点打卡攻略 (25 分)</h2><p>一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个正整数：网红点的个数 <em>N</em>（1&lt;<em>N</em>≤200）和网红点之间通路的条数 <em>M</em>。随后 <em>M</em> 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 <em>N</em> 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 <code>0</code>。</p><p>再下一行给出一个正整数 <em>K</em>，是待检验的攻略的数量。随后 <em>K</em> 行，每行给出一条待检攻略，格式为：</p><p><em>n</em> <em>V</em>1 <em>V</em>2 ⋯ Vn</p><p>其中 <em>n</em>(≤200) 是攻略中的网红点数，<em>Vi</em> 是路径上的网红点编号。这里假设你从家里出发，从 <em>V</em>1 开始打卡，最后从 <em>Vn</em> 回家。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在第一行输出满足要求的攻略的个数。</p><p>在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。</p><p>题目保证至少存在一个有效攻略，并且总路费不超过 109。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">6 13<br>0 5 2<br>6 2 2<br>6 0 1<br>3 4 2<br>1 5 2<br>2 5 1<br>3 1 1<br>4 1 2<br>1 6 1<br>6 3 2<br>1 2 1<br>4 5 3<br>2 0 2<br>7<br>6 5 1 4 3 6 2<br>6 5 2 1 6 3 4<br>8 6 2 1 6 3 4 5 2<br>3 2 1 5<br>6 6 1 3 4 5 2<br>7 6 2 1 3 4 5 2<br>6 5 2 1 4 3 6<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">3<br>5 11<br></code></pre></div></td></tr></table></figure><h3 id="样例说明："><a href="#样例说明：" class="headerlink" title="样例说明："></a>样例说明：</h3><p>第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。</p><p>第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 &#x3D; 14；</p><p>第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &#x3D; 11，是一条更省钱的攻略；</p><p>第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<br><span class="hljs-keyword">int</span> minsize=INT_MAX;<span class="hljs-comment">//初始化为INT_MAX</span><br><span class="hljs-keyword">int</span> minid=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b]=c;<br>        g[b][a]=c;<br>    &#125;<br>    <span class="hljs-keyword">int</span> time;<br>    cin&gt;&gt;time;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-keyword">int</span> roll[k+<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">int</span> has[k+<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">memset</span>(has,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(has));<br>        roll[<span class="hljs-number">0</span>]=roll[k+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//起点和终点必定是家</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=k ; ++i) &#123;<br>            cin&gt;&gt;roll[i];<br>            <span class="hljs-keyword">if</span>(has[roll[i]]) has[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//每个打卡点仅能打卡一次</span><br>            <span class="hljs-keyword">else</span> has[roll[i]]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> tmpsize=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(k!=n||has[<span class="hljs-number">0</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=k+<span class="hljs-number">1</span> ; ++l) &#123;<br>            <span class="hljs-keyword">if</span>(g[roll[l<span class="hljs-number">-1</span>]][roll[l]]==<span class="hljs-number">0</span>)<br>            &#123;<br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tmpsize+=g[roll[l<span class="hljs-number">-1</span>]][roll[l]];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmpsize&lt;minsize)&#123;<br>                minsize=tmpsize;<br>                minid=j+<span class="hljs-number">1</span>;<br><br>            &#125;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    cout&lt;&lt;minid&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;minsize&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059">题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-039 清点代码库 (25 分)</title>
    <link href="/2022/04/23/Algorithm031/"/>
    <url>/2022/04/23/Algorithm031/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-039-清点代码库-25-分"><a href="#L2-039-清点代码库-25-分" class="headerlink" title="L2-039 清点代码库 (25 分)"></a>L2-039 清点代码库 (25 分)</h2><p><img src="/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg" alt="code.jpg"></p><p>上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”</p><p>这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 <strong>int</strong> 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出 2 个正整数，依次为 <em>N</em>（≤104）和 <em>M</em>（≤102），对应功能模块的个数和系列测试输入的个数。</p><p>随后 <em>N</em> 行，每行给出一个功能模块的 <em>M</em> 个对应输出，数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第一行输出不同功能的个数 <em>K</em>。随后 <em>K</em> 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。</p><p>注：所谓数列 { <em>A</em>1, …, <em>A</em>M } 比 { <em>B</em>1, …, <em>B</em>M } 大，是指存在 1≤i&lt;*M*，使得 *A*1&#x3D;*B*1，…，*Ai*&#x3D;*Bi* 成立，且 *Ai*+1&gt;<em>B</em>+1。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">7 3<br>35 28 74<br>-1 -1 22<br>28 74 35<br>-1 -1 22<br>11 66 0<br>35 28 74<br>35 28 74<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">4<br>3 35 28 74<br>2 -1 -1 22<br>1 11 66 0<br>1 28 74 35<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>利用map的映射关系</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; mp;   <span class="hljs-comment">//key，value</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; a,pair&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.second==b.second)<br>    &#123;<br>        <span class="hljs-keyword">return</span> a.first&lt;b.first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.second&gt;b.second;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            tmp.<span class="hljs-built_in">push_back</span>(num);<br>        &#125;<br>        mp[tmp]++;<br>        tmp.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    vector&lt;pair&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">v</span>(mp.<span class="hljs-built_in">begin</span>(),mp.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//把map类型转化成vector</span><br>    cout&lt;&lt;v.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmp);<span class="hljs-comment">//sort排序，注意终点和起点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;v.<span class="hljs-built_in">size</span>() ; ++k) &#123;<br>        cout&lt;&lt;v[k].second&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(i!=m<span class="hljs-number">-1</span>)&#123;<br>                cout&lt;&lt;v[k].first[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;v[k].first[i]&lt;&lt;endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362">题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>Vector</tag>
      
      <tag>Map</tag>
      
      <tag>Pair</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-005 集合相似度 (25 分)</title>
    <link href="/2022/04/23/Algorithm030/"/>
    <url>/2022/04/23/Algorithm030/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-005-集合相似度-25-分"><a href="#L2-005-集合相似度-25-分" class="headerlink" title="L2-005 集合相似度 (25 分)"></a>L2-005 集合相似度 (25 分)</h2><p>给定两个整数集合，它们的相似度定义为：Nc&#x2F;Nt×100%。其中Nc是两个集合都有的不相等整数的个数，Nt是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤50），是集合的个数。随后<em>N</em>行，每行对应一个集合。每个集合首先给出一个正整数<em>M</em>（≤104），是集合中元素的个数；然后跟<em>M</em>个[0,109]区间内的整数。</p><p>之后一行给出一个正整数<em>K</em>（≤2000），随后<em>K</em>行，每行对应一对需要计算相似度的集合的编号（集合从1到<em>N</em>编号）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">3<br>3 99 87 101<br>4 87 101 5 87<br>7 99 101 18 5 135 18 99<br>2<br>1 2<br>1 3<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">50.00%<br>33.33%<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>双set模拟</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    set&lt;<span class="hljs-keyword">int</span>&gt; s[<span class="hljs-number">55</span>];<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            s[i].<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> find;<br>    cin&gt;&gt;find;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;find ; ++l) &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        set&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br>        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (it=s[a<span class="hljs-number">-1</span>].<span class="hljs-built_in">begin</span>(); it!=s[a<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>() ; it++) &#123;<br>            <span class="hljs-keyword">if</span>(s[b<span class="hljs-number">-1</span>].<span class="hljs-built_in">find</span>(*it)!=s[b<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//找到了</span><br>                cnt++;<span class="hljs-comment">//Nc</span><br>            &#125;<br>        &#125;<br>        sum=s[a<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>()+s[b<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>()-cnt;<span class="hljs-comment">//Nt=两个集合的总个数-相同个数</span><br>        <span class="hljs-keyword">double</span> ans=<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(cnt)/<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(sum))*<span class="hljs-number">100.0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf%\n&quot;</span>,ans);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805070149828608">题目详情 - L2-005 集合相似度 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL中map的使用</title>
    <link href="/2022/04/16/Algorithm029/"/>
    <url>/2022/04/16/Algorithm029/</url>
    
    <content type="html"><![CDATA[<h2 id="STL中map的使用"><a href="#STL中map的使用" class="headerlink" title="STL中map的使用"></a>STL中map的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>map 是 STL 的一个关联容器，它提供一对一的数据处理能力。</p><p>map 对象是<strong>模板类</strong>，需要<strong>关键字</strong>和<strong>存储对象</strong>两个模板参数：其中第一个参数称为关键字，每个关键字只能在 map 中出现一次；第二个参数称为该关键字的值。可以将关键字和存储对象理解为“{键，值}对”。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt; mp;<br></code></pre></div></td></tr></table></figure><h3 id="map的数据插入操作"><a href="#map的数据插入操作" class="headerlink" title="map的数据插入操作"></a>map的数据插入操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//使用insert函数插入pair数据</span><br>mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;xingyuanjie&quot;</span>));<br><span class="hljs-comment">//使用数组方式插入数据</span><br>mp[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;wangzhouyang&quot;</span>;<br></code></pre></div></td></tr></table></figure><p><strong>说明：上面的两种方法是有区别的，用 insert 函数插入数据，涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能实现数据插入的；但是数组方式能够插入数据，插入的数据会覆盖该关键字之前对应的值。</strong></p><h3 id="map中数据的遍历"><a href="#map中数据的遍历" class="headerlink" title="map中数据的遍历"></a>map中数据的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br><span class="hljs-keyword">for</span> (it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++) &#123;<br>    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="map中数据的查找"><a href="#map中数据的查找" class="headerlink" title="map中数据的查找"></a>map中数据的查找</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br>it=mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(it!=mp.<span class="hljs-built_in">end</span>())&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Find it, the relative value is: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;Can not find the relative value.&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="map中数据的删除"><a href="#map中数据的删除" class="headerlink" title="map中数据的删除"></a>map中数据的删除</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br>it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br>mp.<span class="hljs-built_in">erase</span>(it);<br></code></pre></div></td></tr></table></figure><h3 id="map中数据的排序"><a href="#map中数据的排序" class="headerlink" title="map中数据的排序"></a>map中数据的排序</h3><p><strong>map 中的所有元素都会根据元素的键值，自动进行升序排序。</strong></p><h3 id="完整操作"><a href="#完整操作" class="headerlink" title="完整操作"></a>完整操作</h3><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;<span class="hljs-keyword">int</span>,string&gt; mp;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//使用insert函数插入pair数据</span><br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;xingyuanjie&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;shicheng&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;tanghaipeng&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;zhouyuhao&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;heqichuan&quot;</span>));<br>    <span class="hljs-comment">//使用数组方式插入数据</span><br>    mp[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;wangzhouyang&quot;</span>;<br>    <span class="hljs-comment">//map的遍历</span><br>    map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<br>    <span class="hljs-keyword">for</span> (it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++) &#123;<br>        cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//查找操作</span><br>    it=mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(it!=mp.<span class="hljs-built_in">end</span>())&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Find it, the relative value is: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Can not find the relative value.&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//删除操作</span><br>    it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br>    mp.<span class="hljs-built_in">erase</span>(it);<br>    <span class="hljs-keyword">for</span> (it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++) &#123;<br>        cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span> shicheng<br><span class="hljs-number">2</span> wangzhouyang<br><span class="hljs-number">3</span> xingyuanjie<br><span class="hljs-number">4</span> tanghaipeng<br><span class="hljs-number">5</span> heqichuan<br><span class="hljs-number">6</span> zhouyuhao<br>Find it, the relative value is: shicheng<br><span class="hljs-number">1</span> shicheng<br><span class="hljs-number">3</span> xingyuanjie<br><span class="hljs-number">4</span> tanghaipeng<br><span class="hljs-number">5</span> heqichuan<br><span class="hljs-number">6</span> zhouyuhao<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/liitdar/article/details/80009712">(20条消息) STL中map介绍_liitdar的博客-CSDN博客_stlmap</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-010 排座位 (25 分)</title>
    <link href="/2022/04/16/Algorithm028/"/>
    <url>/2022/04/16/Algorithm028/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-010-排座位-25-分"><a href="#L2-010-排座位-25-分" class="headerlink" title="L2-010 排座位 (25 分)"></a><strong>L2-010 排座位 (25 分)</strong></h2><p>布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出3个正整数：<code>N</code>（≤100），即前来参宴的宾客总人数，则这些人从1到<code>N</code>编号；<code>M</code>为已知两两宾客之间的关系数；<code>K</code>为查询的条数。随后<code>M</code>行，每行给出一对宾客之间的关系，格式为：<code>宾客1 宾客2 关系</code>，其中<code>关系</code>为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后<code>K</code>行，每行给出一对需要查询的宾客编号。</p><p>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出<code>No problem</code>；如果他们之间并不是朋友，但也不敌对，则输出<code>OK</code>；如果他们之间有敌对，然而也有共同的朋友，则输出<code>OK but...</code>；如果他们之间只有敌对关系，则输出<code>No way</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">7 8 4<br>5 6 1<br>2 7 -1<br>1 3 1<br>3 4 1<br>6 7 -1<br>1 2 1<br>1 4 1<br>2 3 -1<br>3 4<br>5 7<br>2 3<br>7 2<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">No problem<br>OK<br>OK but...<br>No way<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接矩阵 + 并查集</strong></p><p><strong>并查集具体链接：</strong></p><p><a href="https://xingyuanjie.top/2022/01/04/Algorithm004/">并查集 - 计算机奇妙之旅 (xingyuanjie.top)</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> pre[<span class="hljs-number">100</span>];<span class="hljs-comment">//父节点</span><br><span class="hljs-keyword">int</span> deep[<span class="hljs-number">100</span>];<span class="hljs-comment">//深度</span><br><span class="hljs-keyword">int</span> g[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<span class="hljs-comment">//邻接矩阵建图</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        pre[i]=i;<br>        deep[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(pre[x]==x)&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> pre[x]=<span class="hljs-built_in">find</span>(pre[x]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    x=<span class="hljs-built_in">find</span>(x);<br>    y=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(deep[x]&lt;deep[y])&#123;<br>        pre[x]=y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        pre[y]=x;<br>        <span class="hljs-keyword">if</span>(deep[x]==deep[y])&#123;<br>            deep[x]++;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m,k;<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">105</span>);<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b]=g[b][a]=c;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-number">1</span>) <span class="hljs-built_in">unit</span>(a,b);<span class="hljs-comment">//如果是朋友则合并</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;k ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">1</span>&amp;&amp;g[b][a]==<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;No problem&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">0</span>&amp;&amp;g[b][a]==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;OK&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//两人毫无关系</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">-1</span>&amp;&amp;g[b][a]==<span class="hljs-number">-1</span>&amp;&amp;<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b)) cout&lt;&lt;<span class="hljs-string">&quot;OK but...&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//敌对且有共同朋友</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">-1</span>&amp;&amp;g[b][a]==<span class="hljs-number">-1</span>) cout&lt;&lt;<span class="hljs-string">&quot;No way&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//仅敌对</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/weixin_45260385/article/details/109752008">(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680">题目详情 - L2-010 排座位 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-009 抢红包 (25 分)</title>
    <link href="/2022/04/16/Algorithm027/"/>
    <url>/2022/04/16/Algorithm027/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-009-抢红包-25-分"><a href="#L2-009-抢红包-25-分" class="headerlink" title="L2-009 抢红包 (25 分)"></a><strong>L2-009 抢红包 (25 分)</strong></h2><p>没有人没抢过红包吧…… 这里给出<em>N</em>个人之间互相发红包、抢红包的记录，请你统计一下他们抢红包的收获。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤104），即参与发红包和抢红包的总人数，则这些人从1到<em>N</em>编号。随后<em>N</em>行，第<em>i</em>行给出编号为<em>i</em>的人发红包的记录，格式如下：</p><p><em>K     N</em>1 <em>P</em>1⋯ NK PK</p><p>其中<em>K</em>（0≤<em>K</em>≤20）是发出去的红包个数，<em>N</em>i<em>是抢到红包的人的编号，</em>Pi（&gt;0）是其抢到的红包金额（以分为单位）。注意：对于同一个人发出的红包，每人最多只能抢1次，不能重复抢。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照收入金额从高到低的递减顺序输出每个人的编号和收入金额（以元为单位，输出小数点后2位）。每个人的信息占一行，两数字间有1个空格。如果收入金额有并列，则按抢到红包的个数递减输出；如果还有并列，则按个人编号递增输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">10<br>3 2 22 10 58 8 125<br>5 1 345 3 211 5 233 7 13 8 101<br>1 7 8800<br>2 1 1000 2 1000<br>2 4 250 10 320<br>6 5 11 9 22 8 33 7 44 10 55 4 2<br>1 3 8800<br>2 1 23 2 123<br>1 8 250<br>4 2 121 4 516 7 112 9 10<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">1 11.63<br>2 3.63<br>8 3.63<br>3 2.11<br>7 1.69<br>6 -1.67<br>9 -2.18<br>10 -3.26<br>5 -3.26<br>4 -12.32<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>结构体 + Sort</strong></p><p><strong>需要注意的就是double类型相等的比较</strong></p><p><strong>首先，浮点数在计算机中并不能精确的表示，所以在判断两个double类型的数时需要其他的手段，而不是直接 a&#x3D;&#x3D; b</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-keyword">int</span> id=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> money=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">double</span> dis=<span class="hljs-number">1e-6</span>;<span class="hljs-comment">//定义一个误差</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(student a,student b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a.money-b.money)&lt;dis)&#123;<span class="hljs-comment">//如果两个double型相减在误差的范围内，我们认定这两个double类型相等</span><br>        <span class="hljs-keyword">if</span>(a.cnt==b.cnt)&#123;<br>            <span class="hljs-keyword">return</span> a.id&lt;b.id;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> a.cnt&gt;b.cnt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.money&gt;b.money;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    student st[n+<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        st[i].id=i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> p;<br>            <span class="hljs-keyword">double</span> x;<br>            cin&gt;&gt;p&gt;&gt;x;<br>            st[p<span class="hljs-number">-1</span>].money+=x/<span class="hljs-number">100</span>;<br>            st[i].money-=x/<span class="hljs-number">100</span>;<br>            st[p<span class="hljs-number">-1</span>].cnt++;<span class="hljs-comment">//记录抢到的红包数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(st,st+n,cmp);<span class="hljs-comment">//sort从数组下标0开始排序，左闭右开</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;n ; ++k) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf\n&quot;</span>,st[k].id,st[k].money);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/dingpiao190/article/details/73512811?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">(20条消息) double类型是否相等的判断方法_dingpiao190的博客-CSDN博客_double判断相等</a></p><p><a href="https://blog.csdn.net/patrick_star_cowboy/article/details/82083392">(20条消息) 如何判断两个double类型的数是否相等？_Patrick-Star的博客-CSDN博客_两个double怎么判断相等</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805066890854400">题目详情 - L2-009 抢红包 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>结构体</tag>
      
      <tag>Double类型相等比较</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-003 月饼 (25 分)</title>
    <link href="/2022/04/15/Algorithm026/"/>
    <url>/2022/04/15/Algorithm026/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-003-月饼-25-分"><a href="#L2-003-月饼-25-分" class="headerlink" title="L2-003 月饼 (25 分)"></a>L2-003 月饼 (25 分)</h2><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45&#x2F;2 &#x3D; 94.5（亿元）。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 <em>N</em> 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 <em>D</em> 表示市场最大需求量。随后一行给出 <em>N</em> 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 <em>N</em> 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">3 20<br>18 15 10<br>75 72 45<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">94.50<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>贪心 + Sort</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mooncake</span>&#123;</span><br>    <span class="hljs-keyword">double</span> pow;<br>    <span class="hljs-keyword">double</span> price;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(mooncake a,mooncake b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.price*<span class="hljs-number">1.0</span>/a.pow&gt;b.price*<span class="hljs-number">1.0</span>/b.pow;<span class="hljs-comment">//返回单价高的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">double</span> d;<br>    cin&gt;&gt;n&gt;&gt;d;<br>    mooncake m[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin&gt;&gt;m[i].pow;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n ; ++j) &#123;<br>        cin&gt;&gt;m[j].price;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(m,m+n,cmp);<br>    <span class="hljs-keyword">double</span> price=<span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">double</span> tmpd=d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;n ; ++k) &#123;<span class="hljs-comment">//模拟求解</span><br>        <span class="hljs-keyword">if</span>(m[k].pow&lt;=tmpd)&#123;<br>            tmpd-=m[k].pow;<br>            price+=m[k].price;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m[k].pow&gt;tmpd)&#123;<br>            price+=tmpd*(m[k].price/m[k].pow);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f\n&quot;</span>,price);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805071789801472">题目详情 - L2-003 月饼 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>结构体</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-013 红色警报 (25 分)</title>
    <link href="/2022/04/15/Algorithm025/"/>
    <url>/2022/04/15/Algorithm025/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-013-红色警报-25-分"><a href="#L2-013-红色警报-25-分" class="headerlink" title="L2-013 红色警报 (25 分)"></a>L2-013 红色警报 (25 分)</h2><p>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个整数<code>N</code>（0 &lt; <code>N</code> ≤ 500）和<code>M</code>（≤ 5000），分别为城市个数（于是默认城市从0到<code>N</code>-1编号）和连接两城市的通路条数。随后<code>M</code>行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数<code>K</code>和随后的<code>K</code>个被攻占的城市的编号。</p><p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出<code>Red Alert: City k is lost!</code>，其中<code>k</code>是该城市的编号；否则只输出<code>City k is lost.</code>即可。如果该国失去了最后一个城市，则增加一行输出<code>Game Over.</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">5 4<br>0 1<br>1 3<br>3 0<br>0 4<br>5<br>1 2 0 4 3<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">City 1 is lost.<br>City 2 is lost.<br>Red Alert: City 0 is lost!<br>City 4 is lost.<br>City 3 is lost.<br>Game Over.<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接矩阵建图 + DFS统计连通分量数</strong></p><p><strong>对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数</strong></p><p><strong>无向图中的极大连通子图称为连通分量</strong></p><p><strong>极大连通子图必须连通，且包含尽可能多的顶点和边</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<span class="hljs-comment">//邻接矩阵存图</span><br><span class="hljs-keyword">int</span> visit[<span class="hljs-number">505</span>];<span class="hljs-comment">//标记访问数组</span><br><span class="hljs-keyword">int</span> lost[<span class="hljs-number">505</span>];<span class="hljs-comment">//记录被攻占的城市</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span></span>&#123;<span class="hljs-comment">//正常的DFS</span><br>    visit[node]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(visit[i]==<span class="hljs-number">0</span>&amp;&amp;g[node][i]==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfstrave</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(visit,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(visit));<span class="hljs-comment">//初始化访问数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(lost[i]==<span class="hljs-number">1</span>) visit[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//如果该城市被攻占，则标记他为以访问</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(visit[i]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(i);<br>            cnt++;      <span class="hljs-comment">//统计连通分量数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(lost,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(lost));<span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        g[a][b]=g[b][a]=<span class="hljs-number">1</span>;<span class="hljs-comment">//存储无向图</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-built_in">dfstrave</span>();<span class="hljs-comment">//获得初始的连通分量数</span><br>    <span class="hljs-keyword">int</span> k;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w=<span class="hljs-number">0</span>;w&lt;k;w++)&#123;<br>        <span class="hljs-keyword">int</span> city;<br>        cin&gt;&gt;city;<br>        lost[city]=<span class="hljs-number">1</span>;<span class="hljs-comment">//记录该城市被攻占</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(g[city][i]==<span class="hljs-number">1</span>)&#123;<br>                g[city][i]=g[i][city]=<span class="hljs-number">0</span>;<span class="hljs-comment">//标记和他相连的城市不再相连</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> tempcnt=<span class="hljs-built_in">dfstrave</span>();<span class="hljs-comment">//当前的连通分量</span><br>        <span class="hljs-keyword">if</span>(tempcnt&lt;=cnt)&#123;<span class="hljs-comment">//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;City %d is lost.\n&quot;</span>, city);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则，连通性被改变了</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Red Alert: City %d is lost!\n&quot;</span>, city);<br>        &#125;<br>        cnt=tempcnt;<span class="hljs-comment">//更新连通分量</span><br>        <span class="hljs-keyword">if</span>(w==n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//城市已经被攻占完毕</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over.\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208">题目详情 - L2-013 红色警报 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-011 玩转二叉树 (25 分)</title>
    <link href="/2022/04/14/Algorithm024/"/>
    <url>/2022/04/14/Algorithm024/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-011-玩转二叉树-25-分"><a href="#L2-011-玩转二叉树-25-分" class="headerlink" title="L2-011 玩转二叉树 (25 分)"></a><strong>L2-011 玩转二叉树 (25 分)</strong></h2><p>给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">7<br>1 2 3 4 5 6 7<br>4 1 3 2 6 5 7<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">4 6 1 7 5 3 2<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>镜面反转即为在层序遍历时交换左右子树的遍历顺序，左-&gt;右变成右-&gt;左</strong></p><p><strong>前序 + 中序 建树 + BFS</strong></p><p><strong>建树详细过程：</strong></p><p><a href="https://xingyuanjie.top/2022/04/07/Algorithm014/">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;BiTNode,*BiTree;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> in[<span class="hljs-number">35</span>];<br><span class="hljs-keyword">int</span> pre[<span class="hljs-number">35</span>];<br><span class="hljs-function">BiTree <span class="hljs-title">PostCreate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prel,<span class="hljs-keyword">int</span> prer,<span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<span class="hljs-comment">//前序加中序建树</span><br>    <span class="hljs-keyword">if</span>(prel&gt;prer)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>    root-&gt;data=pre[prel];<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inl; i &lt;=inr; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(pre[prel]==in[i])&#123;<br>            index=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> numleft=index-inl;<br>    root-&gt;lchild=<span class="hljs-built_in">PostCreate</span>(prel+<span class="hljs-number">1</span>,prel+numleft,inl,index<span class="hljs-number">-1</span>);<br>    root-&gt;rchild=<span class="hljs-built_in">PostCreate</span>(prel+numleft+<span class="hljs-number">1</span>,prer,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;BiTree&gt; q;<br>    q.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        BiTNode *tmp =q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(i!=n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//输出格式控制</span><br>            cout&lt;&lt;tmp-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;tmp-&gt;data;<br>        &#125;<br>        i++;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//镜面反转，左-&gt;右变成右-&gt;左</span><br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;rchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;lchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree tree;<br>    tree=<span class="hljs-literal">NULL</span>;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        cin&gt;&gt;in[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n ; ++j) &#123;<br>        cin&gt;&gt;pre[j];<br>    &#125;<br>    tree=<span class="hljs-built_in">PostCreate</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">LevelOrder</span>(tree);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784">题目详情 - L2-011 玩转二叉树 (25 分) (pintia.cn)</a></p><p><a href="https://xingyuanjie.top/2022/04/07/Algorithm014/">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-035 完全二叉树的层序遍历 (25 分)</title>
    <link href="/2022/04/14/Algorithm023/"/>
    <url>/2022/04/14/Algorithm023/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-035-完全二叉树的层序遍历-25-分"><a href="#L2-035-完全二叉树的层序遍历-25-分" class="headerlink" title="L2-035 完全二叉树的层序遍历 (25 分)"></a>L2-035 完全二叉树的层序遍历 (25 分)</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是<strong>完美二叉树</strong>。对于深度为 <em>D</em> 的，有 <em>N</em> 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 <em>N</em> 个结点，这样的树就是<strong>完全二叉树</strong>。</p><p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>N</em>（≤30），即树中结点个数。第二行给出后序遍历序列，为 <em>N</em> 个不超过 100 的正整数。同一行中所有数字都以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">8<br>91 71 2 34 10 15 55 18<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">18 34 55 71 2 10 15 91<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>后序遍历建树 + 完全二叉树性质</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> tree[<span class="hljs-number">10001</span>];<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//根据后序遍历建树</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i&lt;=n)&#123;<span class="hljs-comment">//当2*i&lt;=n时，结点i的左孩子编号为2*i，否则无左孩子</span><br>        <span class="hljs-built_in">post</span>(<span class="hljs-number">2</span>*i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>&lt;=n)&#123;<span class="hljs-comment">//当2*i+1&lt;=n时，结点i的右孩子编号为2*i+1，否则无右孩子</span><br>        <span class="hljs-built_in">post</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>);<br>    &#125;<br>    cin&gt;&gt;tree[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">post</span>(<span class="hljs-number">1</span>);           <span class="hljs-comment">//后序遍历建树</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<span class="hljs-comment">//顺序输出即为层序遍历</span><br>        <span class="hljs-keyword">if</span>(i!=n)&#123;<br>            cout&lt;&lt;tree[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;tree[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Binary tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-031 深入虎穴 (25 分)</title>
    <link href="/2022/04/13/Algorithm022/"/>
    <url>/2022/04/13/Algorithm022/</url>
    
    <content type="html"><![CDATA[<p>著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。</p><p>内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在一行中给出正整数 <em>N</em>（&lt;105），是门的数量。最后 <em>N</em> 行，第 <em>i</em> 行（1≤<em>i</em>≤<em>N</em>）按以下格式描述编号为 <em>i</em> 的那扇门背后能通向的门：</p><figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-built_in">K</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">[</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">...</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">]</span><br></code></pre></div></td></tr></table></figure><p>其中 <code>K</code> 是通道的数量，其后是每扇门的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">13<br>3 2 3 4<br>2 5 6<br>1 7<br>1 8<br>1 9<br>0<br>2 11 10<br>1 13<br>0<br>0<br>1 12<br>0<br>0<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">12<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表 + BFS</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v[<span class="hljs-number">100005</span>];<br><span class="hljs-keyword">int</span> book[<span class="hljs-number">100005</span>];<br><span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//BFS</span><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<span class="hljs-comment">//根节点入队</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        x=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;v[x].<span class="hljs-built_in">size</span>() ; ++i) &#123;<br>            q.<span class="hljs-built_in">push</span>(v[x][i]);<br>        &#125;<br>    &#125;<span class="hljs-comment">//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</span><br>    <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=time ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            book[num]=<span class="hljs-number">1</span>;<br>            v[i].<span class="hljs-built_in">push_back</span>(num);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;=n ; ++k) &#123;<span class="hljs-comment">//找入口</span><br>        <span class="hljs-keyword">if</span>(book[k]==<span class="hljs-number">0</span>) start=k;<span class="hljs-comment">//没有门通向的门，即为入口</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">bfs</span>();<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888">题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-040 哲哲打游戏 (25 分)</title>
    <link href="/2022/04/13/Algorithm021/"/>
    <url>/2022/04/13/Algorithm021/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-040-哲哲打游戏-25-分"><a href="#L2-040-哲哲打游戏-25-分" class="headerlink" title="L2-040 哲哲打游戏 (25 分)"></a><strong>L2-040 哲哲打游戏 (25 分)</strong></h2><p>哲哲是一位硬核游戏玩家。最近一款名叫《达诺达诺》的新游戏刚刚上市，哲哲自然要快速攻略游戏，守护硬核游戏玩家的一切！</p><p>为简化模型，我们不妨假设游戏有 <em>N</em> 个剧情点，通过游戏里不同的操作或选择可以从某个剧情点去往另外一个剧情点。此外，游戏还设置了一些<strong>存档</strong>，在某个剧情点可以将玩家的游戏进度保存在一个档位上，读取存档后可以回到剧情点，重新进行操作或者选择，到达不同的剧情点。</p><p>为了追踪硬核游戏玩家哲哲的攻略进度，你打算写一个程序来完成这个工作。假设你已经知道了游戏的全部剧情点和流程，以及哲哲的游戏操作，请你输出哲哲的游戏进度。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行是两个正整数 <em>N</em> 和 <em>M</em> (1≤<em>N</em>,<em>M</em>≤105)，表示总共有 <em>N</em> 个剧情点，哲哲有 <em>M</em> 个游戏操作。</p><p>接下来的 <em>N</em> 行，每行对应一个剧情点的发展设定。第 <em>i</em> 行的第一个数字是 <em>K**i</em>，表示剧情点 <em>i</em> 通过一些操作或选择能去往下面 <em>K**i</em> 个剧情点；接下来有 <em>K**i</em> 个数字，第 <em>k</em> 个数字表示做第 <em>k</em> 个操作或选择可以去往的剧情点编号。</p><p>最后有 <em>M</em> 行，每行第一个数字是 0、1 或 2，分别表示：</p><ul><li>0 表示哲哲做出了某个操作或选择，后面紧接着一个数字 <em>j</em>，表示哲哲在当前剧情点做出了第 <em>j</em> 个选择。我们保证哲哲的选择永远是合法的。</li><li>1 表示哲哲进行了一次存档，后面紧接着是一个数字 <em>j</em>，表示存档放在了第 <em>j</em> 个档位上。</li><li>2 表示哲哲进行了一次读取存档的操作，后面紧接着是一个数字 <em>j</em>，表示读取了放在第 <em>j</em> 个位置的存档。</li></ul><p>约定：所有操作或选择以及剧情点编号都从 1 号开始。存档的档位不超过 100 个，编号也从 1 开始。游戏默认从 1 号剧情点开始。总的选项数（即 ∑<em>K**i</em>）不超过 106。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对于每个 1（即存档）操作，在一行中输出存档的剧情点编号。</p><p>最后一行输出哲哲最后到达的剧情点编号。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">10 11<br>3 2 3 4<br>1 6<br>3 4 7 5<br>1 3<br>1 9<br>2 3 5<br>3 1 8 5<br>1 9<br>2 8 10<br>0<br>1 1<br>0 3<br>0 1<br>1 2<br>0 2<br>0 2<br>2 2<br>0 3<br>0 1<br>1 1<br>0 2<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">1<br>3<br>9<br>10<br></code></pre></div></td></tr></table></figure><h3 id="样例解释："><a href="#样例解释：" class="headerlink" title="样例解释："></a>样例解释：</h3><p>简单给出样例中经过的剧情点顺序：</p><p>1 -&gt; 4 -&gt; 3 -&gt; 7 -&gt; 8 -&gt; 3 -&gt; 5 -&gt; 9 -&gt; 10。</p><p>档位 1 开始存的是 1 号剧情点；档位 2 存的是 3 号剧情点；档位 1 后来又存了 9 号剧情点。</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表 + 模拟，主要是理解题意</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> save[<span class="hljs-number">105</span>];<span class="hljs-comment">//存档点</span><br>    <span class="hljs-keyword">int</span> now=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前剧情点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> num;<br>        cin&gt;&gt;num;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;num ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> x;<br>            cin&gt;&gt;x;<br>            v[i].<span class="hljs-built_in">push_back</span>(x);<span class="hljs-comment">//邻接表存操作数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;k ; ++l) &#123;<span class="hljs-comment">//模拟过程</span><br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>)&#123;<br>            save[b]=now;<br>            cout&lt;&lt;now&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>)&#123;<br>            now=v[now][b<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">2</span>)&#123;<br>            now=save[b];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;now&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652363">题目详情 - L2-040 哲哲打游戏 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-027 名人堂与代金券 (25 分)</title>
    <link href="/2022/04/13/Algorithm020/"/>
    <url>/2022/04/13/Algorithm020/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-027-名人堂与代金券-25-分"><a href="#L2-027-名人堂与代金券-25-分" class="headerlink" title="L2-027 名人堂与代金券 (25 分)"></a>L2-027 名人堂与代金券 (25 分)</h2><p>对于在中国大学MOOC（<a href="http://www.icourse163.org/">http://www.icourse163.org/</a> ）学习“数据结构”课程的学生，想要获得一张合格证书，总评成绩必须达到 60 分及以上，并且有另加福利：总评分在 [G, 100] 区间内者，可以得到 50 元 PAT 代金券；在 [60, G) 区间内者，可以得到 20 元PAT代金券。全国考点通用，一年有效。同时任课老师还会把总评成绩前 K 名的学生列入课程“名人堂”。本题就请你编写程序，帮助老师列出名人堂的学生，并统计一共发出了面值多少元的 PAT 代金券。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出 3 个整数，分别是 N（不超过 10 000 的正整数，为学生总数）、G（在 (60,100) 区间内的整数，为题面中描述的代金券等级分界线）、K（不超过 100 且不超过 N 的正整数，为进入名人堂的最低名次）。接下来 N 行，每行给出一位学生的账号（长度不超过15位、不带空格的字符串）和总评成绩（区间 [0, 100] 内的整数），其间以空格分隔。题目保证没有重复的账号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出发出的 PAT 代金券的总面值。然后按总评成绩非升序输出进入名人堂的学生的名次、账号和成绩，其间以 1 个空格分隔。需要注意的是：成绩相同的学生享有并列的排名，排名并列时，按账号的字母序升序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">10 80 5<br>cy@zju.edu.cn 78<br>cy@pat-edu.com 87<br>1001@qq.com 65<br>uh-oh@163.com 96<br>test@126.com 39<br>anyone@qq.com 87<br>zoe@mit.edu 80<br>jack@ucla.edu 88<br>bob@cmu.edu 80<br>ken@163.com 70<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">360<br>1 uh-oh@163.com 96<br>2 jack@ucla.edu 88<br>3 anyone@qq.com 87<br>3 cy@pat-edu.com 87<br>5 bob@cmu.edu 80<br>5 zoe@mit.edu 80<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>结构体数组+sort排序，需要注意输出格式控制</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-keyword">int</span> score=<span class="hljs-number">0</span>;<br>    string email;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(student a,student b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.score==b.score) <span class="hljs-keyword">return</span> a.email&lt;b.email;<span class="hljs-comment">//如果分数相同返回字典序小的</span><br>    <span class="hljs-keyword">return</span> a.score&gt;b.score;<span class="hljs-comment">//返回分数最大的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,g,k;<br>    cin&gt;&gt;n&gt;&gt;g&gt;&gt;k;<br>    student st[n];<br>    <span class="hljs-keyword">int</span> money=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<span class="hljs-comment">//输入加存钱</span><br>        cin&gt;&gt;st[i].email&gt;&gt;st[i].score;<br>        <span class="hljs-keyword">if</span>(g&lt;=st[i].score&amp;&amp;st[i].score&lt;=<span class="hljs-number">100</span>)&#123;<br>            money+=<span class="hljs-number">50</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">60</span>&lt;=st[i].score&amp;&amp;st[i].score&lt;g)&#123;<br>            money+=<span class="hljs-number">20</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(st,st+n,cmp);<span class="hljs-comment">//排序</span><br>    cout&lt;&lt;money&lt;&lt;endl;<br>    <span class="hljs-keyword">int</span> cnt =<span class="hljs-number">1</span>;<span class="hljs-comment">//用来判断用否超过名人堂个数</span><br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-comment">//遍历st结构体数组</span><br>    <span class="hljs-keyword">int</span> same=<span class="hljs-number">1</span>;<span class="hljs-comment">//分数相同的个数</span><br>    <span class="hljs-keyword">int</span> fscore=st[<span class="hljs-number">0</span>].score;<span class="hljs-comment">//用来判断分数是否相同</span><br>    <span class="hljs-comment">//这道题就格式输出需要注意下！</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><br>        <span class="hljs-keyword">if</span>(fscore==st[i].score)&#123;<br>            cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].email&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].score&lt;&lt;endl;<span class="hljs-comment">//相同即输出</span><br>            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>) same++;<span class="hljs-comment">//不为0号，则same++。</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(fscore&gt;st[i].score)&#123;<br>            cnt=cnt+same;<span class="hljs-comment">//不等，更新cnt值</span><br>            same=<span class="hljs-number">1</span>;<span class="hljs-comment">//更新same值</span><br>            <span class="hljs-keyword">if</span>(cnt&gt;k)&#123; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//大于名人堂个数结束</span><br>            cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].email&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].score&lt;&lt;endl;<br>            fscore=st[i].score;<span class="hljs-comment">//更新用来判断分数是否相同的fscore</span><br><br>        &#125;<br>        i++;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805055176163328">题目详情 - L2-027 名人堂与代金券 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-026 小字辈 (25 分)</title>
    <link href="/2022/04/13/Algorithm019/"/>
    <url>/2022/04/13/Algorithm019/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-026-小字辈-25-分"><a href="#L2-026-小字辈-25-分" class="headerlink" title="L2-026 小字辈 (25 分)"></a><strong>L2-026 小字辈 (25 分)</strong></h2><p>本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父&#x2F;母。家谱中辈分最高的老祖宗对应的父&#x2F;母编号为 -1。一行中的数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">9<br>2 6 5 5 -1 5 6 4 7<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">4<br>1 9<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表建树+BFS</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; tree[<span class="hljs-number">100005</span>];<span class="hljs-comment">//邻接表建树</span><br><span class="hljs-keyword">int</span> deeptree[<span class="hljs-number">100005</span>];<span class="hljs-comment">//记录树的深度</span><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> root;<span class="hljs-comment">//根节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//bfs</span><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<span class="hljs-comment">//根节点入队</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        x=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;tree[x].<span class="hljs-built_in">size</span>() ; ++i) &#123;<br>            deeptree[tree[x][i]]=deeptree[x]+<span class="hljs-number">1</span>;<span class="hljs-comment">//每一层的深度为上一层加1</span><br>            q.<span class="hljs-built_in">push</span>(tree[x][i]);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> deeptree[x];<span class="hljs-comment">//返回最后一个结点的深度，即深度的最大值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> a[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        cin&gt;&gt;a[i];<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">-1</span>)&#123;<br>            root=i;<span class="hljs-comment">//找根节点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ; ++j) &#123;<span class="hljs-comment">//建树</span><br>        tree[a[j]].<span class="hljs-built_in">push_back</span>(j);<span class="hljs-comment">//j是a[j]的孩子节点</span><br>        <span class="hljs-keyword">if</span>(a[j]==<span class="hljs-number">-1</span>) deeptree[j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//初始化根节点深度为1</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">bfs</span>();<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">int</span> maxdeepcnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录最大深度的个数</span><br>    <span class="hljs-keyword">int</span> tmp[n];<span class="hljs-comment">//找最大深度的id</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;=n ; ++k) &#123;<br>        <span class="hljs-keyword">if</span>(ans==deeptree[k])&#123;<br>            maxdeepcnt++;<br>            tmp[maxdeepcnt]=k;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//输出格式控制</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=maxdeepcnt ; ++l) &#123;<br>        <span class="hljs-keyword">if</span>(l!=maxdeepcnt) cout&lt;&lt;tmp[l]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;tmp[l]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808">题目详情 - L2-026 小字辈 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-023 图着色问题 (25 分)</title>
    <link href="/2022/04/12/Algorithm018/"/>
    <url>/2022/04/12/Algorithm018/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-023-图着色问题-25-分"><a href="#L2-023-图着色问题-25-分" class="headerlink" title="L2-023 图着色问题 (25 分)"></a>L2-023 图着色问题 (25 分)</h2><p>图着色问题是一个著名的NP完全问题。给定无向图<em>G</em>&#x3D;(<em>V</em>,<em>E</em>)，问可否用<em>K</em>种颜色为<em>V</em>中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？</p><p>但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出3个整数<em>V</em>（0&lt;<em>V</em>≤500）、<em>E</em>（≥0）和<em>K</em>（0&lt;<em>K</em>≤<em>V</em>），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到<em>V</em>编号。随后<em>E</em>行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数<em>N</em>（≤20），是待检查的颜色分配方案的个数。随后<em>N</em>行，每行顺次给出<em>V</em>个顶点的颜色（第<em>i</em>个数字表示第<em>i</em>个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每种颜色分配方案，如果是图着色问题的一个解则输出<code>Yes</code>，否则输出<code>No</code>，每句占一行。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><img src="/2022/04/12/Algorithm018/graph.png" alt="graph" style="zoom: 67%;"><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">6 8 3<br>2 1<br>1 3<br>4 6<br>2 5<br>2 4<br>5 4<br>5 6<br>3 6<br>4<br>1 2 3 3 1 2<br>4 5 6 6 4 5<br>1 2 3 4 5 6<br>2 3 4 2 3 4<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">Yes<br>Yes<br>No<br>No<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>Set + 邻接表</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> v,e,k;<br>    cin&gt;&gt;v&gt;&gt;e&gt;&gt;k;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; g[<span class="hljs-number">505</span>];<span class="hljs-comment">//邻接表</span><br>    <span class="hljs-keyword">int</span> color[<span class="hljs-number">505</span>];<span class="hljs-comment">//记录颜色</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;e ; ++i) &#123;       <span class="hljs-comment">//建立邻接表</span><br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        g[a].<span class="hljs-built_in">push_back</span>(b);<br>        g[b].<span class="hljs-built_in">push_back</span>(a);<br>    &#125;<br>    <span class="hljs-keyword">int</span> time;<br>    cin&gt;&gt;time;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>        set&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-comment">//用来统计颜色总数</span><br>        s.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=v; ++i) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            color[i]=num;<br>            s.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()!=k)&#123;<span class="hljs-comment">//如果颜色数不等于k即非法</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=v ; ++l) &#123;<span class="hljs-comment">//遍历邻接表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;g[l].<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">if</span>(color[l]==color[g[l][i]])&#123;<span class="hljs-comment">//如果相邻结点颜色一样则为假</span><br>                    flag=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805057298481152">题目详情 - L2-023 图着色问题 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-022 重排链表 (25 分)</title>
    <link href="/2022/04/12/Algorithm017/"/>
    <url>/2022/04/12/Algorithm017/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-022-重排链表-25-分"><a href="#L2-022-重排链表-25-分" class="headerlink" title="L2-022 重排链表 (25 分)"></a>L2-022 重排链表 (25 分)</h2><p>给定一个单链表 <em>L</em>1→<em>L</em>2→⋯→<em>Ln</em>−1→<em>Ln</em>，请编写程序将链表重新排列为 <em>Ln</em>→<em>L</em>1→<em>Ln</em>−1→<em>L</em>2→⋯。例如：给定<em>L</em>为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数<em>N</em> (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。</p><p>接下来有<em>N</em>行，每行格式为：</p><figure class="highlight purebasic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span><br></code></pre></div></td></tr></table></figure><p>其中<code>Address</code>是结点地址；<code>Data</code>是该结点保存的数据，为不超过105的正整数；<code>Next</code>是下一结点的地址。题目保证给出的链表上至少有两个结点。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">00100 6<br>00000 4 99999<br>00100 1 12309<br>68237 6 -1<br>33218 3 00000<br>99999 5 68237<br>12309 2 33218<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">68237 6 00100<br>00100 1 99999<br>99999 5 12309<br>12309 2 00000<br>00000 4 33218<br>33218 3 -1<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>利用双向链表，头尾指针来模拟</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linklist</span>&#123;</span><br>    <span class="hljs-keyword">int</span> address=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录当前结点的地址，虽然也没用到</span><br>    <span class="hljs-keyword">int</span> data=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录数据域</span><br>    <span class="hljs-keyword">int</span> next=<span class="hljs-number">0</span>;<span class="hljs-comment">//指向下一个结点的地址</span><br>    <span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>;<span class="hljs-comment">//指向上一个结点的地址</span><br>&#125;l[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> start,back=<span class="hljs-number">-1</span>;<span class="hljs-comment">//头尾指针</span><br>    <span class="hljs-keyword">int</span> tmp;<span class="hljs-comment">//用来遍历当前链表用于统计链表的长度</span><br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;start&gt;&gt;n;<br>    tmp=start;<br>    <span class="hljs-keyword">int</span> address, data, next;<br>    l[start].pre=<span class="hljs-number">-1</span>;   <span class="hljs-comment">//初始化第一个结点的前一个结点位置为-1</span><br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;  <span class="hljs-comment">//记录链表长</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>       cin&gt;&gt;address&gt;&gt;data&gt;&gt;next;<br>       l[address].address=address;<br>       l[address].data=data;<br>       l[address].next=next;<br>       <span class="hljs-keyword">if</span>(next!=<span class="hljs-number">-1</span>)&#123;<br>           l[next].pre=address;<span class="hljs-comment">//设值上一个结点的地址</span><br>       &#125;<br>    &#125;<br>    <span class="hljs-comment">//这道题比较坑的地方是会出现不是这个链表的结点，所以n不是真正的链表长，需要统计真正的链表长</span><br>    <span class="hljs-comment">//如果没注意这点，第三个测试点会不通过，不过也能得到21分</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        cnt++;<span class="hljs-comment">//统计链表长</span><br>        <span class="hljs-keyword">if</span>(l[tmp].next==<span class="hljs-number">-1</span>)&#123;<br>            back=tmp;       <span class="hljs-comment">//尾指针</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        tmp=l[tmp].next;<br>    &#125;<br>    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//flag=0动尾指针,flag=1动头指针。我并没有改变原来链表！</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;cnt ; ++k) &#123;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(k==cnt<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %d\n&quot;</span>,l[back].address,l[back].data,<span class="hljs-number">-1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>,l[back].address,l[back].data,start);<br>                &#125;<br>                back=l[back].pre;<br>                flag=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(k==cnt<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %d\n&quot;</span>,l[start].address,l[start].data,<span class="hljs-number">-1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>,l[start].address,l[start].data,back);<br>                &#125;<br>                start=l[start].next;<br>                flag=<span class="hljs-number">0</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805057860517888">题目详情 - L2-022 重排链表 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>LinkList</tag>
      
      <tag>双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-021 点赞狂魔 (25 分)</title>
    <link href="/2022/04/11/Algorithm016/"/>
    <url>/2022/04/11/Algorithm016/</url>
    
    <content type="html"><![CDATA[<h1 id="L2-021-点赞狂魔-25-分"><a href="#L2-021-点赞狂魔-25-分" class="headerlink" title="L2-021 点赞狂魔 (25 分)"></a>L2-021 点赞狂魔 (25 分)</h1><p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤100），是待统计的用户数。随后<em>N</em>行，每行列出一位用户的点赞标签。格式为“<code>Name</code> <em>K</em> <em>F</em>1⋯<em>F**K</em>”，其中<code>Name</code>是不超过8个英文小写字母的非空用户名，1≤<em>K</em>≤1000，<em>F**i</em>（<em>i</em>&#x3D;1,⋯,<em>K</em>）是特性标签的编号，我们将所有特性标签从 1 到 107 编号。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用<code>-</code>补齐缺失，例如<code>mike jenny -</code>就表示只有2人。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">5<br>bob 11 101 102 103 104 105 106 107 108 108 107 107<br>peter 8 1 2 3 4 3 2 5 1<br>chris 12 1 2 3 4 5 6 7 8 9 1 2 3<br>john 10 8 7 6 5 4 3 2 1 7 5<br>jack 9 6 7 8 9 10 11 12 13 14<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">jack chris john<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>结构体数组 + sort排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span>&#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">10</span>];<br>    set&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-comment">//set容器中的每个元素值唯一</span><br>    <span class="hljs-keyword">int</span> all=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录点赞次数</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(person a,person b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.s.<span class="hljs-built_in">size</span>()==b.s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a.all&lt;b.all;<span class="hljs-comment">//如果有并列，则输出标签出现次数平均值最小的那个</span><br>    <span class="hljs-keyword">return</span> a.s.<span class="hljs-built_in">size</span>()&gt;b.s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//点赞的不同标签的数量最多的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    person p[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        cin&gt;&gt;p[i].name;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        p[i].all=time;<span class="hljs-comment">//记录点赞次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; time; ++j) &#123;<br>            <span class="hljs-keyword">int</span> tmp;<br>            cin&gt;&gt;tmp;<br>            p[i].s.<span class="hljs-built_in">insert</span>(tmp);<span class="hljs-comment">//插入set容器</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(p,p+n,cmp);<span class="hljs-comment">//排序</span><br>    <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">3</span>)&#123;<br>        cout&lt;&lt;p[<span class="hljs-number">0</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p[<span class="hljs-number">1</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p[<span class="hljs-number">2</span>].name&lt;&lt;endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)&#123;<br>        cout&lt;&lt;p[<span class="hljs-number">0</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p[<span class="hljs-number">1</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>        cout&lt;&lt;p[<span class="hljs-number">0</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805058485469184">题目详情 - L2-021 点赞狂魔 (25 分) (pintia.cn)</a></p><p><a href="https://blog.csdn.net/changjiale110/article/details/79108447">(19条消息) STL中的set使用方法详细！！！！_知足–常乐的博客-CSDN博客_set stl</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的STL中字符串string自带方法find查找</title>
    <link href="/2022/04/08/Algorithm015/"/>
    <url>/2022/04/08/Algorithm015/</url>
    
    <content type="html"><![CDATA[<h1 id="C-的STL中字符串string自带方法find查找"><a href="#C-的STL中字符串string自带方法find查找" class="headerlink" title="C++的STL中字符串string自带方法find查找"></a>C++的STL中字符串string自带方法find查找</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;abcd&quot;</span>;<br>cout &lt;&lt; str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-comment">//返回的是下标的值而不是指针或是迭代器</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;abcd&quot;</span><br>string sub = <span class="hljs-string">&quot;cd&quot;</span><br><span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">find</span>(sub)!=string::npos)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;找到了&quot;</span>&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;没有找到&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>要是没有找到，返回的是str::npos<br>注意，只有string的find方法是返回的下标，因为string是顺序索引，set,map,multiset,multimap都不是顺序索引的数据结构，所以返回的是迭代器。</p><h2 id="样例一-L1-070-吃火锅-15-分"><a href="#样例一-L1-070-吃火锅-15-分" class="headerlink" title="样例一:L1-070 吃火锅 (15 分)"></a>样例一:<strong>L1-070 吃火锅 (15 分)</strong></h2><p><strong>题目链接：</strong></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053</a></p><p><img src="/2022/04/08/Algorithm015/68518b64-f2f7-4694-aaeb-d32afe657f7b.jpg" alt="chg.jpg"></p><p>以上图片来自微信朋友圈：这种天气你有什么破事打电话给我基本没用。但是如果你说“吃火锅”，那就厉害了，我们的故事就开始了。</p><p>本题要求你实现一个程序，自动检查你朋友给你发来的信息里有没有 <code>chi1 huo3 guo1</code>。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入每行给出一句不超过 80 个字符的、以回车结尾的朋友信息，信息为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。当读到某一行只有一个英文句点 <code>.</code> 时，输入结束，此行不算在朋友信息里。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出朋友信息的总条数。然后对朋友的每一行信息，检查其中是否包含 <code>chi1 huo3 guo1</code>，并且统计这样厉害的信息有多少条。在第二行中首先输出第一次出现 <code>chi1 huo3 guo1</code> 的信息是第几条（从 1 开始计数），然后输出这类信息的总条数，其间以一个空格分隔。题目保证输出的所有数字不超过 100。</p><p>如果朋友从头到尾都没提 <code>chi1 huo3 guo1</code> 这个关键词，则在第二行输出一个表情 <code>-_-#</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">Hello!<br>are you there?<br>wantta chi1 huo3 guo1?<br>that&#x27;s so li hai le<br>our story begins from chi1 huo3 guo1 le<br>.<br></code></pre></div></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">5<br>3 2<br></code></pre></div></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">Hello!<br>are you there?<br>wantta qi huo3 guo1 chi1huo3guo1?<br>that&#x27;s so li hai le<br>our story begins from ci1 huo4 guo2 le<br>.<br></code></pre></div></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">5<br>-_-#<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来判断是否是第一次找到吃火锅</span><br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录总行数</span><br>    <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录有多少个吃火锅</span><br>    <span class="hljs-keyword">int</span> firstp=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录第一次出现吃火锅的位置</span><br>    string cmp=<span class="hljs-string">&quot;chi1 huo3 guo1&quot;</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        string s;<br>        s.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">getline</span>(cin,s);<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>&amp;&amp;s==<span class="hljs-string">&quot;.&quot;</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        string tmp =s;<br>        <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">find</span>(cmp)!=string::npos)&#123;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>) &#123;<br>                flag =<span class="hljs-number">1</span>;<br>                firstp = cnt+<span class="hljs-number">1</span>;<br>            &#125;<br>            count=count+<span class="hljs-number">1</span>;<br>        &#125;<br>        cnt=cnt+<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        cout&lt;&lt;cnt&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;-_-#&quot;</span>&lt;&lt;endl;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;cnt&lt;&lt;endl;<br>        cout&lt;&lt;firstp&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;count&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_50675813/article/details/113313343">(18条消息) c++STL中的find()函数 有两种使用方法_我们不生产代码，只是代码的搬运工的博客-CSDN博客_c++中find函数的使用方法</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Find</tag>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由遍历顺序构建二叉树(前序+中序;后序+中序)</title>
    <link href="/2022/04/07/Algorithm014/"/>
    <url>/2022/04/07/Algorithm014/</url>
    
    <content type="html"><![CDATA[<h1 id="由遍历顺序构建二叉树-前序-中序-后序-中序"><a href="#由遍历顺序构建二叉树-前序-中序-后序-中序" class="headerlink" title="由遍历顺序构建二叉树(前序+中序;后序+中序)"></a>由遍历顺序构建二叉树(前序+中序;后序+中序)</h1><h2 id="前序-中序"><a href="#前序-中序" class="headerlink" title="前序+中序"></a>前序+中序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BiTree <span class="hljs-title">PreAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prel,<span class="hljs-keyword">int</span> prer, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(prel&gt;prer)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<span class="hljs-comment">//记住分配空间</span><br>    root-&gt;data=preF[prel];<span class="hljs-comment">//前序遍历的第一个结点是根结点</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=inl;i&lt;=inr;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(preF[prel]==inF[i])&#123;<br>            index=i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//前序遍历的第一个结点是根结点,所以新的递归区间是prel+1,到prel+index-inl,</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+<span class="hljs-number">1</span>,prel+index-inl,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//前序遍历是根左右，所以新的递归区间是prel+index-inl+1,prep</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+index-inl+<span class="hljs-number">1</span>,prer,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="后序-中序"><a href="#后序-中序" class="headerlink" title="后序+中序"></a>后序+中序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BiTree <span class="hljs-title">PostAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> postl,<span class="hljs-keyword">int</span> postr, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(postl&gt;postr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>    root-&gt;data=posts[postr];<span class="hljs-comment">//后序遍历的最后一个结点是根结点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inl; i &lt;=inr ; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(posts[postr]==ins[i])<br>        &#123;<br>            index =i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//后续遍历的最后一个结点是根节点，所以新的递归区间是，postl,postl+index-inl-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl,postl+index-inl<span class="hljs-number">-1</span>,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//后序遍历是左右根，所以新的递归区间是postl+index-inl,postr-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl+index-inl,postr<span class="hljs-number">-1</span>,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h2><p><strong>前序+中序；后序+中序。递归调用可视化查看：(有助于理解递归调用过程)</strong></p><p><a href="https://pythontutor.com/">Python Tutor - Visualize Python, Java, C, C++, JavaScript, TypeScript, and Ruby code execution</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125;BiTNode,*BiTree;<br><span class="hljs-comment">//tree</span><br><span class="hljs-keyword">int</span> preF[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">int</span> inF[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//中序遍历</span><br><span class="hljs-comment">//trees</span><br><span class="hljs-keyword">int</span> posts[<span class="hljs-number">7</span>]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//后序遍历</span><br><span class="hljs-keyword">int</span> ins[<span class="hljs-number">7</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<span class="hljs-comment">//中序遍历</span><br><span class="hljs-function">BiTree <span class="hljs-title">PreAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prel,<span class="hljs-keyword">int</span> prer, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(prel&gt;prer)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<span class="hljs-comment">//记住分配空间</span><br>    root-&gt;data=preF[prel];<span class="hljs-comment">//前序遍历的第一个结点是根结点</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=inl;i&lt;=inr;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(preF[prel]==inF[i])&#123;<br>            index=i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//前序遍历的第一个结点是根结点,所以新的递归区间是prel+1,到prel+index-inl,</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+<span class="hljs-number">1</span>,prel+index-inl,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//前序遍历是根左右，所以新的递归区间是prel+index-inl+1,prep</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+index-inl+<span class="hljs-number">1</span>,prer,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function">BiTree <span class="hljs-title">PostAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> postl,<span class="hljs-keyword">int</span> postr, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(postl&gt;postr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>    root-&gt;data=posts[postr];<span class="hljs-comment">//后序遍历的最后一个结点是根结点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inl; i &lt;=inr ; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(posts[postr]==ins[i])<br>        &#123;<br>            index =i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//后续遍历的最后一个结点是根节点，所以新的递归区间是，postl,postl+index-inl-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl,postl+index-inl<span class="hljs-number">-1</span>,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//后序遍历是左右根，所以新的递归区间是postl+index-inl,postr-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl+index-inl,postr<span class="hljs-number">-1</span>,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;BiTree&gt; q;<br>    q.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        BiTNode *tmp =q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;tmp-&gt;data;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    BiTree tree;<br>    tree=<span class="hljs-literal">NULL</span>;<br>    tree=<span class="hljs-built_in">PreAndInCreateTree</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;输入为前序加中序遍历，输出他的层序遍历：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">LevelOrder</span>(tree);<br>    cout&lt;&lt;endl;<br>    BiTree trees;<br>    trees=<span class="hljs-literal">NULL</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;输入为后序加中序遍历，输出他的层序遍历：&quot;</span>&lt;&lt;endl;<br>    trees=<span class="hljs-built_in">PostAndInCreateTree</span>(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">LevelOrder</span>(trees);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">输入为前序加中序遍历，输出他的层序遍历：<br><span class="hljs-number">425136</span><br>输入为后序加中序遍历，输出他的层序遍历：<br><span class="hljs-number">4163572</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的存储结构</title>
    <link href="/2022/04/06/Algorithm012/"/>
    <url>/2022/04/06/Algorithm012/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h2 id="1-顺序存储方式"><a href="#1-顺序存储方式" class="headerlink" title="1.顺序存储方式"></a>1.顺序存储方式</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 100</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    ElemType value;<span class="hljs-comment">//结点中的数据元素</span><br>    <span class="hljs-keyword">bool</span> isEmpty;<span class="hljs-comment">//结点是否为空</span><br>&#125;;<br><br>TreeNode t[MaxSize];<br></code></pre></div></td></tr></table></figure><h2 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="2.链式存储结构"></a>2.链式存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125;BiTNode,*BiTree;<br></code></pre></div></td></tr></table></figure><h2 id="3-三叉链表"><a href="#3-三叉链表" class="headerlink" title="3.三叉链表"></a>3.三叉链表</h2><p>三叉链表—方便找父节点</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">parent</span>;</span><span class="hljs-comment">//父结点指针</span><br>&#125;BiTNode,*BiTree;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串的存储结构</title>
    <link href="/2022/04/06/Algorithm011/"/>
    <url>/2022/04/06/Algorithm011/</url>
    
    <content type="html"><![CDATA[<h1 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h1><h2 id="1-定长顺序存储表示"><a href="#1-定长顺序存储表示" class="headerlink" title="1.定长顺序存储表示"></a>1.定长顺序存储表示</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLEN 255<span class="hljs-comment">//预定义最大串长</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">char</span> ch[MAXLEN];<span class="hljs-comment">//每个分量存储一个字符</span><br>    <span class="hljs-keyword">int</span> length;<span class="hljs-comment">//串的实际长度</span><br>&#125;SSting;<br></code></pre></div></td></tr></table></figure><h2 id="2-堆分配存储表示"><a href="#2-堆分配存储表示" class="headerlink" title="2.堆分配存储表示"></a>2.堆分配存储表示</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">char</span> *ch;<span class="hljs-comment">//按串长分配存储区，ch指向串的基地址</span><br>    <span class="hljs-keyword">int</span> length;<span class="hljs-comment">//串的长度</span><br>&#125;HString;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(六)-两个矩阵相加MPI版本</title>
    <link href="/2022/04/02/mpi006/"/>
    <url>/2022/04/02/mpi006/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI学习-六-两个矩阵相加MPI版本"><a href="#MPI学习-六-两个矩阵相加MPI版本" class="headerlink" title="MPI学习(六)-两个矩阵相加MPI版本"></a>MPI学习(六)-两个矩阵相加MPI版本</h1><p>这里，我们演示了两个简单的程序，一个是矩阵相加串行版本，一个是矩阵相加MPI版本</p><h2 id="串行版本"><a href="#串行版本" class="headerlink" title="串行版本"></a>串行版本</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<br><span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<br><span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<br><span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>&#125;;<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<br><span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<br><span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">17</span>,<span class="hljs-number">5</span>,<br><span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c)); <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>&#123;<br>c[i][j]=a[i][j]+b[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">11</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">15</span> <span class="hljs-number">17</span><br><span class="hljs-number">20</span> <span class="hljs-number">22</span> <span class="hljs-number">28</span> <span class="hljs-number">17</span><br><span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">35</span> <span class="hljs-number">19</span><br></code></pre></div></td></tr></table></figure><h2 id="MPI版本"><a href="#MPI版本" class="headerlink" title="MPI版本"></a>MPI版本</h2><h3 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h3><p>北京超级云计算中心A3分区</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>mpi&#x2F;intel&#x2F;2017.5</p><h3 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h3><p>mpicxx mpi006.c -o mpi006</p><h3 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h3><p>srun -p amd_256 -N 1 -n  5  .&#x2F;mpi006(使用SLURM任务调度系统)</p><p>1个分区，核数为5</p><h3 id="程序源代码-1"><a href="#程序源代码-1" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc ,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<br><span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<br><span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<br><span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>&#125;;<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<br><span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<br><span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">17</span>,<span class="hljs-number">5</span>,<br><span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-keyword">int</span> tmp[<span class="hljs-number">4</span>];<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));<br><span class="hljs-keyword">int</span> myid, numprocs;<br>MPI_Status status;<br>MPI_Request request;<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc,&amp;argv);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;numprocs);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;myid);<br><span class="hljs-keyword">if</span>(myid == <span class="hljs-number">0</span>)<span class="hljs-comment">//0号进程接受来自其他进程的消息</span><br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;numprocs;i++)<br>&#123;<br><span class="hljs-built_in">MPI_Irecv</span>(&amp;c[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],<span class="hljs-number">4</span>,MPI_INT,i,<span class="hljs-number">0</span>,MPI_COMM_WORLD,&amp;request);<span class="hljs-comment">//采用非阻塞接受</span><br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//打印矩阵</span><br>&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(myid != <span class="hljs-number">0</span> )<span class="hljs-comment">//当进程不是0号进程时，则向0号进程发送消息</span><br>&#123;<br><span class="hljs-built_in">memset</span>(tmp,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(tmp));<span class="hljs-comment">//初始化tmp数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br>tmp[i]=a[myid<span class="hljs-number">-1</span>][i]+b[myid<span class="hljs-number">-1</span>][i];<span class="hljs-comment">//用tmp来临时存储相加结果，随后发送给0号进程</span><br><br>&#125;<br><span class="hljs-built_in">MPI_Isend</span>(&amp;tmp,<span class="hljs-number">4</span>,MPI_INT,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,MPI_COMM_WORLD,&amp;request);<span class="hljs-comment">//采用非阻塞发送</span><br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br>&#125;<br><span class="hljs-built_in">MPI_Finalize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序输出-1"><a href="#程序输出-1" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">11</span> <br><span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">15</span> <span class="hljs-number">17</span> <br><span class="hljs-number">20</span> <span class="hljs-number">22</span> <span class="hljs-number">28</span> <span class="hljs-number">17</span> <br><span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">35</span> <span class="hljs-number">19</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2022/03/31/Algorithm010/"/>
    <url>/2022/03/31/Algorithm010/</url>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的顺序存储解构"><a href="#队列的顺序存储解构" class="headerlink" title="队列的顺序存储解构"></a>队列的顺序存储解构</h3><h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><p>队列的顺序存储类型可描述为</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义队列中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放队列元素</span><br>    <span class="hljs-keyword">int</span> front,rear;<span class="hljs-comment">//队头指针和队尾指针</span><br>&#125;SqQueue;<br></code></pre></div></td></tr></table></figure><h4 id="循环队列的操作"><a href="#循环队列的操作" class="headerlink" title="循环队列的操作"></a>循环队列的操作</h4><p>(1)初始化</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>    Q.rear=Q.front=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化队首、队尾指针</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>(2)判队空</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//队空条件</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>(3)入队</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MaxSize==Q.front)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//队满则报错</span><br>    Q.data[Q.rear]=x;<br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队尾指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>(4)出队</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//队列空则报错</span><br>    x=Q.data[Q.front];<br>    Q.front=(Q.front+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队头指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="循环队列的完整操作"><a href="#循环队列的完整操作" class="headerlink" title="循环队列的完整操作"></a>循环队列的完整操作</h4><h5 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义队列中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放队列元素</span><br>    <span class="hljs-keyword">int</span> front,rear;<span class="hljs-comment">//队头指针和队尾指针</span><br>&#125;SqQueue;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>    Q.rear=Q.front=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化队首、队尾指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//队空条件</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MaxSize==Q.front)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//队满则报错</span><br>    Q.data[Q.rear]=x;<br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队尾指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//队列空则报错</span><br>    x=Q.data[Q.front];<br>    Q.front=(Q.front+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队头指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintSqQueue</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<span class="hljs-comment">//遍历操作 </span><br><span class="hljs-keyword">int</span> point = Q.front;<br><span class="hljs-keyword">while</span>(point!=Q.rear)<span class="hljs-comment">//如果point指向Q.rear说明遍历结束 </span><br>&#123;<span class="hljs-comment">//也就是point指向了队尾元素的下一个位置 </span><br>cout&lt;&lt;Q.data[point]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>point=(point+<span class="hljs-number">1</span>)%MaxSize;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>SqQueue Q;<span class="hljs-comment">//声明了一个顺序队列 </span><br><span class="hljs-built_in">InitQueue</span>(Q);<span class="hljs-comment">//初始化这个队列 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-built_in">EnQueue</span>(Q,i);<span class="hljs-comment">//入队操作 </span><br>&#125;<br><span class="hljs-built_in">PrintSqQueue</span>(Q);<span class="hljs-comment">//遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">DeQueue</span>(Q,x);<span class="hljs-comment">//出队 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是第&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;次出队&quot;</span>&lt;&lt;<span class="hljs-string">&quot;出队的元素是&quot;</span> &lt;&lt;x&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isEmpty</span>(Q))<span class="hljs-comment">//队列非空则遍历 </span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;当前队列为：&quot;</span>;<br><span class="hljs-built_in">PrintSqQueue</span>(Q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;此时的队列为空队列&quot;</span>&lt;&lt;endl;<br>&#125;<br><br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h5 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">1</span>次出队出队的元素是<span class="hljs-number">0</span><br>当前队列为：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">2</span>次出队出队的元素是<span class="hljs-number">1</span><br>当前队列为：<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">3</span>次出队出队的元素是<span class="hljs-number">2</span><br>当前队列为：<span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">4</span>次出队出队的元素是<span class="hljs-number">3</span><br>当前队列为：<span class="hljs-number">4</span><br>这是第<span class="hljs-number">5</span>次出队出队的元素是<span class="hljs-number">4</span><br>此时的队列为空队列<br></code></pre></div></td></tr></table></figure><h3 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h3><h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><p>队列的链式存储类型可描述为</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><span class="hljs-comment">//链式队列结点</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LinkNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//链式队列</span><br>    LinkNode *front,*rear;<span class="hljs-comment">//队列的对头和队尾指针</span><br>&#125;LinkQueue;<br></code></pre></div></td></tr></table></figure><h4 id="链式队列的基本操作"><a href="#链式队列的基本操作" class="headerlink" title="链式队列的基本操作"></a>链式队列的基本操作</h4><p>(1)初始化</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    Q.front = Q.rear=(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<span class="hljs-comment">//建立头结点</span><br>    Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始为空</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>(2判队空</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>(3)入队</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;<br>    LinkNode *s =(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<br>    s-&gt;data=x;<span class="hljs-comment">//创建新结点，插入到链尾</span><br>    s-&gt;next=<span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next=s;<br>    Q.rear=s;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>(4)出队</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//空队</span><br>    LinkNode *p =Q.front-&gt;next;<br>    x=p-&gt;data;<br>    Q.front-&gt;next=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear==p)&#123;<br>        Q.rear = Q.front;<span class="hljs-comment">//若原队列中只有一个结点，删除后变空</span><br>    &#125;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="链式队列的完整操作"><a href="#链式队列的完整操作" class="headerlink" title="链式队列的完整操作"></a>链式队列的完整操作</h4><h5 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><span class="hljs-comment">//链式队列结点</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LinkNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//链式队列</span><br>    LinkNode *front,*rear;<span class="hljs-comment">//队列的对头和队尾指针</span><br>&#125;LinkQueue;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    Q.front = Q.rear=(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<span class="hljs-comment">//建立头结点</span><br>    Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始为空</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    LinkNode *s =(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<br>    s-&gt;data=x;<span class="hljs-comment">//创建新结点，插入到链尾</span><br>    s-&gt;next=<span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next=s;<br>    Q.rear=s;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,<span class="hljs-keyword">int</span> &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//空队</span><br>    LinkNode *p =Q.front-&gt;next;<br>    x=p-&gt;data;<br>    Q.front-&gt;next=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear==p)&#123;<br>        Q.rear = Q.front;<span class="hljs-comment">//若原队列中只有一个结点，删除后变空</span><br>    &#125;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintQueue</span><span class="hljs-params">(LinkQueue Q)</span><span class="hljs-comment">//遍历队列 </span></span><br><span class="hljs-function"></span>&#123;<br>LinkNode *tmp=Q.front-&gt;next;<span class="hljs-comment">//声明一个结点用于遍历</span><br><span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果这个结点为空则停止遍历</span><br>&#123;<span class="hljs-comment">//这里即tmp已经指向最后一个元素的-&gt;next</span><br>cout&lt;&lt;tmp-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//因为在初始化时已经置最后一个元素的-&gt;next=NULL</span><br>tmp=tmp-&gt;next;<span class="hljs-comment">//所以说这里只需要判断tmp为空即可</span><br>&#125;<br>cout&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>LinkQueue Q;<span class="hljs-comment">//声明链式一个队列 </span><br><span class="hljs-built_in">InitQueue</span>(Q);<span class="hljs-comment">//初始化队列 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">5</span>;i&gt;<span class="hljs-number">0</span>;i--)     <span class="hljs-comment">//创建队列 </span><br>&#123;<br><span class="hljs-built_in">EnQueue</span>(Q,i);<br>&#125;<br><span class="hljs-built_in">PrintQueue</span>(Q);      <span class="hljs-comment">//遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">DeQueue</span>(Q,x);<span class="hljs-comment">//出队 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是第&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;次出队&quot;</span>&lt;&lt;<span class="hljs-string">&quot;出队的元素是&quot;</span> &lt;&lt;x&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))<span class="hljs-comment">//队列非空则遍历 </span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;当前队列为：&quot;</span>;<br><span class="hljs-built_in">PrintQueue</span>(Q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;此时的队列为空队列&quot;</span>&lt;&lt;endl;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="程序输出：-1"><a href="#程序输出：-1" class="headerlink" title="程序输出："></a>程序输出：</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">1</span>次出队出队的元素是<span class="hljs-number">5</span><br>当前队列为：<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">2</span>次出队出队的元素是<span class="hljs-number">4</span><br>当前队列为：<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">3</span>次出队出队的元素是<span class="hljs-number">3</span><br>当前队列为：<span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">4</span>次出队出队的元素是<span class="hljs-number">2</span><br>当前队列为：<span class="hljs-number">1</span><br>这是第<span class="hljs-number">5</span>次出队出队的元素是<span class="hljs-number">1</span><br>此时的队列为空队列<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2022/03/30/Algorithm009/"/>
    <url>/2022/03/30/Algorithm009/</url>
    
    <content type="html"><![CDATA[<h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><h3 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h3><p>栈的顺序存储类型可描述为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义栈中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放栈中元素</span><br>    <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶指针</span><br>&#125;SqStack;<br></code></pre></div></td></tr></table></figure><h3 id="顺序栈的基本运算"><a href="#顺序栈的基本运算" class="headerlink" title="顺序栈的基本运算"></a>顺序栈的基本运算</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;s)</span></span>&#123;<br>    s.top=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化栈顶指针</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="判栈空"><a href="#判栈空" class="headerlink" title="判栈空"></a>判栈空</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//不空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;s,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == MaxSize<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈满，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s.data[++s.top]=x;<span class="hljs-comment">//指针先加1，在入栈</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;s,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    x=s.data[s.top--];<span class="hljs-comment">//先出栈，指针再减1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s,ElemType &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span> )<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   x=s.data[s.top];<span class="hljs-comment">//x记录栈顶元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="顺序栈的完整操作"><a href="#顺序栈的完整操作" class="headerlink" title="顺序栈的完整操作"></a>顺序栈的完整操作</h3><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义栈中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放栈中元素</span><br>    <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶指针</span><br>&#125;SqStack;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;s)</span></span>&#123;<br>    s.top=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化栈顶指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//不空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;s,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == MaxSize<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈满，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s.data[++s.top]=x;<span class="hljs-comment">//指针先加1，在入栈</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;s,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    x=s.data[s.top--];<span class="hljs-comment">//先出栈，指针再减1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s,ElemType &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span> )<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   x=s.data[s.top];<span class="hljs-comment">//x记录栈顶元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintSqStack</span><span class="hljs-params">(SqStack s)</span><span class="hljs-comment">//遍历栈 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> tmp = s.top;<br><span class="hljs-keyword">while</span>(tmp!=<span class="hljs-number">-1</span>)<span class="hljs-comment">//如果tmp==-1说明遍历结束 </span><br>&#123; <br>cout&lt;&lt;s.data[tmp--]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>SqStack s;<span class="hljs-comment">//声明一个顺序栈 </span><br><span class="hljs-built_in">InitStack</span>(s);<span class="hljs-comment">//初始化一个顺序栈 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-built_in">Push</span>(s,i);<span class="hljs-comment">//入栈 </span><br>&#125;<br><span class="hljs-built_in">PrintSqStack</span>(s);<span class="hljs-comment">//遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<span class="hljs-comment">//为了对比GetTop和Pop操作 </span><br><span class="hljs-keyword">int</span> x; <br><span class="hljs-built_in">GetTop</span>(s,x);<span class="hljs-comment">//取栈顶元素 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是GetTop操作,栈顶元素为&quot;</span>&lt;&lt;x&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;这是GetTop操作后的栈遍历:&quot;</span>;<br><span class="hljs-built_in">PrintSqStack</span>(s); <br><span class="hljs-built_in">Pop</span>(s,x);<span class="hljs-comment">//出栈 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是Pop操作,出栈的元素为&quot;</span>&lt;&lt;x&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">StackEmpty</span>(s))<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;这是Pop操作后的栈遍历:&quot;</span>;<br><span class="hljs-built_in">PrintSqStack</span>(s); <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;此时栈空！&quot;</span>&lt;&lt;endl;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">5</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">5</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">4</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">4</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">3</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">3</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">2</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">2</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">1</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">1</span><br>此时栈空！<br></code></pre></div></td></tr></table></figure><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>栈的链式存储类型可描述为</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Linknode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Linknode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span><br>&#125;*Linknode;<span class="hljs-comment">//栈类型操作</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双链表与静态链表</title>
    <link href="/2022/03/29/Algorithm008/"/>
    <url>/2022/03/29/Algorithm008/</url>
    
    <content type="html"><![CDATA[<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>双链表中结点类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>&#123;</span><span class="hljs-comment">//定义双链表结点类型</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span><span class="hljs-comment">//前驱和后继指针</span><br>&#125;DNode,*DLinkList;<br></code></pre></div></td></tr></table></figure><h3 id="双链表的插入操作"><a href="#双链表的插入操作" class="headerlink" title="双链表的插入操作"></a>双链表的插入操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//p所指结点是s所指结点的前驱结点</span><br>s-&gt;next=p-&gt;next;           <span class="hljs-comment">//将结点*s插入到结点*p之后</span><br>p-&gt;next-&gt;prior=s;<br>s-&gt;prior=p;<br>p-&gt;next=s;<br></code></pre></div></td></tr></table></figure><h3 id="双链表的删除操作"><a href="#双链表的删除操作" class="headerlink" title="双链表的删除操作"></a>双链表的删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//删除双链表中结点*p的后继结点*q</span><br>p-&gt;next=q-&gt;next;<br>q-&gt;next-&gt;prior=p;<br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放节点空间</span><br></code></pre></div></td></tr></table></figure><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>静态链表结构类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//静态链表的最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//静态链表结构类型的定义</span><br>    ElemType data;<span class="hljs-comment">//储存数据元素</span><br>    <span class="hljs-keyword">int</span> next;<span class="hljs-comment">//下一个元素的数组下标</span><br>&#125;SLinkList[MaxSize];<br></code></pre></div></td></tr></table></figure><h3 id="对静态链表结构类型的定义的理解与猜想验证"><a href="#对静态链表结构类型的定义的理解与猜想验证" class="headerlink" title="对静态链表结构类型的定义的理解与猜想验证"></a>对静态链表结构类型的定义的理解与猜想验证</h3><p><img src="/2022/03/29/Algorithm008/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8-16485415016461.png" alt="静态链表"></p><p><img src="/2022/03/29/Algorithm008/123-16485415073922.png" alt="123"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表上的基本操作</title>
    <link href="/2022/03/28/Algorithm007/"/>
    <url>/2022/03/28/Algorithm007/</url>
    
    <content type="html"><![CDATA[<h2 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h2><p>单链表中结点类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span><br>&#125;LNode,*LinkList;<br></code></pre></div></td></tr></table></figure><h2 id="单链表上基本操作的实现"><a href="#单链表上基本操作的实现" class="headerlink" title="单链表上基本操作的实现"></a>单链表上基本操作的实现</h2><h3 id="1-采用头插法建立单链表"><a href="#1-采用头插法建立单链表" class="headerlink" title="1.采用头插法建立单链表"></a>1.采用头插法建立单链表</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//逆向建立单链表</span><br>    LNode *s;<br>    <span class="hljs-keyword">int</span> x;<br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//创建头结点</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始化为空链表</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<span class="hljs-comment">//输入结点的值</span><br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<span class="hljs-comment">//输入9999表示结束</span><br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//建立新结点</span><br>        s-&gt;data = x;<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;<span class="hljs-comment">//将新结点插入表中，L为头指针</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-采用尾插法建立单链表"><a href="#2-采用尾插法建立单链表" class="headerlink" title="2.采用尾插法建立单链表"></a>2.采用尾插法建立单链表</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">List_TailInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//正向建立单链表</span><br>    <span class="hljs-keyword">int</span> x;<span class="hljs-comment">//设置元素类型为整型</span><br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>    LNode *s,*r=L;<span class="hljs-comment">//r为表尾指针</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>        s-&gt;data=x;<br>        r-&gt;next = s;<br>        r = s;<span class="hljs-comment">//r指向新的表尾结点</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        <br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-按序号查找结点值"><a href="#3-按序号查找结点值" class="headerlink" title="3.按序号查找结点值"></a>3.按序号查找结点值</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">LNode *<span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<span class="hljs-comment">//计数，初始为1</span><br>    LNode *p = L-&gt;next;<span class="hljs-comment">//第1个结点指针赋给p</span><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> L;<span class="hljs-comment">//若i等于0，则返回头结点</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//若i无效，则返回NULL</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)<span class="hljs-comment">//从第一个结点开始找，查找第i个结点</span><br>    &#123;<br>        p=p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-按值查找表结点"><a href="#4-按值查找表结点" class="headerlink" title="4.按值查找表结点"></a>4.按值查找表结点</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,ElemType e)</span></span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=e)<span class="hljs-comment">//从第i个结点开始查找data域为e的结点</span><br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//找到后返回该结点指针，否则返回NULL</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-插入结点操作"><a href="#5-插入结点操作" class="headerlink" title="5.插入结点操作"></a>5.插入结点操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//p所指结点是s所指结点的前驱结点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>LNode *p;<br>LNode *s=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//一定要分配空间！！！！！</span><br>s-&gt;data=x;<br>s-&gt;next=<span class="hljs-literal">NULL</span>; <br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>s-&gt;next =p-&gt;next;<br>p-&gt;next=s;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;插入值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> ; <br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对某一结点进行前插操作</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//注意与插入结点相对比!!!!!!!!</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delect</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//p所指结点是q所指结点的前驱结点</span><br>LNode *p;<br>LNode *q=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));   <span class="hljs-comment">//申请空间 </span><br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);    <span class="hljs-comment">//查找删除位置的前驱结点</span><br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>||p-&gt;next==<span class="hljs-literal">NULL</span>)          <span class="hljs-comment">//p==NULL是i值不合法的情况 </span><br>&#123;    <span class="hljs-comment">//p-&gt;next==NUll是i-1号结点后已无其他结点 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;删除值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">free</span>(q);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>q=p-&gt;next;<span class="hljs-comment">//令q指向被删除的结点</span><br>p-&gt;next=q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-删除结点操作"><a href="#6-删除结点操作" class="headerlink" title="6.删除结点操作"></a>6.删除结点操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//p所指结点是q所指结点的前驱结点</span><br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>)<span class="hljs-comment">//查找删除位置的前驱结点</span><br>q=p-&gt;next;<span class="hljs-comment">//令q指向被删除的结点</span><br>p-&gt;next=q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放结点的储存空间</span><br></code></pre></div></td></tr></table></figure><p>拓展:删除结点*p</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">q=p-&gt;next;<span class="hljs-comment">//令q指向*p的后继节点</span><br>p-&gt;data = p-&gt;next-&gt;data<span class="hljs-comment">//和后继结点交换数据域</span><br>p-&gt;next = q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放后继结点的储存空间</span><br></code></pre></div></td></tr></table></figure><h2 id="单链表上基本操作的完整实现"><a href="#单链表上基本操作的完整实现" class="headerlink" title="单链表上基本操作的完整实现"></a>单链表上基本操作的完整实现</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span><br>&#125;LNode,*LinkList;<br><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//逆向建立单链表</span><br>    LNode *s;<br>    <span class="hljs-keyword">int</span> x;<br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//创建头结点</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始化为空链表</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<span class="hljs-comment">//输入结点的值</span><br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<span class="hljs-comment">//输入9999表示结束</span><br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//建立新结点</span><br>        s-&gt;data = x;<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;<span class="hljs-comment">//将新结点插入表中，L为头指针</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><span class="hljs-function">LNode *<span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<span class="hljs-comment">//计数，初始为1</span><br>    LNode *p = L-&gt;next;<span class="hljs-comment">//第1个结点指针赋给p</span><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> L;<span class="hljs-comment">//若i等于0，则返回头结点</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//若i无效，则返回NULL</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)<span class="hljs-comment">//从第一个结点开始找，查找第i个结点</span><br>    &#123;<br>        p=p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span><br>&#125;<br><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,ElemType e)</span></span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=e)<span class="hljs-comment">//从第i个结点开始查找data域为e的结点</span><br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//找到后返回该结点指针，否则返回NULL</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintLinkList</span><span class="hljs-params">(LinkList L)</span></span>&#123;        <span class="hljs-comment">//这段代码根据链表表尾结点的 next 指针指向 NULL 来遍历整个链表。</span><br>LNode *tmp = L-&gt;next;<br><span class="hljs-keyword">if</span>(tmp==<span class="hljs-literal">NULL</span>)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;链表为空&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> ; <br>&#125;<br><span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>cout&lt;&lt;tmp-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>tmp=tmp-&gt;next;<br>&#125;<br>cout&lt;&lt;endl; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>LNode *p;<br>LNode *s=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//申请空间 </span><br>s-&gt;data=x;<br>s-&gt;next=<span class="hljs-literal">NULL</span>; <br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>s-&gt;next =p-&gt;next;<br>p-&gt;next=s;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;插入值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> ; <br>&#125;<br><br>&#125;<br><span class="hljs-comment">//注意与插入结点相对比!!!!!!!!</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delect</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//p所指结点是q所指结点的前驱结点</span><br>LNode *p;<br>LNode *q=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));   <span class="hljs-comment">//申请空间 </span><br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);    <span class="hljs-comment">//查找删除位置的前驱结点</span><br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>||p-&gt;next==<span class="hljs-literal">NULL</span>)          <span class="hljs-comment">//p==NULL是i值不合法的情况 </span><br>&#123;    <span class="hljs-comment">//p-&gt;next==NUll是i-1号结点后已无其他结点 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;删除值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">free</span>(q);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>q=p-&gt;next;<span class="hljs-comment">//令q指向被删除的结点</span><br>p-&gt;next=q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>LinkList L;<span class="hljs-comment">//声明一个单链表 </span><br><span class="hljs-built_in">List_HeadInsert</span>(L);<span class="hljs-comment">//使用头插法插入4个元素，分别是1,2,3,4 </span><br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br>LNode *tmp;<br>tmp=<span class="hljs-built_in">GetElem</span>(L,<span class="hljs-number">2</span>);<span class="hljs-comment">//找到位置为2的元素 </span><br><span class="hljs-keyword">if</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;位置为2的元素是：&quot;</span>&lt;&lt;tmp-&gt;data&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;非法的位置&quot;</span>&lt;&lt;endl;<br>&#125;<br>tmp=<span class="hljs-built_in">LocateElem</span>(L,<span class="hljs-number">1</span>);<span class="hljs-comment">//找到值为1的元素</span><br><span class="hljs-keyword">if</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;存在值为1的元素：&quot;</span>&lt;&lt;tmp-&gt;data&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;没有找到该值&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br><span class="hljs-built_in">Insert</span>(L,<span class="hljs-number">5</span>,<span class="hljs-number">110</span>);<span class="hljs-comment">//在5这个位置插入元素110</span><br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br><span class="hljs-built_in">Delect</span>(L,<span class="hljs-number">2</span>);        <span class="hljs-comment">//删除位序为2的元素</span><br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>位置为<span class="hljs-number">2</span>的元素是：<span class="hljs-number">3</span><br>存在值为<span class="hljs-number">1</span>的元素：<span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">110</span><br><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">110</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表的定义</title>
    <link href="/2022/03/28/Algorithm006/"/>
    <url>/2022/03/28/Algorithm006/</url>
    
    <content type="html"><![CDATA[<h1 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h1><h2 id="1-单链表的定义"><a href="#1-单链表的定义" class="headerlink" title="1.单链表的定义"></a>1.单链表的定义</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>      <span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;         <span class="hljs-comment">//每个结点存放一个数据元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-comment">//指针指向下一个节点</span><br>&#125;LNode,*LinkList;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>      <span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;         <span class="hljs-comment">//每个结点存放一个数据元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-comment">//指针指向下一个节点</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> <span class="hljs-title">LNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></div></td></tr></table></figure><p>这两种定义是一模一样的！</p><p>要表示一个单链表时，只需要声明一个头指针L，指向单链表的第一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">LNoode *L;      <span class="hljs-comment">//声明一个指向单链表第一个结点的指针</span><br><span class="hljs-comment">//或：</span><br>LinkList L;     <span class="hljs-comment">//声明一个指向单链表第一个结点的指针</span><br></code></pre></div></td></tr></table></figure><h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">LNode *L；<br><span class="hljs-comment">//和：</span><br>LinkList L;<br><span class="hljs-comment">//两者的区别就是强调不同</span><br></code></pre></div></td></tr></table></figure><p><img src="/2022/03/28/Algorithm006/%E6%BC%94%E7%A4%BA.png"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优先队列</title>
    <link href="/2022/03/11/Algorithm005/"/>
    <url>/2022/03/11/Algorithm005/</url>
    
    <content type="html"><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>定义：priority_queue&lt;Type, Container, Functional&gt;</p><p>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。</p><p>当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。<br>一般是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//升序队列，小顶堆</span><br>priority_queue &lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br><span class="hljs-comment">//降序队列，大顶堆</span><br>priority_queue &lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt; &gt;q;<br><br><span class="hljs-comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span><br></code></pre></div></td></tr></table></figure><h2 id="样例一P1090-NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G"><a href="#样例一P1090-NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G" class="headerlink" title="样例一P1090 [NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G"></a>样例一P1090 [NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p><p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p><p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p><p>例如有 33种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 、 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 &#x3D;3+12&#x3D;15 。可以证明 15为最小的体力耗费值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>共两行。<br>第一行是一个整数 n*(1≤<em>n</em>≤10000) ，表示果子的种类数。</p><p>第二行包含 <em>n</em> 个整数，用空格分隔，第 <em>i</em> 个整数 a<strong>i*(1≤*a</strong>i<em>≤20000) 是第 i</em> 种果子的数目。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^{31} 。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a><strong>输入 #1</strong></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3</span> <br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span> <br></code></pre></div></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a><strong>输出 #1</strong></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> num;<br>        cin&gt;&gt;num;<br>        q.<span class="hljs-built_in">push</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n<span class="hljs-number">-1</span> ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> a=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">int</span> b=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        ans+=a+b;<br>        q.<span class="hljs-built_in">push</span>(a+b);<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/huashanqingzhu/p/11040390.html">c++优先队列(priority_queue)用法详解 - 华山青竹 - 博客园 (cnblogs.com)</a></p><p>[P1090 <a href="https://www.luogu.com.cn/problem/P1090">NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perf-系统级性能分析工具</title>
    <link href="/2022/01/19/tool003/"/>
    <url>/2022/01/19/tool003/</url>
    
    <content type="html"><![CDATA[<p>系统级性能优化通常包括两个阶段：性能剖析（performance profiling）和代码优化。</p><p>性能剖析的目标是寻找性能瓶颈，查找引发性能问题的原因及热点代码。</p><p>代码优化的目标是针对具体性能问题而优化代码或编译选项，以改善软件性能。</p><p>在性能剖析阶段，需要借助于现有的profiling工具，如perf等。在代码优化阶段往往需要借助开发者的经验，编写简洁高效的代码，甚至在汇编级别合理使用各种指令，合理安排各种指令的执行顺序。</p><p>perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。<br>通过perf，应用程序可以利用PMU、tracepoint和内核中的计数器来进行性能统计。它不但可以分析制定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用程序和内核，从而全面理解应用程序中的性能瓶颈。</p><p>使用perf，可以分析程序运行期间发生的硬件事件，比如instructions retired、processor clock cycles等；也可以分析软件时间，比如page fault和进程切换。</p><p>perf是一款综合性分析工具，大到系统全局性性能，再小到进程线程级别，甚至到函数及汇编级别。</p><p>perf提供了十八般武器，可以拿大刀大卸八块，也可以拿起手术刀细致分析。</p><h1 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1. 背景知识"></a>1. 背景知识</h1><h2 id="1-1-tracepoints"><a href="#1-1-tracepoints" class="headerlink" title="1.1 tracepoints"></a>1.1 tracepoints</h2><p>tracepoints是散落在内核源码中的一些hook，它们可以在特定的代码被执行到时触发，这一特定可以被各种trace&#x2F;debug工具所使用。</p><p>perf将tracepoint产生的时间记录下来，生成报告，通过分析这些报告，便可以了解程序运行期间内核的各种细节，对性能症状做出准确的诊断。</p><p>这些tracepint的对应的sysfs节点在&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events目录下。</p><h2 id="1-2-硬件特性之cache"><a href="#1-2-硬件特性之cache" class="headerlink" title="1.2 硬件特性之cache"></a>1.2 硬件特性之cache</h2><p>内存读写是很快的，但是还是无法和处理器指令执行速度相比。为了从内存中读取指令和数据，处理器需要等待，用处理器时间来衡量，这种等待非常漫长。cache是一种SRAM，读写速度非常快，能和处理器相匹配。因此将常用的数据保存在cache中，处理器便无需等待，从而提高性能。cache的尺寸一般都很小，充分利用cache是软件调优非常重要部分。</p><h1 id="2-主要关注点"><a href="#2-主要关注点" class="headerlink" title="2. 主要关注点"></a>2. 主要关注点</h1><p>基于性能分析，可以进行算法优化（空间复杂度和时间复杂度权衡）、代码优化（提高执行速度、减少内存占用）。</p><p>评估程序对硬件资源的使用情况，例如各级cache的访问次数、各级cache的丢失次数、流水线停顿周期、前端总线访问次数等。</p><p>评估程序对操作系统资源的使用情况，系统调用次数、上下文切换次数、任务迁移次数。</p><p>事件可以分为三种：</p><ol><li>Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。</li><li>Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如进程切换，tick数等。</li><li>Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。</li></ol><h1 id="3-perf的使用"><a href="#3-perf的使用" class="headerlink" title="3. perf的使用"></a>3. perf的使用</h1><p>perf –help后可以看到perf的二级命令</p><p><img src="/2022/01/19/tool003/image-20220119120817508.png"></p><h2 id="3-1perf-list"><a href="#3-1perf-list" class="headerlink" title="3.1perf list"></a>3.1perf list</h2><p>perf list查看支持的事件类型</p><p><img src="/2022/01/19/tool003/image-20220119121131231.png"></p><h2 id="3-2perf-top"><a href="#3-2perf-top" class="headerlink" title="3.2perf top"></a>3.2perf top</h2><p>即可以正常显示perf top如下：</p><p>第一列：符号引发的性能事件的比例，指占用的cpu周期比例。</p><p>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。</p><p>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库；[k]表述此符号属于内核或模块。</p><p>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p><p><img src="/2022/01/19/tool003/image-20220119121453395.png"></p><h2 id="3-3-perf-stat"><a href="#3-3-perf-stat" class="headerlink" title="3.3 perf stat"></a>3.3 perf stat</h2><p>perf stat用于运行指令，并分析其统计结果。虽然perf top也可以指定pid，但是必须先启动应用才能查看信息。</p><p>perf stat能完整统计应用整个生命周期的信息。</p><p>命令格式为：</p><blockquote><p>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] <command><br>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] — <command> [<options>]</options></EVENT></EVENT></p></blockquote><p><img src="/2022/01/19/tool003/image-20220119122351095.png" alt="image-20220119122351095"></p><p><img src="/2022/01/19/tool003/C2DDB2280E83453D6D8FE0D11A4380C3.png"></p><p>cpu-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized &#x3D; task-clock &#x2F; time elapsed，CPU的占用率。</p><p>context-switches：程序在运行过程中上下文的切换次数。</p><p>CPU-migrations：程序在运行过程中发生的处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。</p><p>CPU迁移和上下文切换：发生上下文切换不一定会发生CPU迁移，而发生CPU迁移时肯定会发生上下文切换。发生上下文切换有可能只是把上下文从当前CPU中换出，下一次调度器还是将进程安排在这个CPU上执行。</p><p>page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。</p><p>cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles &#x2F; task-clock算出。</p><p>stalled-cycles-frontend：指令读取或解码的质量步骤，未能按理想状态发挥并行左右，发生停滞的时钟周期。</p><p>stalled-cycles-backend：指令执行步骤，发生停滞的时钟周期。</p><p>instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。</p><p>branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p><h2 id="3-4-perf-record-amp-report"><a href="#3-4-perf-record-amp-report" class="headerlink" title="3.4 perf record &amp; report"></a>3.4 perf record &amp; report</h2><p>运行一个命令，并将其数据保存到perf.data中。随后，可以使用perf report进行分析。</p><p>perf record和perf report可以更精确的分析一个应用，perf record可以精确到函数级别。并且在函数里面混合显示汇编语言和代码。</p><p><img src="/2022/01/19/tool003/image-20220119123152290.png"></p><p>1.编译程序(这里以test.c为例子)</p><p><img src="/2022/01/19/tool003/image-20220119124049654.png"></p><p>2.perf record</p><p><img src="/2022/01/19/tool003/image-20220119124217563.png"></p><p>3.perf report</p><p><img src="/2022/01/19/tool003/image-20220119124149337.png"></p><p><img src="/2022/01/19/tool003/image-20220119124013315.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/arnoldlu/p/6241297.html">系统级性能分析工具perf的介绍与使用 - ArnoldLu - 博客园 (cnblogs.com)</a>-系统性能分析工具perf的介绍与使用</p><p><a href="https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=11304698501320722134&spm_id_from=333.337.0.0">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcov代码覆盖率测试</title>
    <link href="/2022/01/18/tool002/"/>
    <url>/2022/01/18/tool002/</url>
    
    <content type="html"><![CDATA[<h1 id="gcov代码覆盖率测试"><a href="#gcov代码覆盖率测试" class="headerlink" title="gcov代码覆盖率测试"></a>gcov代码覆盖率测试</h1><h2 id="gcov的简单介绍"><a href="#gcov的简单介绍" class="headerlink" title="gcov的简单介绍"></a>gcov的简单介绍</h2><p>1.gcov是一个测试代码覆盖率的工具。与GCC一起使用来分析程序，以帮助创建更高效、更快的运行代码，并发现程序的未测试部分<br>2.是一个命令行方式的控制台程序。需要结合lcov,gcovr等前端图形工具才能实现统计数据图形化<br>3.伴随GCC发布，不需要单独下载gcov工具。配合GCC共同实现对c&#x2F;c++文件的语句覆盖和分支覆盖测试<br>4.与程序概要分析工具（profiling tool，例如gprof）一起工作，可以估计程序中哪段代码最耗时</p><h2 id="gcov能做什么"><a href="#gcov能做什么" class="headerlink" title="gcov能做什么"></a>gcov能做什么</h2><p>使用像gcov或gprof这样的分析器，您可以找到一些基本的性能统计数据：</p><ul><li>每一行代码执行的频率是多少</li><li>实际执行了哪些行代码，配合测试用例达到满意的覆盖率和预期工作</li><li>每段代码使用了多少计算时间，从而找到热点优化代码</li><li>gcov创建一个sourcefile.gcov的日志文件，此文件标识源文件sourcefile.c每一行执行的次数,您可以与gprof一起使用这些日志文件来帮助优化程序的性能。gprof提供了您可以使用的时间信息以及从gcov获得的信息。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.通过将一些代码行合并到一个函数中，可能不会提供足够的信息来查找代码使用大量计算机时间的“热点”。同样地，由于gcov按行(在最低的分辨率下)积累统计数据，它最适合于只在每行上放置一个语句的编程风格。如果您使用扩展到循环或其他控制结构的复杂宏，那么统计信息就没有那么有用了——它们只报告出现宏调用的行。如果您的复杂宏的行为类似于函数，那么您可以用inline fu替换它们。<br>2.gcov只在使用GCC编译的代码上工作。它与任何其他概要或测试覆盖机制不兼容。</p><h2 id="使用gcov的3个阶段"><a href="#使用gcov的3个阶段" class="headerlink" title="使用gcov的3个阶段"></a>使用gcov的3个阶段</h2><h3 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1.编译阶段"></a>1.编译阶段</h3><p>要开启gcov功能，需要在源码编译参数中加入-fprofile-arcs -ftest-coverage</p><ul><li>-ftest-coverage：在编译的时候产生.gcno文件，它包含了重建基本块图和相应的块的源码的行号的信息。</li><li>-fprofile-arcs：在运行编译过的程序的时候，会产生.gcda文件，它包含了弧跳变的次数等信息。</li></ul><p>以下我们以test.c这个程序为例子，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> a =<span class="hljs-number">20220118</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>编译阶段：</strong></p><p><img src="/2022/01/18/tool002/image-20220118145007919.png"></p><h3 id="2-gcov收集代码运行信息"><a href="#2-gcov收集代码运行信息" class="headerlink" title="2. gcov收集代码运行信息"></a>2. gcov收集代码运行信息</h3><ul><li>运行<code>./test</code>产生<code>test.gcda</code>文件，其中包含了代码基本块和狐跳变次数统计信息</li></ul><p><img src="/2022/01/18/tool002/image-20220118145103922.png"></p><h4 id="3-生成gcov代码覆盖率报告"><a href="#3-生成gcov代码覆盖率报告" class="headerlink" title="3. 生成gcov代码覆盖率报告"></a>3. 生成gcov代码覆盖率报告</h4><ul><li>再次运行<code>gcov test.c</code>产生的<code>test.c.gcov</code>中包含了代码覆盖率数据,其数据的来源为<code>test.gcda</code></li></ul><p><img src="/2022/01/18/tool002/image-20220118145303290.png"></p><h3 id="4-查看生成gcov代码覆盖率报告"><a href="#4-查看生成gcov代码覆盖率报告" class="headerlink" title="4.查看生成gcov代码覆盖率报告"></a>4.查看生成gcov代码覆盖率报告</h3><p><img src="/2022/01/18/tool002/image-20220118145514099.png"></p><p>可以看到以下结果：</p><ul><li>其中<code>#####</code>表示未运行的行</li><li>每行前面的数字表示行运行的次数</li><li>—代表不必执行</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">-:    <span class="hljs-number">0</span>:Source:test.c<br>-:    <span class="hljs-number">0</span>:Graph:test.gcno<br>-:    <span class="hljs-number">0</span>:Data:test.gcda<br>-:    <span class="hljs-number">0</span>:Runs:<span class="hljs-number">1</span><br>-:    <span class="hljs-number">0</span>:Programs:<span class="hljs-number">1</span><br>-:    <span class="hljs-number">1</span>:<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">1</span>:    <span class="hljs-number">2</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">-:    3:</span>&#123;<br><span class="hljs-number">1</span>:    <span class="hljs-number">4</span>:        <span class="hljs-keyword">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-number">1</span>:    <span class="hljs-number">5</span>:        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-number">5</span>:    <span class="hljs-number">6</span>:        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>-:    <span class="hljs-number">7</span>:        &#123;<br><span class="hljs-number">4</span>:    <span class="hljs-number">8</span>:           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>-:    <span class="hljs-number">9</span>:        &#125;<br><span class="hljs-number">1</span>:   <span class="hljs-number">10</span>:        <span class="hljs-keyword">int</span> a =<span class="hljs-number">20220118</span>;<br><span class="hljs-number">1</span>:   <span class="hljs-number">11</span>:        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a);<br><span class="hljs-number">1</span>:   <span class="hljs-number">12</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>-:   <span class="hljs-number">13</span>:&#125;<br></code></pre></div></td></tr></table></figure><h2 id="配合lcov使用，图形化显示"><a href="#配合lcov使用，图形化显示" class="headerlink" title="配合lcov使用，图形化显示"></a>配合lcov使用，图形化显示</h2><p><strong>1.centos安装lcov:</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">yum install lcov<br></code></pre></div></td></tr></table></figure><p><strong>2.运行lcov，生成相应信息</strong></p><p><img src="/2022/01/18/tool002/image-20220118151526665.png"></p><p>运行结果：</p><p><img src="/2022/01/18/tool002/image-20220118151553801.png"></p><p><strong>3.生成web可视化信息</strong></p><p><img src="/2022/01/18/tool002/image-20220118151821325.png"></p><p>运行结果：</p><p><img src="/2022/01/18/tool002/image-20220118151853477.png"></p><p><strong>4.打包result文件</strong></p><p><img src="/2022/01/18/tool002/image-20220118152629648.png"></p><p><strong>5.从服务器下载到本地</strong></p><p><img src="/2022/01/18/tool002/image-20220118152705023.png"></p><p><strong>6.查看web</strong></p><p>​1）查看index.html：</p><p><img src="/2022/01/18/tool002/image-20220118152825105.png"></p><p>​2）详细信息：</p><p><img src="/2022/01/18/tool002/image-20220118152908078.png"></p><p>上述界面包含：</p><ul><li>函数覆盖率（执行率）</li><li>代码行数覆盖率（执行率）</li><li>语句执行次数</li><li>源码级的详细信息</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/yanxiangyfg/article/details/80989680">(6条消息) gcov代码覆盖率测试-原理和实践总结_yanxiangyfg的专栏-CSDN博客_gcov代码覆盖率</a>-gcov代码覆盖率测试-原理和实践总结</p><p><a href="https://blog.csdn.net/u012247418/article/details/90137291">(6条消息) 代码覆盖率测试工具：gcov和lcov的使用_ARM-Linux-CSDN博客</a>-代码覆盖率测试工具：gcov和lcov的使用</p><p><a href="https://www.cnblogs.com/haoshine/p/5777735.html">linux文件夹打包命令 - 小作一个 - 博客园 (cnblogs.com)</a>-Linux文件打包命令</p><p><a href="https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=16561916178807634748&spm_id_from=333.337.0.0">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(五)-INT型数组相加操作</title>
    <link href="/2022/01/17/AVX005/"/>
    <url>/2022/01/17/AVX005/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX向量化学习-五-INT型数组相加操作"><a href="#AVX向量化学习-五-INT型数组相加操作" class="headerlink" title="AVX向量化学习(五)-INT型数组相加操作"></a>AVX向量化学习(五)-INT型数组相加操作</h1><p>使用AVX指令集进行2个INT型的数组相加操作</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256i _mm256_loadu_si256 (__m256i <span class="hljs-keyword">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure><p><strong>Synopsis</strong></p><p>m256i _mm256_loadu_si256 (m256i const * mem_addr)<br>#include &lt;immintrin.h&gt;<br>Instruction: vmovdqu ymm, m256<br>CPUID Flags: AVX</p><p><strong>Description</strong></p><p>Load 256-bits of integer data from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">dst[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>] := MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr] <br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">7</td><td align="center">0.5</td></tr><tr><td align="left">Skylake</td><td align="center">7</td><td align="center">0.5</td></tr><tr><td align="left">Broadwell</td><td align="center">1</td><td align="center">0.25</td></tr><tr><td align="left">Haswell</td><td align="center">1</td><td align="center">0.25</td></tr><tr><td align="left">Ivy Bridge</td><td align="center">1</td><td align="center">0.5</td></tr></tbody></table><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256i _mm256_add_epi32 (__m256i a, __m256i b)<br></code></pre></div></td></tr></table></figure><p><strong>Synopsis</strong></p><p>m256i _mm256_add_epi32 (m256i a, __m256i b)<br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd ymm, ymm, ymm<br>CPUID Flags: AVX2</p><p><strong>Description</strong></p><p>Add packed 32-bit integers in a and b, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">FOR</span> j := <span class="hljs-number">0</span> to <span class="hljs-number">7</span> <br>     <span class="hljs-attribute">i</span> := j*<span class="hljs-number">32</span> <br>     <span class="hljs-attribute">dst</span>[i+<span class="hljs-number">31</span>:i] := a[i+<span class="hljs-number">31</span>:i] + b[i+<span class="hljs-number">31</span>:i] <br><span class="hljs-attribute">ENDFOR</span> <br><span class="hljs-attribute">dst</span>[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">1</td><td align="center">0.33</td></tr><tr><td align="left">Skylake</td><td align="center">1</td><td align="center">0.33</td></tr><tr><td align="left">Broadwell</td><td align="center">1</td><td align="center">0.5</td></tr><tr><td align="left">Haswell</td><td align="center">1</td><td align="center">0.5</td></tr></tbody></table><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">40</span>];<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">40</span>];<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> ans1[<span class="hljs-number">40</span>];    <span class="hljs-comment">//记录串行结果 </span><br><span class="hljs-keyword">int</span> ans2[<span class="hljs-number">40</span>]; <span class="hljs-comment">//记录AVX向量化后的结果</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br>a[i]=i;<br>b[i]=<span class="hljs-number">2</span>*i;<br>&#125;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br>ans1[i]=a[i]+b[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;串行计算结果：\n&quot;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans1[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>__m256i v0;<br>__m256i v1;<br>__m256i v2;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span><span class="hljs-number">-8</span>;i+=<span class="hljs-number">8</span>)<br>&#123;<br>v0 = _mm256_loadu_si256((<span class="hljs-keyword">const</span> __m256i*)(a+i)); <span class="hljs-comment">//强制类型转换</span><br>v1 = _mm256_loadu_si256((<span class="hljs-keyword">const</span> __m256i*)(b+i)); <span class="hljs-comment">//强制类型转化</span><br>v2 = _mm256_add_epi32(v0,v1);     <span class="hljs-comment">//v0+v1</span><br>_mm256_storeu_si256((__m256i*)(ans2+i),v2);<br><br>&#125;<span class="hljs-comment">//边界处理</span><br><span class="hljs-keyword">for</span> (;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br>ans2[i]=a[i]+b[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;并行计算结果：\n&quot;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans2[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">串行计算结果：<br><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">15</span> <span class="hljs-number">18</span> <span class="hljs-number">21</span> <span class="hljs-number">24</span> <span class="hljs-number">27</span> <span class="hljs-number">30</span> <span class="hljs-number">33</span> <span class="hljs-number">36</span> <span class="hljs-number">39</span> <span class="hljs-number">42</span> <span class="hljs-number">45</span> <span class="hljs-number">48</span> <span class="hljs-number">51</span> <span class="hljs-number">54</span> <span class="hljs-number">57</span> <span class="hljs-number">60</span> <span class="hljs-number">63</span> <span class="hljs-number">66</span> <span class="hljs-number">69</span> <span class="hljs-number">72</span> <span class="hljs-number">75</span> <span class="hljs-number">78</span> <span class="hljs-number">81</span> <span class="hljs-number">84</span> <span class="hljs-number">87</span> <span class="hljs-number">90</span> <span class="hljs-number">93</span> <span class="hljs-number">96</span> <span class="hljs-number">99</span> <span class="hljs-number">102</span> <span class="hljs-number">105</span> <span class="hljs-number">108</span> <span class="hljs-number">111</span> <span class="hljs-number">114</span> <span class="hljs-number">117</span><br>并行计算结果：<br><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">15</span> <span class="hljs-number">18</span> <span class="hljs-number">21</span> <span class="hljs-number">24</span> <span class="hljs-number">27</span> <span class="hljs-number">30</span> <span class="hljs-number">33</span> <span class="hljs-number">36</span> <span class="hljs-number">39</span> <span class="hljs-number">42</span> <span class="hljs-number">45</span> <span class="hljs-number">48</span> <span class="hljs-number">51</span> <span class="hljs-number">54</span> <span class="hljs-number">57</span> <span class="hljs-number">60</span> <span class="hljs-number">63</span> <span class="hljs-number">66</span> <span class="hljs-number">69</span> <span class="hljs-number">72</span> <span class="hljs-number">75</span> <span class="hljs-number">78</span> <span class="hljs-number">81</span> <span class="hljs-number">84</span> <span class="hljs-number">87</span> <span class="hljs-number">90</span> <span class="hljs-number">93</span> <span class="hljs-number">96</span> <span class="hljs-number">99</span> <span class="hljs-number">102</span> <span class="hljs-number">105</span> <span class="hljs-number">108</span> <span class="hljs-number">111</span> <span class="hljs-number">114</span> <span class="hljs-number">117</span><br></code></pre></div></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(四)-INT类型转化成DOUBLE类型</title>
    <link href="/2022/01/17/AVX004/"/>
    <url>/2022/01/17/AVX004/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX向量化学习-四-INT类型转化成DOUBLE类型"><a href="#AVX向量化学习-四-INT类型转化成DOUBLE类型" class="headerlink" title="AVX向量化学习(四)-INT类型转化成DOUBLE类型"></a>AVX向量化学习(四)-INT类型转化成DOUBLE类型</h1><p>使用AVX指令集把INT类型转化为DOUBLE类型</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m128i _mm_setr_epi32 (<span class="hljs-keyword">int</span> e3, <span class="hljs-keyword">int</span> e2, <span class="hljs-keyword">int</span> e1, <span class="hljs-keyword">int</span> e0)<br></code></pre></div></td></tr></table></figure><p><strong>Synopsis</strong></p><p>__m128i _mm_setr_epi32 (int e3, int e2, int e1, int e0)<br>#include &lt;emmintrin.h&gt;<br>Instruction: <strong>Sequence</strong><br>CPUID Flags: SSE2</p><p><strong>Description</strong></p><p>Set packed 32-bit integers in dst with the supplied values in reverse order.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">dst[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] := e3 <br>dst[<span class="hljs-number">63</span>:<span class="hljs-number">32</span>] := e2 <br>dst[<span class="hljs-number">95</span>:<span class="hljs-number">64</span>] := e1 <br>dst[<span class="hljs-number">127</span>:<span class="hljs-number">96</span>] := e0<br></code></pre></div></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256d _mm256_cvtepi32_pd (__m128i a)<br></code></pre></div></td></tr></table></figure><p><strong>Synopsis</strong></p><p>m256d _mm256_cvtepi32_pd (m128i a)<br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtdq2pd ymm, xmm<br>CPUID Flags: AVX</p><p><strong>Description</strong></p><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span> <br>    i := j*<span class="hljs-number">32</span> <br>    m := j*<span class="hljs-number">64</span> <br>    dst[m+<span class="hljs-number">63</span>:m] := <span class="hljs-built_in">Convert_Int32_To_FP64</span>(a[i+<span class="hljs-number">31</span>:i]) <br>ENDFOR <br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">7</td><td align="center">1</td></tr><tr><td align="left">Skylake</td><td align="center">7</td><td align="center">1</td></tr><tr><td align="left">Broadwell</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="left">Haswell</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="left">Ivy Bridge</td><td align="center">4</td><td align="center">1</td></tr></tbody></table><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>g++ int_to_double.cpp -msse2 -mavx -o test01</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>.&#x2F;test01</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    __m128i x = _mm_setr_epi32(a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>],a[<span class="hljs-number">3</span>]);   <span class="hljs-comment">//load</span><br> __m256d v5=_mm256_cvtepi32_pd(x);       <span class="hljs-comment">//convert</span><br>    _mm256_storeu_pd(b,v5);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>    &#123;<br>    cout&lt;&lt;b[i]&lt;&lt;endl;<br>&#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gprof、gprof2dot.py、dot使用方法简介</title>
    <link href="/2022/01/09/tool001/"/>
    <url>/2022/01/09/tool001/</url>
    
    <content type="html"><![CDATA[<h1 id="gprof、gprof2dot-py、dot使用方法简介"><a href="#gprof、gprof2dot-py、dot使用方法简介" class="headerlink" title="gprof、gprof2dot.py、dot使用方法简介"></a>gprof、gprof2dot.py、dot使用方法简介</h1><h2 id="1-：gprof使用步骤如下，以SLIC为例："><a href="#1-：gprof使用步骤如下，以SLIC为例：" class="headerlink" title="(1)：gprof使用步骤如下，以SLIC为例："></a>(1)：gprof使用步骤如下，以SLIC为例：</h2><h3 id="1-在编译过程中添加-pg选项，命令如下："><a href="#1-在编译过程中添加-pg选项，命令如下：" class="headerlink" title="1 在编译过程中添加-pg选项，命令如下："></a>1 在编译过程中添加-pg选项，命令如下：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">gcc -pg SLIC.cpp -o SLIC<br></code></pre></div></td></tr></table></figure><h3 id="2-运行程序，运行结束之后会形成文件gmon-out，命令如下"><a href="#2-运行程序，运行结束之后会形成文件gmon-out，命令如下" class="headerlink" title="2 运行程序，运行结束之后会形成文件gmon.out，命令如下:"></a>2 运行程序，运行结束之后会形成文件gmon.out，命令如下:</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./SLIC</span><br></code></pre></div></td></tr></table></figure><h3 id="3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下："><a href="#3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下：" class="headerlink" title="3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下："></a>3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下：</h3><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">gprof ./SLIC &gt; <span class="hljs-keyword">prof</span>.<span class="hljs-built_in">log</span><br></code></pre></div></td></tr></table></figure><p>分析prof.log就可以获得程序的调用关系、函数执行时间等信息。对gprof的分析方法见以下blog</p><p><a href="http://blog.csdn.net/macky0668/article/details/6839517">http://blog.csdn.net/macky0668/article/details/6839517</a></p><h2 id="2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台"><a href="#2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台" class="headerlink" title="(2)：配合gprof2dot.py与dot工具的使用(我是安装在了Win10平台)"></a>(2)：配合<em>gprof2dot.py</em>与dot工具的使用(我是安装在了Win10平台)</h2><p>以上方法仍然存在一个问题就是分析结果不够直观，特别是函数的调用关系。因此为解决以上问题，可以配合<em>gprof2dot.py</em>与dot工具的使用。</p><h3 id="1-安装gprof2dot-py与dot"><a href="#1-安装gprof2dot-py与dot" class="headerlink" title="1.安装gprof2dot.py与dot"></a>1.安装<em>gprof2dot.py</em>与dot</h3><p><a href="https://github.com/jrfonseca/gprof2dot">GitHub - jrfonseca&#x2F;gprof2dot: Converts profiling output to a dot graph.</a></p><h3 id="2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具"><a href="#2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具" class="headerlink" title="2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具"></a>2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具</h3><p><a href="https://graphviz.org/download/source/">Source Code | Graphviz</a></p><p>在使用上述工具前，还需要先产生prof.log文件，prof.log文件的产生方法见上文。</p><h3 id="3-首先通过命令行进入你安装gprof2dot-py的根目录："><a href="#3-首先通过命令行进入你安装gprof2dot-py的根目录：" class="headerlink" title="3.首先通过命令行进入你安装gprof2dot.py的根目录："></a>3.首先通过命令行进入你安装gprof2dot.py的根目录：</h3><p><img src="/2022/01/09/tool001/image-20220109165659998.png"></p><h3 id="4-通过以下命令即可得到函数调用图："><a href="#4-通过以下命令即可得到函数调用图：" class="headerlink" title="4.通过以下命令即可得到函数调用图："></a>4.通过以下命令即可得到函数调用图：</h3><p><img src="/2022/01/09/tool001/image-20220109170212157.png"></p><h3 id="5-结果如下："><a href="#5-结果如下：" class="headerlink" title="5.结果如下："></a>5.结果如下：</h3><p><img src="/2022/01/09/tool001/image-20220109170315471.png"></p><h2 id="3-：接上文补充几点可能无法产生gmon-out文件的情况："><a href="#3-：接上文补充几点可能无法产生gmon-out文件的情况：" class="headerlink" title="(3)：接上文补充几点可能无法产生gmon.out文件的情况："></a>(3)：接上文补充几点可能无法产生gmon.out文件的情况：</h2><p>  1.程序不是从main return或exit()退出，则可能不生成gmon.out。<br>  2.程序如果崩溃，可能不生成gmon.out。<br>  3.测试发现在虚拟机上运行，可能不生成gmon.out。<br>  4.程序忽略SIGPROF信号！一定不能捕获、忽略SIGPROF信号。man手册对SIGPROF的解释是：profiling timer expired. 如果忽略这个信号，gprof的输出则是：Each sample counts as 0.01 seconds. no time accumulated.<br>  5.如果程序运行时间非常短，则gprof可能无效</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://blog.csdn.net/u012927281/article/details/51132064">(4条消息) gprof、gprof2dot.py、dot使用方法简介_Andy.Wang的博客-CSDN博客_gprof2dot</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/01/04/Algorithm004/"/>
    <url>/2022/01/04/Algorithm004/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集（Disjoint Set）是一种非常精巧而实用的数据结构。用于处理不相交集合的合并问题。</p><p>并查集用来管理元素分组情况。并查集可以高效地进行如下操作。</p><p>1.查询元素 a和元素 b是否属于同一组。<br>2.合并元素 a和元素 b所在的组。<br><img src="/2022/01/04/Algorithm004/20191114081139557.png"></p><p><img src="/2022/01/04/Algorithm004/20191114081642983-16413015433853.png"></p><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><p>我们准备 n个节点来表示 n个元素。最开始时没有边。</p><p><img src="/2022/01/04/Algorithm004/20191114081846480.png"></p><h2 id="2-查询"><a href="#2-查询" class="headerlink" title="2.查询"></a>2.查询</h2><p>为了查询两个节点是否属于同一组，我们需要沿着树向上走，来查询包含这个元素的树的根是谁。如果两个节点走到了同一个根，那么就可以知道它们属于同一组。</p><p>在下图中，元素 2 和元素 5都走到了元素 1，因此它们属于同一组。另一方面，由于元素 7 走到的是元素 6，因此同元素 2或元素 5 属于不同组。</p><p><img src="/2022/01/04/Algorithm004/20191114082935860.png"></p><h2 id="3-合并"><a href="#3-合并" class="headerlink" title="3.合并"></a>3.合并</h2><p>像下图一样，从一个组的根向另一个组的根连边，这样两棵树就变成了一棵树， 也就把两个组合并为一个组了。</p><p><img src="/2022/01/04/Algorithm004/20191114082505100.png"></p><h2 id="4-路径压缩"><a href="#4-路径压缩" class="headerlink" title="4.路径压缩"></a>4.路径压缩</h2><p>上面的查询程序 find() 沿着搜索路径找到根结点，这条路径可能很长。</p><p>优化：沿路径返回时，顺便把 i 所属的集改成根结点。下次再搜，复杂度是 O(1)。</p><p>这种方法称为路径压缩，在递归过程中，整个搜索路径上的元素所属的集都被改为根结点。</p><p>路径压缩的思想是，我们只关心每个结点的父结点，而并不太关心树的真正的结构。路径压缩不仅优化了下次查询，而且也优化了合并，因为合并时也用到了查询。<br><img src="/2022/01/04/Algorithm004/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODE1MTg4,size_16,color_FFFFFF,t_70.png"><img src="/2022/01/04/Algorithm004/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODE1MTg4,size_16,color_FFFFFF,t_70-16413019286669.png"></p><h2 id="5-按秩合并"><a href="#5-按秩合并" class="headerlink" title="5.按秩合并"></a>5.按秩合并</h2><p>合并元素 x 和 y 时，先搜到它们的根结点；<br>合并这两个根结点：把一个根结点的集改成另一个根结点。<br>这两个根结点的高度不同，把高度较小的集合并到较大的集上，能减少树的高度。</p><p><img src="/2022/01/04/Algorithm004/20191114090118888.png"></p><p>这样，在初始化时就要用一个数组定义元素 i的高度，在合并时更改。</p><p>下面代码加入了上述两个优化，我们用编号代表每个元素。数组 par[ ]表示的是父亲的编号，par[ x ] &#x3D; &#x3D; x  时，x 是所在的树的根。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> par[N];   <span class="hljs-comment">//父亲</span><br><span class="hljs-keyword">int</span> rank[N];  <span class="hljs-comment">//树的高度</span><br><br><span class="hljs-comment">// 初始化n个元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>par[i] = i;<br>rank[i] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查询树的根（路径压缩）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(par[x] == x)<br><span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> par[x] = <span class="hljs-built_in">find</span>(par[x]);<br>&#125;<br><br><span class="hljs-comment">// 合并x和y所属的集合（按秩合并）</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>x = <span class="hljs-built_in">find</span>(x);<br>y = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(x == y)  <span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span>(rank[x] &lt; rank[y])<br>par[x] = y;<br><span class="hljs-keyword">else</span><br>&#123;<br>par[y] = x;<br><span class="hljs-keyword">if</span>(rank[x] == rank[y])rank[x]++;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="样题一：L2-024-部落-25-分"><a href="#样题一：L2-024-部落-25-分" class="headerlink" title="样题一：L2-024 部落 (25 分)"></a>样题一：<strong>L2-024 部落 (25 分)</strong></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查任意两个人是否属于同一个部落。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤104），是已知小圈子的个数。随后<em>N</em>行，每行按下列格式给出一个小圈子里的人：</p><p><em>K</em> <em>P</em>[1] <em>P</em>[2] ⋯ <em>P</em>[<em>K</em>]</p><p>其中<em>K</em>是小圈子里的人数，<em>P</em>[<em>i</em>]（<em>i</em>&#x3D;1,⋯,<em>K</em>）是小圈子里每个人的编号。这里所有人的编号从1开始连续编号，最大编号不会超过104。</p><p>之后一行给出一个非负整数<em>Q</em>（≤104），是查询次数。随后<em>Q</em>行，每行给出一对被查询的人的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出<code>Y</code>，否则输出<code>N</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">4<br>3 10 1 2<br>2 3 4<br>4 1 5 7 8<br>3 9 6 4<br>2<br>10 5<br>3 7结尾无空行<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">10 2<br>Y<br>N结尾无空行<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  N=<span class="hljs-number">10005</span>;<br><span class="hljs-keyword">int</span> par[N];       <span class="hljs-comment">//父亲</span><br><span class="hljs-keyword">int</span> deep[N];      <span class="hljs-comment">//树的高度</span><br><span class="hljs-keyword">int</span> isroot[N];    <span class="hljs-comment">//用来记录互不相交的部落的个数。如果同属于一个部落，那个这个部落的元素的根节点都是一样的。</span><br>                  <span class="hljs-comment">//所以只要统计有多少个根节点就可以知道有多少个互不相交的部落个数</span><br>set&lt;<span class="hljs-keyword">int</span>&gt; st;      <span class="hljs-comment">//集合能很好的过滤到重复元素，可以很方便的用来统计不是重复元素的个数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        par[i] = i;<br>        deep[i] =<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(par[x] == x ) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> par[x] = <span class="hljs-built_in">find</span>(par[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    x=<span class="hljs-built_in">find</span>(x);<br>    y=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(deep[x]&lt;deep[y])<br>    &#123;<br>        par[x]=y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        par[y]=x;<br>        <span class="hljs-keyword">if</span>(deep[x]==deep[y]) deep[x]++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">10005</span>);<br>    <span class="hljs-built_in">memset</span>(isroot,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(isroot));<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> num,first;<br>        cin&gt;&gt;num&gt;&gt;first;<br>        st.<span class="hljs-built_in">insert</span>(first);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;num ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> next;<br>            cin&gt;&gt;next;<br>            st.<span class="hljs-built_in">insert</span>(next);<br>            <span class="hljs-built_in">unite</span>(first,next);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//寻找互不相交的部落</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=st.<span class="hljs-built_in">size</span>() ; ++l) &#123;<br>        isroot[<span class="hljs-built_in">find</span>(l)]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">1</span>; m &lt;=st.<span class="hljs-built_in">size</span>() ; ++m) &#123;<br>        ans+=isroot[m];<br>    &#125;<br>    cout&lt;&lt;st.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">int</span> time;<br>    cin&gt;&gt;time;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;time ; ++k) &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b))<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Y&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;N&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="相关资料："><a href="#相关资料：" class="headerlink" title="相关资料："></a>相关资料：</h2><p><a href="https://blog.csdn.net/qq_42815188/article/details/86769629">(3条消息) 并查集_早睡身体好hh-CSDN博客_并查集</a>：早睡身体好hh-并查集(CSDN)</p><h2 id="样题链接："><a href="#样题链接：" class="headerlink" title="样题链接："></a>样题链接：</h2><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805056736444416">题目详情 - L2-024 部落 (25 分) (pintia.cn)</a>：L2-024 部落 (25 分)</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径-Floyed和Dijkstra</title>
    <link href="/2022/01/03/Algorithm003/"/>
    <url>/2022/01/03/Algorithm003/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径-Floyed和Dijkstra"><a href="#最短路径-Floyed和Dijkstra" class="headerlink" title="最短路径-Floyed和Dijkstra"></a>最短路径-Floyed和Dijkstra</h1><h2 id="Floyed"><a href="#Floyed" class="headerlink" title="Floyed"></a>Floyed</h2><h3 id="样题一：P1364-医院设置"><a href="#样题一：P1364-医院设置" class="headerlink" title="样题一：P1364 医院设置"></a>样题一：P1364 医院设置</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设有一棵二叉树，如图：</p><p><img src="/2022/01/03/Algorithm003/166.png"></p><p>其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 11。如上图中，若医院建在1 处，则距离和 &#x3D;4+12+2\times20+2\times40&#x3D;136&#x3D;4+12+2×20+2×40&#x3D;136；若医院建在 33 处，则距离和 &#x3D;4\times2+13+20+40&#x3D;81&#x3D;4×2+13+20+40&#x3D;81。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>第一行一个整数 n<em>n</em>，表示树的结点数。</p><p>接下来的 n<em>n</em> 行每行描述了一个结点的状况，包含三个整数 w, u, v<em>w</em>,<em>u</em>,<em>v</em>，其中 w<em>w</em> 为居民人口数，u<em>u</em> 为左链接（为 00 表示无链接），v<em>v</em> 为右链接（为 00 表示无链接）。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>一个整数，表示最小距离和。</p><h4 id="输入输出样例："><a href="#输入输出样例：" class="headerlink" title="输入输出样例："></a>输入输出样例：</h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">13 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">40 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">81<br></code></pre></div></td></tr></table></figure><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> tree[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];   <span class="hljs-comment">//tree的作用邻接矩阵建树</span><br><span class="hljs-keyword">int</span> w[<span class="hljs-number">1000</span>],l,r;  <span class="hljs-comment">//w每个结点的居民人口数</span><br><span class="hljs-keyword">int</span> mindis;       <span class="hljs-comment">//最小记录和</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            tree[i][j]=<span class="hljs-number">0X3FFFFFFF</span>;    <span class="hljs-comment">//初始化邻接矩阵</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        tree[i][i]=<span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化</span><br>        cin&gt;&gt;w[i]&gt;&gt;l&gt;&gt;r;  <span class="hljs-comment">//读入数据</span><br>        <span class="hljs-keyword">if</span>(l&gt;<span class="hljs-number">0</span>) tree[i][l]=tree[l][i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(r&gt;<span class="hljs-number">0</span>) tree[i][r]=tree[r][i]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;=n ; ++k) <span class="hljs-comment">//用Floyed求任意两结点之间的最短路径</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(i!=k)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ; ++j) &#123;<br>                    <span class="hljs-keyword">if</span>(i!=j&amp;&amp;j!=k&amp;&amp;tree[i][k]+tree[k][j]&lt;tree[i][j])<br>                    &#123;<br>                        tree[i][j]=tree[i][k]+tree[k][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    mindis=INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//穷举医院建在N个结点，找出最短距离</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            sum+=tree[i][j]*w[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&lt;mindis) mindis=sum;<br>    &#125;<br>    cout&lt;&lt;mindis&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="样题二："><a href="#样题二：" class="headerlink" title="样题二："></a>样题二：</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p><img src="/2022/01/03/Algorithm003/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x5bm5fbWc=,size_16,color_FFFFFF,t_70.png"></p><p>输入n和m，代表n个节点，m条边，然后是m行输入，每行有x,y,z，代表x到y的路距离为z。<br>问题：从1出发到各点的最短路径</p><h4 id="测试样例："><a href="#测试样例：" class="headerlink" title="测试样例："></a>测试样例：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">7</span> <span class="hljs-number">12</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">20</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">50</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">30</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">25</span><br><span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">70</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">40</span><br><span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">50</span><br><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">25</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">55</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span><br><span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">70</span><br><span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">50</span><br><span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span><br><span class="hljs-attribute">70</span><br></code></pre></div></td></tr></table></figure><h4 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">int</span> mapdis[maxn][maxn];  <span class="hljs-comment">//表示x-&gt;y的距离(有向)</span><br><span class="hljs-keyword">int</span> dis[maxn];  <span class="hljs-comment">//代表最短路径长</span><br><span class="hljs-keyword">int</span> path[maxn];  <span class="hljs-comment">//记录前驱节点</span><br><span class="hljs-keyword">int</span> vis[maxn]; <span class="hljs-comment">//用来记录该点是否已经是最短路径的点</span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dis));<br>    <span class="hljs-built_in">memset</span>(path,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(path));<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>    <br>    dis[s]=<span class="hljs-number">0</span>;   <span class="hljs-comment">//自身到自身的距离是0</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; <span class="hljs-comment">//用来记录当轮的起始点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;dis[i]&lt;dis[k])     <span class="hljs-comment">//如果这个点还不为最短路径的点，并且这个点的路径是现在所有点中最小的</span><br>            &#123;<br>                k=i;      <span class="hljs-comment">//那么就记录这个点为当轮的起始点</span><br>                  <span class="hljs-comment">//特殊的这里第一次找到的是起点，及s=1。</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!k) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//所有点已经为最短路径的点，则返回</span><br>        vis[k]=<span class="hljs-number">1</span>;       <span class="hljs-comment">//标记该点为最短路径的点</span><br>        <span class="hljs-comment">//松弛操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ; ++j) &#123;   <br>            <span class="hljs-comment">//第一次循环只有起点的邻接点的距离被更新</span><br>            <span class="hljs-comment">//每次都更新找到，新找到的点的邻接点(新找到的点也就是当轮的起始点)</span><br>            <span class="hljs-keyword">if</span>(dis[j]&gt;dis[k]+mapdis[k][j])  <span class="hljs-comment">//最短路是由最短路+某一条固定路组成</span><br>            &#123;<br>                dis[j]=dis[k]+mapdis[k][j];<span class="hljs-comment">//路径被改变</span><br>                path[j]=k;<span class="hljs-comment">//重新记录前驱，最短路是由最短路+某一条固定路组成，所以前驱是有效的</span><br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-comment">//递归打印</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">print</span>(path[x]);<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(mapdis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(mapdis));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> x,y,z;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-comment">//记录x-&gt;y的距离</span><br>        mapdis[x][y]=z;<br>    &#125;<br>    <span class="hljs-built_in">Dijkstra</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//求1出发到各点的最短路径</span><br>    <span class="hljs-keyword">int</span> order;    <span class="hljs-comment">//读入终点</span><br>    cin&gt;&gt;order;<br>    <span class="hljs-built_in">print</span>(path[order]);  <span class="hljs-comment">//打印最短路径</span><br>    cout&lt;&lt;order&lt;&lt;endl;<br>    cout&lt;&lt;dis[order];    <span class="hljs-comment">//最短路径长</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="样题三：L2-001-紧急救援-25-分"><a href="#样题三：L2-001-紧急救援-25-分" class="headerlink" title="样题三：L2-001 紧急救援 (25 分)"></a>样题三：<strong>L2-001 紧急救援 (25 分)</strong></h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h4><p>输入第一行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0 ~ (<em>N</em>−1)；<em>M</em>是快速道路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。</p><p>第二行给出<em>N</em>个正整数，其中第<em>i</em>个数是第<em>i</em>个城市的救援队的数目，数字间以空格分隔。随后的<em>M</em>行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h4><p>第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从<em>S</em>到<em>D</em>的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span><br><span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">10</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>结尾无空行<br></code></pre></div></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">2</span> <span class="hljs-number">60</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>结尾无空行<br></code></pre></div></td></tr></table></figure><h4 id="最短路径条数："><a href="#最短路径条数：" class="headerlink" title="最短路径条数："></a>最短路径条数：</h4><p>如果通过 <strong>index</strong> 点能把最短路径更新，那么最短路径条数就是从起点到<strong>index</strong>的最短路径条数。</p><p><img src="/2022/01/03/Algorithm003/134d3eff026ab567e3a337c45dda5d61.png"></p><p>例如这张图，如果<strong>index</strong>可以更新当前的最短路径，并且s通过1和2到达index点的距离都相等，那么从s到d的最短路径条数其实就是从s到index的最短路径条数，由此可以得到第一个式子</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">num[i]=num[index];<br></code></pre></div></td></tr></table></figure><p>如果通过index点的周转，距离不变（依然是最小值），这说明通过index周转使得最短路径条数又多出了一部分，只需要用之前得到的最短路径条数加上num[index]即可，由此得出第二个式子</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">num[i]+=num[index];<br></code></pre></div></td></tr></table></figure><h4 id="程序源代码：-2"><a href="#程序源代码：-2" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m,s,d;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">505</span>;<br><span class="hljs-keyword">int</span> arr[maxn];   <span class="hljs-comment">//记录每个城市的援兵数</span><br><span class="hljs-keyword">int</span> dismap[maxn][maxn];    <span class="hljs-comment">//储存X-Y的长度</span><br><span class="hljs-keyword">int</span> path[maxn];    <span class="hljs-comment">//前驱节点</span><br><span class="hljs-keyword">int</span> dis[maxn];     <span class="hljs-comment">//最短路径</span><br><span class="hljs-keyword">int</span> cost[maxn];    <span class="hljs-comment">//最大救援队数量</span><br><span class="hljs-keyword">int</span> vis[maxn];     <span class="hljs-comment">//用来记录该点是否已经是最短路径的点</span><br><span class="hljs-keyword">int</span> num[maxn];     <span class="hljs-comment">//最短路径的条数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(path,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(path));<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dis));<br>    <span class="hljs-built_in">memset</span>(cost,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(cost));<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>    <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num));<br>    dis[s]=<span class="hljs-number">0</span>;<br>    cost[s]=arr[s];   <span class="hljs-comment">//此时救援队数量等于出发点的救援队数量</span><br>    num[s]=<span class="hljs-number">1</span>;         <span class="hljs-comment">//一条最短路径</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> maxt =<span class="hljs-number">0x3f</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;dis[i]&lt;maxt)<br>            &#123;<br>                k=i;<br>                maxt=dis[i];<br>            &#125;<br>        &#125;<br>        vis[k]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;dis[j]&gt;dis[k]+dismap[k][j])&#123;<br>                dis[j]=dis[k]+dismap[k][j];<br>                path[j]=k;<br>                num[j]=num[k];   <span class="hljs-comment">//如果能更新，说明产生了新的最短路径，num[i]变为从s到k的路径条数</span><br>                cost[j] = cost[k]+arr[j];  <span class="hljs-comment">//产生了新的最短路径,人数为cost[k]+arr[j]</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vis[j]&amp;&amp;dis[j]==dis[k]+dismap[k][j])&#123; <span class="hljs-comment">//存在新的最短路径</span><br>                num[j]+=num[k];   <span class="hljs-comment">//最短路径条数更新</span><br>                <span class="hljs-comment">//无论援兵量是否能更新，既然已经有了另一条路与当前最短路长度相同</span><br><span class="hljs-comment">//就说明多了一些最短路条数</span><br>                <span class="hljs-keyword">if</span>(cost[j]&lt;cost[k]+arr[j])   <span class="hljs-comment">//援兵量能更新</span><br>                &#123;<br>                    cost[j]=cost[k]+arr[j];<br>                    path[j]=k;<br><br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">print</span>(path[x]);<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d;<br>    <span class="hljs-built_in">memset</span>(arr,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr));<br>    <span class="hljs-built_in">memset</span>(dismap,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dismap));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n ; ++j) &#123;<br>        cin&gt;&gt;arr[j];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> x,y,z;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-comment">//此题是无向图</span><br>        dismap[x][y]=z;<br>        dismap[y][x]=z;<br>    &#125;<br>    <span class="hljs-built_in">dijk</span>(s);<br>    cout&lt;&lt;num[d]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cost[d]&lt;&lt;endl;<span class="hljs-comment">//打印最短路径条数和最大援兵数</span><br>    <span class="hljs-built_in">print</span>(path[d]);<br>    cout&lt;&lt;d&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="相关题目链接："><a href="#相关题目链接：" class="headerlink" title="相关题目链接："></a>相关题目链接：</h2><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://www.luogu.com.cn/problem/P1364">P1364 医院设置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></a>]: “ 样题一：P1364 医院设置”</p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805073643683840">题目详情 - L2-001 紧急救援 (25 分) (pintia.cn)</a> ：样题三：L2-001 紧急救援 (25 分)</p><p><a href="https://www.freesion.com/article/8556971489/">L2-001 紧急救援 (25 分)&amp;&amp;dijkstra - 灰信网（软件开发博客聚合） (freesion.com)</a>：样题三参考资料</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(五)-环形拓扑上利用MPI进行通信</title>
    <link href="/2022/01/01/mpi005/"/>
    <url>/2022/01/01/mpi005/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI学习-五-环形拓扑上利用MPI进行通信"><a href="#MPI学习-五-环形拓扑上利用MPI进行通信" class="headerlink" title="MPI学习(五)-环形拓扑上利用MPI进行通信"></a>MPI学习(五)-环形拓扑上利用MPI进行通信</h1><p>这里，我们演示了一个简单的MPI程序，它使用阻塞通信原语send和receive来进行广播操作：</p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpic++ mpi005.cpp -o mpi005</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>srun -p amd_256 -N 1 -n  4   .&#x2F;mpi005(使用SLURM任务调度系统)</p><p>1个分区，核数为4</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> rank, value, size;<br>MPI_Status status;<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc, &amp;argv);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;rank);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;size);<br><br><span class="hljs-keyword">if</span>(rank == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value );<br><span class="hljs-comment">/*Master node sends out the value*/</span><br><span class="hljs-built_in">MPI_Send</span>(&amp;value, <span class="hljs-number">1</span>, MPI_INT, rank + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD);&#125;<span class="hljs-comment">//</span><br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">/*Slave nodes block on receive the send on the value*/</span><br>        <span class="hljs-comment">//接受上一个进程发送的消息</span><br><span class="hljs-built_in">MPI_Recv</span>(&amp;value, <span class="hljs-number">1</span>, MPI_INT, rank - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,MPI_COMM_WORLD, &amp;status);<br><br><span class="hljs-keyword">if</span>(rank &lt; size<span class="hljs-number">-1</span>)<br>&#123;<br>            <span class="hljs-comment">//向下一个进程发送消息</span><br><span class="hljs-built_in">MPI_Send</span>(&amp;value, <span class="hljs-number">1</span>, MPI_INT, rank + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process %d got %d\n&quot;</span>, rank, value);<br>&#125;<br><span class="hljs-built_in">MPI_Finalize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br><br></code></pre></div></td></tr></table></figure><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//5 5为读入的value值</span><br>process <span class="hljs-number">1</span> got <span class="hljs-number">5</span><br>process <span class="hljs-number">2</span> got <span class="hljs-number">5</span><br>process <span class="hljs-number">3</span> got <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graph-Data Structure</title>
    <link href="/2021/12/22/algorithm002/"/>
    <url>/2021/12/22/algorithm002/</url>
    
    <content type="html"><![CDATA[<h1 id="Graph-Data-Structure"><a href="#Graph-Data-Structure" class="headerlink" title="Graph-Data Structure"></a>Graph-Data Structure</h1><h2 id="1-邻接表的应用"><a href="#1-邻接表的应用" class="headerlink" title="1.邻接表的应用"></a>1.邻接表的应用</h2><h3 id="样题一：L2-025-分而治之-25-分"><a href="#样题一：L2-025-分而治之-25-分" class="headerlink" title="样题一：L2-025 分而治之 (25 分)"></a>样题一：L2-025 分而治之 (25 分)</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">Np v<span class="hljs-selector-attr">[1]</span> v<span class="hljs-selector-attr">[2]</span> ... v<span class="hljs-selector-attr">[Np]</span><br></code></pre></div></td></tr></table></figure><p>其中 <code>Np</code> 是该方案中计划攻下的城市数量，后面的系列 <code>v[i]</code> 是计划攻下的城市编号。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>对每一套方案，如果可行就输出<code>YES</code>，否则输出<code>NO</code>。</p><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v[<span class="hljs-number">10005</span>]; <span class="hljs-comment">//声明邻接表</span><br>    <span class="hljs-keyword">int</span> n,num;<br>    cin&gt;&gt;n&gt;&gt;num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;num ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> start,end;<br>        cin&gt;&gt;start&gt;&gt;end;<br>        <span class="hljs-comment">//创建邻接表</span><br>        v[start].<span class="hljs-built_in">push_back</span>(end); <br>        v[end].<span class="hljs-built_in">push_back</span>(start);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> k;<br>    cin&gt;&gt;k;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;k ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> np;<br>        cin&gt;&gt;np;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> book[<span class="hljs-number">10005</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//每轮炸毁城市初始化</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=np ; ++i) &#123;<br>            <span class="hljs-keyword">int</span> dead;<br>            cin&gt;&gt;dead;<br>            book[dead]=<span class="hljs-number">1</span>; <span class="hljs-comment">//被炸毁的城市标记为1</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=n ; ++l) &#123;<br>            <br>            <span class="hljs-keyword">if</span>(book[l]==<span class="hljs-number">0</span>)<span class="hljs-comment">//没有被炸毁的城市</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;v[l].<span class="hljs-built_in">size</span>() ; ++i) &#123; <span class="hljs-comment">//遍历该城市的邻接表</span><br>                    <br>                    <span class="hljs-keyword">if</span>(book[v[l][i]]==<span class="hljs-number">0</span>) <span class="hljs-comment">//存在着还连通的城市</span><br>                    &#123;<br>                        flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//说明方案不可行</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="程序输入："><a href="#程序输入：" class="headerlink" title="程序输入："></a>程序输入：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">10</span> <span class="hljs-number">11</span><br><span class="hljs-number">8</span> <span class="hljs-number">7</span><br><span class="hljs-number">6</span> <span class="hljs-number">8</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-number">8</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">9</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">10</span><br><span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span><br><span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">NO<br>YES<br>YES<br>NO<br>NO<br></code></pre></div></td></tr></table></figure><h2 id="题目相关链接："><a href="#题目相关链接：" class="headerlink" title="题目相关链接："></a>题目相关链接：</h2><p>[<a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]">https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]</a>: “样例一:L2-025 分而治之 (25 分)”</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS-深度优先搜索</title>
    <link href="/2021/12/21/algorithm001/"/>
    <url>/2021/12/21/algorithm001/</url>
    
    <content type="html"><![CDATA[<h1 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS-深度优先搜索"></a>DFS-深度优先搜索</h1><h2 id="样题1-全排列"><a href="#样题1-全排列" class="headerlink" title="样题1-全排列"></a>样题1-全排列</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>输入一个数n，输出n的全排列</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">int</span> book[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> step)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span>(step==n+<span class="hljs-number">1</span>)  <span class="hljs-comment">//这里表示dfs结束,没有可以排的数字了</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>;  i&lt;=n ; i++) &#123;<br>            cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(book[i]==<span class="hljs-number">0</span>)  <span class="hljs-comment">//说明数字i还没有被使用,可以用来排列</span><br>        &#123;<br>            a[step]=i;<span class="hljs-comment">//排列数字i</span><br>            book[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//标记数字i为已使用</span><br>            <span class="hljs-built_in">dfs</span>(step+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//继续排列没有使用的数字</span><br>            book[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//这里表示dfs调用结束了,意思是数字i已经全部排列完了，但还需要</span><br>            <span class="hljs-comment">//按照顺序将数字i收回，重新排列。</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//dfs函数的开始</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序输入："><a href="#程序输入：" class="headerlink" title="程序输入："></a>程序输入：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><h3 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h2 id="样题二-自然数的拆分问题"><a href="#样题二-自然数的拆分问题" class="headerlink" title="样题二-自然数的拆分问题"></a>样题二-自然数的拆分问题</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。现在给你一个自然数n，要求你求出n的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。</p><h3 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100000</span>]=&#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//输出一种拆分方案</span><br><br>            <span class="hljs-keyword">if</span>(i!=t<span class="hljs-number">-1</span>) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;+&quot;</span>;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;a[i];<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=a[t<span class="hljs-number">-1</span>];i&lt;=n;i++) &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;num)<span class="hljs-comment">//当前数i要大于等于前一位数，且不超过n</span><br>        &#123;<br>            a[t]=i;<span class="hljs-comment">//保存当前拆分的数i</span><br>            n-=i;<span class="hljs-comment">//n减去数i，n的值将继续拆分</span><br>            <span class="hljs-built_in">dfs</span>(n,t+<span class="hljs-number">1</span>);<br>            n+=i;<span class="hljs-comment">//回溯：加上拆分的数，以便产生所有可能的拆分</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;num;<br>    <span class="hljs-built_in">dfs</span>(num,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序输入：-1"><a href="#程序输入：-1" class="headerlink" title="程序输入："></a>程序输入：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure><h3 id="程序输出：-1"><a href="#程序输出：-1" class="headerlink" title="程序输出："></a>程序输出：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">3</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">4</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">5</span><br><span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">4</span><br><span class="hljs-number">1</span>+<span class="hljs-number">3</span>+<span class="hljs-number">3</span><br><span class="hljs-number">1</span>+<span class="hljs-number">6</span><br><span class="hljs-number">2</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span><br><span class="hljs-number">2</span>+<span class="hljs-number">5</span><br><span class="hljs-number">3</span>+<span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><h2 id="样例三：L2-038-病毒溯源-25-分"><a href="#样例三：L2-038-病毒溯源-25-分" class="headerlink" title="样例三：L2-038 病毒溯源 (25 分)"></a>样例三：<strong>L2-038 病毒溯源 (25 分)</strong></h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>病毒容易发生变异。某种病毒可以通过突变产生若干变异的毒株，而这些变异的病毒又可能被诱发突变产生第二代变异，如此继续不断变化。</p><p>现给定一些病毒之间的变异关系，要求你找出其中最长的一条变异链。</p><p>在此假设给出的变异都是由突变引起的，不考虑复杂的基因重组变异问题 —— 即每一种病毒都是由唯一的一种病毒突变而来，并且不存在循环变异的情况。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出一个正整数 <em>N</em>（≤104），即病毒种类的总数。于是我们将所有病毒从 0 到 <em>N</em>−1 进行编号。</p><p>随后 <em>N</em> 行，每行按以下格式描述一种病毒的变异情况：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">k</span> 变异株<span class="hljs-number">1</span> …… 变异株k<br></code></pre></div></td></tr></table></figure><p>其中 <code>k</code> 是该病毒产生的变异毒株的种类数，后面跟着每种变异株的编号。第 <em>i</em> 行对应编号为 <em>i</em> 的病毒（0≤<em>i</em>&lt;<em>N</em>）。题目保证病毒源头有且仅有一个。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先输出从源头开始最长变异链的长度。</p><p>在第二行中输出从源头开始最长的一条变异链，编号间以 1 个空格分隔，行首尾不得有多余空格。如果最长链不唯一，则输出最小序列。</p><p>注：我们称序列 { <em>a</em>1,⋯,<em>a**n</em> } 比序列 { <em>b</em>1,⋯,<em>b**n</em> } “小”，如果存在 1≤<em>k</em>≤<em>n</em> 满足 <em>a**i</em>&#x3D;<em>b**i</em> 对所有 <em>i</em>&lt;<em>k</em> 成立，且 <em>a**k</em>&lt;<em>b**k</em>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">10<br>3 6 4 8<br>0<br>0<br>0<br>2 5 9<br>0<br>1 7<br>1 2<br>0<br>2 3 1结尾无空行<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">4<br>0 4 9 1结尾无空行<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码：-2"><a href="#程序源代码：-2" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; ans, tmp;<br><span class="hljs-keyword">bool</span> a[<span class="hljs-number">10005</span>][<span class="hljs-number">10005</span>];<br><span class="hljs-keyword">bool</span> book[<span class="hljs-number">10005</span>];<br><span class="hljs-keyword">int</span> maxn;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root,<span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(len&gt;maxn)<br>    &#123;<br>        maxn =len;<br>        ans = tmp;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == maxn &amp;&amp; tmp &lt; ans)<br>    &#123;<br>        ans = tmp;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[root][i]) <span class="hljs-comment">//连通</span><br>        &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(i,len+<span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> root=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;k ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> x;<br>            cin&gt;&gt;x;<br>            book[x]=<span class="hljs-literal">true</span>;    <span class="hljs-comment">//用来判断谁是病毒源头，题目给出病毒源头有且仅有一个</span><br>            a[i][x]=<span class="hljs-literal">true</span>;    <span class="hljs-comment">//使用邻接矩阵来储存图，连通为true，否则为false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(book[root]) root++;  <span class="hljs-comment">//寻找病毒源头</span><br>    tmp.<span class="hljs-built_in">push_back</span>(root);<br>    <span class="hljs-built_in">dfs</span>(root,<span class="hljs-number">1</span>); <span class="hljs-comment">//从病毒源头开始dfs</span><br>    cout&lt;&lt;ans.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//输出格式控制</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); i++)&#123;<br>       <span class="hljs-keyword">if</span>(i!=ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>       &#123;<br>           cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>           cout&lt;&lt;ans[i];<br>       &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="样题四：L2-020-功夫传人-25-分"><a href="#样题四：L2-020-功夫传人-25-分" class="headerlink" title="样题四：L2-020 功夫传人 (25 分)"></a>样题四：<strong>L2-020 功夫传人 (25 分)</strong></h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。</p><p>这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第<code>i</code>代传人只能在第<code>i-1</code>代传人中拜1个师傅。我们假设已知祖师爷的功力值为<code>Z</code>，每向下传承一代，就会减弱<code>r%</code>，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。</p><h3 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出3个正整数，分别是：<em>N</em>（≤105）——整个师门的总人数（于是每个人从0到<em>N</em>−1编号，祖师爷的编号为0）；<em>Z</em>——祖师爷的功力值（不一定是整数，但起码是正数）；<em>r</em> ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有<em>N</em>行，第<em>i</em>行（<em>i</em>&#x3D;0,⋯,<em>N</em>−1）描述编号为<em>i</em>的人所传的徒弟，格式为：</p><p><em>K**i</em> ID[1] ID[2] ⋯ ID[<em>K**i</em>]</p><p>其中<em>K**i</em>是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。<em>K**i</em>为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。</p><h3 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过1010。</p><h3 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">10 18.0 1.00<br>3 2 3 5<br>1 9<br>1 4<br>1 7<br>0 7<br>2 6 1<br>1 8<br>0 9<br>0 4<br>0 3结尾无空行<br></code></pre></div></td></tr></table></figure><h3 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">404<br>结尾无空行<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码：-3"><a href="#程序源代码：-3" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; tree[<span class="hljs-number">100000</span>];  <span class="hljs-comment">//用于邻接表建树</span><br><span class="hljs-keyword">int</span> book[<span class="hljs-number">100000</span>];<br><span class="hljs-keyword">double</span> sum;<br><span class="hljs-keyword">double</span> r;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">double</span> power)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(book[index]) <span class="hljs-comment">//是得道者就乘他的倍数 </span><br>    &#123;<br>        sum += power * book[index];<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tree[index].<span class="hljs-built_in">size</span>();i++)  <span class="hljs-comment">//遍历整个树</span><br>    &#123;<br>        <span class="hljs-built_in">dfs</span>(tree[index][i],power*r);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">double</span> z;<br>    cin&gt;&gt;n&gt;&gt;z&gt;&gt;r;<br>    r=(<span class="hljs-number">100</span>-r)/<span class="hljs-number">100.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)   <span class="hljs-comment">//这个弟子是否为得道者</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> power;<br>            cin&gt;&gt;power;<br>            book[i]=power;   <span class="hljs-comment">//记录得道者放大倍数</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k;j++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> id;<br>                cin&gt;&gt;id;<br>                tree[i].<span class="hljs-built_in">push_back</span>(id);      <span class="hljs-comment">//使用邻接表建树</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,z);<br>    cout&lt;&lt;(<span class="hljs-keyword">int</span>)sum&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="题目相关链接："><a href="#题目相关链接：" class="headerlink" title="题目相关链接："></a>题目相关链接：</h2><p>[<a href="https://www.luogu.com.cn/problem/P2404">P2404 自然数的拆分问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>]: “ 样例二-自然数的拆分问题”</p><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652361">题目详情 - L2-038 病毒溯源 (25 分) (pintia.cn)</a></a>]: “ 样例三-L2-038 病毒溯源 (25 分)”</p><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805059118809088">题目详情 - L2-020 功夫传人 (25 分) (pintia.cn)</a></a>]: “ 样例四-L2-020 功夫传人 (25 分)”</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning(一) 一个神经元网络-线性函数</title>
    <link href="/2021/12/09/tensorflow001/"/>
    <url>/2021/12/09/tensorflow001/</url>
    
    <content type="html"><![CDATA[<h1 id="一个神经元的网络-线性函数"><a href="#一个神经元的网络-线性函数" class="headerlink" title="一个神经元的网络(线性函数)"></a>一个神经元的网络(线性函数)</h1><p>线性函数 y &#x3D; 2 * x -1 </p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#构建模型</span><br>model = keras.Sequential([keras.layers.Dense(units=<span class="hljs-number">1</span>,input_shape=[<span class="hljs-number">1</span>])])<br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;sgd&#x27;</span>,loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>)<br><span class="hljs-comment">#准备训练数据</span><br>xs=np.array([-<span class="hljs-number">1.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">4.0</span>], dtype = <span class="hljs-built_in">float</span>)<br>ys=np.array([-<span class="hljs-number">3.0</span>,-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">5.0</span>,<span class="hljs-number">7.0</span>], dtype = <span class="hljs-built_in">float</span>)<br><span class="hljs-comment">#训练模型</span><br>model.fit(xs,ys,epochs=<span class="hljs-number">500</span>)<br></code></pre></div></td></tr></table></figure><h2 id="训练模型过程-截取"><a href="#训练模型过程-截取" class="headerlink" title="训练模型过程(截取)"></a>训练模型过程(截取)</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">Epoch <span class="hljs-number">1</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 388ms/step - loss: <span class="hljs-number">3.4976</span><br>Epoch <span class="hljs-number">2</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">2.9127</span><br>Epoch <span class="hljs-number">3</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">2.4493</span><br>Epoch <span class="hljs-number">4</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">2.0814</span><br>Epoch <span class="hljs-number">5</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.7888</span><br>Epoch <span class="hljs-number">6</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.5555</span><br>Epoch <span class="hljs-number">7</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.3689</span><br>Epoch <span class="hljs-number">8</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.2191</span><br>Epoch <span class="hljs-number">9</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">1.0983</span><br>Epoch <span class="hljs-number">10</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.0005</span><br>Epoch <span class="hljs-number">11</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">0.9207</span><br>Epoch <span class="hljs-number">12</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 2ms/step - loss: <span class="hljs-number">0.8551</span><br>Epoch <span class="hljs-number">13</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 5ms/step - loss: <span class="hljs-number">0.8009</span><br></code></pre></div></td></tr></table></figure><h2 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#使用模型(输入)</span><br><span class="hljs-built_in">print</span>(model.predict([<span class="hljs-number">2021</span>]))<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#输出</span><br>[[<span class="hljs-number">4036.6035</span>]]<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#输入</span><br>model.predict([<span class="hljs-number">10.0</span>])<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#输出</span><br>array([[<span class="hljs-number">18.984968</span>]], dtype=float32)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tensorflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(四)-广播、散播、收集、归约和全归约的MPI语法</title>
    <link href="/2021/11/27/mpi004/"/>
    <url>/2021/11/27/mpi004/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-广播、散播、收集、归约和全归约的MPI语法"><a href="#MPI-广播、散播、收集、归约和全归约的MPI语法" class="headerlink" title="MPI-广播、散播、收集、归约和全归约的MPI语法"></a>MPI-广播、散播、收集、归约和全归约的MPI语法</h1><h2 id="广播：MPI-Bcast"><a href="#广播：MPI-Bcast" class="headerlink" title="广播：MPI_Bcast"></a>广播：MPI_Bcast</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Bcast</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *buffer, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> root, MPI_Comm comm)</span></span><br><span class="hljs-function"><span class="hljs-comment">//int root 广播数据的根进程的标识号(整型)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi001.png"></p><h2 id="散播：MPI-Scatter"><a href="#散播：MPI-Scatter" class="headerlink" title="散播：MPI_Scatter"></a>散播：MPI_Scatter</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Scatter</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">int</span> sendcount, MPI_Datatype sendtype, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> root, MPI_Comm comm)</span></span><br><span class="hljs-function"><span class="hljs-comment">//void *sendbuf 发送消息缓冲区的起始地址(可选数据类型)</span></span><br><span class="hljs-function"><span class="hljs-comment">//void *recvbuf 接收消息缓冲区的起始地址(可选数据类型)</span></span><br><span class="hljs-function"></span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi002.png"></p><h2 id="收集：MPI-Gather"><a href="#收集：MPI-Gather" class="headerlink" title="收集：MPI_Gather"></a>收集：MPI_Gather</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Gather</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">int</span> sendcount, MPI_Datatype sendtype, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> recvcount, MPI_Datatype recvtype, <span class="hljs-keyword">int</span> root, MPI_Comm comm)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi003.png"></p><h2 id="归约：MPI-Reduce"><a href="#归约：MPI-Reduce" class="headerlink" title="归约：MPI_Reduce"></a>归约：MPI_Reduce</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Reduce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, MPI_Op op, <span class="hljs-keyword">int</span> root,  MPI_Comm comm)</span></span><br><span class="hljs-function"><span class="hljs-comment">//MPI_Op op  归约操作符(句柄)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi004.png"></p><p><img src="/2021/11/27/mpi004/mpi005.png"></p><h2 id="全归约：MPI-Allreduce"><a href="#全归约：MPI-Allreduce" class="headerlink" title="全归约：MPI_Allreduce"></a>全归约：MPI_Allreduce</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Allreduce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi006.png"></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(三)-通过OpenmMP使用MPI</title>
    <link href="/2021/11/26/mpi003/"/>
    <url>/2021/11/26/mpi003/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-通过OpenMP使用MPI"><a href="#MPI-通过OpenMP使用MPI" class="headerlink" title="MPI-通过OpenMP使用MPI"></a>MPI-通过OpenMP使用MPI</h1><p>OpenMP是另一种为基于共享内存的并行编程提供的应用编程接口。当人们想使用多核处理器时，通常使用OpenMP。下面是一个“Hello World”程序，使用了MPI和OpenMP的API。</p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpic++    -fopenmp  mpi003.cpp -o mpi003</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>srun -p amd_256 -N 2 -n  2   .&#x2F;mpi003(使用SLURM任务调度系统)</p><p>2个分区，核数为2</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;omp.h&gt;</span>  <span class="hljs-comment">//OpenMP所需要的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> myid, numprocs;<br><span class="hljs-keyword">int</span> namelen;<br><span class="hljs-keyword">int</span> thread_id , nthreads;<br><span class="hljs-keyword">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc, &amp;argv);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;myid);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;numprocs);<br><span class="hljs-built_in">MPI_Get_processor_name</span>(processor_name, &amp;namelen);<br>    <span class="hljs-comment">//构造并行区</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel private(thread_id, nthreads) num_threads(8) <span class="hljs-comment">//设置线程数为8</span></span><br>&#123;<br>thread_id = <span class="hljs-built_in">omp_get_thread_num</span>();  <span class="hljs-comment">//获得当前线程的id</span><br>nthreads = <span class="hljs-built_in">omp_get_num_threads</span>();  <span class="hljs-comment">//获得总的线程数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread number %d (on %d) for the MPI process number %d (on %d) [%s]\n&quot;</span>,<br>thread_id, nthreads, myid, numprocs, processor_name);<br>&#125; <br><span class="hljs-built_in">MPI_Finalize</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Thread number <span class="hljs-number">0</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">4</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">3</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">5</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">2</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">6</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">0</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">1</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">2</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">5</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">1</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">7</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">3</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">4</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">6</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">7</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(二)-非阻塞通信程序(无缓冲)</title>
    <link href="/2021/11/26/mpi002/"/>
    <url>/2021/11/26/mpi002/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-非阻塞通信程序-无缓冲"><a href="#MPI-非阻塞通信程序-无缓冲" class="headerlink" title="MPI-非阻塞通信程序(无缓冲)"></a>MPI-非阻塞通信程序(无缓冲)</h1><p>非阻塞通信程序(无缓冲)是由MPI中的Isend和Ireceive来表示的，即异步通信。在这种情况下，发送进程发布一条“发送授权请求”(挂起的消息)的消息，并继续其程序的执行。当接收进程发布一个“同意发送”许可指令时，数据传输就启动了。所有的这些机制都是通过操作系统的信号进行内部管理的。当数据传输完成时，检查状态并指示进程是否可以安全地进行读&#x2F;写数据。                                                                      需要注意的是原语MPI_Wait(&amp;request,&amp;status)等到数据传输完成(或中断后)，使用一个成为status的状态变量来指示数据传输是否已经成功。</p><h2 id="相关的MPI原语"><a href="#相关的MPI原语" class="headerlink" title="相关的MPI原语"></a>相关的MPI原语</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Isend</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> dest, <span class="hljs-keyword">int</span> tag, MPI_comm comm, MPI_Request *req)</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Irecv</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> tag, MPI_Comm comm, MPI_Request *req)</span></span><br></code></pre></div></td></tr></table></figure><p>MPI_Request结构中经常使用的：当*req操作完成时返回 *flag &#x3D; 1,否则返回 0。</p><p>原语MPI_Wait一直等到*req所执行的操作完成。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Wait</span><span class="hljs-params">(MPI_Request *req, MPI_Status *status)</span></span><br></code></pre></div></td></tr></table></figure><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpicc  mpi002.cpp -o mpi002</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>mpirun -np 10   .&#x2F;mpi002(本地提交,采取10个进程)</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> myid, numprocs;<br><span class="hljs-keyword">int</span> tag,source,destination,count;<br><span class="hljs-keyword">int</span> buffer;<br>MPI_Status status;<br>MPI_Request request;<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc,&amp;argv);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;numprocs);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;myid);<br>tag =<span class="hljs-number">2021</span>; <span class="hljs-comment">/* any integer to tag messages */</span><br>source = <span class="hljs-number">0</span>;<br>count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(myid != source )<br>&#123;<br>buffer =<span class="hljs-number">2077</span>;<br><span class="hljs-comment">//其他进程向0号进程发送消息</span><br><span class="hljs-built_in">MPI_Isend</span>(&amp;buffer,count,MPI_INT,source,tag,MPI_COMM_WORLD,&amp;request);<br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor %d send %d to processor %d\n&quot;</span>,myid,buffer,source);<br>&#125;<br><br><span class="hljs-keyword">if</span>(myid == source )<br>&#123;<br><span class="hljs-comment">//0号进程接收来自其他进程的消息</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;numprocs;i++)<br>&#123;<br><span class="hljs-built_in">MPI_Irecv</span>(&amp;buffer,count,MPI_INT,i,tag,MPI_COMM_WORLD,&amp;request);<br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor %d received %d from processor %d \n&quot;</span>,myid,buffer,i);<br>&#125;<br><br>&#125;<br><br><span class="hljs-built_in">MPI_Finalize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processor <span class="hljs-number">2</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">3</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">5</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">6</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">7</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">8</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">9</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">4</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">1</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">1</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">2</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">3</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">4</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">5</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">6</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">7</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">8</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">9</span> <br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(三)-if判断的处理</title>
    <link href="/2021/11/24/AVX003/"/>
    <url>/2021/11/24/AVX003/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX-if判断的处理"><a href="#AVX-if判断的处理" class="headerlink" title="AVX-if判断的处理"></a>AVX-if判断的处理</h1><p>使用AVX指令集对if判断进行处理</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)<br></code></pre></div></td></tr></table></figure><p><strong>Description</strong></p><p>Blend packed double-precision (64-bit) floating-point elements from a and b using mask, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span><br>i := j*<span class="hljs-number">64</span><br>IF mask[i+<span class="hljs-number">63</span>]<br>dst[i+<span class="hljs-number">63</span>:i] := b[i+<span class="hljs-number">63</span>:i]<br>ELSE<br>dst[i+<span class="hljs-number">63</span>:i] := a[i+<span class="hljs-number">63</span>:i]<br>FI<br>ENDFOR<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256d _mm256_cmp_pd (__m256d a, __m256d b, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> imm8)<br></code></pre></div></td></tr></table></figure><p><strong>Description</strong></p><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">CASE</span> (imm8[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]) OF<br><span class="hljs-number">0</span>: OP := _CMP_EQ_OQ<br><span class="hljs-number">1</span>: OP := _CMP_LT_OS<br><span class="hljs-number">2</span>: OP := _CMP_LE_OS<br><span class="hljs-number">3</span>: OP := _CMP_UNORD_Q <br><span class="hljs-number">4</span>: OP := _CMP_NEQ_UQ<br><span class="hljs-number">5</span>: OP := _CMP_NLT_US<br><span class="hljs-number">6</span>: OP := _CMP_NLE_US<br><span class="hljs-number">7</span>: OP := _CMP_ORD_Q<br><span class="hljs-number">8</span>: OP := _CMP_EQ_UQ<br><span class="hljs-number">9</span>: OP := _CMP_NGE_US<br><span class="hljs-number">10</span>: OP := _CMP_NGT_US<br><span class="hljs-number">11</span>: OP := _CMP_FALSE_OQ<br><span class="hljs-number">12</span>: OP := _CMP_NEQ_OQ<br><span class="hljs-number">13</span>: OP := _CMP_GE_OS<br><span class="hljs-number">14</span>: OP := _CMP_GT_OS<br><span class="hljs-number">15</span>: OP := _CMP_TRUE_UQ<br><span class="hljs-number">16</span>: OP := _CMP_EQ_OS<br><span class="hljs-number">17</span>: OP := _CMP_LT_OQ<br><span class="hljs-number">18</span>: OP := _CMP_LE_OQ<br><span class="hljs-number">19</span>: OP := _CMP_UNORD_S<br><span class="hljs-number">20</span>: OP := _CMP_NEQ_US<br><span class="hljs-number">21</span>: OP := _CMP_NLT_UQ<br><span class="hljs-number">22</span>: OP := _CMP_NLE_UQ<br><span class="hljs-number">23</span>: OP := _CMP_ORD_S<br><span class="hljs-number">24</span>: OP := _CMP_EQ_US<br><span class="hljs-number">25</span>: OP := _CMP_NGE_UQ <br><span class="hljs-number">26</span>: OP := _CMP_NGT_UQ <br><span class="hljs-number">27</span>: OP := _CMP_FALSE_OS <br><span class="hljs-number">28</span>: OP := _CMP_NEQ_OS <br><span class="hljs-number">29</span>: OP := _CMP_GE_OQ<br><span class="hljs-number">30</span>: OP := _CMP_GT_OQ<br><span class="hljs-number">31</span>: OP := _CMP_TRUE_US<br>ESAC<br>FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span><br>i := j*<span class="hljs-number">64</span><br>dst[i+<span class="hljs-number">63</span>:i] := ( a[i+<span class="hljs-number">63</span>:i] OP b[i+<span class="hljs-number">63</span>:i] ) ? <span class="hljs-number">0xFFFFFFFFFFFFFFFF</span> : <span class="hljs-number">0</span><br>ENDFOR<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span> d[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>&#125;;     <span class="hljs-comment">//记录原始if判断后的值</span><br><span class="hljs-keyword">double</span> e[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>&#125;;     <span class="hljs-comment">//记录AVX-if判断后的值</span><br><br>__m256d v0;<br>__m256d v1;<br>__m256d v2,v3;<br>__m256d v4;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&gt;b[i])<br>&#123;<br>d[i] = a[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>d[i]=b[i];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span><span class="hljs-number">-4</span>;i+=<span class="hljs-number">4</span>)<br>&#123;<br>v0 = _mm256_loadu_pd(a+i);<br>v1 = _mm256_loadu_pd(b+i);<br>v2=_mm256_add_pd(v0,v1);<br>v3 =_mm256_blendv_pd(v0,v1,_mm256_cmp_pd(v0,v1,_CMP_LE_OQ));<br>_mm256_storeu_pd(e+i,v3);<br><br>&#125;<br>    <br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&gt;b[i])<br>&#123;<br>e[i] = a[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>e[i]=b[i];<br>&#125;<br>&#125;<br>    <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is d.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,d[i]);<br>&#125;<br>    <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is e with AVX.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,e[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is d.<br><span class="hljs-number">2.100000</span><br><span class="hljs-number">3.200000</span><br><span class="hljs-number">6.400000</span><br><span class="hljs-number">8.600000</span><br><span class="hljs-number">5.500000</span><br><span class="hljs-number">9.900000</span><br><span class="hljs-number">7.700000</span><br><span class="hljs-number">8.800000</span><br><span class="hljs-number">6.600000</span><br><span class="hljs-keyword">this</span> is e with AVX.<br><span class="hljs-number">2.100000</span><br><span class="hljs-number">3.200000</span><br><span class="hljs-number">6.400000</span><br><span class="hljs-number">8.600000</span><br><span class="hljs-number">5.500000</span><br><span class="hljs-number">9.900000</span><br><span class="hljs-number">7.700000</span><br><span class="hljs-number">8.800000</span><br><span class="hljs-number">6.600000</span><br></code></pre></div></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p><p>[<a href="https://stackoverflow.com/questions/16988199/how-to-choose-avx-compare-predicate-variants">simd - How to choose AVX compare predicate variants - Stack Overflow</a>]: “Stack Overflow”</p><p>[<a href="https://www.officedaytime.com/simd512e/simdimg/si.php?f=blendvpd">blendvpd (officedaytime.com)</a>]: “_mm256_Blendv_pd()原理解释”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
