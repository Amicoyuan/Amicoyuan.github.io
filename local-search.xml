<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.gcov/"/>
    <url>/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - /root/study/test02/IPCC/SLIC.cpp</title>  <link rel="stylesheet" type="text/css" href="../../../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.gcov/../../../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">root/study/test02/IPCC</a> - SLIC.cpp<span style="font-size: 80%;"> (source / <a href="SLIC.cpp.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">355</td>            <td class="headerCovTableEntry">365</td>            <td class="headerCovTableEntryHi">97.3 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntry">18</td>            <td class="headerCovTableEntryHi">94.4 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.gcov/../../../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.gcov/../../../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // SLIC.cpp: implementation of the SLIC class.</a><span class="lineNum">       2 </span>            : //===========================================================================<span class="lineNum">       3 </span>            : // This code implements the zero parameter superpixel segmentation technique<span class="lineNum">       4 </span>            : // described in:<span class="lineNum">       5 </span>            : //<span class="lineNum">       6 </span>            : //<span class="lineNum">       7 </span>            : //<span class="lineNum">       8 </span>            : // &quot;SLIC Superpixels Compared to State-of-the-art Superpixel Methods&quot;<span class="lineNum">       9 </span>            : //<span class="lineNum">      10 </span>            : // Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua,<span class="lineNum">      11 </span>            : // and Sabine Susstrunk,<span class="lineNum">      12 </span>            : //<span class="lineNum">      13 </span>            : // IEEE TPAMI, Volume 34, Issue 11, Pages 2274-2282, November 2012.<span class="lineNum">      14 </span>            : //<span class="lineNum">      15 </span>            : // https://www.epfl.ch/labs/ivrl/research/slic-superpixels/<span class="lineNum">      16 </span>            : //===========================================================================<span class="lineNum">      17 </span>            : // Copyright (c) 2013 Radhakrishna Achanta.<span class="lineNum">      18 </span>            : //<span class="lineNum">      19 </span>            : // For commercial use please contact the author:<span class="lineNum">      20 </span>            : //<span class="lineNum">      21 </span>            : // Email: firstname.lastname@epfl.ch<span class="lineNum">      22 </span>            : //===========================================================================<span class="lineNum">      23 </span>            : <span class="lineNum">      24 </span>            : #include &lt;stdio.h&gt;<span class="lineNum">      25 </span>            : #include &lt;cfloat&gt;<span class="lineNum">      26 </span>            : #include &lt;cmath&gt;<span class="lineNum">      27 </span>            : #include &lt;iostream&gt;<span class="lineNum">      28 </span>            : #include &lt;fstream&gt;<span class="lineNum">      29 </span>            : #include &quot;SLIC.h&quot;<span class="lineNum">      30 </span>            : #include &lt;chrono&gt;<span class="lineNum">      31 </span>            : <span class="lineNum">      32 </span>            : typedef chrono::high_resolution_clock Clock;<span class="lineNum">      33 </span>            : <span class="lineNum">      34 </span>            : // For superpixels<span class="lineNum">      35 </span>            : const int dx4[4] = {-1,  0,  1,  0};<span class="lineNum">      36 </span>            : const int dy4[4] = { 0, -1,  0,  1};<span class="lineNum">      37 </span>            : //const int dx8[8] = {-1, -1,  0,  1, 1, 1, 0, -1};<span class="lineNum">      38 </span>            : //const int dy8[8] = { 0, -1, -1, -1, 0, 1, 1,  1};<span class="lineNum">      39 </span>            : <span class="lineNum">      40 </span>            : // For supervoxels<span class="lineNum">      41 </span>            : const int dx10[10] = {-1,  0,  1,  0, -1,  1,  1, -1,  0, 0};<span class="lineNum">      42 </span>            : const int dy10[10] = { 0, -1,  0,  1, -1, -1,  1,  1,  0, 0};<span class="lineNum">      43 </span>            : const int dz10[10] = { 0,  0,  0,  0,  0,  0,  0,  0, -1, 1};<span class="lineNum">      44 </span>            : <span class="lineNum">      45 </span>            : //////////////////////////////////////////////////////////////////////<span class="lineNum">      46 </span>            : // Construction/Destruction<a name="47"><span class="lineNum">      47 </span>            : //////////////////////////////////////////////////////////////////////</a><span class="lineNum">      48 </span>            : <span class="lineNum">      49 </span><span class="lineCov">          1 : SLIC::SLIC()</span><span class="lineNum">      50 </span>            : {<span class="lineNum">      51 </span><span class="lineCov">          1 :         m_lvec = NULL;</span><span class="lineNum">      52 </span><span class="lineCov">          1 :         m_avec = NULL;</span><span class="lineNum">      53 </span><span class="lineCov">          1 :         m_bvec = NULL;</span><span class="lineNum">      54 </span>            : <span class="lineNum">      55 </span><span class="lineCov">          1 :         m_lvecvec = NULL;</span><span class="lineNum">      56 </span><span class="lineCov">          1 :         m_avecvec = NULL;</span><span class="lineNum">      57 </span><span class="lineCov">          1 :         m_bvecvec = NULL;</span><a name="58"><span class="lineNum">      58 </span><span class="lineCov">          1 : }</span></a><span class="lineNum">      59 </span>            : <span class="lineNum">      60 </span><span class="lineCov">          1 : SLIC::~SLIC()</span><span class="lineNum">      61 </span>            : {<span class="lineNum">      62 </span><span class="lineCov">          1 :         if(m_lvec) delete [] m_lvec;</span><span class="lineNum">      63 </span><span class="lineCov">          1 :         if(m_avec) delete [] m_avec;</span><span class="lineNum">      64 </span><span class="lineCov">          1 :         if(m_bvec) delete [] m_bvec;</span><span class="lineNum">      65 </span>            : <span class="lineNum">      66 </span>            : <span class="lineNum">      67 </span><span class="lineCov">          1 :         if(m_lvecvec)</span><span class="lineNum">      68 </span>            :         {<span class="lineNum">      69 </span><span class="lineNoCov">          0 :                 for( int d = 0; d &lt; m_depth; d++ ) delete [] m_lvecvec[d];</span><span class="lineNum">      70 </span><span class="lineNoCov">          0 :                 delete [] m_lvecvec;</span><span class="lineNum">      71 </span>            :         }<span class="lineNum">      72 </span><span class="lineCov">          1 :         if(m_avecvec)</span><span class="lineNum">      73 </span>            :         {<span class="lineNum">      74 </span><span class="lineNoCov">          0 :                 for( int d = 0; d &lt; m_depth; d++ ) delete [] m_avecvec[d];</span><span class="lineNum">      75 </span><span class="lineNoCov">          0 :                 delete [] m_avecvec;</span><span class="lineNum">      76 </span>            :         }<span class="lineNum">      77 </span><span class="lineCov">          1 :         if(m_bvecvec)</span><span class="lineNum">      78 </span>            :         {<span class="lineNum">      79 </span><span class="lineNoCov">          0 :                 for( int d = 0; d &lt; m_depth; d++ ) delete [] m_bvecvec[d];</span><span class="lineNum">      80 </span><span class="lineNoCov">          0 :                 delete [] m_bvecvec;</span><span class="lineNum">      81 </span>            :         }<span class="lineNum">      82 </span><span class="lineCov">          1 : }</span><span class="lineNum">      83 </span>            : <span class="lineNum">      84 </span>            : //==============================================================================<span class="lineNum">      85 </span>            : ///     RGB2XYZ<span class="lineNum">      86 </span>            : ///<a name="87"><span class="lineNum">      87 </span>            : /// sRGB (D65 illuninant assumption) to XYZ conversion</a><span class="lineNum">      88 </span>            : //==============================================================================<span class="lineNum">      89 </span><span class="lineCov">   10130902 : void SLIC::RGB2XYZ(</span><span class="lineNum">      90 </span>            :         const int&amp;          sR,<span class="lineNum">      91 </span>            :         const int&amp;          sG,<span class="lineNum">      92 </span>            :         const int&amp;          sB,<span class="lineNum">      93 </span>            :         double&amp;                     X,<span class="lineNum">      94 </span>            :         double&amp;                     Y,<span class="lineNum">      95 </span>            :         double&amp;                     Z)<span class="lineNum">      96 </span>            : {<span class="lineNum">      97 </span><span class="lineCov">   10130902 :         double R = sR/255.0;</span><span class="lineNum">      98 </span><span class="lineCov">   10130902 :         double G = sG/255.0;</span><span class="lineNum">      99 </span><span class="lineCov">   10130902 :         double B = sB/255.0;</span><span class="lineNum">     100 </span>            : <span class="lineNum">     101 </span>            :         double r, g, b;<span class="lineNum">     102 </span>            : <span class="lineNum">     103 </span><span class="lineCov">   10130902 :         if(R &lt;= 0.04045)     r = R/12.92;</span><span class="lineNum">     104 </span><span class="lineCov">    9593232 :         else                            r = pow((R+0.055)/1.055,2.4);</span><span class="lineNum">     105 </span><span class="lineCov">   10130902 :         if(G &lt;= 0.04045)     g = G/12.92;</span><span class="lineNum">     106 </span><span class="lineCov">    9896286 :         else                            g = pow((G+0.055)/1.055,2.4);</span><span class="lineNum">     107 </span><span class="lineCov">   10130902 :         if(B &lt;= 0.04045)     b = B/12.92;</span><span class="lineNum">     108 </span><span class="lineCov">    9712489 :         else                            b = pow((B+0.055)/1.055,2.4);</span><span class="lineNum">     109 </span>            : <span class="lineNum">     110 </span><span class="lineCov">   10130902 :         X = r*0.4124564 + g*0.3575761 + b*0.1804375;</span><span class="lineNum">     111 </span><span class="lineCov">   10130902 :         Y = r*0.2126729 + g*0.7151522 + b*0.0721750;</span><span class="lineNum">     112 </span><span class="lineCov">   10130902 :         Z = r*0.0193339 + g*0.1191920 + b*0.9503041;</span><span class="lineNum">     113 </span><span class="lineCov">   10130902 : }</span><span class="lineNum">     114 </span>            : <span class="lineNum">     115 </span>            : //===========================================================================<a name="116"><span class="lineNum">     116 </span>            : ///     RGB2LAB</a><span class="lineNum">     117 </span>            : //===========================================================================<span class="lineNum">     118 </span><span class="lineCov">   10130902 : void SLIC::RGB2LAB(const int&amp; sR, const int&amp; sG, const int&amp; sB, double&amp; lval, double&amp; aval, double&amp; bval)</span><span class="lineNum">     119 </span>            : {<span class="lineNum">     120 </span>            :         //------------------------<span class="lineNum">     121 </span>            :         // sRGB to XYZ conversion<span class="lineNum">     122 </span>            :         //------------------------<span class="lineNum">     123 </span>            :         double X, Y, Z;<span class="lineNum">     124 </span><span class="lineCov">   10130902 :         RGB2XYZ(sR, sG, sB, X, Y, Z);</span><span class="lineNum">     125 </span>            : <span class="lineNum">     126 </span>            :         //------------------------<span class="lineNum">     127 </span>            :         // XYZ to LAB conversion<span class="lineNum">     128 </span>            :         //------------------------<span class="lineNum">     129 </span><span class="lineCov">   10130902 :         double epsilon = 0.008856;      //actual CIE standard</span><span class="lineNum">     130 </span><span class="lineCov">   10130902 :         double kappa   = 903.3;         //actual CIE standard</span><span class="lineNum">     131 </span>            : <span class="lineNum">     132 </span><span class="lineCov">   10130902 :         double Xr = 0.950456;   //reference white</span><span class="lineNum">     133 </span><span class="lineCov">   10130902 :         double Yr = 1.0;                //reference white</span><span class="lineNum">     134 </span><span class="lineCov">   10130902 :         double Zr = 1.088754;   //reference white</span><span class="lineNum">     135 </span>            : <span class="lineNum">     136 </span><span class="lineCov">   10130902 :         double xr = X/Xr;</span><span class="lineNum">     137 </span><span class="lineCov">   10130902 :         double yr = Y/Yr;</span><span class="lineNum">     138 </span><span class="lineCov">   10130902 :         double zr = Z/Zr;</span><span class="lineNum">     139 </span>            : <span class="lineNum">     140 </span>            :         double fx, fy, fz;<span class="lineNum">     141 </span><span class="lineCov">   10130902 :         if(xr &gt; epsilon)     fx = pow(xr, 1.0/3.0);</span><span class="lineNum">     142 </span><span class="lineCov">     669542 :         else                            fx = (kappa*xr + 16.0)/116.0;</span><span class="lineNum">     143 </span><span class="lineCov">   10130902 :         if(yr &gt; epsilon)     fy = pow(yr, 1.0/3.0);</span><span class="lineNum">     144 </span><span class="lineCov">     512690 :         else                            fy = (kappa*yr + 16.0)/116.0;</span><span class="lineNum">     145 </span><span class="lineCov">   10130902 :         if(zr &gt; epsilon)     fz = pow(zr, 1.0/3.0);</span><span class="lineNum">     146 </span><span class="lineCov">     766636 :         else                            fz = (kappa*zr + 16.0)/116.0;</span><span class="lineNum">     147 </span>            : <span class="lineNum">     148 </span><span class="lineCov">   10130902 :         lval = 116.0*fy-16.0;</span><span class="lineNum">     149 </span><span class="lineCov">   10130902 :         aval = 500.0*(fx-fy);</span><span class="lineNum">     150 </span><span class="lineCov">   10130902 :         bval = 200.0*(fy-fz);</span><span class="lineNum">     151 </span><span class="lineCov">   10130902 : }</span><span class="lineNum">     152 </span>            : <span class="lineNum">     153 </span>            : //===========================================================================<span class="lineNum">     154 </span>            : ///     DoRGBtoLABConversion<span class="lineNum">     155 </span>            : ///<a name="156"><span class="lineNum">     156 </span>            : ///     For whole image: overlaoded floating point version</a><span class="lineNum">     157 </span>            : //===========================================================================<span class="lineNum">     158 </span><span class="lineCov">          1 : void SLIC::DoRGBtoLABConversion(</span><span class="lineNum">     159 </span>            :         const unsigned int*&amp;                ubuff,<span class="lineNum">     160 </span>            :         double*&amp;                                    lvec,<span class="lineNum">     161 </span>            :         double*&amp;                                    avec,<span class="lineNum">     162 </span>            :         double*&amp;                                    bvec)<span class="lineNum">     163 </span>            : {<span class="lineNum">     164 </span><span class="lineCov">          1 :         int sz = m_width*m_height;</span><span class="lineNum">     165 </span><span class="lineCov">          1 :         lvec = new double[sz];</span><span class="lineNum">     166 </span><span class="lineCov">          1 :         avec = new double[sz];</span><span class="lineNum">     167 </span><span class="lineCov">          1 :         bvec = new double[sz];</span><span class="lineNum">     168 </span>            : <span class="lineNum">     169 </span><span class="lineCov">   10130903 :         for( int j = 0; j &lt; sz; j++ )</span><span class="lineNum">     170 </span>            :         {<span class="lineNum">     171 </span><span class="lineCov">   10130902 :                 int r = (ubuff[j] &gt;&gt; 16) &amp; 0xFF;</span><span class="lineNum">     172 </span><span class="lineCov">   10130902 :                 int g = (ubuff[j] &gt;&gt;  8) &amp; 0xFF;</span><span class="lineNum">     173 </span><span class="lineCov">   10130902 :                 int b = (ubuff[j]      ) &amp; 0xFF;</span><span class="lineNum">     174 </span>            : <span class="lineNum">     175 </span><span class="lineCov">   10130902 :                 RGB2LAB( r, g, b, lvec[j], avec[j], bvec[j] );</span><span class="lineNum">     176 </span>            :         }<span class="lineNum">     177 </span><span class="lineCov">          1 : }</span><span class="lineNum">     178 </span>            : <span class="lineNum">     179 </span>            : //==============================================================================<a name="180"><span class="lineNum">     180 </span>            : ///     DetectLabEdges</a><span class="lineNum">     181 </span>            : //==============================================================================<span class="lineNum">     182 </span><span class="lineCov">          1 : void SLIC::DetectLabEdges(</span><span class="lineNum">     183 </span>            :         const double*                           lvec,<span class="lineNum">     184 </span>            :         const double*                           avec,<span class="lineNum">     185 </span>            :         const double*                           bvec,<span class="lineNum">     186 </span>            :         const int&amp;                                  width,<span class="lineNum">     187 </span>            :         const int&amp;                                  height,<span class="lineNum">     188 </span>            :         vector&lt;double&gt;&amp;                               edges)<span class="lineNum">     189 </span>            : {<span class="lineNum">     190 </span><span class="lineCov">          1 :         int sz = width*height;</span><span class="lineNum">     191 </span>            : <span class="lineNum">     192 </span><span class="lineCov">          1 :         edges.resize(sz,0);</span><span class="lineNum">     193 </span><span class="lineCov">       3897 :         for( int j = 1; j &lt; height-1; j++ )</span><span class="lineNum">     194 </span>            :         {<span class="lineNum">     195 </span><span class="lineCov">   10121808 :                 for( int k = 1; k &lt; width-1; k++ )</span><span class="lineNum">     196 </span>            :                 {<span class="lineNum">     197 </span><span class="lineCov">   10117912 :                         int i = j*width+k;</span><span class="lineNum">     198 </span>            : <span class="lineNum">     199 </span><span class="lineCov">   20235824 :                         double dx = (lvec[i-1]-lvec[i+1])*(lvec[i-1]-lvec[i+1]) +</span><span class="lineNum">     200 </span><span class="lineCov">   10117912 :                                                 (avec[i-1]-avec[i+1])*(avec[i-1]-avec[i+1]) +</span><span class="lineNum">     201 </span><span class="lineCov">   10117912 :                                                 (bvec[i-1]-bvec[i+1])*(bvec[i-1]-bvec[i+1]);</span><span class="lineNum">     202 </span>            : <span class="lineNum">     203 </span><span class="lineCov">   20235824 :                         double dy = (lvec[i-width]-lvec[i+width])*(lvec[i-width]-lvec[i+width]) +</span><span class="lineNum">     204 </span><span class="lineCov">   10117912 :                                                 (avec[i-width]-avec[i+width])*(avec[i-width]-avec[i+width]) +</span><span class="lineNum">     205 </span><span class="lineCov">   10117912 :                                                 (bvec[i-width]-bvec[i+width])*(bvec[i-width]-bvec[i+width]);</span><span class="lineNum">     206 </span>            : <span class="lineNum">     207 </span>            :                         //edges[i] = (sqrt(dx) + sqrt(dy));<span class="lineNum">     208 </span><span class="lineCov">   10117912 :                         edges[i] = (dx + dy);</span><span class="lineNum">     209 </span>            :                 }<span class="lineNum">     210 </span>            :         }<span class="lineNum">     211 </span><span class="lineCov">          1 : }</span><span class="lineNum">     212 </span>            : <span class="lineNum">     213 </span>            : //===========================================================================<a name="214"><span class="lineNum">     214 </span>            : ///     PerturbSeeds</a><span class="lineNum">     215 </span>            : //===========================================================================<span class="lineNum">     216 </span><span class="lineCov">          1 : void SLIC::PerturbSeeds(</span><span class="lineNum">     217 </span>            :         vector&lt;double&gt;&amp;                               kseedsl,<span class="lineNum">     218 </span>            :         vector&lt;double&gt;&amp;                               kseedsa,<span class="lineNum">     219 </span>            :         vector&lt;double&gt;&amp;                               kseedsb,<span class="lineNum">     220 </span>            :         vector&lt;double&gt;&amp;                               kseedsx,<span class="lineNum">     221 </span>            :         vector&lt;double&gt;&amp;                               kseedsy,<span class="lineNum">     222 </span>            :         const vector&lt;double&gt;&amp;         edges)<span class="lineNum">     223 </span>            : {<span class="lineNum">     224 </span><span class="lineCov">          1 :         const int dx8[8] = {-1, -1,  0,  1, 1, 1, 0, -1};</span><span class="lineNum">     225 </span><span class="lineCov">          1 :         const int dy8[8] = { 0, -1, -1, -1, 0, 1, 1,  1};</span><span class="lineNum">     226 </span>            :         <span class="lineNum">     227 </span><span class="lineCov">          1 :         int numseeds = kseedsl.size();</span><span class="lineNum">     228 </span>            : <span class="lineNum">     229 </span><span class="lineCov">        197 :         for( int n = 0; n &lt; numseeds; n++ )</span><span class="lineNum">     230 </span>            :         {<span class="lineNum">     231 </span><span class="lineCov">        196 :                 int ox = kseedsx[n];//original x</span><span class="lineNum">     232 </span><span class="lineCov">        196 :                 int oy = kseedsy[n];//original y</span><span class="lineNum">     233 </span><span class="lineCov">        196 :                 int oind = oy*m_width + ox;</span><span class="lineNum">     234 </span>            : <span class="lineNum">     235 </span><span class="lineCov">        196 :                 int storeind = oind;</span><span class="lineNum">     236 </span><span class="lineCov">       1764 :                 for( int i = 0; i &lt; 8; i++ )</span><span class="lineNum">     237 </span>            :                 {<span class="lineNum">     238 </span><span class="lineCov">       1568 :                         int nx = ox+dx8[i];//new x</span><span class="lineNum">     239 </span><span class="lineCov">       1568 :                         int ny = oy+dy8[i];//new y</span><span class="lineNum">     240 </span>            : <span class="lineNum">     241 </span><span class="lineCov">       1568 :                         if( nx &gt;= 0 &amp;&amp; nx &lt; m_width &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m_height)</span><span class="lineNum">     242 </span>            :                         {<span class="lineNum">     243 </span><span class="lineCov">       1568 :                                 int nind = ny*m_width + nx;</span><span class="lineNum">     244 </span><span class="lineCov">       1568 :                                 if( edges[nind] &lt; edges[storeind])</span><span class="lineNum">     245 </span>            :                                 {<span class="lineNum">     246 </span><span class="lineCov">        259 :                                         storeind = nind;</span><span class="lineNum">     247 </span>            :                                 }<span class="lineNum">     248 </span>            :                         }<span class="lineNum">     249 </span>            :                 }<span class="lineNum">     250 </span><span class="lineCov">        196 :                 if(storeind != oind)</span><span class="lineNum">     251 </span>            :                 {<span class="lineNum">     252 </span><span class="lineCov">        138 :                         kseedsx[n] = storeind%m_width;</span><span class="lineNum">     253 </span><span class="lineCov">        138 :                         kseedsy[n] = storeind/m_width;</span><span class="lineNum">     254 </span><span class="lineCov">        138 :                         kseedsl[n] = m_lvec[storeind];</span><span class="lineNum">     255 </span><span class="lineCov">        138 :                         kseedsa[n] = m_avec[storeind];</span><span class="lineNum">     256 </span><span class="lineCov">        138 :                         kseedsb[n] = m_bvec[storeind];</span><span class="lineNum">     257 </span>            :                 }<span class="lineNum">     258 </span>            :         }<span class="lineNum">     259 </span><span class="lineCov">          1 : }</span><span class="lineNum">     260 </span>            : <span class="lineNum">     261 </span>            : //===========================================================================<span class="lineNum">     262 </span>            : ///     GetLABXYSeeds_ForGivenK<span class="lineNum">     263 </span>            : ///<a name="264"><span class="lineNum">     264 </span>            : /// The k seed values are taken as uniform spatial pixel samples.</a><span class="lineNum">     265 </span>            : //===========================================================================<span class="lineNum">     266 </span><span class="lineCov">          1 : void SLIC::GetLABXYSeeds_ForGivenK(</span><span class="lineNum">     267 </span>            :         vector&lt;double&gt;&amp;                               kseedsl,<span class="lineNum">     268 </span>            :         vector&lt;double&gt;&amp;                               kseedsa,<span class="lineNum">     269 </span>            :         vector&lt;double&gt;&amp;                               kseedsb,<span class="lineNum">     270 </span>            :         vector&lt;double&gt;&amp;                               kseedsx,<span class="lineNum">     271 </span>            :         vector&lt;double&gt;&amp;                               kseedsy,<span class="lineNum">     272 </span>            :         const int&amp;                                  K,<span class="lineNum">     273 </span>            :         const bool&amp;                                 perturbseeds,<span class="lineNum">     274 </span>            :         const vector&lt;double&gt;&amp;         edgemag)<span class="lineNum">     275 </span>            : {<span class="lineNum">     276 </span><span class="lineCov">          1 :         int sz = m_width*m_height;</span><span class="lineNum">     277 </span><span class="lineCov">          1 :         double step = sqrt(double(sz)/double(K));</span><span class="lineNum">     278 </span><span class="lineCov">          1 :         int T = step;</span><span class="lineNum">     279 </span><span class="lineCov">          1 :         int xoff = step/2;</span><span class="lineNum">     280 </span><span class="lineCov">          1 :         int yoff = step/2;</span><span class="lineNum">     281 </span>            :         <span class="lineNum">     282 </span><span class="lineCov">          1 :         int n(0);int r(0);</span><span class="lineNum">     283 </span><span class="lineCov">         18 :         for( int y = 0; y &lt; m_height; y++ )</span><span class="lineNum">     284 </span>            :         {<span class="lineNum">     285 </span><span class="lineCov">         18 :                 int Y = y*step + yoff;</span><span class="lineNum">     286 </span><span class="lineCov">         18 :                 if( Y &gt; m_height-1 ) break;</span><span class="lineNum">     287 </span>            : <span class="lineNum">     288 </span><span class="lineCov">        213 :                 for( int x = 0; x &lt; m_width; x++ )</span><span class="lineNum">     289 </span>            :                 {<span class="lineNum">     290 </span>            :                         //int X = x*step + xoff;//square grid<span class="lineNum">     291 </span><span class="lineCov">        213 :                         int X = x*step + (xoff&lt;&lt;(r&amp;0x1));//hex grid</span><span class="lineNum">     292 </span><span class="lineCov">        213 :                         if(X &gt; m_width-1) break;</span><span class="lineNum">     293 </span>            : <span class="lineNum">     294 </span><span class="lineCov">        196 :                         int i = Y*m_width + X;</span><span class="lineNum">     295 </span>            : <span class="lineNum">     296 </span>            :                         //_ASSERT(n &lt; K);<span class="lineNum">     297 </span>            :                         <span class="lineNum">     298 </span>            :                         //kseedsl[n] = m_lvec[i];<span class="lineNum">     299 </span>            :                         //kseedsa[n] = m_avec[i];<span class="lineNum">     300 </span>            :                         //kseedsb[n] = m_bvec[i];<span class="lineNum">     301 </span>            :                         //kseedsx[n] = X;<span class="lineNum">     302 </span>            :                         //kseedsy[n] = Y;<span class="lineNum">     303 </span><span class="lineCov">        196 :                         kseedsl.push_back(m_lvec[i]);</span><span class="lineNum">     304 </span><span class="lineCov">        196 :                         kseedsa.push_back(m_avec[i]);</span><span class="lineNum">     305 </span><span class="lineCov">        196 :                         kseedsb.push_back(m_bvec[i]);</span><span class="lineNum">     306 </span><span class="lineCov">        196 :                         kseedsx.push_back(X);</span><span class="lineNum">     307 </span><span class="lineCov">        196 :                         kseedsy.push_back(Y);</span><span class="lineNum">     308 </span><span class="lineCov">        196 :                         n++;</span><span class="lineNum">     309 </span>            :                 }<span class="lineNum">     310 </span><span class="lineCov">         17 :                 r++;</span><span class="lineNum">     311 </span>            :         }<span class="lineNum">     312 </span>            : <span class="lineNum">     313 </span><span class="lineCov">          1 :         if(perturbseeds)</span><span class="lineNum">     314 </span>            :         {<span class="lineNum">     315 </span><span class="lineCov">          1 :                 PerturbSeeds(kseedsl, kseedsa, kseedsb, kseedsx, kseedsy, edgemag);</span><span class="lineNum">     316 </span>            :         }<span class="lineNum">     317 </span><span class="lineCov">          1 : }</span><span class="lineNum">     318 </span>            : <span class="lineNum">     319 </span>            : //===========================================================================<span class="lineNum">     320 </span>            : ///     PerformSuperpixelSegmentation_VariableSandM<span class="lineNum">     321 </span>            : ///<span class="lineNum">     322 </span>            : ///     Magic SLIC - no parameters<span class="lineNum">     323 </span>            : ///<span class="lineNum">     324 </span>            : ///     Performs k mean segmentation. It is fast because it looks locally, not<span class="lineNum">     325 </span>            : /// over the entire image.<span class="lineNum">     326 </span>            : /// This function picks the maximum value of color distance as compact factor<span class="lineNum">     327 </span>            : /// M and maximum pixel distance as grid step size S from each cluster (13 April 2011).<span class="lineNum">     328 </span>            : /// So no need to input a constant value of M and S. There are two clear<span class="lineNum">     329 </span>            : /// advantages:<span class="lineNum">     330 </span>            : ///<span class="lineNum">     331 </span>            : /// [1] The algorithm now better handles both textured and non-textured regions<span class="lineNum">     332 </span>            : /// [2] There is not need to set any parameters!!!<span class="lineNum">     333 </span>            : ///<span class="lineNum">     334 </span>            : /// SLICO (or SLIC Zero) dynamically varies only the compactness factor S,<a name="335"><span class="lineNum">     335 </span>            : /// not the step size S.</a><span class="lineNum">     336 </span>            : //===========================================================================<span class="lineNum">     337 </span><span class="lineCov">          1 : void SLIC::PerformSuperpixelSegmentation_VariableSandM(</span><span class="lineNum">     338 </span>            :         vector&lt;double&gt;&amp;                               kseedsl,<span class="lineNum">     339 </span>            :         vector&lt;double&gt;&amp;                               kseedsa,<span class="lineNum">     340 </span>            :         vector&lt;double&gt;&amp;                               kseedsb,<span class="lineNum">     341 </span>            :         vector&lt;double&gt;&amp;                               kseedsx,<span class="lineNum">     342 </span>            :         vector&lt;double&gt;&amp;                               kseedsy,<span class="lineNum">     343 </span>            :         int*                                            klabels,<span class="lineNum">     344 </span>            :         const int&amp;                                  STEP,<span class="lineNum">     345 </span>            :         const int&amp;                                  NUMITR)<span class="lineNum">     346 </span>            : {<span class="lineNum">     347 </span><span class="lineCov">          1 :         int sz = m_width*m_height;</span><span class="lineNum">     348 </span><span class="lineCov">          1 :         const int numk = kseedsl.size();</span><span class="lineNum">     349 </span>            :         //double cumerr(99999.9);<span class="lineNum">     350 </span><span class="lineCov">          1 :         int numitr(0);</span><span class="lineNum">     351 </span>            : <span class="lineNum">     352 </span>            :         //----------------<span class="lineNum">     353 </span><span class="lineCov">          1 :         int offset = STEP;</span><span class="lineNum">     354 </span><span class="lineCov">          1 :         if(STEP &lt; 10) offset = STEP*1.5;</span><span class="lineNum">     355 </span>            :         //----------------<span class="lineNum">     356 </span>            : <span class="lineNum">     357 </span><span class="lineCov">          1 :         vector&lt;double&gt; sigmal(numk, 0);</span><span class="lineNum">     358 </span><span class="lineCov">          2 :         vector&lt;double&gt; sigmaa(numk, 0);</span><span class="lineNum">     359 </span><span class="lineCov">          2 :         vector&lt;double&gt; sigmab(numk, 0);</span><span class="lineNum">     360 </span><span class="lineCov">          2 :         vector&lt;double&gt; sigmax(numk, 0);</span><span class="lineNum">     361 </span><span class="lineCov">          2 :         vector&lt;double&gt; sigmay(numk, 0);</span><span class="lineNum">     362 </span><span class="lineCov">          2 :         vector&lt;int&gt; clustersize(numk, 0);</span><span class="lineNum">     363 </span><span class="lineCov">          2 :         vector&lt;double&gt; inv(numk, 0);//to store 1/clustersize[k] values</span><span class="lineNum">     364 </span><span class="lineCov">          2 :         vector&lt;double&gt; distxy(sz, DBL_MAX);</span><span class="lineNum">     365 </span><span class="lineCov">          2 :         vector&lt;double&gt; distlab(sz, DBL_MAX);</span><span class="lineNum">     366 </span><span class="lineCov">          2 :         vector&lt;double&gt; distvec(sz, DBL_MAX);</span><span class="lineNum">     367 </span><span class="lineCov">          2 :         vector&lt;double&gt; maxlab(numk, 10*10);//THIS IS THE VARIABLE VALUE OF M, just start with 10</span><span class="lineNum">     368 </span><span class="lineCov">          2 :         vector&lt;double&gt; maxxy(numk, STEP*STEP);//THIS IS THE VARIABLE VALUE OF M, just start with 10</span><span class="lineNum">     369 </span>            : <span class="lineNum">     370 </span><span class="lineCov">          1 :         double invxywt = 1.0/(STEP*STEP);//NOTE: this is different from how usual SLIC/LKM works</span><span class="lineNum">     371 </span>            : <span class="lineNum">     372 </span><span class="lineCov">         12 :         while( numitr &lt; NUMITR )</span><span class="lineNum">     373 </span>            :         {<span class="lineNum">     374 </span>            :                 //------<span class="lineNum">     375 </span>            :                 //cumerr = 0;<span class="lineNum">     376 </span><span class="lineCov">         10 :                 numitr++;</span><span class="lineNum">     377 </span>            :                 //------<span class="lineNum">     378 </span>            : <span class="lineNum">     379 </span><span class="lineCov">         10 :                 distvec.assign(sz, DBL_MAX);</span><span class="lineNum">     380 </span><span class="lineCov">       1970 :                 for( int n = 0; n &lt; numk; n++ )</span><span class="lineNum">     381 </span>            :                 {<span class="lineNum">     382 </span><span class="lineCov">       1960 :                         int y1 = max(0,                 (int)(kseedsy[n]-offset));</span><span class="lineNum">     383 </span><span class="lineCov">       1960 :                         int y2 = min(m_height,  (int)(kseedsy[n]+offset));</span><span class="lineNum">     384 </span><span class="lineCov">       1960 :                         int x1 = max(0,                 (int)(kseedsx[n]-offset));</span><span class="lineNum">     385 </span><span class="lineCov">       1960 :                         int x2 = min(m_width,   (int)(kseedsx[n]+offset));</span><span class="lineNum">     386 </span>            : <span class="lineNum">     387 </span><span class="lineCov">     867855 :                         for( int y = y1; y &lt; y2; y++ )</span><span class="lineNum">     388 </span>            :                         {<span class="lineNum">     389 </span><span class="lineCov">  377486194 :                                 for( int x = x1; x &lt; x2; x++ )</span><span class="lineNum">     390 </span>            :                                 {<span class="lineNum">     391 </span><span class="lineCov">  376620299 :                                         int i = y*m_width + x;</span><span class="lineNum">     392 </span>            :                                         //_ASSERT( y &lt; m_height &amp;&amp; x &lt; m_width &amp;&amp; y &gt;= 0 &amp;&amp; x &gt;= 0 );<span class="lineNum">     393 </span>            : <span class="lineNum">     394 </span><span class="lineCov">  376620299 :                                         double l = m_lvec[i];</span><span class="lineNum">     395 </span><span class="lineCov">  376620299 :                                         double a = m_avec[i];</span><span class="lineNum">     396 </span><span class="lineCov">  376620299 :                                         double b = m_bvec[i];</span><span class="lineNum">     397 </span>            : <span class="lineNum">     398 </span><span class="lineCov">  753240598 :                                         distlab[i] =    (l - kseedsl[n])*(l - kseedsl[n]) +</span><span class="lineNum">     399 </span><span class="lineCov">  753240598 :                                                                         (a - kseedsa[n])*(a - kseedsa[n]) +</span><span class="lineNum">     400 </span><span class="lineCov">  753240598 :                                                                         (b - kseedsb[n])*(b - kseedsb[n]);</span><span class="lineNum">     401 </span>            : <span class="lineNum">     402 </span><span class="lineCov">  753240598 :                                         distxy[i] =             (x - kseedsx[n])*(x - kseedsx[n]) +</span><span class="lineNum">     403 </span><span class="lineCov">  753240598 :                                                                         (y - kseedsy[n])*(y - kseedsy[n]);</span><span class="lineNum">     404 </span>            : <span class="lineNum">     405 </span>            :                                         //------------------------------------------------------------------------<span class="lineNum">     406 </span><span class="lineCov">  376620299 :                                         double dist = distlab[i]/maxlab[n] + distxy[i]*invxywt;//only varying m, prettier superpixels</span><span class="lineNum">     407 </span>            :                                         //double dist = distlab[i]/maxlab[n] + distxy[i]/maxxy[n];//varying both m and S<span class="lineNum">     408 </span>            :                                         //------------------------------------------------------------------------<span class="lineNum">     409 </span>            :                                         <span class="lineNum">     410 </span><span class="lineCov">  376620299 :                                         if( dist &lt; distvec[i] )</span><span class="lineNum">     411 </span>            :                                         {<span class="lineNum">     412 </span><span class="lineCov">  206398438 :                                                 distvec[i] = dist;</span><span class="lineNum">     413 </span><span class="lineCov">  206398438 :                                                 klabels[i]  = n;</span><span class="lineNum">     414 </span>            :                                         }<span class="lineNum">     415 </span>            :                                 }<span class="lineNum">     416 </span>            :                         }<span class="lineNum">     417 </span>            :                 }<span class="lineNum">     418 </span>            :                 //-----------------------------------------------------------------<span class="lineNum">     419 </span>            :                 // Assign the max color distance for a cluster<span class="lineNum">     420 </span>            :                 //-----------------------------------------------------------------<span class="lineNum">     421 </span><span class="lineCov">         10 :                 if(0 == numitr)</span><span class="lineNum">     422 </span>            :                 {<span class="lineNum">     423 </span><span class="lineNoCov">          0 :                         maxlab.assign(numk,1);</span><span class="lineNum">     424 </span><span class="lineNoCov">          0 :                         maxxy.assign(numk,1);</span><span class="lineNum">     425 </span>            :                 }<span class="lineNum">     426 </span><span class="lineCov">  101309030 :                 {for( int i = 0; i &lt; sz; i++ )</span><span class="lineNum">     427 </span>            :                 {<span class="lineNum">     428 </span><span class="lineCov">  101309020 :                         if(maxlab[klabels[i]] &lt; distlab[i]) maxlab[klabels[i]] = distlab[i];</span><span class="lineNum">     429 </span><span class="lineCov">  101309020 :                         if(maxxy[klabels[i]] &lt; distxy[i]) maxxy[klabels[i]] = distxy[i];</span><span class="lineNum">     430 </span>            :                 }}<span class="lineNum">     431 </span>            :                 //-----------------------------------------------------------------<span class="lineNum">     432 </span>            :                 // Recalculate the centroid and store in the seed values<span class="lineNum">     433 </span>            :                 //-----------------------------------------------------------------<span class="lineNum">     434 </span><span class="lineCov">         10 :                 sigmal.assign(numk, 0);</span><span class="lineNum">     435 </span><span class="lineCov">         10 :                 sigmaa.assign(numk, 0);</span><span class="lineNum">     436 </span><span class="lineCov">         10 :                 sigmab.assign(numk, 0);</span><span class="lineNum">     437 </span><span class="lineCov">         10 :                 sigmax.assign(numk, 0);</span><span class="lineNum">     438 </span><span class="lineCov">         10 :                 sigmay.assign(numk, 0);</span><span class="lineNum">     439 </span><span class="lineCov">         10 :                 clustersize.assign(numk, 0);</span><span class="lineNum">     440 </span>            : <span class="lineNum">     441 </span><span class="lineCov">  101309030 :                 for( int j = 0; j &lt; sz; j++ )</span><span class="lineNum">     442 </span>            :                 {<span class="lineNum">     443 </span><span class="lineCov">  101309020 :                         int temp = klabels[j];</span><span class="lineNum">     444 </span>            :                         //_ASSERT(klabels[j] &gt;= 0);<span class="lineNum">     445 </span><span class="lineCov">  101309020 :                         sigmal[klabels[j]] += m_lvec[j];</span><span class="lineNum">     446 </span><span class="lineCov">  101309020 :                         sigmaa[klabels[j]] += m_avec[j];</span><span class="lineNum">     447 </span><span class="lineCov">  101309020 :                         sigmab[klabels[j]] += m_bvec[j];</span><span class="lineNum">     448 </span><span class="lineCov">  101309020 :                         sigmax[klabels[j]] += (j%m_width);</span><span class="lineNum">     449 </span><span class="lineCov">  101309020 :                         sigmay[klabels[j]] += (j/m_width);</span><span class="lineNum">     450 </span>            : <span class="lineNum">     451 </span><span class="lineCov">  101309020 :                         clustersize[klabels[j]]++;</span><span class="lineNum">     452 </span>            :                 }<span class="lineNum">     453 </span>            : <span class="lineNum">     454 </span><span class="lineCov">       1970 :                 {for( int k = 0; k &lt; numk; k++ )</span><span class="lineNum">     455 </span>            :                 {<span class="lineNum">     456 </span>            :                         //_ASSERT(clustersize[k] &gt; 0);<span class="lineNum">     457 </span><span class="lineCov">       1960 :                         if( clustersize[k] &lt;= 0 ) clustersize[k] = 1;</span><span class="lineNum">     458 </span><span class="lineCov">       1960 :                         inv[k] = 1.0/double(clustersize[k]);//computing inverse now to multiply, than divide later</span><span class="lineNum">     459 </span>            :                 }}<span class="lineNum">     460 </span>            :                 <span class="lineNum">     461 </span><span class="lineCov">       1970 :                 {for( int k = 0; k &lt; numk; k++ )</span><span class="lineNum">     462 </span>            :                 {<span class="lineNum">     463 </span><span class="lineCov">       1960 :                         kseedsl[k] = sigmal[k]*inv[k];</span><span class="lineNum">     464 </span><span class="lineCov">       1960 :                         kseedsa[k] = sigmaa[k]*inv[k];</span><span class="lineNum">     465 </span><span class="lineCov">       1960 :                         kseedsb[k] = sigmab[k]*inv[k];</span><span class="lineNum">     466 </span><span class="lineCov">       1960 :                         kseedsx[k] = sigmax[k]*inv[k];</span><span class="lineNum">     467 </span><span class="lineCov">       1960 :                         kseedsy[k] = sigmay[k]*inv[k];</span><span class="lineNum">     468 </span>            :                 }}<span class="lineNum">     469 </span><span class="lineCov">          1 :         }</span><span class="lineNum">     470 </span><span class="lineCov">          1 : }</span><span class="lineNum">     471 </span>            : <span class="lineNum">     472 </span>            : //===========================================================================<span class="lineNum">     473 </span>            : ///     SaveSuperpixelLabels2PGM<span class="lineNum">     474 </span>            : ///<a name="475"><span class="lineNum">     475 </span>            : ///     Save labels to PGM in raster scan order.</a><span class="lineNum">     476 </span>            : //===========================================================================<span class="lineNum">     477 </span><span class="lineCov">          1 : void SLIC::SaveSuperpixelLabels2PPM(</span><span class="lineNum">     478 </span>            :         char*                           filename, <span class="lineNum">     479 </span>            :         int *                           labels, <span class="lineNum">     480 </span>            :         const int                       width, <span class="lineNum">     481 </span>            :         const int                       height)<span class="lineNum">     482 </span>            : {<span class="lineNum">     483 </span>            :     FILE* fp;<span class="lineNum">     484 </span>            :     char header[20];<span class="lineNum">     485 </span>            :  <span class="lineNum">     486 </span><span class="lineCov">          1 :     fp = fopen(filename, &quot;wb&quot;);</span><span class="lineNum">     487 </span>            :  <span class="lineNum">     488 </span>            :     // write the PPM header info, such as type, width, height and maximum<span class="lineNum">     489 </span><span class="lineCov">          1 :     fprintf(fp,&quot;P6\n%d %d\n255\n&quot;, width, height);</span><span class="lineNum">     490 </span>            :  <span class="lineNum">     491 </span>            :     // write the RGB data<span class="lineNum">     492 </span><span class="lineCov">          1 :     unsigned char *rgb = new unsigned char [ (width)*(height)*3 ];</span><span class="lineNum">     493 </span><span class="lineCov">          1 :     int k = 0;</span><span class="lineNum">     494 </span><span class="lineCov">          1 :         unsigned char c = 0;</span><span class="lineNum">     495 </span><span class="lineCov">       3899 :     for ( int i = 0; i &lt; (height); i++ ) {</span><span class="lineNum">     496 </span><span class="lineCov">   10134800 :         for ( int j = 0; j &lt; (width); j++ ) {</span><span class="lineNum">     497 </span><span class="lineCov">   10130902 :                         c = (unsigned char)(labels[k]);</span><span class="lineNum">     498 </span><span class="lineCov">   10130902 :             rgb[i*(width)*3 + j*3 + 2] = labels[k] &gt;&gt; 16 &amp; 0xff;  // r</span><span class="lineNum">     499 </span><span class="lineCov">   10130902 :             rgb[i*(width)*3 + j*3 + 1] = labels[k] &gt;&gt; 8  &amp; 0xff;  // g</span><span class="lineNum">     500 </span><span class="lineCov">   10130902 :             rgb[i*(width)*3 + j*3 + 0] = labels[k]       &amp; 0xff;  // b</span><span class="lineNum">     501 </span>            : <span class="lineNum">     502 </span>            :                         // rgb[i*(width) + j + 0] = c;<span class="lineNum">     503 </span><span class="lineCov">   10130902 :             k++;</span><span class="lineNum">     504 </span>            :         }<span class="lineNum">     505 </span>            :     }<span class="lineNum">     506 </span><span class="lineCov">          1 :     fwrite(rgb, width*height*3, 1, fp);</span><span class="lineNum">     507 </span>            : <span class="lineNum">     508 </span><span class="lineCov">          1 :     delete [] rgb;</span><span class="lineNum">     509 </span>            :  <span class="lineNum">     510 </span><span class="lineCov">          1 :     fclose(fp);</span><span class="lineNum">     511 </span>            : <span class="lineNum">     512 </span><span class="lineCov">          1 : }</span><span class="lineNum">     513 </span>            : <span class="lineNum">     514 </span>            : //===========================================================================<span class="lineNum">     515 </span>            : ///     EnforceLabelConnectivity<span class="lineNum">     516 </span>            : ///<span class="lineNum">     517 </span>            : ///             1. finding an adjacent label for each new component at the start<span class="lineNum">     518 </span>            : ///             2. if a certain component is too small, assigning the previously found<a name="519"><span class="lineNum">     519 </span>            : ///                 adjacent label to this component, and not incrementing the label.</a><span class="lineNum">     520 </span>            : //===========================================================================<span class="lineNum">     521 </span><span class="lineCov">          1 : void SLIC::EnforceLabelConnectivity(</span><span class="lineNum">     522 </span>            :         const int*                                      labels,//input labels that need to be corrected to remove stray labels<span class="lineNum">     523 </span>            :         const int&amp;                                  width,<span class="lineNum">     524 </span>            :         const int&amp;                                  height,<span class="lineNum">     525 </span>            :         int*                                            nlabels,//new labels<span class="lineNum">     526 </span>            :         int&amp;                                                numlabels,//the number of labels changes in the end if segments are removed<span class="lineNum">     527 </span>            :         const int&amp;                                  K) //the number of superpixels desired by the user<span class="lineNum">     528 </span>            : {<span class="lineNum">     529 </span>            : //      const int dx8[8] = {-1, -1,  0,  1, 1, 1, 0, -1};<span class="lineNum">     530 </span>            : //      const int dy8[8] = { 0, -1, -1, -1, 0, 1, 1,  1};<span class="lineNum">     531 </span>            : <span class="lineNum">     532 </span><span class="lineCov">          1 :         const int dx4[4] = {-1,  0,  1,  0};</span><span class="lineNum">     533 </span><span class="lineCov">          1 :         const int dy4[4] = { 0, -1,  0,  1};</span><span class="lineNum">     534 </span>            : <span class="lineNum">     535 </span><span class="lineCov">          1 :         const int sz = width*height;</span><span class="lineNum">     536 </span><span class="lineCov">          1 :         const int SUPSZ = sz/K;</span><span class="lineNum">     537 </span>            :         //nlabels.resize(sz, -1);<span class="lineNum">     538 </span><span class="lineCov">          1 :         for( int i = 0; i &lt; sz; i++ ) nlabels[i] = -1;</span><span class="lineNum">     539 </span><span class="lineCov">          1 :         int label(0);</span><span class="lineNum">     540 </span><span class="lineCov">          1 :         int* xvec = new int[sz];</span><span class="lineNum">     541 </span><span class="lineCov">          1 :         int* yvec = new int[sz];</span><span class="lineNum">     542 </span><span class="lineCov">          1 :         int oindex(0);</span><span class="lineNum">     543 </span><span class="lineCov">          1 :         int adjlabel(0);//adjacent label</span><span class="lineNum">     544 </span><span class="lineCov">       3899 :         for( int j = 0; j &lt; height; j++ )</span><span class="lineNum">     545 </span>            :         {<span class="lineNum">     546 </span><span class="lineCov">   10134800 :                 for( int k = 0; k &lt; width; k++ )</span><span class="lineNum">     547 </span>            :                 {<span class="lineNum">     548 </span><span class="lineCov">   10130902 :                         if( 0 &gt; nlabels[oindex] )</span><span class="lineNum">     549 </span>            :                         {<span class="lineNum">     550 </span><span class="lineCov">        579 :                                 nlabels[oindex] = label;</span><span class="lineNum">     551 </span>            :                                 //--------------------<span class="lineNum">     552 </span>            :                                 // Start a new segment<span class="lineNum">     553 </span>            :                                 //--------------------<span class="lineNum">     554 </span><span class="lineCov">        579 :                                 xvec[0] = k;</span><span class="lineNum">     555 </span><span class="lineCov">        579 :                                 yvec[0] = j;</span><span class="lineNum">     556 </span>            :                                 //-------------------------------------------------------<span class="lineNum">     557 </span>            :                                 // Quickly find an adjacent label for use later if needed<span class="lineNum">     558 </span>            :                                 //-------------------------------------------------------<span class="lineNum">     559 </span><span class="lineCov">       2895 :                                 {for( int n = 0; n &lt; 4; n++ )</span><span class="lineNum">     560 </span>            :                                 {<span class="lineNum">     561 </span><span class="lineCov">       2316 :                                         int x = xvec[0] + dx4[n];</span><span class="lineNum">     562 </span><span class="lineCov">       2316 :                                         int y = yvec[0] + dy4[n];</span><span class="lineNum">     563 </span><span class="lineCov">       2316 :                                         if( (x &gt;= 0 &amp;&amp; x &lt; width) &amp;&amp; (y &gt;= 0 &amp;&amp; y &lt; height) )</span><span class="lineNum">     564 </span>            :                                         {<span class="lineNum">     565 </span><span class="lineCov">       2296 :                                                 int nindex = y*width + x;</span><span class="lineNum">     566 </span><span class="lineCov">       2296 :                                                 if(nlabels[nindex] &gt;= 0) adjlabel = nlabels[nindex];</span><span class="lineNum">     567 </span>            :                                         }<span class="lineNum">     568 </span>            :                                 }}<span class="lineNum">     569 </span>            : <span class="lineNum">     570 </span><span class="lineCov">        579 :                                 int count(1);</span><span class="lineNum">     571 </span><span class="lineCov">   10131481 :                                 for( int c = 0; c &lt; count; c++ )</span><span class="lineNum">     572 </span>            :                                 {<span class="lineNum">     573 </span><span class="lineCov">   50654510 :                                         for( int n = 0; n &lt; 4; n++ )</span><span class="lineNum">     574 </span>            :                                         {<span class="lineNum">     575 </span><span class="lineCov">   40523608 :                                                 int x = xvec[c] + dx4[n];</span><span class="lineNum">     576 </span><span class="lineCov">   40523608 :                                                 int y = yvec[c] + dy4[n];</span><span class="lineNum">     577 </span>            : <span class="lineNum">     578 </span><span class="lineCov">   40523608 :                                                 if( (x &gt;= 0 &amp;&amp; x &lt; width) &amp;&amp; (y &gt;= 0 &amp;&amp; y &lt; height) )</span><span class="lineNum">     579 </span>            :                                                 {<span class="lineNum">     580 </span><span class="lineCov">   40510614 :                                                         int nindex = y*width + x;</span><span class="lineNum">     581 </span>            : <span class="lineNum">     582 </span><span class="lineCov">   40510614 :                                                         if( 0 &gt; nlabels[nindex] &amp;&amp; labels[oindex] == labels[nindex] )</span><span class="lineNum">     583 </span>            :                                                         {<span class="lineNum">     584 </span><span class="lineCov">   10130323 :                                                                 xvec[count] = x;</span><span class="lineNum">     585 </span><span class="lineCov">   10130323 :                                                                 yvec[count] = y;</span><span class="lineNum">     586 </span><span class="lineCov">   10130323 :                                                                 nlabels[nindex] = label;</span><span class="lineNum">     587 </span><span class="lineCov">   10130323 :                                                                 count++;</span><span class="lineNum">     588 </span>            :                                                         }<span class="lineNum">     589 </span>            :                                                 }<span class="lineNum">     590 </span>            : <span class="lineNum">     591 </span>            :                                         }<span class="lineNum">     592 </span>            :                                 }<span class="lineNum">     593 </span>            :                                 //-------------------------------------------------------<span class="lineNum">     594 </span>            :                                 // If segment size is less then a limit, assign an<span class="lineNum">     595 </span>            :                                 // adjacent label found before, and decrement label count.<span class="lineNum">     596 </span>            :                                 //-------------------------------------------------------<span class="lineNum">     597 </span><span class="lineCov">        579 :                                 if(count &lt;= SUPSZ &gt;&gt; 2)</span><span class="lineNum">     598 </span>            :                                 {<span class="lineNum">     599 </span><span class="lineCov">      47277 :                                         for( int c = 0; c &lt; count; c++ )</span><span class="lineNum">     600 </span>            :                                         {<span class="lineNum">     601 </span><span class="lineCov">      46894 :                                                 int ind = yvec[c]*width+xvec[c];</span><span class="lineNum">     602 </span><span class="lineCov">      46894 :                                                 nlabels[ind] = adjlabel;</span><span class="lineNum">     603 </span>            :                                         }<span class="lineNum">     604 </span><span class="lineCov">        383 :                                         label--;</span><span class="lineNum">     605 </span>            :                                 }<span class="lineNum">     606 </span><span class="lineCov">        579 :                                 label++;</span><span class="lineNum">     607 </span>            :                         }<span class="lineNum">     608 </span><span class="lineCov">   10130902 :                         oindex++;</span><span class="lineNum">     609 </span>            :                 }<span class="lineNum">     610 </span>            :         }<span class="lineNum">     611 </span><span class="lineCov">          1 :         numlabels = label;</span><span class="lineNum">     612 </span>            : <span class="lineNum">     613 </span><span class="lineCov">          1 :         if(xvec) delete [] xvec;</span><span class="lineNum">     614 </span><span class="lineCov">          1 :         if(yvec) delete [] yvec;</span><span class="lineNum">     615 </span><span class="lineCov">          1 : }</span><span class="lineNum">     616 </span>            : <span class="lineNum">     617 </span>            : //===========================================================================<span class="lineNum">     618 </span>            : ///     PerformSLICO_ForGivenK<span class="lineNum">     619 </span>            : ///<a name="620"><span class="lineNum">     620 </span>            : /// Zero parameter SLIC algorithm for a given number K of superpixels.</a><span class="lineNum">     621 </span>            : //===========================================================================<span class="lineNum">     622 </span><span class="lineCov">          1 : void SLIC::PerformSLICO_ForGivenK(</span><span class="lineNum">     623 </span>            :         const unsigned int*                     ubuff,<span class="lineNum">     624 </span>            :         const int                                       width,<span class="lineNum">     625 </span>            :         const int                                       height,<span class="lineNum">     626 </span>            :         int*                                            klabels,<span class="lineNum">     627 </span>            :         int&amp;                                                numlabels,<span class="lineNum">     628 </span>            :         const int&amp;                                  K,//required number of superpixels<span class="lineNum">     629 </span>            :         const double&amp;                               m)//weight given to spatial distance<span class="lineNum">     630 </span>            : {<span class="lineNum">     631 </span><span class="lineCov">          1 :         vector&lt;double&gt; kseedsl(0);</span><span class="lineNum">     632 </span><span class="lineCov">          2 :         vector&lt;double&gt; kseedsa(0);</span><span class="lineNum">     633 </span><span class="lineCov">          2 :         vector&lt;double&gt; kseedsb(0);</span><span class="lineNum">     634 </span><span class="lineCov">          2 :         vector&lt;double&gt; kseedsx(0);</span><span class="lineNum">     635 </span><span class="lineCov">          2 :         vector&lt;double&gt; kseedsy(0);</span><span class="lineNum">     636 </span>            : <span class="lineNum">     637 </span>            :         //--------------------------------------------------<span class="lineNum">     638 </span><span class="lineCov">          1 :         m_width  = width;</span><span class="lineNum">     639 </span><span class="lineCov">          1 :         m_height = height;</span><span class="lineNum">     640 </span><span class="lineCov">          1 :         int sz = m_width*m_height;</span><span class="lineNum">     641 </span>            :         //--------------------------------------------------<span class="lineNum">     642 </span>            :         //if(0 == klabels) klabels = new int[sz];<span class="lineNum">     643 </span><span class="lineCov">          1 :         for( int s = 0; s &lt; sz; s++ ) klabels[s] = -1;</span><span class="lineNum">     644 </span>            :         //--------------------------------------------------<span class="lineNum">     645 </span>            :         if(1)//LAB<span class="lineNum">     646 </span>            :         {<span class="lineNum">     647 </span><span class="lineCov">          1 :                 DoRGBtoLABConversion(ubuff, m_lvec, m_avec, m_bvec);</span><span class="lineNum">     648 </span>            :         }<span class="lineNum">     649 </span>            :         else//RGB<span class="lineNum">     650 </span>            :         {<span class="lineNum">     651 </span>            :                 m_lvec = new double[sz]; m_avec = new double[sz]; m_bvec = new double[sz];<span class="lineNum">     652 </span>            :                 for( int i = 0; i &lt; sz; i++ )<span class="lineNum">     653 </span>            :                 {<span class="lineNum">     654 </span>            :                         m_lvec[i] = ubuff[i] &gt;&gt; 16 &amp; 0xff;<span class="lineNum">     655 </span>            :                         m_avec[i] = ubuff[i] &gt;&gt;  8 &amp; 0xff;<span class="lineNum">     656 </span>            :                         m_bvec[i] = ubuff[i]       &amp; 0xff;<span class="lineNum">     657 </span>            :                 }<span class="lineNum">     658 </span>            :         }<span class="lineNum">     659 </span>            :         //--------------------------------------------------<span class="lineNum">     660 </span>            : <span class="lineNum">     661 </span><span class="lineCov">          1 :         bool perturbseeds(true);</span><span class="lineNum">     662 </span><span class="lineCov">          2 :         vector&lt;double&gt; edgemag(0);</span><span class="lineNum">     663 </span><span class="lineCov">          1 :         if(perturbseeds) DetectLabEdges(m_lvec, m_avec, m_bvec, m_width, m_height, edgemag);</span><span class="lineNum">     664 </span><span class="lineCov">          1 :         GetLABXYSeeds_ForGivenK(kseedsl, kseedsa, kseedsb, kseedsx, kseedsy, K, perturbseeds, edgemag);</span><span class="lineNum">     665 </span>            : <span class="lineNum">     666 </span><span class="lineCov">          1 :         int STEP = sqrt(double(sz)/double(K)) + 2.0;//adding a small value in the even the STEP size is too small.</span><span class="lineNum">     667 </span><span class="lineCov">          1 :         PerformSuperpixelSegmentation_VariableSandM(kseedsl,kseedsa,kseedsb,kseedsx,kseedsy,klabels,STEP,10);</span><span class="lineNum">     668 </span><span class="lineCov">          1 :         numlabels = kseedsl.size();</span><span class="lineNum">     669 </span>            : <span class="lineNum">     670 </span><span class="lineCov">          1 :         int* nlabels = new int[sz];</span><span class="lineNum">     671 </span><span class="lineCov">          1 :         EnforceLabelConnectivity(klabels, m_width, m_height, nlabels, numlabels, K);</span><span class="lineNum">     672 </span><span class="lineCov">          1 :         {for(int i = 0; i &lt; sz; i++ ) klabels[i] = nlabels[i];}</span><span class="lineNum">     673 </span><span class="lineCov">          2 :         if(nlabels) delete [] nlabels;</span><span class="lineNum">     674 </span><span class="lineCov">          1 : }</span><span class="lineNum">     675 </span>            : <span class="lineNum">     676 </span>            : //===========================================================================<span class="lineNum">     677 </span>            : /// Load PPM file<span class="lineNum">     678 </span>            : ///<a name="679"><span class="lineNum">     679 </span>            : /// </a><span class="lineNum">     680 </span>            : //===========================================================================<span class="lineNum">     681 </span><span class="lineCov">          1 : void LoadPPM(char* filename, unsigned int** data, int* width, int* height)</span><span class="lineNum">     682 </span>            : {<span class="lineNum">     683 </span>            :     char header[1024];<span class="lineNum">     684 </span><span class="lineCov">          1 :     FILE* fp = NULL;</span><span class="lineNum">     685 </span><span class="lineCov">          1 :     int line = 0;</span><span class="lineNum">     686 </span>            :  <span class="lineNum">     687 </span><span class="lineCov">          1 :     fp = fopen(filename, &quot;rb&quot;);</span><span class="lineNum">     688 </span>            :  <span class="lineNum">     689 </span>            :     // read the image type, such as: P6<span class="lineNum">     690 </span>            :     // skip the comment lines<span class="lineNum">     691 </span><span class="lineCov">          4 :     while (line &lt; 2) {    </span><span class="lineNum">     692 </span><span class="lineCov">          2 :         fgets(header, 1024, fp);</span><span class="lineNum">     693 </span><span class="lineCov">          2 :         if (header[0] != '#') {</span><span class="lineNum">     694 </span><span class="lineCov">          2 :             ++line;</span><span class="lineNum">     695 </span>            :         }<span class="lineNum">     696 </span>            :     }<span class="lineNum">     697 </span>            :     // read width and height<span class="lineNum">     698 </span><span class="lineCov">          1 :     sscanf(header,&quot;%d %d\n&quot;, width, height);</span><span class="lineNum">     699 </span>            :  <span class="lineNum">     700 </span>            :     // read the maximum of pixels<span class="lineNum">     701 </span><span class="lineCov">          1 :     fgets(header, 20, fp);</span><span class="lineNum">     702 </span>            :  <span class="lineNum">     703 </span>            :     // get rgb data<span class="lineNum">     704 </span><span class="lineCov">          1 :     unsigned char *rgb = new unsigned char [ (*width)*(*height)*3 ];</span><span class="lineNum">     705 </span><span class="lineCov">          1 :     fread(rgb, (*width)*(*height)*3, 1, fp);</span><span class="lineNum">     706 </span>            : <span class="lineNum">     707 </span><span class="lineCov">          1 :     *data = new unsigned int [ (*width)*(*height)*4 ];</span><span class="lineNum">     708 </span><span class="lineCov">          1 :     int k = 0;</span><span class="lineNum">     709 </span><span class="lineCov">       3899 :     for ( int i = 0; i &lt; (*height); i++ ) {</span><span class="lineNum">     710 </span><span class="lineCov">   10134800 :         for ( int j = 0; j &lt; (*width); j++ ) {</span><span class="lineNum">     711 </span><span class="lineCov">   10130902 :             unsigned char *p = rgb + i*(*width)*3 + j*3;</span><span class="lineNum">     712 </span>            :                                       // a ( skipped )<span class="lineNum">     713 </span><span class="lineCov">   10130902 :             (*data)[k]  = p[2] &lt;&lt; 16; // r</span><span class="lineNum">     714 </span><span class="lineCov">   10130902 :             (*data)[k] |= p[1] &lt;&lt; 8;  // g</span><span class="lineNum">     715 </span><span class="lineCov">   10130902 :             (*data)[k] |= p[0];       // b</span><span class="lineNum">     716 </span><span class="lineCov">   10130902 :             k++;</span><span class="lineNum">     717 </span>            :         }<span class="lineNum">     718 </span>            :     }<span class="lineNum">     719 </span>            : <span class="lineNum">     720 </span>            :     // ofc, later, you'll have to cleanup<span class="lineNum">     721 </span><span class="lineCov">          1 :     delete [] rgb;</span><span class="lineNum">     722 </span>            :  <span class="lineNum">     723 </span><span class="lineCov">          1 :     fclose(fp);</span><span class="lineNum">     724 </span><span class="lineCov">          1 : }</span><span class="lineNum">     725 </span>            : <span class="lineNum">     726 </span>            : //===========================================================================<span class="lineNum">     727 </span>            : /// Load PPM file<span class="lineNum">     728 </span>            : ///<a name="729"><span class="lineNum">     729 </span>            : /// </a><span class="lineNum">     730 </span>            : //===========================================================================<span class="lineNum">     731 </span><span class="lineCov">          1 : int CheckLabelswithPPM(char* filename, int* labels, int width, int height)</span><span class="lineNum">     732 </span>            : {<span class="lineNum">     733 </span>            :     char header[1024];<span class="lineNum">     734 </span><span class="lineCov">          1 :     FILE* fp = NULL;</span><span class="lineNum">     735 </span><span class="lineCov">          1 :     int line = 0, ground = 0;</span><span class="lineNum">     736 </span>            :  <span class="lineNum">     737 </span><span class="lineCov">          1 :     fp = fopen(filename, &quot;rb&quot;);</span><span class="lineNum">     738 </span>            :  <span class="lineNum">     739 </span>            :     // read the image type, such as: P6<span class="lineNum">     740 </span>            :     // skip the comment lines<span class="lineNum">     741 </span><span class="lineCov">          4 :     while (line &lt; 2) {    </span><span class="lineNum">     742 </span><span class="lineCov">          2 :         fgets(header, 1024, fp);</span><span class="lineNum">     743 </span><span class="lineCov">          2 :         if (header[0] != '#') {</span><span class="lineNum">     744 </span><span class="lineCov">          2 :             ++line;</span><span class="lineNum">     745 </span>            :         }<span class="lineNum">     746 </span>            :     }<span class="lineNum">     747 </span>            :     // read width and height<span class="lineNum">     748 </span><span class="lineCov">          1 :         int w(0);</span><span class="lineNum">     749 </span><span class="lineCov">          1 :         int h(0);</span><span class="lineNum">     750 </span><span class="lineCov">          1 :     sscanf(header,&quot;%d %d\n&quot;, &amp;w, &amp;h);</span><span class="lineNum">     751 </span><span class="lineCov">          1 :         if (w != width || h != height) return -1;</span><span class="lineNum">     752 </span>            :  <span class="lineNum">     753 </span>            :     // read the maximum of pixels<span class="lineNum">     754 </span><span class="lineCov">          1 :     fgets(header, 20, fp);</span><span class="lineNum">     755 </span>            :  <span class="lineNum">     756 </span>            :     // get rgb data<span class="lineNum">     757 </span><span class="lineCov">          1 :     unsigned char *rgb = new unsigned char [ (w)*(h)*3 ];</span><span class="lineNum">     758 </span><span class="lineCov">          1 :     fread(rgb, (w)*(h)*3, 1, fp);</span><span class="lineNum">     759 </span>            : <span class="lineNum">     760 </span><span class="lineCov">          1 :     int num = 0, k = 0;</span><span class="lineNum">     761 </span><span class="lineCov">       3899 :     for ( int i = 0; i &lt; (h); i++ ) {</span><span class="lineNum">     762 </span><span class="lineCov">   10134800 :         for ( int j = 0; j &lt; (w); j++ ) {</span><span class="lineNum">     763 </span><span class="lineCov">   10130902 :             unsigned char *p = rgb + i*(w)*3 + j*3;</span><span class="lineNum">     764 </span>            :                                   // a ( skipped )<span class="lineNum">     765 </span><span class="lineCov">   10130902 :             ground  = p[2] &lt;&lt; 16; // r</span><span class="lineNum">     766 </span><span class="lineCov">   10130902 :             ground |= p[1] &lt;&lt; 8;  // g</span><span class="lineNum">     767 </span><span class="lineCov">   10130902 :             ground |= p[0];       // b</span><span class="lineNum">     768 </span>            :             <span class="lineNum">     769 </span><span class="lineCov">   10130902 :                         if (ground != labels[k])</span><span class="lineNum">     770 </span><span class="lineNoCov">          0 :                                 num++;</span><span class="lineNum">     771 </span>            : <span class="lineNum">     772 </span><span class="lineCov">   10130902 :                         k++;</span><span class="lineNum">     773 </span>            :         }<span class="lineNum">     774 </span>            :     }<span class="lineNum">     775 </span>            : <span class="lineNum">     776 </span>            :     // ofc, later, you'll have to cleanup<span class="lineNum">     777 </span><span class="lineCov">          1 :     delete [] rgb;</span><span class="lineNum">     778 </span>            :  <span class="lineNum">     779 </span><span class="lineCov">          1 :     fclose(fp);</span><span class="lineNum">     780 </span>            : <span class="lineNum">     781 </span><span class="lineCov">          1 :         return num;</span><span class="lineNum">     782 </span>            : }<span class="lineNum">     783 </span>            : <span class="lineNum">     784 </span>            : //===========================================================================<span class="lineNum">     785 </span>            : ///     The main function<a name="786"><span class="lineNum">     786 </span>            : ///</a><span class="lineNum">     787 </span>            : //===========================================================================<span class="lineNum">     788 </span><span class="lineCov">          1 : int main (int argc, char **argv)</span><span class="lineNum">     789 </span>            : {<span class="lineNum">     790 </span><span class="lineCov">          1 :         unsigned int* img = NULL;</span><span class="lineNum">     791 </span><span class="lineCov">          1 :         int width(0);</span><span class="lineNum">     792 </span><span class="lineCov">          1 :         int height(0);</span><span class="lineNum">     793 </span>            : <span class="lineNum">     794 </span><span class="lineCov">          1 :         LoadPPM((char *)&quot;input_image.ppm&quot;, &amp;img, &amp;width, &amp;height);</span><span class="lineNum">     795 </span><span class="lineCov">          1 :         if (width == 0 || height == 0) return -1;</span><span class="lineNum">     796 </span>            : <span class="lineNum">     797 </span><span class="lineCov">          1 :         int sz = width*height;</span><span class="lineNum">     798 </span><span class="lineCov">          1 :         int* labels = new int[sz];</span><span class="lineNum">     799 </span><span class="lineCov">          1 :         int numlabels(0);</span><span class="lineNum">     800 </span><span class="lineCov">          1 :         SLIC slic;</span><span class="lineNum">     801 </span>            :         int m_spcount;<span class="lineNum">     802 </span>            :         double m_compactness;<span class="lineNum">     803 </span><span class="lineCov">          1 :         m_spcount = 200;</span><span class="lineNum">     804 </span><span class="lineCov">          1 :         m_compactness = 10.0;</span><span class="lineNum">     805 </span><span class="lineCov">          1 :     auto startTime = Clock::now();</span><span class="lineNum">     806 </span><span class="lineCov">          1 :         slic.PerformSLICO_ForGivenK(img, width, height, labels, numlabels, m_spcount, m_compactness);//for a given number K of superpixels</span><span class="lineNum">     807 </span><span class="lineCov">          1 :     auto endTime = Clock::now();</span><span class="lineNum">     808 </span><span class="lineCov">          1 :     auto compTime = chrono::duration_cast&lt;chrono::microseconds&gt;(endTime - startTime);</span><span class="lineNum">     809 </span><span class="lineCov">          1 :     cout &lt;&lt;  &quot;Computing time=&quot; &lt;&lt; compTime.count()/1000 &lt;&lt; &quot; ms&quot; &lt;&lt; endl;</span><span class="lineNum">     810 </span>            : <span class="lineNum">     811 </span><span class="lineCov">          1 :         int num = CheckLabelswithPPM((char *)&quot;check.ppm&quot;, labels, width, height);</span><span class="lineNum">     812 </span><span class="lineCov">          1 :         if (num &lt; 0) {</span><span class="lineNum">     813 </span><span class="lineNoCov">          0 :                 cout &lt;&lt;  &quot;The result for labels is different from output_labels.ppm.&quot; &lt;&lt; endl;</span><span class="lineNum">     814 </span>            :         } else {<span class="lineNum">     815 </span><span class="lineCov">          1 :                 cout &lt;&lt;  &quot;There are &quot; &lt;&lt; num &lt;&lt; &quot; points' labels are different from original file.&quot; &lt;&lt; endl;</span><span class="lineNum">     816 </span>            :         }<span class="lineNum">     817 </span>            :         <span class="lineNum">     818 </span><span class="lineCov">          1 :         slic.SaveSuperpixelLabels2PPM((char *)&quot;output_labels.ppm&quot;, labels, width, height);</span><span class="lineNum">     819 </span><span class="lineCov">          1 :         if(labels) delete [] labels;</span><span class="lineNum">     820 </span>            :         <span class="lineNum">     821 </span><span class="lineCov">          1 :         if(img) delete [] img;</span><a name="822"><span class="lineNum">     822 </span>            : </a><span class="lineNum">     823 </span><span class="lineCov">          1 :         return 0;</span><span class="lineNum">     824 </span><span class="lineCov">          3 : }</span></pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.gcov/../../../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func/"/>
    <url>/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - /root/study/test02/IPCC/SLIC.cpp - functions</title>  <link rel="stylesheet" type="text/css" href="../../../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func/../../../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">root/study/test02/IPCC</a> - SLIC.cpp<span style="font-size: 80%;"> (<a href="SLIC.cpp.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">355</td>            <td class="headerCovTableEntry">365</td>            <td class="headerCovTableEntryHi">97.3 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntry">18</td>            <td class="headerCovTableEntryHi">94.4 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func/../../../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func/../../../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func/../../../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="SLIC.cpp.func-sort-c.html"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func/../../../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#822">_GLOBAL__sub_I__ZN4SLICC2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#729">_Z18CheckLabelswithPPMPcPiii</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#822">_Z41__static_initialization_and_destruction_0ii</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#679">_Z7LoadPPMPcPPjPiS2_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#214">_ZN4SLIC12PerturbSeedsERSt6vectorIdSaIdEES3_S3_S3_S3_RKS2_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#180">_ZN4SLIC14DetectLabEdgesEPKdS1_S1_RKiS3_RSt6vectorIdSaIdEE</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#156">_ZN4SLIC20DoRGBtoLABConversionERPKjRPdS4_S4_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#620">_ZN4SLIC22PerformSLICO_ForGivenKEPKjiiPiRiRKiRKd</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#264">_ZN4SLIC23GetLABXYSeeds_ForGivenKERSt6vectorIdSaIdEES3_S3_S3_S3_RKiRKbRKS2_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#519">_ZN4SLIC24EnforceLabelConnectivityEPKiRS0_S2_PiRiS2_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#475">_ZN4SLIC24SaveSuperpixelLabels2PPMEPcPiii</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#335">_ZN4SLIC43PerformSuperpixelSegmentation_VariableSandMERSt6vectorIdSaIdEES3_S3_S3_S3_PiRKiS6_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#116">_ZN4SLIC7RGB2LABERKiS1_S1_RdS2_S2_</a></td>              <td class="coverFnHi">10130902</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#87">_ZN4SLIC7RGB2XYZERKiS1_S1_RdS2_S2_</a></td>              <td class="coverFnHi">10130902</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#47">_ZN4SLICC2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#58">_ZN4SLICD0Ev</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#58">_ZN4SLICD2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#786">main</a></td>              <td class="coverFnHi">1</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func/../../../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func-sort-c/"/>
    <url>/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - /root/study/test02/IPCC/SLIC.cpp - functions</title>  <link rel="stylesheet" type="text/css" href="../../../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func-sort-c/../../../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">root/study/test02/IPCC</a> - SLIC.cpp<span style="font-size: 80%;"> (<a href="SLIC.cpp.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">355</td>            <td class="headerCovTableEntry">365</td>            <td class="headerCovTableEntryHi">97.3 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntry">18</td>            <td class="headerCovTableEntryHi">94.4 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func-sort-c/../../../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func-sort-c/../../../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="SLIC.cpp.func.html"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func-sort-c/../../../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func-sort-c/../../../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#58">_ZN4SLICD0Ev</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#822">_GLOBAL__sub_I__ZN4SLICC2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#729">_Z18CheckLabelswithPPMPcPiii</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#822">_Z41__static_initialization_and_destruction_0ii</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#679">_Z7LoadPPMPcPPjPiS2_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#214">_ZN4SLIC12PerturbSeedsERSt6vectorIdSaIdEES3_S3_S3_S3_RKS2_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#180">_ZN4SLIC14DetectLabEdgesEPKdS1_S1_RKiS3_RSt6vectorIdSaIdEE</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#156">_ZN4SLIC20DoRGBtoLABConversionERPKjRPdS4_S4_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#620">_ZN4SLIC22PerformSLICO_ForGivenKEPKjiiPiRiRKiRKd</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#264">_ZN4SLIC23GetLABXYSeeds_ForGivenKERSt6vectorIdSaIdEES3_S3_S3_S3_RKiRKbRKS2_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#519">_ZN4SLIC24EnforceLabelConnectivityEPKiRS0_S2_PiRiS2_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#475">_ZN4SLIC24SaveSuperpixelLabels2PPMEPcPiii</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#335">_ZN4SLIC43PerformSuperpixelSegmentation_VariableSandMERSt6vectorIdSaIdEES3_S3_S3_S3_PiRKiS6_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#47">_ZN4SLICC2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#58">_ZN4SLICD2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#786">main</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#116">_ZN4SLIC7RGB2LABERKiS1_S1_RdS2_S2_</a></td>              <td class="coverFnHi">10130902</td>            </tr>    <tr>              <td class="coverFn"><a href="SLIC.cpp.gcov.html#87">_ZN4SLIC7RGB2XYZERKiS1_S1_RdS2_S2_</a></td>              <td class="coverFnHi">10130902</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/SLIC.cpp.func-sort-c/../../../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/root/study/test02/IPCC/index/"/>
    <url>/2022/05/08/tool004/root/study/test02/IPCC/index/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - /root/study/test02/IPCC</title>  <link rel="stylesheet" type="text/css" href="../../../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index/../../../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - /root/study/test02/IPCC</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">355</td>            <td class="headerCovTableEntry">365</td>            <td class="headerCovTableEntryHi">97.3 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntry">18</td>            <td class="headerCovTableEntryHi">94.4 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/root/study/test02/IPCC/index/../../../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index/../../../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index/../../../glass.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><a href="index-sort-l.html"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index/../../../updown.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></a></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><a href="index-sort-f.html"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index/../../../updown.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></a></span></td>    </tr>    <tr>      <td class="coverFile"><a href="SLIC.cpp.gcov.html">SLIC.cpp</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index/../../../emerald.png" width="97" height="10" alt="97.3%"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index/../../../snow.png" width="3" height="10" alt="97.3%"></td></tr></table>      </td>      <td class="coverPerHi">97.3&nbsp;%</td>      <td class="coverNumHi">355 / 365</td>      <td class="coverPerHi">94.4&nbsp;%</td>      <td class="coverNumHi">17 / 18</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index/../../../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/"/>
    <url>/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - /root/study/test02/IPCC</title>  <link rel="stylesheet" type="text/css" href="../../../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/../../../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - /root/study/test02/IPCC</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">355</td>            <td class="headerCovTableEntry">365</td>            <td class="headerCovTableEntryHi">97.3 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntry">18</td>            <td class="headerCovTableEntryHi">94.4 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/../../../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/../../../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><a href="index.html"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/../../../updown.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></a></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/../../../glass.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><a href="index-sort-f.html"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/../../../updown.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></a></span></td>    </tr>    <tr>      <td class="coverFile"><a href="SLIC.cpp.gcov.html">SLIC.cpp</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/../../../emerald.png" width="97" height="10" alt="97.3%"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/../../../snow.png" width="3" height="10" alt="97.3%"></td></tr></table>      </td>      <td class="coverPerHi">97.3&nbsp;%</td>      <td class="coverNumHi">355 / 365</td>      <td class="coverPerHi">94.4&nbsp;%</td>      <td class="coverNumHi">17 / 18</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-l/../../../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/"/>
    <url>/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - /root/study/test02/IPCC</title>  <link rel="stylesheet" type="text/css" href="../../../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/../../../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - /root/study/test02/IPCC</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">355</td>            <td class="headerCovTableEntry">365</td>            <td class="headerCovTableEntryHi">97.3 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntry">18</td>            <td class="headerCovTableEntryHi">94.4 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/../../../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/../../../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><a href="index.html"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/../../../updown.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></a></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><a href="index-sort-l.html"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/../../../updown.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></a></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/../../../glass.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></span></td>    </tr>    <tr>      <td class="coverFile"><a href="SLIC.cpp.gcov.html">SLIC.cpp</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/../../../emerald.png" width="97" height="10" alt="97.3%"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/../../../snow.png" width="3" height="10" alt="97.3%"></td></tr></table>      </td>      <td class="coverPerHi">97.3&nbsp;%</td>      <td class="coverNumHi">355 / 365</td>      <td class="coverPerHi">94.4&nbsp;%</td>      <td class="coverNumHi">17 / 18</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/root/study/test02/IPCC/index-sort-f/../../../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/ext/new_allocator.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/ext/new_allocator.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/ext</a> - new_allocator.h<span style="font-size: 80%;"> (source / <a href="new_allocator.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">12</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntryMed">85.7 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">15</td>            <td class="headerCovTableEntryHi">93.3 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Allocator that wraps operator new -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2001-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /** @file ext/new_allocator.h<span class="lineNum">      26 </span>            :  *  This file is a GNU extension to the Standard C++ Library.<span class="lineNum">      27 </span>            :  */<span class="lineNum">      28 </span>            : <span class="lineNum">      29 </span>            : #ifndef _NEW_ALLOCATOR_H<span class="lineNum">      30 </span>            : #define _NEW_ALLOCATOR_H 1<span class="lineNum">      31 </span>            : <span class="lineNum">      32 </span>            : #include &lt;bits/c++config.h&gt;<span class="lineNum">      33 </span>            : #include &lt;new&gt;<span class="lineNum">      34 </span>            : #include &lt;bits/functexcept.h&gt;<span class="lineNum">      35 </span>            : #include &lt;bits/move.h&gt;<span class="lineNum">      36 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      37 </span>            : #include &lt;type_traits&gt;<span class="lineNum">      38 </span>            : #endif<span class="lineNum">      39 </span>            : <span class="lineNum">      40 </span>            : namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)<span class="lineNum">      41 </span>            : {<span class="lineNum">      42 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      43 </span>            : <span class="lineNum">      44 </span>            :   using std::size_t;<span class="lineNum">      45 </span>            :   using std::ptrdiff_t;<span class="lineNum">      46 </span>            : <span class="lineNum">      47 </span>            :   /**<span class="lineNum">      48 </span>            :    *  @brief  An allocator that uses global new, as per [20.4].<span class="lineNum">      49 </span>            :    *  @ingroup allocators<span class="lineNum">      50 </span>            :    *<span class="lineNum">      51 </span>            :    *  This is precisely the allocator defined in the C++ Standard. <span class="lineNum">      52 </span>            :    *    - all allocation calls operator new<span class="lineNum">      53 </span>            :    *    - all deallocation calls operator delete<span class="lineNum">      54 </span>            :    *<span class="lineNum">      55 </span>            :    *  @tparam  _Tp  Type of allocated object.<span class="lineNum">      56 </span>            :    */<span class="lineNum">      57 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      58 </span>            :     class new_allocator<span class="lineNum">      59 </span>            :     {<span class="lineNum">      60 </span>            :     public:<span class="lineNum">      61 </span>            :       typedef size_t     size_type;<span class="lineNum">      62 </span>            :       typedef ptrdiff_t  difference_type;<span class="lineNum">      63 </span>            :       typedef _Tp*       pointer;<span class="lineNum">      64 </span>            :       typedef const _Tp* const_pointer;<span class="lineNum">      65 </span>            :       typedef _Tp&amp;       reference;<span class="lineNum">      66 </span>            :       typedef const _Tp&amp; const_reference;<span class="lineNum">      67 </span>            :       typedef _Tp        value_type;<span class="lineNum">      68 </span>            : <span class="lineNum">      69 </span>            :       template&lt;typename _Tp1&gt;<span class="lineNum">      70 </span>            :         struct rebind<span class="lineNum">      71 </span>            :         { typedef new_allocator&lt;_Tp1&gt; other; };<span class="lineNum">      72 </span>            : <span class="lineNum">      73 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      74 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">      75 </span>            :       // 2103. propagate_on_container_move_assignment<span class="lineNum">      76 </span>            :       typedef std::true_type propagate_on_container_move_assignment;<a name="77"><span class="lineNum">      77 </span>            : #endif</a><span class="lineNum">      78 </span>            : <a name="79"><span class="lineNum">      79 </span><span class="lineCov">         36 :       new_allocator() _GLIBCXX_USE_NOEXCEPT { }</span></a><span class="lineNum">      80 </span>            : <span class="lineNum">      81 </span><span class="lineCov">         36 :       new_allocator(const new_allocator&amp;) _GLIBCXX_USE_NOEXCEPT { }</span><span class="lineNum">      82 </span>            : <span class="lineNum">      83 </span>            :       template&lt;typename _Tp1&gt;<a name="84"><span class="lineNum">      84 </span>            :         new_allocator(const new_allocator&lt;_Tp1&gt;&amp;) _GLIBCXX_USE_NOEXCEPT { }</a><span class="lineNum">      85 </span>            : <span class="lineNum">      86 </span><span class="lineCov">         72 :       ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }</span><span class="lineNum">      87 </span>            : <span class="lineNum">      88 </span>            :       pointer<span class="lineNum">      89 </span>            :       address(reference __x) const _GLIBCXX_NOEXCEPT<span class="lineNum">      90 </span>            :       { return std::__addressof(__x); }<span class="lineNum">      91 </span>            : <span class="lineNum">      92 </span>            :       const_pointer<span class="lineNum">      93 </span>            :       address(const_reference __x) const _GLIBCXX_NOEXCEPT<span class="lineNum">      94 </span>            :       { return std::__addressof(__x); }<span class="lineNum">      95 </span>            : <span class="lineNum">      96 </span>            :       // NB: __n is permitted to be 0.  The C++ standard says nothing<a name="97"><span class="lineNum">      97 </span>            :       // about what the return value is when __n == 0.</a><span class="lineNum">      98 </span>            :       pointer<span class="lineNum">      99 </span><span class="lineCov">        116 :       allocate(size_type __n, const void* = 0)</span><span class="lineNum">     100 </span>            :       { <span class="lineNum">     101 </span><span class="lineCov">        116 :         if (__n &gt; this-&gt;max_size())</span><span class="lineNum">     102 </span><span class="lineNoCov">          0 :           std::__throw_bad_alloc();</span><span class="lineNum">     103 </span>            : <span class="lineNum">     104 </span><span class="lineCov">        116 :         return static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp)));</span><span class="lineNum">     105 </span>            :       }<span class="lineNum">     106 </span>            : <a name="107"><span class="lineNum">     107 </span>            :       // __p is not permitted to be a null pointer.</a><span class="lineNum">     108 </span>            :       void<span class="lineNum">     109 </span><span class="lineCov">        116 :       deallocate(pointer __p, size_type)</span><span class="lineNum">     110 </span><span class="lineCov">        116 :       { ::operator delete(__p); }</span><a name="111"><span class="lineNum">     111 </span>            : </a><span class="lineNum">     112 </span>            :       size_type<span class="lineNum">     113 </span><span class="lineCov">        300 :       max_size() const _GLIBCXX_USE_NOEXCEPT</span><span class="lineNum">     114 </span><span class="lineCov">        300 :       { return size_t(-1) / sizeof(_Tp); }</span><span class="lineNum">     115 </span>            : <span class="lineNum">     116 </span>            : #if __cplusplus &gt;= 201103L<a name="117"><span class="lineNum">     117 </span>            :       template&lt;typename _Up, typename... _Args&gt;</a><span class="lineNum">     118 </span>            :         void<span class="lineNum">     119 </span><span class="lineCov">       1960 :         construct(_Up* __p, _Args&amp;&amp;... __args)</span><span class="lineNum">     120 </span><span class="lineCov">       1960 :         { ::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...); }</span><span class="lineNum">     121 </span>            : <a name="122"><span class="lineNum">     122 </span>            :       template&lt;typename _Up&gt;</a><span class="lineNum">     123 </span>            :         void <span class="lineNum">     124 </span><span class="lineNoCov">          0 :         destroy(_Up* __p) { __p-&gt;~_Up(); }</span><span class="lineNum">     125 </span>            : #else<span class="lineNum">     126 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     127 </span>            :       // 402. wrong new expression in [some_] allocator::construct<span class="lineNum">     128 </span>            :       void <span class="lineNum">     129 </span>            :       construct(pointer __p, const _Tp&amp; __val) <span class="lineNum">     130 </span>            :       { ::new((void *)__p) _Tp(__val); }<span class="lineNum">     131 </span>            : <span class="lineNum">     132 </span>            :       void <span class="lineNum">     133 </span>            :       destroy(pointer __p) { __p-&gt;~_Tp(); }<span class="lineNum">     134 </span>            : #endif<span class="lineNum">     135 </span>            :     };<span class="lineNum">     136 </span>            : <span class="lineNum">     137 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     138 </span>            :     inline bool<span class="lineNum">     139 </span>            :     operator==(const new_allocator&lt;_Tp&gt;&amp;, const new_allocator&lt;_Tp&gt;&amp;)<span class="lineNum">     140 </span>            :     { return true; }<span class="lineNum">     141 </span>            :   <span class="lineNum">     142 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     143 </span>            :     inline bool<span class="lineNum">     144 </span>            :     operator!=(const new_allocator&lt;_Tp&gt;&amp;, const new_allocator&lt;_Tp&gt;&amp;)<span class="lineNum">     145 </span>            :     { return false; }<span class="lineNum">     146 </span>            : <span class="lineNum">     147 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     148 </span>            : } // namespace<span class="lineNum">     149 </span>            : <span class="lineNum">     150 </span>            : #endif</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/ext/new_allocator.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/ext</a> - new_allocator.h<span style="font-size: 80%;"> (<a href="new_allocator.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">12</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntryMed">85.7 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">15</td>            <td class="headerCovTableEntryHi">93.3 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="new_allocator.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#107">_ZN9__gnu_cxx13new_allocatorIdE10deallocateEPdm</a></td>              <td class="coverFnHi">57</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#122">_ZN9__gnu_cxx13new_allocatorIdE7destroyIdEEvPT_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#97">_ZN9__gnu_cxx13new_allocatorIdE8allocateEmPKv</a></td>              <td class="coverFnHi">57</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#117">_ZN9__gnu_cxx13new_allocatorIdE9constructIdIRKdEEEvPT_DpOT0_</a></td>              <td class="coverFnHi">588</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#117">_ZN9__gnu_cxx13new_allocatorIdE9constructIdIdEEEvPT_DpOT0_</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#79">_ZN9__gnu_cxx13new_allocatorIdEC2ERKS1_</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#77">_ZN9__gnu_cxx13new_allocatorIdEC2Ev</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#84">_ZN9__gnu_cxx13new_allocatorIdED2Ev</a></td>              <td class="coverFnHi">34</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#107">_ZN9__gnu_cxx13new_allocatorIiE10deallocateEPim</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#97">_ZN9__gnu_cxx13new_allocatorIiE8allocateEmPKv</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#79">_ZN9__gnu_cxx13new_allocatorIiEC2ERKS1_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#77">_ZN9__gnu_cxx13new_allocatorIiEC2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#84">_ZN9__gnu_cxx13new_allocatorIiED2Ev</a></td>              <td class="coverFnHi">2</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#111">_ZNK9__gnu_cxx13new_allocatorIdE8max_sizeEv</a></td>              <td class="coverFnHi">149</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#111">_ZNK9__gnu_cxx13new_allocatorIiE8max_sizeEv</a></td>              <td class="coverFnHi">1</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/ext/new_allocator.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/ext</a> - new_allocator.h<span style="font-size: 80%;"> (<a href="new_allocator.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">12</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntryMed">85.7 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">15</td>            <td class="headerCovTableEntryHi">93.3 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="new_allocator.h.func.html"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#122">_ZN9__gnu_cxx13new_allocatorIdE7destroyIdEEvPT_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#107">_ZN9__gnu_cxx13new_allocatorIiE10deallocateEPim</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#97">_ZN9__gnu_cxx13new_allocatorIiE8allocateEmPKv</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#79">_ZN9__gnu_cxx13new_allocatorIiEC2ERKS1_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#77">_ZN9__gnu_cxx13new_allocatorIiEC2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#111">_ZNK9__gnu_cxx13new_allocatorIiE8max_sizeEv</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#84">_ZN9__gnu_cxx13new_allocatorIiED2Ev</a></td>              <td class="coverFnHi">2</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#79">_ZN9__gnu_cxx13new_allocatorIdEC2ERKS1_</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#77">_ZN9__gnu_cxx13new_allocatorIdEC2Ev</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#84">_ZN9__gnu_cxx13new_allocatorIdED2Ev</a></td>              <td class="coverFnHi">34</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#107">_ZN9__gnu_cxx13new_allocatorIdE10deallocateEPdm</a></td>              <td class="coverFnHi">57</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#97">_ZN9__gnu_cxx13new_allocatorIdE8allocateEmPKv</a></td>              <td class="coverFnHi">57</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#111">_ZNK9__gnu_cxx13new_allocatorIdE8max_sizeEv</a></td>              <td class="coverFnHi">149</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#117">_ZN9__gnu_cxx13new_allocatorIdE9constructIdIdEEEvPT_DpOT0_</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="new_allocator.h.gcov.html#117">_ZN9__gnu_cxx13new_allocatorIdE9constructIdIRKdEEEvPT_DpOT0_</a></td>              <td class="coverFnHi">588</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/new_allocator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/ext/index/"/>
    <url>/2022/05/08/tool004/4.8.2/ext/index/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/ext</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/index/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - 4.8.2/ext</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">12</td>            <td class="headerCovTableEntry">16</td>            <td class="headerCovTableEntryMed">75.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntryMed">82.4 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/ext/index/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/index/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/ext/index/../glass.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><a href="index-sort-l.html"><img src="/2022/05/08/tool004/4.8.2/ext/index/../updown.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></a></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><a href="index-sort-f.html"><img src="/2022/05/08/tool004/4.8.2/ext/index/../updown.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></a></span></td>    </tr>    <tr>      <td class="coverFile"><a href="alloc_traits.h.gcov.html">alloc_traits.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/ext/index/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>    </tr>    <tr>      <td class="coverFile"><a href="new_allocator.h.gcov.html">new_allocator.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/ext/index/../amber.png" width="86" height="10" alt="85.7%"><img src="/2022/05/08/tool004/4.8.2/ext/index/../snow.png" width="14" height="10" alt="85.7%"></td></tr></table>      </td>      <td class="coverPerMed">85.7&nbsp;%</td>      <td class="coverNumMed">12 / 14</td>      <td class="coverPerHi">93.3&nbsp;%</td>      <td class="coverNumHi">14 / 15</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/index/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/ext/index-sort-l/"/>
    <url>/2022/05/08/tool004/4.8.2/ext/index-sort-l/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/ext</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-l/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - 4.8.2/ext</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">12</td>            <td class="headerCovTableEntry">16</td>            <td class="headerCovTableEntryMed">75.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntryMed">82.4 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-l/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-l/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><a href="index.html"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-l/../updown.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></a></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-l/../glass.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><a href="index-sort-f.html"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-l/../updown.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></a></span></td>    </tr>    <tr>      <td class="coverFile"><a href="alloc_traits.h.gcov.html">alloc_traits.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-l/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>    </tr>    <tr>      <td class="coverFile"><a href="new_allocator.h.gcov.html">new_allocator.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-l/../amber.png" width="86" height="10" alt="85.7%"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-l/../snow.png" width="14" height="10" alt="85.7%"></td></tr></table>      </td>      <td class="coverPerMed">85.7&nbsp;%</td>      <td class="coverNumMed">12 / 14</td>      <td class="coverPerHi">93.3&nbsp;%</td>      <td class="coverNumHi">14 / 15</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-l/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/ext/index-sort-f/"/>
    <url>/2022/05/08/tool004/4.8.2/ext/index-sort-f/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/ext</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-f/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - 4.8.2/ext</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">12</td>            <td class="headerCovTableEntry">16</td>            <td class="headerCovTableEntryMed">75.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntryMed">82.4 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-f/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-f/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><a href="index.html"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-f/../updown.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></a></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><a href="index-sort-l.html"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-f/../updown.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></a></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-f/../glass.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></span></td>    </tr>    <tr>      <td class="coverFile"><a href="alloc_traits.h.gcov.html">alloc_traits.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-f/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>    </tr>    <tr>      <td class="coverFile"><a href="new_allocator.h.gcov.html">new_allocator.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-f/../amber.png" width="86" height="10" alt="85.7%"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-f/../snow.png" width="14" height="10" alt="85.7%"></td></tr></table>      </td>      <td class="coverPerMed">85.7&nbsp;%</td>      <td class="coverNumMed">12 / 14</td>      <td class="coverPerHi">93.3&nbsp;%</td>      <td class="coverNumHi">14 / 15</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/index-sort-f/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/ext/alloc_traits.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/ext</a> - alloc_traits.h<span style="font-size: 80%;"> (source / <a href="alloc_traits.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Allocator traits -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2011-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /** @file ext/alloc_traits.h<span class="lineNum">      26 </span>            :  *  This file is a GNU extension to the Standard C++ Library.<span class="lineNum">      27 </span>            :  */<span class="lineNum">      28 </span>            : <span class="lineNum">      29 </span>            : #ifndef _EXT_ALLOC_TRAITS_H<span class="lineNum">      30 </span>            : #define _EXT_ALLOC_TRAITS_H 1<span class="lineNum">      31 </span>            : <span class="lineNum">      32 </span>            : #pragma GCC system_header<span class="lineNum">      33 </span>            : <span class="lineNum">      34 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      35 </span>            : # include &lt;bits/move.h&gt;<span class="lineNum">      36 </span>            : # include &lt;bits/alloc_traits.h&gt;<span class="lineNum">      37 </span>            : #else<span class="lineNum">      38 </span>            : # include &lt;bits/allocator.h&gt;  // for __alloc_swap<span class="lineNum">      39 </span>            : #endif<span class="lineNum">      40 </span>            : <span class="lineNum">      41 </span>            : namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)<span class="lineNum">      42 </span>            : {<span class="lineNum">      43 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      44 </span>            : <span class="lineNum">      45 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      46 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">      47 </span>            :     struct __allocator_always_compares_equal<span class="lineNum">      48 </span>            :     { static const bool value = false; };<span class="lineNum">      49 </span>            : <span class="lineNum">      50 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">      51 </span>            :     const bool __allocator_always_compares_equal&lt;_Alloc&gt;::value;<span class="lineNum">      52 </span>            : <span class="lineNum">      53 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      54 </span>            :     struct __allocator_always_compares_equal&lt;std::allocator&lt;_Tp&gt;&gt;<span class="lineNum">      55 </span>            :     { static const bool value = true; };<span class="lineNum">      56 </span>            : <span class="lineNum">      57 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      58 </span>            :     const bool __allocator_always_compares_equal&lt;std::allocator&lt;_Tp&gt;&gt;::value;<span class="lineNum">      59 </span>            : <span class="lineNum">      60 </span>            :   template&lt;typename, typename&gt; struct array_allocator;<span class="lineNum">      61 </span>            : <span class="lineNum">      62 </span>            :   template&lt;typename _Tp, typename _Array&gt;<span class="lineNum">      63 </span>            :     struct __allocator_always_compares_equal&lt;array_allocator&lt;_Tp, _Array&gt;&gt;<span class="lineNum">      64 </span>            :     { static const bool value = true; };<span class="lineNum">      65 </span>            : <span class="lineNum">      66 </span>            :   template&lt;typename _Tp, typename _Array&gt;<span class="lineNum">      67 </span>            :     const bool<span class="lineNum">      68 </span>            :     __allocator_always_compares_equal&lt;array_allocator&lt;_Tp, _Array&gt;&gt;::value;<span class="lineNum">      69 </span>            : <span class="lineNum">      70 </span>            :   template&lt;typename&gt; struct bitmap_allocator;<span class="lineNum">      71 </span>            : <span class="lineNum">      72 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      73 </span>            :     struct __allocator_always_compares_equal&lt;bitmap_allocator&lt;_Tp&gt;&gt;<span class="lineNum">      74 </span>            :     { static const bool value = true; };<span class="lineNum">      75 </span>            : <span class="lineNum">      76 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      77 </span>            :     const bool __allocator_always_compares_equal&lt;bitmap_allocator&lt;_Tp&gt;&gt;::value;<span class="lineNum">      78 </span>            : <span class="lineNum">      79 </span>            :   template&lt;typename&gt; struct malloc_allocator;<span class="lineNum">      80 </span>            : <span class="lineNum">      81 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      82 </span>            :     struct __allocator_always_compares_equal&lt;malloc_allocator&lt;_Tp&gt;&gt;<span class="lineNum">      83 </span>            :     { static const bool value = true; };<span class="lineNum">      84 </span>            : <span class="lineNum">      85 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      86 </span>            :     const bool __allocator_always_compares_equal&lt;malloc_allocator&lt;_Tp&gt;&gt;::value;<span class="lineNum">      87 </span>            : <span class="lineNum">      88 </span>            :   template&lt;typename&gt; struct mt_allocator;<span class="lineNum">      89 </span>            : <span class="lineNum">      90 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      91 </span>            :     struct __allocator_always_compares_equal&lt;mt_allocator&lt;_Tp&gt;&gt;<span class="lineNum">      92 </span>            :     { static const bool value = true; };<span class="lineNum">      93 </span>            : <span class="lineNum">      94 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      95 </span>            :     const bool __allocator_always_compares_equal&lt;mt_allocator&lt;_Tp&gt;&gt;::value;<span class="lineNum">      96 </span>            : <span class="lineNum">      97 </span>            :   template&lt;typename&gt; struct new_allocator;<span class="lineNum">      98 </span>            : <span class="lineNum">      99 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     100 </span>            :     struct __allocator_always_compares_equal&lt;new_allocator&lt;_Tp&gt;&gt;<span class="lineNum">     101 </span>            :     { static const bool value = true; };<span class="lineNum">     102 </span>            : <span class="lineNum">     103 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     104 </span>            :     const bool __allocator_always_compares_equal&lt;new_allocator&lt;_Tp&gt;&gt;::value;<span class="lineNum">     105 </span>            : <span class="lineNum">     106 </span>            :   template&lt;typename&gt; struct pool_allocator;<span class="lineNum">     107 </span>            : <span class="lineNum">     108 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     109 </span>            :     struct __allocator_always_compares_equal&lt;pool_allocator&lt;_Tp&gt;&gt;<span class="lineNum">     110 </span>            :     { static const bool value = true; };<span class="lineNum">     111 </span>            : <span class="lineNum">     112 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     113 </span>            :     const bool __allocator_always_compares_equal&lt;pool_allocator&lt;_Tp&gt;&gt;::value;<span class="lineNum">     114 </span>            : #endif<span class="lineNum">     115 </span>            : <span class="lineNum">     116 </span>            : /**<span class="lineNum">     117 </span>            :  * @brief  Uniform interface to C++98 and C++0x allocators.<span class="lineNum">     118 </span>            :  * @ingroup allocators<span class="lineNum">     119 </span>            : */<span class="lineNum">     120 </span>            : template&lt;typename _Alloc&gt;<span class="lineNum">     121 </span>            :   struct __alloc_traits<span class="lineNum">     122 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     123 </span>            :   : std::allocator_traits&lt;_Alloc&gt;<span class="lineNum">     124 </span>            : #endif<span class="lineNum">     125 </span>            :   {<span class="lineNum">     126 </span>            :     typedef _Alloc allocator_type;<span class="lineNum">     127 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     128 </span>            :     typedef std::allocator_traits&lt;_Alloc&gt;           _Base_type;<span class="lineNum">     129 </span>            :     typedef typename _Base_type::value_type         value_type;<span class="lineNum">     130 </span>            :     typedef typename _Base_type::pointer            pointer;<span class="lineNum">     131 </span>            :     typedef typename _Base_type::const_pointer      const_pointer;<span class="lineNum">     132 </span>            :     typedef typename _Base_type::size_type          size_type;<span class="lineNum">     133 </span>            :     typedef typename _Base_type::difference_type    difference_type;<span class="lineNum">     134 </span>            :     // C++0x allocators do not define reference or const_reference<span class="lineNum">     135 </span>            :     typedef value_type&amp;                             reference;<span class="lineNum">     136 </span>            :     typedef const value_type&amp;                       const_reference;<span class="lineNum">     137 </span>            :     using _Base_type::allocate;<span class="lineNum">     138 </span>            :     using _Base_type::deallocate;<span class="lineNum">     139 </span>            :     using _Base_type::construct;<span class="lineNum">     140 </span>            :     using _Base_type::destroy;<span class="lineNum">     141 </span>            :     using _Base_type::max_size;<span class="lineNum">     142 </span>            : <span class="lineNum">     143 </span>            :   private:<span class="lineNum">     144 </span>            :     template&lt;typename _Ptr&gt;<span class="lineNum">     145 </span>            :       struct __is_custom_pointer<span class="lineNum">     146 </span>            :       : std::integral_constant&lt;bool, std::is_same&lt;pointer, _Ptr&gt;::value<span class="lineNum">     147 </span>            :                                      &amp;&amp; !std::is_pointer&lt;_Ptr&gt;::value&gt;<span class="lineNum">     148 </span>            :       { };<span class="lineNum">     149 </span>            : <span class="lineNum">     150 </span>            :   public:<span class="lineNum">     151 </span>            :     // overload construct for non-standard pointer types<span class="lineNum">     152 </span>            :     template&lt;typename _Ptr, typename... _Args&gt;<span class="lineNum">     153 </span>            :       static typename std::enable_if&lt;__is_custom_pointer&lt;_Ptr&gt;::value&gt;::type<span class="lineNum">     154 </span>            :       construct(_Alloc&amp; __a, _Ptr __p, _Args&amp;&amp;... __args)<span class="lineNum">     155 </span>            :       {<span class="lineNum">     156 </span>            :         _Base_type::construct(__a, std::addressof(*__p),<span class="lineNum">     157 </span>            :                               std::forward&lt;_Args&gt;(__args)...);<span class="lineNum">     158 </span>            :       }<span class="lineNum">     159 </span>            : <span class="lineNum">     160 </span>            :     // overload destroy for non-standard pointer types<span class="lineNum">     161 </span>            :     template&lt;typename _Ptr&gt;<span class="lineNum">     162 </span>            :       static typename std::enable_if&lt;__is_custom_pointer&lt;_Ptr&gt;::value&gt;::type<span class="lineNum">     163 </span>            :       destroy(_Alloc&amp; __a, _Ptr __p)<span class="lineNum">     164 </span>            :       { _Base_type::destroy(__a, std::addressof(*__p)); }<span class="lineNum">     165 </span>            : <span class="lineNum">     166 </span>            :     static _Alloc _S_select_on_copy(const _Alloc&amp; __a)<a name="167"><span class="lineNum">     167 </span>            :     { return _Base_type::select_on_container_copy_construction(__a); }</a><span class="lineNum">     168 </span>            : <span class="lineNum">     169 </span><span class="lineNoCov">          0 :     static void _S_on_swap(_Alloc&amp; __a, _Alloc&amp; __b)</span><span class="lineNum">     170 </span><span class="lineNoCov">          0 :     { std::__alloc_on_swap(__a, __b); }</span><span class="lineNum">     171 </span>            : <span class="lineNum">     172 </span>            :     static constexpr bool _S_propagate_on_copy_assign()<span class="lineNum">     173 </span>            :     { return _Base_type::propagate_on_container_copy_assignment::value; }<span class="lineNum">     174 </span>            : <span class="lineNum">     175 </span>            :     static constexpr bool _S_propagate_on_move_assign()<span class="lineNum">     176 </span>            :     { return _Base_type::propagate_on_container_move_assignment::value; }<span class="lineNum">     177 </span>            : <span class="lineNum">     178 </span>            :     static constexpr bool _S_propagate_on_swap()<span class="lineNum">     179 </span>            :     { return _Base_type::propagate_on_container_swap::value; }<span class="lineNum">     180 </span>            : <span class="lineNum">     181 </span>            :     static constexpr bool _S_always_equal()<span class="lineNum">     182 </span>            :     { return __allocator_always_compares_equal&lt;_Alloc&gt;::value; }<span class="lineNum">     183 </span>            : <span class="lineNum">     184 </span>            :     static constexpr bool _S_nothrow_move()<span class="lineNum">     185 </span>            :     { return _S_propagate_on_move_assign() || _S_always_equal(); }<span class="lineNum">     186 </span>            : <span class="lineNum">     187 </span>            :     static constexpr bool _S_nothrow_swap()<span class="lineNum">     188 </span>            :     {<span class="lineNum">     189 </span>            :       using std::swap;<span class="lineNum">     190 </span>            :       return !_S_propagate_on_swap()<span class="lineNum">     191 </span>            :         || noexcept(swap(std::declval&lt;_Alloc&amp;&gt;(), std::declval&lt;_Alloc&amp;&gt;()));<span class="lineNum">     192 </span>            :     }<span class="lineNum">     193 </span>            : <span class="lineNum">     194 </span>            :     template&lt;typename _Tp&gt;<span class="lineNum">     195 </span>            :       struct rebind<span class="lineNum">     196 </span>            :       { typedef typename _Base_type::template rebind_alloc&lt;_Tp&gt; other; };<span class="lineNum">     197 </span>            : #else<span class="lineNum">     198 </span>            : <span class="lineNum">     199 </span>            :     typedef typename _Alloc::pointer                pointer;<span class="lineNum">     200 </span>            :     typedef typename _Alloc::const_pointer          const_pointer;<span class="lineNum">     201 </span>            :     typedef typename _Alloc::value_type             value_type;<span class="lineNum">     202 </span>            :     typedef typename _Alloc::reference              reference;<span class="lineNum">     203 </span>            :     typedef typename _Alloc::const_reference        const_reference;<span class="lineNum">     204 </span>            :     typedef typename _Alloc::size_type              size_type;<span class="lineNum">     205 </span>            :     typedef typename _Alloc::difference_type        difference_type;<span class="lineNum">     206 </span>            : <span class="lineNum">     207 </span>            :     static pointer<span class="lineNum">     208 </span>            :     allocate(_Alloc&amp; __a, size_type __n)<span class="lineNum">     209 </span>            :     { return __a.allocate(__n); }<span class="lineNum">     210 </span>            : <span class="lineNum">     211 </span>            :     static void deallocate(_Alloc&amp; __a, pointer __p, size_type __n)<span class="lineNum">     212 </span>            :     { __a.deallocate(__p, __n); }<span class="lineNum">     213 </span>            : <span class="lineNum">     214 </span>            :     template&lt;typename _Tp&gt;<span class="lineNum">     215 </span>            :       static void construct(_Alloc&amp; __a, pointer __p, const _Tp&amp; __arg)<span class="lineNum">     216 </span>            :       { __a.construct(__p, __arg); }<span class="lineNum">     217 </span>            : <span class="lineNum">     218 </span>            :     static void destroy(_Alloc&amp; __a, pointer __p)<span class="lineNum">     219 </span>            :     { __a.destroy(__p); }<span class="lineNum">     220 </span>            : <span class="lineNum">     221 </span>            :     static size_type max_size(const _Alloc&amp; __a)<span class="lineNum">     222 </span>            :     { return __a.max_size(); }<span class="lineNum">     223 </span>            : <span class="lineNum">     224 </span>            :     static const _Alloc&amp; _S_select_on_copy(const _Alloc&amp; __a) { return __a; }<span class="lineNum">     225 </span>            : <span class="lineNum">     226 </span>            :     static void _S_on_swap(_Alloc&amp; __a, _Alloc&amp; __b)<span class="lineNum">     227 </span>            :     {<span class="lineNum">     228 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     229 </span>            :       // 431. Swapping containers with unequal allocators.<span class="lineNum">     230 </span>            :       std::__alloc_swap&lt;_Alloc&gt;::_S_do_it(__a, __b);<span class="lineNum">     231 </span>            :     }<span class="lineNum">     232 </span>            : <span class="lineNum">     233 </span>            :     template&lt;typename _Tp&gt;<span class="lineNum">     234 </span>            :       struct rebind<span class="lineNum">     235 </span>            :       { typedef typename _Alloc::template rebind&lt;_Tp&gt;::other other; };<span class="lineNum">     236 </span>            : #endif<span class="lineNum">     237 </span>            :   };<span class="lineNum">     238 </span>            : <span class="lineNum">     239 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     240 </span>            : } // namespace std<span class="lineNum">     241 </span>            : <span class="lineNum">     242 </span>            : #endif</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/ext/alloc_traits.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/ext</a> - alloc_traits.h<span style="font-size: 80%;"> (<a href="alloc_traits.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="alloc_traits.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#167">_ZN9__gnu_cxx14__alloc_traitsISaIdEE10_S_on_swapERS1_S3_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#167">_ZN9__gnu_cxx14__alloc_traitsISaIiEE10_S_on_swapERS1_S3_</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/ext/alloc_traits.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/ext</a> - alloc_traits.h<span style="font-size: 80%;"> (<a href="alloc_traits.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="alloc_traits.h.func.html"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#167">_ZN9__gnu_cxx14__alloc_traitsISaIdEE10_S_on_swapERS1_S3_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#167">_ZN9__gnu_cxx14__alloc_traitsISaIiEE10_S_on_swapERS1_S3_</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/ext/alloc_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/vector.tcc.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/vector.tcc.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/vector.tcc</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - vector.tcc<span style="font-size: 80%;"> (source / <a href="vector.tcc.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">53</td>            <td class="headerCovTableEntry">92</td>            <td class="headerCovTableEntryLo">57.6 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Vector implementation (out of line) -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2001-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /*<span class="lineNum">      26 </span>            :  *<span class="lineNum">      27 </span>            :  * Copyright (c) 1994<span class="lineNum">      28 </span>            :  * Hewlett-Packard Company<span class="lineNum">      29 </span>            :  *<span class="lineNum">      30 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      31 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      32 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      33 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      34 </span>            :  * in supporting documentation.  Hewlett-Packard Company makes no<span class="lineNum">      35 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      36 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      37 </span>            :  *<span class="lineNum">      38 </span>            :  *<span class="lineNum">      39 </span>            :  * Copyright (c) 1996<span class="lineNum">      40 </span>            :  * Silicon Graphics Computer Systems, Inc.<span class="lineNum">      41 </span>            :  *<span class="lineNum">      42 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      43 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      44 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      45 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      46 </span>            :  * in supporting documentation.  Silicon Graphics makes no<span class="lineNum">      47 </span>            :  * representations about the suitability of this  software for any<span class="lineNum">      48 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      49 </span>            :  */<span class="lineNum">      50 </span>            : <span class="lineNum">      51 </span>            : /** @file bits/vector.tcc<span class="lineNum">      52 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      53 </span>            :  *  Do not attempt to use it directly. @headername{vector}<span class="lineNum">      54 </span>            :  */<span class="lineNum">      55 </span>            : <span class="lineNum">      56 </span>            : #ifndef _VECTOR_TCC<span class="lineNum">      57 </span>            : #define _VECTOR_TCC 1<span class="lineNum">      58 </span>            : <span class="lineNum">      59 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      60 </span>            : {<span class="lineNum">      61 </span>            : _GLIBCXX_BEGIN_NAMESPACE_CONTAINER<span class="lineNum">      62 </span>            : <span class="lineNum">      63 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">      64 </span>            :     void<span class="lineNum">      65 </span>            :     vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">      66 </span>            :     reserve(size_type __n)<span class="lineNum">      67 </span>            :     {<span class="lineNum">      68 </span>            :       if (__n &gt; this-&gt;max_size())<span class="lineNum">      69 </span>            :         __throw_length_error(__N(&quot;vector::reserve&quot;));<span class="lineNum">      70 </span>            :       if (this-&gt;capacity() &lt; __n)<span class="lineNum">      71 </span>            :         {<span class="lineNum">      72 </span>            :           const size_type __old_size = size();<span class="lineNum">      73 </span>            :           pointer __tmp = _M_allocate_and_copy(__n,<span class="lineNum">      74 </span>            :             _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this-&gt;_M_impl._M_start),<span class="lineNum">      75 </span>            :             _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this-&gt;_M_impl._M_finish));<span class="lineNum">      76 </span>            :           std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,<span class="lineNum">      77 </span>            :                         _M_get_Tp_allocator());<span class="lineNum">      78 </span>            :           _M_deallocate(this-&gt;_M_impl._M_start,<span class="lineNum">      79 </span>            :                         this-&gt;_M_impl._M_end_of_storage<span class="lineNum">      80 </span>            :                         - this-&gt;_M_impl._M_start);<span class="lineNum">      81 </span>            :           this-&gt;_M_impl._M_start = __tmp;<span class="lineNum">      82 </span>            :           this-&gt;_M_impl._M_finish = __tmp + __old_size;<span class="lineNum">      83 </span>            :           this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __n;<span class="lineNum">      84 </span>            :         }<span class="lineNum">      85 </span>            :     }<span class="lineNum">      86 </span>            : <span class="lineNum">      87 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      88 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<a name="89"><span class="lineNum">      89 </span>            :     template&lt;typename... _Args&gt;</a><span class="lineNum">      90 </span>            :       void<span class="lineNum">      91 </span><span class="lineCov">        784 :       vector&lt;_Tp, _Alloc&gt;::</span><span class="lineNum">      92 </span>            :       emplace_back(_Args&amp;&amp;... __args)<span class="lineNum">      93 </span>            :       {<span class="lineNum">      94 </span><span class="lineCov">        784 :         if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)</span><span class="lineNum">      95 </span>            :           {<span class="lineNum">      96 </span><span class="lineCov">        748 :             _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,</span><span class="lineNum">      97 </span><span class="lineCov">        748 :                                      std::forward&lt;_Args&gt;(__args)...);</span><span class="lineNum">      98 </span><span class="lineCov">        748 :             ++this-&gt;_M_impl._M_finish;</span><span class="lineNum">      99 </span>            :           }<span class="lineNum">     100 </span>            :         else<span class="lineNum">     101 </span><span class="lineCov">         36 :           _M_emplace_back_aux(std::forward&lt;_Args&gt;(__args)...);</span><span class="lineNum">     102 </span><span class="lineCov">        784 :       }</span><span class="lineNum">     103 </span>            : #endif<span class="lineNum">     104 </span>            : <span class="lineNum">     105 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     106 </span>            :     typename vector&lt;_Tp, _Alloc&gt;::iterator<span class="lineNum">     107 </span>            :     vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     108 </span>            :     insert(iterator __position, const value_type&amp; __x)<span class="lineNum">     109 </span>            :     {<span class="lineNum">     110 </span>            :       const size_type __n = __position - begin();<span class="lineNum">     111 </span>            :       if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     112 </span>            :           &amp;&amp; __position == end())<span class="lineNum">     113 </span>            :         {<span class="lineNum">     114 </span>            :           _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish, __x);<span class="lineNum">     115 </span>            :           ++this-&gt;_M_impl._M_finish;<span class="lineNum">     116 </span>            :         }<span class="lineNum">     117 </span>            :       else<span class="lineNum">     118 </span>            :         {<span class="lineNum">     119 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     120 </span>            :           if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)<span class="lineNum">     121 </span>            :             {<span class="lineNum">     122 </span>            :               _Tp __x_copy = __x;<span class="lineNum">     123 </span>            :               _M_insert_aux(__position, std::move(__x_copy));<span class="lineNum">     124 </span>            :             }<span class="lineNum">     125 </span>            :           else<span class="lineNum">     126 </span>            : #endif<span class="lineNum">     127 </span>            :             _M_insert_aux(__position, __x);<span class="lineNum">     128 </span>            :         }<span class="lineNum">     129 </span>            :       return iterator(this-&gt;_M_impl._M_start + __n);<span class="lineNum">     130 </span>            :     }<span class="lineNum">     131 </span>            : <span class="lineNum">     132 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     133 </span>            :     typename vector&lt;_Tp, _Alloc&gt;::iterator<span class="lineNum">     134 </span>            :     vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     135 </span>            :     erase(iterator __position)<span class="lineNum">     136 </span>            :     {<span class="lineNum">     137 </span>            :       if (__position + 1 != end())<span class="lineNum">     138 </span>            :         _GLIBCXX_MOVE3(__position + 1, end(), __position);<span class="lineNum">     139 </span>            :       --this-&gt;_M_impl._M_finish;<span class="lineNum">     140 </span>            :       _Alloc_traits::destroy(this-&gt;_M_impl, this-&gt;_M_impl._M_finish);<span class="lineNum">     141 </span>            :       return __position;<span class="lineNum">     142 </span>            :     }<span class="lineNum">     143 </span>            : <span class="lineNum">     144 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     145 </span>            :     typename vector&lt;_Tp, _Alloc&gt;::iterator<span class="lineNum">     146 </span>            :     vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     147 </span>            :     erase(iterator __first, iterator __last)<span class="lineNum">     148 </span>            :     {<span class="lineNum">     149 </span>            :       if (__first != __last)<span class="lineNum">     150 </span>            :         {<span class="lineNum">     151 </span>            :           if (__last != end())<span class="lineNum">     152 </span>            :             _GLIBCXX_MOVE3(__last, end(), __first);<span class="lineNum">     153 </span>            :           _M_erase_at_end(__first.base() + (end() - __last));<span class="lineNum">     154 </span>            :         }<span class="lineNum">     155 </span>            :       return __first;<span class="lineNum">     156 </span>            :     }<span class="lineNum">     157 </span>            : <span class="lineNum">     158 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     159 </span>            :     vector&lt;_Tp, _Alloc&gt;&amp;<span class="lineNum">     160 </span>            :     vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     161 </span>            :     operator=(const vector&lt;_Tp, _Alloc&gt;&amp; __x)<span class="lineNum">     162 </span>            :     {<span class="lineNum">     163 </span>            :       if (&amp;__x != this)<span class="lineNum">     164 </span>            :         {<span class="lineNum">     165 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     166 </span>            :           if (_Alloc_traits::_S_propagate_on_copy_assign())<span class="lineNum">     167 </span>            :             {<span class="lineNum">     168 </span>            :               if (!_Alloc_traits::_S_always_equal()<span class="lineNum">     169 </span>            :                   &amp;&amp; _M_get_Tp_allocator() != __x._M_get_Tp_allocator())<span class="lineNum">     170 </span>            :                 {<span class="lineNum">     171 </span>            :                   // replacement allocator cannot free existing storage<span class="lineNum">     172 </span>            :                   this-&gt;clear();<span class="lineNum">     173 </span>            :                   _M_deallocate(this-&gt;_M_impl._M_start,<span class="lineNum">     174 </span>            :                                 this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     175 </span>            :                                 - this-&gt;_M_impl._M_start);<span class="lineNum">     176 </span>            :                   this-&gt;_M_impl._M_start = nullptr;<span class="lineNum">     177 </span>            :                   this-&gt;_M_impl._M_finish = nullptr;<span class="lineNum">     178 </span>            :                   this-&gt;_M_impl._M_end_of_storage = nullptr;<span class="lineNum">     179 </span>            :                 }<span class="lineNum">     180 </span>            :               std::__alloc_on_copy(_M_get_Tp_allocator(),<span class="lineNum">     181 </span>            :                                    __x._M_get_Tp_allocator());<span class="lineNum">     182 </span>            :             }<span class="lineNum">     183 </span>            : #endif<span class="lineNum">     184 </span>            :           const size_type __xlen = __x.size();<span class="lineNum">     185 </span>            :           if (__xlen &gt; capacity())<span class="lineNum">     186 </span>            :             {<span class="lineNum">     187 </span>            :               pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),<span class="lineNum">     188 </span>            :                                                    __x.end());<span class="lineNum">     189 </span>            :               std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,<span class="lineNum">     190 </span>            :                             _M_get_Tp_allocator());<span class="lineNum">     191 </span>            :               _M_deallocate(this-&gt;_M_impl._M_start,<span class="lineNum">     192 </span>            :                             this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     193 </span>            :                             - this-&gt;_M_impl._M_start);<span class="lineNum">     194 </span>            :               this-&gt;_M_impl._M_start = __tmp;<span class="lineNum">     195 </span>            :               this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __xlen;<span class="lineNum">     196 </span>            :             }<span class="lineNum">     197 </span>            :           else if (size() &gt;= __xlen)<span class="lineNum">     198 </span>            :             {<span class="lineNum">     199 </span>            :               std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),<span class="lineNum">     200 </span>            :                             end(), _M_get_Tp_allocator());<span class="lineNum">     201 </span>            :             }<span class="lineNum">     202 </span>            :           else<span class="lineNum">     203 </span>            :             {<span class="lineNum">     204 </span>            :               std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),<span class="lineNum">     205 </span>            :                         this-&gt;_M_impl._M_start);<span class="lineNum">     206 </span>            :               std::__uninitialized_copy_a(__x._M_impl._M_start + size(),<span class="lineNum">     207 </span>            :                                           __x._M_impl._M_finish,<span class="lineNum">     208 </span>            :                                           this-&gt;_M_impl._M_finish,<span class="lineNum">     209 </span>            :                                           _M_get_Tp_allocator());<span class="lineNum">     210 </span>            :             }<span class="lineNum">     211 </span>            :           this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_start + __xlen;<span class="lineNum">     212 </span>            :         }<span class="lineNum">     213 </span>            :       return *this;<span class="lineNum">     214 </span>            :     }<span class="lineNum">     215 </span>            : <a name="216"><span class="lineNum">     216 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;</a><span class="lineNum">     217 </span>            :     void<span class="lineNum">     218 </span><span class="lineCov">        140 :     vector&lt;_Tp, _Alloc&gt;::</span><span class="lineNum">     219 </span>            :     _M_fill_assign(size_t __n, const value_type&amp; __val)<span class="lineNum">     220 </span>            :     {<span class="lineNum">     221 </span><span class="lineCov">        140 :       if (__n &gt; capacity())</span><span class="lineNum">     222 </span>            :         {<span class="lineNum">     223 </span><span class="lineNoCov">          0 :           vector __tmp(__n, __val, _M_get_Tp_allocator());</span><span class="lineNum">     224 </span><span class="lineNoCov">          0 :           __tmp.swap(*this);</span><span class="lineNum">     225 </span>            :         }<span class="lineNum">     226 </span><span class="lineCov">        140 :       else if (__n &gt; size())</span><span class="lineNum">     227 </span>            :         {<span class="lineNum">     228 </span><span class="lineNoCov">          0 :           std::fill(begin(), end(), __val);</span><span class="lineNum">     229 </span><span class="lineNoCov">          0 :           std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_finish,</span><span class="lineNum">     230 </span><span class="lineNoCov">          0 :                                         __n - size(), __val,</span><span class="lineNum">     231 </span><span class="lineNoCov">          0 :                                         _M_get_Tp_allocator());</span><span class="lineNum">     232 </span><span class="lineNoCov">          0 :           this-&gt;_M_impl._M_finish += __n - size();</span><span class="lineNum">     233 </span>            :         }<span class="lineNum">     234 </span>            :       else<span class="lineNum">     235 </span><span class="lineCov">        140 :         _M_erase_at_end(std::fill_n(this-&gt;_M_impl._M_start, __n, __val));</span><span class="lineNum">     236 </span><span class="lineCov">        140 :     }</span><span class="lineNum">     237 </span>            : <span class="lineNum">     238 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     239 </span>            :     template&lt;typename _InputIterator&gt;<span class="lineNum">     240 </span>            :       void<span class="lineNum">     241 </span>            :       vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     242 </span>            :       _M_assign_aux(_InputIterator __first, _InputIterator __last,<span class="lineNum">     243 </span>            :                     std::input_iterator_tag)<span class="lineNum">     244 </span>            :       {<span class="lineNum">     245 </span>            :         pointer __cur(this-&gt;_M_impl._M_start);<span class="lineNum">     246 </span>            :         for (; __first != __last &amp;&amp; __cur != this-&gt;_M_impl._M_finish;<span class="lineNum">     247 </span>            :              ++__cur, ++__first)<span class="lineNum">     248 </span>            :           *__cur = *__first;<span class="lineNum">     249 </span>            :         if (__first == __last)<span class="lineNum">     250 </span>            :           _M_erase_at_end(__cur);<span class="lineNum">     251 </span>            :         else<span class="lineNum">     252 </span>            :           insert(end(), __first, __last);<span class="lineNum">     253 </span>            :       }<span class="lineNum">     254 </span>            : <span class="lineNum">     255 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     256 </span>            :     template&lt;typename _ForwardIterator&gt;<span class="lineNum">     257 </span>            :       void<span class="lineNum">     258 </span>            :       vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     259 </span>            :       _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,<span class="lineNum">     260 </span>            :                     std::forward_iterator_tag)<span class="lineNum">     261 </span>            :       {<span class="lineNum">     262 </span>            :         const size_type __len = std::distance(__first, __last);<span class="lineNum">     263 </span>            : <span class="lineNum">     264 </span>            :         if (__len &gt; capacity())<span class="lineNum">     265 </span>            :           {<span class="lineNum">     266 </span>            :             pointer __tmp(_M_allocate_and_copy(__len, __first, __last));<span class="lineNum">     267 </span>            :             std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,<span class="lineNum">     268 </span>            :                           _M_get_Tp_allocator());<span class="lineNum">     269 </span>            :             _M_deallocate(this-&gt;_M_impl._M_start,<span class="lineNum">     270 </span>            :                           this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     271 </span>            :                           - this-&gt;_M_impl._M_start);<span class="lineNum">     272 </span>            :             this-&gt;_M_impl._M_start = __tmp;<span class="lineNum">     273 </span>            :             this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_start + __len;<span class="lineNum">     274 </span>            :             this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_finish;<span class="lineNum">     275 </span>            :           }<span class="lineNum">     276 </span>            :         else if (size() &gt;= __len)<span class="lineNum">     277 </span>            :           _M_erase_at_end(std::copy(__first, __last, this-&gt;_M_impl._M_start));<span class="lineNum">     278 </span>            :         else<span class="lineNum">     279 </span>            :           {<span class="lineNum">     280 </span>            :             _ForwardIterator __mid = __first;<span class="lineNum">     281 </span>            :             std::advance(__mid, size());<span class="lineNum">     282 </span>            :             std::copy(__first, __mid, this-&gt;_M_impl._M_start);<span class="lineNum">     283 </span>            :             this-&gt;_M_impl._M_finish =<span class="lineNum">     284 </span>            :               std::__uninitialized_copy_a(__mid, __last,<span class="lineNum">     285 </span>            :                                           this-&gt;_M_impl._M_finish,<span class="lineNum">     286 </span>            :                                           _M_get_Tp_allocator());<span class="lineNum">     287 </span>            :           }<span class="lineNum">     288 </span>            :       }<span class="lineNum">     289 </span>            : <span class="lineNum">     290 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     291 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     292 </span>            :     template&lt;typename... _Args&gt;<span class="lineNum">     293 </span>            :       typename vector&lt;_Tp, _Alloc&gt;::iterator<span class="lineNum">     294 </span>            :       vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     295 </span>            :       emplace(iterator __position, _Args&amp;&amp;... __args)<span class="lineNum">     296 </span>            :       {<span class="lineNum">     297 </span>            :         const size_type __n = __position - begin();<span class="lineNum">     298 </span>            :         if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     299 </span>            :             &amp;&amp; __position == end())<span class="lineNum">     300 </span>            :           {<span class="lineNum">     301 </span>            :             _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,<span class="lineNum">     302 </span>            :                                      std::forward&lt;_Args&gt;(__args)...);<span class="lineNum">     303 </span>            :             ++this-&gt;_M_impl._M_finish;<span class="lineNum">     304 </span>            :           }<span class="lineNum">     305 </span>            :         else<span class="lineNum">     306 </span>            :           _M_insert_aux(__position, std::forward&lt;_Args&gt;(__args)...);<span class="lineNum">     307 </span>            :         return iterator(this-&gt;_M_impl._M_start + __n);<span class="lineNum">     308 </span>            :       }<span class="lineNum">     309 </span>            : <span class="lineNum">     310 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     311 </span>            :     template&lt;typename... _Args&gt;<span class="lineNum">     312 </span>            :       void<span class="lineNum">     313 </span>            :       vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     314 </span>            :       _M_insert_aux(iterator __position, _Args&amp;&amp;... __args)<span class="lineNum">     315 </span>            : #else<span class="lineNum">     316 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     317 </span>            :     void<span class="lineNum">     318 </span>            :     vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     319 </span>            :     _M_insert_aux(iterator __position, const _Tp&amp; __x)<span class="lineNum">     320 </span>            : #endif<span class="lineNum">     321 </span>            :     {<span class="lineNum">     322 </span>            :       if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)<span class="lineNum">     323 </span>            :         {<span class="lineNum">     324 </span>            :           _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,<span class="lineNum">     325 </span>            :                                    _GLIBCXX_MOVE(*(this-&gt;_M_impl._M_finish<span class="lineNum">     326 </span>            :                                                    - 1)));<span class="lineNum">     327 </span>            :           ++this-&gt;_M_impl._M_finish;<span class="lineNum">     328 </span>            : #if __cplusplus &lt; 201103L<span class="lineNum">     329 </span>            :           _Tp __x_copy = __x;<span class="lineNum">     330 </span>            : #endif<span class="lineNum">     331 </span>            :           _GLIBCXX_MOVE_BACKWARD3(__position.base(),<span class="lineNum">     332 </span>            :                                   this-&gt;_M_impl._M_finish - 2,<span class="lineNum">     333 </span>            :                                   this-&gt;_M_impl._M_finish - 1);<span class="lineNum">     334 </span>            : #if __cplusplus &lt; 201103L<span class="lineNum">     335 </span>            :           *__position = __x_copy;<span class="lineNum">     336 </span>            : #else<span class="lineNum">     337 </span>            :           *__position = _Tp(std::forward&lt;_Args&gt;(__args)...);<span class="lineNum">     338 </span>            : #endif<span class="lineNum">     339 </span>            :         }<span class="lineNum">     340 </span>            :       else<span class="lineNum">     341 </span>            :         {<span class="lineNum">     342 </span>            :           const size_type __len =<span class="lineNum">     343 </span>            :             _M_check_len(size_type(1), &quot;vector::_M_insert_aux&quot;);<span class="lineNum">     344 </span>            :           const size_type __elems_before = __position - begin();<span class="lineNum">     345 </span>            :           pointer __new_start(this-&gt;_M_allocate(__len));<span class="lineNum">     346 </span>            :           pointer __new_finish(__new_start);<span class="lineNum">     347 </span>            :           __try<span class="lineNum">     348 </span>            :             {<span class="lineNum">     349 </span>            :               // The order of the three operations is dictated by the C++0x<span class="lineNum">     350 </span>            :               // case, where the moves could alter a new element belonging<span class="lineNum">     351 </span>            :               // to the existing vector.  This is an issue only for callers<span class="lineNum">     352 </span>            :               // taking the element by const lvalue ref (see 23.1/13).<span class="lineNum">     353 </span>            :               _Alloc_traits::construct(this-&gt;_M_impl,<span class="lineNum">     354 </span>            :                                        __new_start + __elems_before,<span class="lineNum">     355 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     356 </span>            :                                        std::forward&lt;_Args&gt;(__args)...);<span class="lineNum">     357 </span>            : #else<span class="lineNum">     358 </span>            :                                        __x);<span class="lineNum">     359 </span>            : #endif<span class="lineNum">     360 </span>            :               __new_finish = 0;<span class="lineNum">     361 </span>            : <span class="lineNum">     362 </span>            :               __new_finish<span class="lineNum">     363 </span>            :                 = std::__uninitialized_move_if_noexcept_a<span class="lineNum">     364 </span>            :                 (this-&gt;_M_impl._M_start, __position.base(),<span class="lineNum">     365 </span>            :                  __new_start, _M_get_Tp_allocator());<span class="lineNum">     366 </span>            : <span class="lineNum">     367 </span>            :               ++__new_finish;<span class="lineNum">     368 </span>            : <span class="lineNum">     369 </span>            :               __new_finish<span class="lineNum">     370 </span>            :                 = std::__uninitialized_move_if_noexcept_a<span class="lineNum">     371 </span>            :                 (__position.base(), this-&gt;_M_impl._M_finish,<span class="lineNum">     372 </span>            :                  __new_finish, _M_get_Tp_allocator());<span class="lineNum">     373 </span>            :             }<span class="lineNum">     374 </span>            :           __catch(...)<span class="lineNum">     375 </span>            :             {<span class="lineNum">     376 </span>            :               if (!__new_finish)<span class="lineNum">     377 </span>            :                 _Alloc_traits::destroy(this-&gt;_M_impl,<span class="lineNum">     378 </span>            :                                        __new_start + __elems_before);<span class="lineNum">     379 </span>            :               else<span class="lineNum">     380 </span>            :                 std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());<span class="lineNum">     381 </span>            :               _M_deallocate(__new_start, __len);<span class="lineNum">     382 </span>            :               __throw_exception_again;<span class="lineNum">     383 </span>            :             }<span class="lineNum">     384 </span>            :           std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,<span class="lineNum">     385 </span>            :                         _M_get_Tp_allocator());<span class="lineNum">     386 </span>            :           _M_deallocate(this-&gt;_M_impl._M_start,<span class="lineNum">     387 </span>            :                         this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     388 </span>            :                         - this-&gt;_M_impl._M_start);<span class="lineNum">     389 </span>            :           this-&gt;_M_impl._M_start = __new_start;<span class="lineNum">     390 </span>            :           this-&gt;_M_impl._M_finish = __new_finish;<span class="lineNum">     391 </span>            :           this-&gt;_M_impl._M_end_of_storage = __new_start + __len;<span class="lineNum">     392 </span>            :         }<span class="lineNum">     393 </span>            :     }<span class="lineNum">     394 </span>            : <span class="lineNum">     395 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     396 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<a name="397"><span class="lineNum">     397 </span>            :     template&lt;typename... _Args&gt;</a><span class="lineNum">     398 </span>            :       void<span class="lineNum">     399 </span><span class="lineCov">         90 :       vector&lt;_Tp, _Alloc&gt;::</span><span class="lineNum">     400 </span>            :       _M_emplace_back_aux(_Args&amp;&amp;... __args)<span class="lineNum">     401 </span>            :       {<span class="lineNum">     402 </span>            :         const size_type __len =<span class="lineNum">     403 </span><span class="lineCov">         90 :           _M_check_len(size_type(1), &quot;vector::_M_emplace_back_aux&quot;);</span><span class="lineNum">     404 </span><span class="lineCov">         90 :         pointer __new_start(this-&gt;_M_allocate(__len));</span><span class="lineNum">     405 </span><span class="lineCov">         90 :         pointer __new_finish(__new_start);</span><span class="lineNum">     406 </span>            :         __try<span class="lineNum">     407 </span>            :           {<span class="lineNum">     408 </span><span class="lineCov">        180 :             _Alloc_traits::construct(this-&gt;_M_impl, __new_start + size(),</span><span class="lineNum">     409 </span><span class="lineCov">        180 :                                      std::forward&lt;_Args&gt;(__args)...);</span><span class="lineNum">     410 </span><span class="lineCov">         90 :             __new_finish = 0;</span><span class="lineNum">     411 </span>            : <span class="lineNum">     412 </span><span class="lineCov">         90 :             __new_finish</span><span class="lineNum">     413 </span>            :               = std::__uninitialized_move_if_noexcept_a<span class="lineNum">     414 </span>            :               (this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,<span class="lineNum">     415 </span><span class="lineCov">         90 :                __new_start, _M_get_Tp_allocator());</span><span class="lineNum">     416 </span>            : <span class="lineNum">     417 </span><span class="lineCov">         90 :             ++__new_finish;</span><span class="lineNum">     418 </span>            :           }<span class="lineNum">     419 </span><span class="lineNoCov">          0 :         __catch(...)</span><span class="lineNum">     420 </span>            :           {<span class="lineNum">     421 </span><span class="lineNoCov">          0 :             if (!__new_finish)</span><span class="lineNum">     422 </span><span class="lineNoCov">          0 :               _Alloc_traits::destroy(this-&gt;_M_impl, __new_start + size());</span><span class="lineNum">     423 </span>            :             else<span class="lineNum">     424 </span><span class="lineNoCov">          0 :               std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());</span><span class="lineNum">     425 </span><span class="lineNoCov">          0 :             _M_deallocate(__new_start, __len);</span><span class="lineNum">     426 </span><span class="lineNoCov">          0 :             __throw_exception_again;</span><span class="lineNum">     427 </span>            :           }<span class="lineNum">     428 </span><span class="lineCov">         90 :         std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,</span><span class="lineNum">     429 </span><span class="lineCov">         90 :                       _M_get_Tp_allocator());</span><span class="lineNum">     430 </span><span class="lineCov">         90 :         _M_deallocate(this-&gt;_M_impl._M_start,</span><span class="lineNum">     431 </span>            :                       this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     432 </span><span class="lineCov">         90 :                       - this-&gt;_M_impl._M_start);</span><span class="lineNum">     433 </span><span class="lineCov">         90 :         this-&gt;_M_impl._M_start = __new_start;</span><span class="lineNum">     434 </span><span class="lineCov">         90 :         this-&gt;_M_impl._M_finish = __new_finish;</span><span class="lineNum">     435 </span><span class="lineCov">         90 :         this-&gt;_M_impl._M_end_of_storage = __new_start + __len;</span><span class="lineNum">     436 </span><span class="lineCov">         90 :       }</span><span class="lineNum">     437 </span>            : #endif<span class="lineNum">     438 </span>            : <a name="439"><span class="lineNum">     439 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;</a><span class="lineNum">     440 </span>            :     void<span class="lineNum">     441 </span><span class="lineCov">          2 :     vector&lt;_Tp, _Alloc&gt;::</span><span class="lineNum">     442 </span>            :     _M_fill_insert(iterator __position, size_type __n, const value_type&amp; __x)<span class="lineNum">     443 </span>            :     {<span class="lineNum">     444 </span><span class="lineCov">          2 :       if (__n != 0)</span><span class="lineNum">     445 </span>            :         {<span class="lineNum">     446 </span><span class="lineCov">          2 :           if (size_type(this-&gt;_M_impl._M_end_of_storage</span><span class="lineNum">     447 </span>            :                         - this-&gt;_M_impl._M_finish) &gt;= __n)<span class="lineNum">     448 </span>            :             {<span class="lineNum">     449 </span><span class="lineNoCov">          0 :               value_type __x_copy = __x;</span><span class="lineNum">     450 </span><span class="lineNoCov">          0 :               const size_type __elems_after = end() - __position;</span><span class="lineNum">     451 </span><span class="lineNoCov">          0 :               pointer __old_finish(this-&gt;_M_impl._M_finish);</span><span class="lineNum">     452 </span><span class="lineNoCov">          0 :               if (__elems_after &gt; __n)</span><span class="lineNum">     453 </span>            :                 {<span class="lineNum">     454 </span><span class="lineNoCov">          0 :                   std::__uninitialized_move_a(this-&gt;_M_impl._M_finish - __n,</span><span class="lineNum">     455 </span>            :                                               this-&gt;_M_impl._M_finish,<span class="lineNum">     456 </span>            :                                               this-&gt;_M_impl._M_finish,<span class="lineNum">     457 </span><span class="lineNoCov">          0 :                                               _M_get_Tp_allocator());</span><span class="lineNum">     458 </span><span class="lineNoCov">          0 :                   this-&gt;_M_impl._M_finish += __n;</span><span class="lineNum">     459 </span><span class="lineNoCov">          0 :                   _GLIBCXX_MOVE_BACKWARD3(__position.base(),</span><span class="lineNum">     460 </span>            :                                           __old_finish - __n, __old_finish);<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                   std::fill(__position.base(), __position.base() + __n,</span><span class="lineNum">     462 </span><span class="lineNoCov">          0 :                             __x_copy);</span><span class="lineNum">     463 </span>            :                 }<span class="lineNum">     464 </span>            :               else<span class="lineNum">     465 </span>            :                 {<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                   std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_finish,</span><span class="lineNum">     467 </span>            :                                                 __n - __elems_after,<span class="lineNum">     468 </span>            :                                                 __x_copy,<span class="lineNum">     469 </span><span class="lineNoCov">          0 :                                                 _M_get_Tp_allocator());</span><span class="lineNum">     470 </span><span class="lineNoCov">          0 :                   this-&gt;_M_impl._M_finish += __n - __elems_after;</span><span class="lineNum">     471 </span><span class="lineNoCov">          0 :                   std::__uninitialized_move_a(__position.base(), __old_finish,</span><span class="lineNum">     472 </span>            :                                               this-&gt;_M_impl._M_finish,<span class="lineNum">     473 </span><span class="lineNoCov">          0 :                                               _M_get_Tp_allocator());</span><span class="lineNum">     474 </span><span class="lineNoCov">          0 :                   this-&gt;_M_impl._M_finish += __elems_after;</span><span class="lineNum">     475 </span><span class="lineNoCov">          0 :                   std::fill(__position.base(), __old_finish, __x_copy);</span><span class="lineNum">     476 </span>            :                 }<span class="lineNum">     477 </span>            :             }<span class="lineNum">     478 </span>            :           else<span class="lineNum">     479 </span>            :             {<span class="lineNum">     480 </span>            :               const size_type __len =<span class="lineNum">     481 </span><span class="lineCov">          2 :                 _M_check_len(__n, &quot;vector::_M_fill_insert&quot;);</span><span class="lineNum">     482 </span><span class="lineCov">          2 :               const size_type __elems_before = __position - begin();</span><span class="lineNum">     483 </span><span class="lineCov">          2 :               pointer __new_start(this-&gt;_M_allocate(__len));</span><span class="lineNum">     484 </span><span class="lineCov">          2 :               pointer __new_finish(__new_start);</span><span class="lineNum">     485 </span>            :               __try<span class="lineNum">     486 </span>            :                 {<span class="lineNum">     487 </span>            :                   // See _M_insert_aux above.<span class="lineNum">     488 </span><span class="lineCov">          2 :                   std::__uninitialized_fill_n_a(__new_start + __elems_before,</span><span class="lineNum">     489 </span>            :                                                 __n, __x,<span class="lineNum">     490 </span><span class="lineCov">          2 :                                                 _M_get_Tp_allocator());</span><span class="lineNum">     491 </span><span class="lineCov">          2 :                   __new_finish = 0;</span><span class="lineNum">     492 </span>            : <span class="lineNum">     493 </span><span class="lineCov">          2 :                   __new_finish</span><span class="lineNum">     494 </span>            :                     = std::__uninitialized_move_if_noexcept_a<span class="lineNum">     495 </span>            :                     (this-&gt;_M_impl._M_start, __position.base(),<span class="lineNum">     496 </span><span class="lineCov">          2 :                      __new_start, _M_get_Tp_allocator());</span><span class="lineNum">     497 </span>            : <span class="lineNum">     498 </span><span class="lineCov">          2 :                   __new_finish += __n;</span><span class="lineNum">     499 </span>            : <span class="lineNum">     500 </span><span class="lineCov">          2 :                   __new_finish</span><span class="lineNum">     501 </span>            :                     = std::__uninitialized_move_if_noexcept_a<span class="lineNum">     502 </span>            :                     (__position.base(), this-&gt;_M_impl._M_finish,<span class="lineNum">     503 </span><span class="lineCov">          2 :                      __new_finish, _M_get_Tp_allocator());</span><span class="lineNum">     504 </span>            :                 }<span class="lineNum">     505 </span><span class="lineNoCov">          0 :               __catch(...)</span><span class="lineNum">     506 </span>            :                 {<span class="lineNum">     507 </span><span class="lineNoCov">          0 :                   if (!__new_finish)</span><span class="lineNum">     508 </span><span class="lineNoCov">          0 :                     std::_Destroy(__new_start + __elems_before,</span><span class="lineNum">     509 </span><span class="lineNoCov">          0 :                                   __new_start + __elems_before + __n,</span><span class="lineNum">     510 </span><span class="lineNoCov">          0 :                                   _M_get_Tp_allocator());</span><span class="lineNum">     511 </span>            :                   else<span class="lineNum">     512 </span><span class="lineNoCov">          0 :                     std::_Destroy(__new_start, __new_finish,</span><span class="lineNum">     513 </span><span class="lineNoCov">          0 :                                   _M_get_Tp_allocator());</span><span class="lineNum">     514 </span><span class="lineNoCov">          0 :                   _M_deallocate(__new_start, __len);</span><span class="lineNum">     515 </span><span class="lineNoCov">          0 :                   __throw_exception_again;</span><span class="lineNum">     516 </span>            :                 }<span class="lineNum">     517 </span><span class="lineCov">          2 :               std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,</span><span class="lineNum">     518 </span><span class="lineCov">          2 :                             _M_get_Tp_allocator());</span><span class="lineNum">     519 </span><span class="lineCov">          2 :               _M_deallocate(this-&gt;_M_impl._M_start,</span><span class="lineNum">     520 </span>            :                             this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     521 </span><span class="lineCov">          2 :                             - this-&gt;_M_impl._M_start);</span><span class="lineNum">     522 </span><span class="lineCov">          2 :               this-&gt;_M_impl._M_start = __new_start;</span><span class="lineNum">     523 </span><span class="lineCov">          2 :               this-&gt;_M_impl._M_finish = __new_finish;</span><span class="lineNum">     524 </span><span class="lineCov">          2 :               this-&gt;_M_impl._M_end_of_storage = __new_start + __len;</span><span class="lineNum">     525 </span>            :             }<span class="lineNum">     526 </span>            :         }<span class="lineNum">     527 </span><span class="lineCov">          2 :     }</span><span class="lineNum">     528 </span>            : <span class="lineNum">     529 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     530 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     531 </span>            :     void<span class="lineNum">     532 </span>            :     vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     533 </span>            :     _M_default_append(size_type __n)<span class="lineNum">     534 </span>            :     {<span class="lineNum">     535 </span>            :       if (__n != 0)<span class="lineNum">     536 </span>            :         {<span class="lineNum">     537 </span>            :           if (size_type(this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     538 </span>            :                         - this-&gt;_M_impl._M_finish) &gt;= __n)<span class="lineNum">     539 </span>            :             {<span class="lineNum">     540 </span>            :               std::__uninitialized_default_n_a(this-&gt;_M_impl._M_finish,<span class="lineNum">     541 </span>            :                                                __n, _M_get_Tp_allocator());<span class="lineNum">     542 </span>            :               this-&gt;_M_impl._M_finish += __n;<span class="lineNum">     543 </span>            :             }<span class="lineNum">     544 </span>            :           else<span class="lineNum">     545 </span>            :             {<span class="lineNum">     546 </span>            :               const size_type __len =<span class="lineNum">     547 </span>            :                 _M_check_len(__n, &quot;vector::_M_default_append&quot;);<span class="lineNum">     548 </span>            :               const size_type __old_size = this-&gt;size();<span class="lineNum">     549 </span>            :               pointer __new_start(this-&gt;_M_allocate(__len));<span class="lineNum">     550 </span>            :               pointer __new_finish(__new_start);<span class="lineNum">     551 </span>            :               __try<span class="lineNum">     552 </span>            :                 {<span class="lineNum">     553 </span>            :                   __new_finish<span class="lineNum">     554 </span>            :                     = std::__uninitialized_move_if_noexcept_a<span class="lineNum">     555 </span>            :                     (this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,<span class="lineNum">     556 </span>            :                      __new_start, _M_get_Tp_allocator());<span class="lineNum">     557 </span>            :                   std::__uninitialized_default_n_a(__new_finish, __n,<span class="lineNum">     558 </span>            :                                                    _M_get_Tp_allocator());<span class="lineNum">     559 </span>            :                   __new_finish += __n;<span class="lineNum">     560 </span>            :                 }<span class="lineNum">     561 </span>            :               __catch(...)<span class="lineNum">     562 </span>            :                 {<span class="lineNum">     563 </span>            :                   std::_Destroy(__new_start, __new_finish,<span class="lineNum">     564 </span>            :                                 _M_get_Tp_allocator());<span class="lineNum">     565 </span>            :                   _M_deallocate(__new_start, __len);<span class="lineNum">     566 </span>            :                   __throw_exception_again;<span class="lineNum">     567 </span>            :                 }<span class="lineNum">     568 </span>            :               std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,<span class="lineNum">     569 </span>            :                             _M_get_Tp_allocator());<span class="lineNum">     570 </span>            :               _M_deallocate(this-&gt;_M_impl._M_start,<span class="lineNum">     571 </span>            :                             this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     572 </span>            :                             - this-&gt;_M_impl._M_start);<span class="lineNum">     573 </span>            :               this-&gt;_M_impl._M_start = __new_start;<span class="lineNum">     574 </span>            :               this-&gt;_M_impl._M_finish = __new_finish;<span class="lineNum">     575 </span>            :               this-&gt;_M_impl._M_end_of_storage = __new_start + __len;<span class="lineNum">     576 </span>            :             }<span class="lineNum">     577 </span>            :         }<span class="lineNum">     578 </span>            :     }<span class="lineNum">     579 </span>            : <span class="lineNum">     580 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     581 </span>            :     bool<span class="lineNum">     582 </span>            :     vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     583 </span>            :     _M_shrink_to_fit()<span class="lineNum">     584 </span>            :     {<span class="lineNum">     585 </span>            :       if (capacity() == size())<span class="lineNum">     586 </span>            :         return false;<span class="lineNum">     587 </span>            :       return std::__shrink_to_fit_aux&lt;vector&gt;::_S_do_it(*this);<span class="lineNum">     588 </span>            :     }<span class="lineNum">     589 </span>            : #endif<span class="lineNum">     590 </span>            : <span class="lineNum">     591 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     592 </span>            :     template&lt;typename _InputIterator&gt;<span class="lineNum">     593 </span>            :       void<span class="lineNum">     594 </span>            :       vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     595 </span>            :       _M_range_insert(iterator __pos, _InputIterator __first,<span class="lineNum">     596 </span>            :                       _InputIterator __last, std::input_iterator_tag)<span class="lineNum">     597 </span>            :       {<span class="lineNum">     598 </span>            :         for (; __first != __last; ++__first)<span class="lineNum">     599 </span>            :           {<span class="lineNum">     600 </span>            :             __pos = insert(__pos, *__first);<span class="lineNum">     601 </span>            :             ++__pos;<span class="lineNum">     602 </span>            :           }<span class="lineNum">     603 </span>            :       }<span class="lineNum">     604 </span>            : <span class="lineNum">     605 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">     606 </span>            :     template&lt;typename _ForwardIterator&gt;<span class="lineNum">     607 </span>            :       void<span class="lineNum">     608 </span>            :       vector&lt;_Tp, _Alloc&gt;::<span class="lineNum">     609 </span>            :       _M_range_insert(iterator __position, _ForwardIterator __first,<span class="lineNum">     610 </span>            :                       _ForwardIterator __last, std::forward_iterator_tag)<span class="lineNum">     611 </span>            :       {<span class="lineNum">     612 </span>            :         if (__first != __last)<span class="lineNum">     613 </span>            :           {<span class="lineNum">     614 </span>            :             const size_type __n = std::distance(__first, __last);<span class="lineNum">     615 </span>            :             if (size_type(this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     616 </span>            :                           - this-&gt;_M_impl._M_finish) &gt;= __n)<span class="lineNum">     617 </span>            :               {<span class="lineNum">     618 </span>            :                 const size_type __elems_after = end() - __position;<span class="lineNum">     619 </span>            :                 pointer __old_finish(this-&gt;_M_impl._M_finish);<span class="lineNum">     620 </span>            :                 if (__elems_after &gt; __n)<span class="lineNum">     621 </span>            :                   {<span class="lineNum">     622 </span>            :                     std::__uninitialized_move_a(this-&gt;_M_impl._M_finish - __n,<span class="lineNum">     623 </span>            :                                                 this-&gt;_M_impl._M_finish,<span class="lineNum">     624 </span>            :                                                 this-&gt;_M_impl._M_finish,<span class="lineNum">     625 </span>            :                                                 _M_get_Tp_allocator());<span class="lineNum">     626 </span>            :                     this-&gt;_M_impl._M_finish += __n;<span class="lineNum">     627 </span>            :                     _GLIBCXX_MOVE_BACKWARD3(__position.base(),<span class="lineNum">     628 </span>            :                                             __old_finish - __n, __old_finish);<span class="lineNum">     629 </span>            :                     std::copy(__first, __last, __position);<span class="lineNum">     630 </span>            :                   }<span class="lineNum">     631 </span>            :                 else<span class="lineNum">     632 </span>            :                   {<span class="lineNum">     633 </span>            :                     _ForwardIterator __mid = __first;<span class="lineNum">     634 </span>            :                     std::advance(__mid, __elems_after);<span class="lineNum">     635 </span>            :                     std::__uninitialized_copy_a(__mid, __last,<span class="lineNum">     636 </span>            :                                                 this-&gt;_M_impl._M_finish,<span class="lineNum">     637 </span>            :                                                 _M_get_Tp_allocator());<span class="lineNum">     638 </span>            :                     this-&gt;_M_impl._M_finish += __n - __elems_after;<span class="lineNum">     639 </span>            :                     std::__uninitialized_move_a(__position.base(),<span class="lineNum">     640 </span>            :                                                 __old_finish,<span class="lineNum">     641 </span>            :                                                 this-&gt;_M_impl._M_finish,<span class="lineNum">     642 </span>            :                                                 _M_get_Tp_allocator());<span class="lineNum">     643 </span>            :                     this-&gt;_M_impl._M_finish += __elems_after;<span class="lineNum">     644 </span>            :                     std::copy(__first, __mid, __position);<span class="lineNum">     645 </span>            :                   }<span class="lineNum">     646 </span>            :               }<span class="lineNum">     647 </span>            :             else<span class="lineNum">     648 </span>            :               {<span class="lineNum">     649 </span>            :                 const size_type __len =<span class="lineNum">     650 </span>            :                   _M_check_len(__n, &quot;vector::_M_range_insert&quot;);<span class="lineNum">     651 </span>            :                 pointer __new_start(this-&gt;_M_allocate(__len));<span class="lineNum">     652 </span>            :                 pointer __new_finish(__new_start);<span class="lineNum">     653 </span>            :                 __try<span class="lineNum">     654 </span>            :                   {<span class="lineNum">     655 </span>            :                     __new_finish<span class="lineNum">     656 </span>            :                       = std::__uninitialized_move_if_noexcept_a<span class="lineNum">     657 </span>            :                       (this-&gt;_M_impl._M_start, __position.base(),<span class="lineNum">     658 </span>            :                        __new_start, _M_get_Tp_allocator());<span class="lineNum">     659 </span>            :                     __new_finish<span class="lineNum">     660 </span>            :                       = std::__uninitialized_copy_a(__first, __last,<span class="lineNum">     661 </span>            :                                                     __new_finish,<span class="lineNum">     662 </span>            :                                                     _M_get_Tp_allocator());<span class="lineNum">     663 </span>            :                     __new_finish<span class="lineNum">     664 </span>            :                       = std::__uninitialized_move_if_noexcept_a<span class="lineNum">     665 </span>            :                       (__position.base(), this-&gt;_M_impl._M_finish,<span class="lineNum">     666 </span>            :                        __new_finish, _M_get_Tp_allocator());<span class="lineNum">     667 </span>            :                   }<span class="lineNum">     668 </span>            :                 __catch(...)<span class="lineNum">     669 </span>            :                   {<span class="lineNum">     670 </span>            :                     std::_Destroy(__new_start, __new_finish,<span class="lineNum">     671 </span>            :                                   _M_get_Tp_allocator());<span class="lineNum">     672 </span>            :                     _M_deallocate(__new_start, __len);<span class="lineNum">     673 </span>            :                     __throw_exception_again;<span class="lineNum">     674 </span>            :                   }<span class="lineNum">     675 </span>            :                 std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,<span class="lineNum">     676 </span>            :                               _M_get_Tp_allocator());<span class="lineNum">     677 </span>            :                 _M_deallocate(this-&gt;_M_impl._M_start,<span class="lineNum">     678 </span>            :                               this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     679 </span>            :                               - this-&gt;_M_impl._M_start);<span class="lineNum">     680 </span>            :                 this-&gt;_M_impl._M_start = __new_start;<span class="lineNum">     681 </span>            :                 this-&gt;_M_impl._M_finish = __new_finish;<span class="lineNum">     682 </span>            :                 this-&gt;_M_impl._M_end_of_storage = __new_start + __len;<span class="lineNum">     683 </span>            :               }<span class="lineNum">     684 </span>            :           }<span class="lineNum">     685 </span>            :       }<span class="lineNum">     686 </span>            : <span class="lineNum">     687 </span>            : <span class="lineNum">     688 </span>            :   // vector&lt;bool&gt;<span class="lineNum">     689 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     690 </span>            :     void<span class="lineNum">     691 </span>            :     vector&lt;bool, _Alloc&gt;::<span class="lineNum">     692 </span>            :     _M_reallocate(size_type __n)<span class="lineNum">     693 </span>            :     {<span class="lineNum">     694 </span>            :       _Bit_type* __q = this-&gt;_M_allocate(__n);<span class="lineNum">     695 </span>            :       this-&gt;_M_impl._M_finish = _M_copy_aligned(begin(), end(),<span class="lineNum">     696 </span>            :                                                 iterator(__q, 0));<span class="lineNum">     697 </span>            :       this-&gt;_M_deallocate();<span class="lineNum">     698 </span>            :       this-&gt;_M_impl._M_start = iterator(__q, 0);<span class="lineNum">     699 </span>            :       this-&gt;_M_impl._M_end_of_storage = __q + _S_nword(__n);<span class="lineNum">     700 </span>            :     }<span class="lineNum">     701 </span>            : <span class="lineNum">     702 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     703 </span>            :     void<span class="lineNum">     704 </span>            :     vector&lt;bool, _Alloc&gt;::<span class="lineNum">     705 </span>            :     _M_fill_insert(iterator __position, size_type __n, bool __x)<span class="lineNum">     706 </span>            :     {<span class="lineNum">     707 </span>            :       if (__n == 0)<span class="lineNum">     708 </span>            :         return;<span class="lineNum">     709 </span>            :       if (capacity() - size() &gt;= __n)<span class="lineNum">     710 </span>            :         {<span class="lineNum">     711 </span>            :           std::copy_backward(__position, end(),<span class="lineNum">     712 </span>            :                              this-&gt;_M_impl._M_finish + difference_type(__n));<span class="lineNum">     713 </span>            :           std::fill(__position, __position + difference_type(__n), __x);<span class="lineNum">     714 </span>            :           this-&gt;_M_impl._M_finish += difference_type(__n);<span class="lineNum">     715 </span>            :         }<span class="lineNum">     716 </span>            :       else<span class="lineNum">     717 </span>            :         {<span class="lineNum">     718 </span>            :           const size_type __len = <span class="lineNum">     719 </span>            :             _M_check_len(__n, &quot;vector&lt;bool&gt;::_M_fill_insert&quot;);<span class="lineNum">     720 </span>            :           _Bit_type * __q = this-&gt;_M_allocate(__len);<span class="lineNum">     721 </span>            :           iterator __i = _M_copy_aligned(begin(), __position,<span class="lineNum">     722 </span>            :                                          iterator(__q, 0));<span class="lineNum">     723 </span>            :           std::fill(__i, __i + difference_type(__n), __x);<span class="lineNum">     724 </span>            :           this-&gt;_M_impl._M_finish = std::copy(__position, end(),<span class="lineNum">     725 </span>            :                                               __i + difference_type(__n));<span class="lineNum">     726 </span>            :           this-&gt;_M_deallocate();<span class="lineNum">     727 </span>            :           this-&gt;_M_impl._M_end_of_storage = __q + _S_nword(__len);<span class="lineNum">     728 </span>            :           this-&gt;_M_impl._M_start = iterator(__q, 0);<span class="lineNum">     729 </span>            :         }<span class="lineNum">     730 </span>            :     }<span class="lineNum">     731 </span>            : <span class="lineNum">     732 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     733 </span>            :     template&lt;typename _ForwardIterator&gt;<span class="lineNum">     734 </span>            :       void<span class="lineNum">     735 </span>            :       vector&lt;bool, _Alloc&gt;::<span class="lineNum">     736 </span>            :       _M_insert_range(iterator __position, _ForwardIterator __first, <span class="lineNum">     737 </span>            :                       _ForwardIterator __last, std::forward_iterator_tag)<span class="lineNum">     738 </span>            :       {<span class="lineNum">     739 </span>            :         if (__first != __last)<span class="lineNum">     740 </span>            :           {<span class="lineNum">     741 </span>            :             size_type __n = std::distance(__first, __last);<span class="lineNum">     742 </span>            :             if (capacity() - size() &gt;= __n)<span class="lineNum">     743 </span>            :               {<span class="lineNum">     744 </span>            :                 std::copy_backward(__position, end(),<span class="lineNum">     745 </span>            :                                    this-&gt;_M_impl._M_finish<span class="lineNum">     746 </span>            :                                    + difference_type(__n));<span class="lineNum">     747 </span>            :                 std::copy(__first, __last, __position);<span class="lineNum">     748 </span>            :                 this-&gt;_M_impl._M_finish += difference_type(__n);<span class="lineNum">     749 </span>            :               }<span class="lineNum">     750 </span>            :             else<span class="lineNum">     751 </span>            :               {<span class="lineNum">     752 </span>            :                 const size_type __len =<span class="lineNum">     753 </span>            :                   _M_check_len(__n, &quot;vector&lt;bool&gt;::_M_insert_range&quot;);<span class="lineNum">     754 </span>            :                 _Bit_type * __q = this-&gt;_M_allocate(__len);<span class="lineNum">     755 </span>            :                 iterator __i = _M_copy_aligned(begin(), __position,<span class="lineNum">     756 </span>            :                                                iterator(__q, 0));<span class="lineNum">     757 </span>            :                 __i = std::copy(__first, __last, __i);<span class="lineNum">     758 </span>            :                 this-&gt;_M_impl._M_finish = std::copy(__position, end(), __i);<span class="lineNum">     759 </span>            :                 this-&gt;_M_deallocate();<span class="lineNum">     760 </span>            :                 this-&gt;_M_impl._M_end_of_storage = __q + _S_nword(__len);<span class="lineNum">     761 </span>            :                 this-&gt;_M_impl._M_start = iterator(__q, 0);<span class="lineNum">     762 </span>            :               }<span class="lineNum">     763 </span>            :           }<span class="lineNum">     764 </span>            :       }<span class="lineNum">     765 </span>            : <span class="lineNum">     766 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     767 </span>            :     void<span class="lineNum">     768 </span>            :     vector&lt;bool, _Alloc&gt;::<span class="lineNum">     769 </span>            :     _M_insert_aux(iterator __position, bool __x)<span class="lineNum">     770 </span>            :     {<span class="lineNum">     771 </span>            :       if (this-&gt;_M_impl._M_finish._M_p != this-&gt;_M_impl._M_end_of_storage)<span class="lineNum">     772 </span>            :         {<span class="lineNum">     773 </span>            :           std::copy_backward(__position, this-&gt;_M_impl._M_finish, <span class="lineNum">     774 </span>            :                              this-&gt;_M_impl._M_finish + 1);<span class="lineNum">     775 </span>            :           *__position = __x;<span class="lineNum">     776 </span>            :           ++this-&gt;_M_impl._M_finish;<span class="lineNum">     777 </span>            :         }<span class="lineNum">     778 </span>            :       else<span class="lineNum">     779 </span>            :         {<span class="lineNum">     780 </span>            :           const size_type __len =<span class="lineNum">     781 </span>            :             _M_check_len(size_type(1), &quot;vector&lt;bool&gt;::_M_insert_aux&quot;);<span class="lineNum">     782 </span>            :           _Bit_type * __q = this-&gt;_M_allocate(__len);<span class="lineNum">     783 </span>            :           iterator __i = _M_copy_aligned(begin(), __position,<span class="lineNum">     784 </span>            :                                          iterator(__q, 0));<span class="lineNum">     785 </span>            :           *__i++ = __x;<span class="lineNum">     786 </span>            :           this-&gt;_M_impl._M_finish = std::copy(__position, end(), __i);<span class="lineNum">     787 </span>            :           this-&gt;_M_deallocate();<span class="lineNum">     788 </span>            :           this-&gt;_M_impl._M_end_of_storage = __q + _S_nword(__len);<span class="lineNum">     789 </span>            :           this-&gt;_M_impl._M_start = iterator(__q, 0);<span class="lineNum">     790 </span>            :         }<span class="lineNum">     791 </span>            :     }<span class="lineNum">     792 </span>            : <span class="lineNum">     793 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     794 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     795 </span>            :     bool<span class="lineNum">     796 </span>            :     vector&lt;bool, _Alloc&gt;::<span class="lineNum">     797 </span>            :     _M_shrink_to_fit()<span class="lineNum">     798 </span>            :     {<span class="lineNum">     799 </span>            :       if (capacity() - size() &lt; int(_S_word_bit))<span class="lineNum">     800 </span>            :         return false;<span class="lineNum">     801 </span>            :       __try<span class="lineNum">     802 </span>            :         {<span class="lineNum">     803 </span>            :           _M_reallocate(size());<span class="lineNum">     804 </span>            :           return true;<span class="lineNum">     805 </span>            :         }<span class="lineNum">     806 </span>            :       __catch(...)<span class="lineNum">     807 </span>            :         { return false; }<span class="lineNum">     808 </span>            :     }<span class="lineNum">     809 </span>            : #endif<span class="lineNum">     810 </span>            : <span class="lineNum">     811 </span>            : _GLIBCXX_END_NAMESPACE_CONTAINER<span class="lineNum">     812 </span>            : } // namespace std<span class="lineNum">     813 </span>            : <span class="lineNum">     814 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     815 </span>            : <span class="lineNum">     816 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">     817 </span>            : {<span class="lineNum">     818 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">     819 </span>            : <span class="lineNum">     820 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     821 </span>            :     size_t<span class="lineNum">     822 </span>            :     hash&lt;_GLIBCXX_STD_C::vector&lt;bool, _Alloc&gt;&gt;::<span class="lineNum">     823 </span>            :     operator()(const _GLIBCXX_STD_C::vector&lt;bool, _Alloc&gt;&amp; __b) const noexcept<span class="lineNum">     824 </span>            :     {<span class="lineNum">     825 </span>            :       size_t __hash = 0;<span class="lineNum">     826 </span>            :       using _GLIBCXX_STD_C::_S_word_bit;<span class="lineNum">     827 </span>            :       using _GLIBCXX_STD_C::_Bit_type;<span class="lineNum">     828 </span>            : <span class="lineNum">     829 </span>            :       const size_t __words = __b.size() / _S_word_bit;<span class="lineNum">     830 </span>            :       if (__words)<span class="lineNum">     831 </span>            :         {<span class="lineNum">     832 </span>            :           const size_t __clength = __words * sizeof(_Bit_type);<span class="lineNum">     833 </span>            :           __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);<span class="lineNum">     834 </span>            :         }<span class="lineNum">     835 </span>            : <span class="lineNum">     836 </span>            :       const size_t __extrabits = __b.size() % _S_word_bit;<span class="lineNum">     837 </span>            :       if (__extrabits)<span class="lineNum">     838 </span>            :         {<span class="lineNum">     839 </span>            :           _Bit_type __hiword = *__b._M_impl._M_finish._M_p;<span class="lineNum">     840 </span>            :           __hiword &amp;= ~((~static_cast&lt;_Bit_type&gt;(0)) &lt;&lt; __extrabits);<span class="lineNum">     841 </span>            : <span class="lineNum">     842 </span>            :           const size_t __clength<span class="lineNum">     843 </span>            :             = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;<span class="lineNum">     844 </span>            :           if (__words)<span class="lineNum">     845 </span>            :             __hash = std::_Hash_impl::hash(&amp;__hiword, __clength, __hash);<span class="lineNum">     846 </span>            :           else<span class="lineNum">     847 </span>            :             __hash = std::_Hash_impl::hash(&amp;__hiword, __clength);<span class="lineNum">     848 </span>            :         }<span class="lineNum">     849 </span>            : <span class="lineNum">     850 </span>            :       return __hash;<span class="lineNum">     851 </span>            :     }<span class="lineNum">     852 </span>            : <span class="lineNum">     853 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     854 </span>            : } // namespace std<span class="lineNum">     855 </span>            : <span class="lineNum">     856 </span>            : #endif // C++11<span class="lineNum">     857 </span>            : <span class="lineNum">     858 </span>            : #endif /* _VECTOR_TCC */</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/vector.tcc.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/vector.tcc - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - vector.tcc<span style="font-size: 80%;"> (<a href="vector.tcc.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">53</td>            <td class="headerCovTableEntry">92</td>            <td class="headerCovTableEntryLo">57.6 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="vector.tcc.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#89">_ZNSt6vectorIdSaIdEE12emplace_backIIdEEEvDpOT_</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#216">_ZNSt6vectorIdSaIdEE14_M_fill_assignEmRKd</a></td>              <td class="coverFnHi">60</td>            </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#439">_ZNSt6vectorIdSaIdEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPdS1_EEmRKd</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#397">_ZNSt6vectorIdSaIdEE19_M_emplace_back_auxIIRKdEEEvDpOT_</a></td>              <td class="coverFnHi">27</td>            </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#397">_ZNSt6vectorIdSaIdEE19_M_emplace_back_auxIIdEEEvDpOT_</a></td>              <td class="coverFnHi">18</td>            </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#216">_ZNSt6vectorIiSaIiEE14_M_fill_assignEmRKi</a></td>              <td class="coverFnHi">10</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/vector.tcc.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/vector.tcc - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - vector.tcc<span style="font-size: 80%;"> (<a href="vector.tcc.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">53</td>            <td class="headerCovTableEntry">92</td>            <td class="headerCovTableEntryLo">57.6 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="vector.tcc.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#439">_ZNSt6vectorIdSaIdEE14_M_fill_insertEN9__gnu_cxx17__normal_iteratorIPdS1_EEmRKd</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#216">_ZNSt6vectorIiSaIiEE14_M_fill_assignEmRKi</a></td>              <td class="coverFnHi">10</td>            </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#397">_ZNSt6vectorIdSaIdEE19_M_emplace_back_auxIIdEEEvDpOT_</a></td>              <td class="coverFnHi">18</td>            </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#397">_ZNSt6vectorIdSaIdEE19_M_emplace_back_auxIIRKdEEEvDpOT_</a></td>              <td class="coverFnHi">27</td>            </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#216">_ZNSt6vectorIdSaIdEE14_M_fill_assignEmRKd</a></td>              <td class="coverFnHi">60</td>            </tr>    <tr>              <td class="coverFn"><a href="vector.tcc.gcov.html#89">_ZNSt6vectorIdSaIdEE12emplace_backIIdEEEvDpOT_</a></td>              <td class="coverFnHi">392</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/vector.tcc.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_vector.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_vector.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_vector.h<span style="font-size: 80%;"> (source / <a href="stl_vector.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">83</td>            <td class="headerCovTableEntry">96</td>            <td class="headerCovTableEntryMed">86.5 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">44</td>            <td class="headerCovTableEntry">50</td>            <td class="headerCovTableEntryMed">88.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Vector implementation -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2001-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /*<span class="lineNum">      26 </span>            :  *<span class="lineNum">      27 </span>            :  * Copyright (c) 1994<span class="lineNum">      28 </span>            :  * Hewlett-Packard Company<span class="lineNum">      29 </span>            :  *<span class="lineNum">      30 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      31 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      32 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      33 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      34 </span>            :  * in supporting documentation.  Hewlett-Packard Company makes no<span class="lineNum">      35 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      36 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      37 </span>            :  *<span class="lineNum">      38 </span>            :  *<span class="lineNum">      39 </span>            :  * Copyright (c) 1996<span class="lineNum">      40 </span>            :  * Silicon Graphics Computer Systems, Inc.<span class="lineNum">      41 </span>            :  *<span class="lineNum">      42 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      43 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      44 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      45 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      46 </span>            :  * in supporting documentation.  Silicon Graphics makes no<span class="lineNum">      47 </span>            :  * representations about the suitability of this  software for any<span class="lineNum">      48 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      49 </span>            :  */<span class="lineNum">      50 </span>            : <span class="lineNum">      51 </span>            : /** @file bits/stl_vector.h<span class="lineNum">      52 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      53 </span>            :  *  Do not attempt to use it directly. @headername{vector}<span class="lineNum">      54 </span>            :  */<span class="lineNum">      55 </span>            : <span class="lineNum">      56 </span>            : #ifndef _STL_VECTOR_H<span class="lineNum">      57 </span>            : #define _STL_VECTOR_H 1<span class="lineNum">      58 </span>            : <span class="lineNum">      59 </span>            : #include &lt;bits/stl_iterator_base_funcs.h&gt;<span class="lineNum">      60 </span>            : #include &lt;bits/functexcept.h&gt;<span class="lineNum">      61 </span>            : #include &lt;bits/concept_check.h&gt;<span class="lineNum">      62 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      63 </span>            : #include &lt;initializer_list&gt;<span class="lineNum">      64 </span>            : #endif<span class="lineNum">      65 </span>            : <span class="lineNum">      66 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      67 </span>            : {<span class="lineNum">      68 </span>            : _GLIBCXX_BEGIN_NAMESPACE_CONTAINER<span class="lineNum">      69 </span>            : <span class="lineNum">      70 </span>            :   /// See bits/stl_deque.h's _Deque_base for an explanation.<span class="lineNum">      71 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">      72 </span>            :     struct _Vector_base<span class="lineNum">      73 </span>            :     {<span class="lineNum">      74 </span>            :       typedef typename __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::template<span class="lineNum">      75 </span>            :         rebind&lt;_Tp&gt;::other _Tp_alloc_type;<span class="lineNum">      76 </span>            :       typedef typename __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;::pointer<a name="77"><span class="lineNum">      77 </span>            :         pointer;</a><span class="lineNum">      78 </span>            : <span class="lineNum">      79 </span><span class="lineCov">         36 :       struct _Vector_impl </span><span class="lineNum">      80 </span>            :       : public _Tp_alloc_type<span class="lineNum">      81 </span>            :       {<span class="lineNum">      82 </span>            :         pointer _M_start;<span class="lineNum">      83 </span>            :         pointer _M_finish;<span class="lineNum">      84 </span>            :         pointer _M_end_of_storage;<span class="lineNum">      85 </span>            : <span class="lineNum">      86 </span>            :         _Vector_impl()<span class="lineNum">      87 </span>            :         : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)<a name="88"><span class="lineNum">      88 </span>            :         { }</a><span class="lineNum">      89 </span>            : <span class="lineNum">      90 </span><span class="lineCov">         36 :         _Vector_impl(_Tp_alloc_type const&amp; __a)</span><span class="lineNum">      91 </span><span class="lineCov">         36 :         : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)</span><span class="lineNum">      92 </span><span class="lineCov">         36 :         { }</span><span class="lineNum">      93 </span>            : <span class="lineNum">      94 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      95 </span>            :         _Vector_impl(_Tp_alloc_type&amp;&amp; __a)<span class="lineNum">      96 </span>            :         : _Tp_alloc_type(std::move(__a)),<span class="lineNum">      97 </span>            :           _M_start(0), _M_finish(0), _M_end_of_storage(0)<span class="lineNum">      98 </span>            :         { }<a name="99"><span class="lineNum">      99 </span>            : #endif</a><span class="lineNum">     100 </span>            : <span class="lineNum">     101 </span><span class="lineNoCov">          0 :         void _M_swap_data(_Vector_impl&amp; __x)</span><span class="lineNum">     102 </span>            :         {<span class="lineNum">     103 </span><span class="lineNoCov">          0 :           std::swap(_M_start, __x._M_start);</span><span class="lineNum">     104 </span><span class="lineNoCov">          0 :           std::swap(_M_finish, __x._M_finish);</span><span class="lineNum">     105 </span><span class="lineNoCov">          0 :           std::swap(_M_end_of_storage, __x._M_end_of_storage);</span><span class="lineNum">     106 </span><span class="lineNoCov">          0 :         }</span><span class="lineNum">     107 </span>            :       };<span class="lineNum">     108 </span>            :       <span class="lineNum">     109 </span>            :     public:<span class="lineNum">     110 </span>            :       typedef _Alloc allocator_type;<a name="111"><span class="lineNum">     111 </span>            : </a><span class="lineNum">     112 </span>            :       _Tp_alloc_type&amp;<span class="lineNum">     113 </span><span class="lineCov">        400 :       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT</span><span class="lineNum">     114 </span><span class="lineCov">        400 :       { return *static_cast&lt;_Tp_alloc_type*&gt;(&amp;this-&gt;_M_impl); }</span><a name="115"><span class="lineNum">     115 </span>            : </a><span class="lineNum">     116 </span>            :       const _Tp_alloc_type&amp;<span class="lineNum">     117 </span><span class="lineCov">        184 :       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT</span><span class="lineNum">     118 </span><span class="lineCov">        184 :       { return *static_cast&lt;const _Tp_alloc_type*&gt;(&amp;this-&gt;_M_impl); }</span><span class="lineNum">     119 </span>            : <span class="lineNum">     120 </span>            :       allocator_type<span class="lineNum">     121 </span>            :       get_allocator() const _GLIBCXX_NOEXCEPT<span class="lineNum">     122 </span>            :       { return allocator_type(_M_get_Tp_allocator()); }<span class="lineNum">     123 </span>            : <span class="lineNum">     124 </span>            :       _Vector_base()<span class="lineNum">     125 </span>            :       : _M_impl() { }<span class="lineNum">     126 </span>            : <span class="lineNum">     127 </span>            :       _Vector_base(const allocator_type&amp; __a)<span class="lineNum">     128 </span>            :       : _M_impl(__a) { }<span class="lineNum">     129 </span>            : <span class="lineNum">     130 </span>            :       _Vector_base(size_t __n)<span class="lineNum">     131 </span>            :       : _M_impl()<a name="132"><span class="lineNum">     132 </span>            :       { _M_create_storage(__n); }</a><span class="lineNum">     133 </span>            : <span class="lineNum">     134 </span><span class="lineCov">         36 :       _Vector_base(size_t __n, const allocator_type&amp; __a)</span><span class="lineNum">     135 </span><span class="lineCov">         36 :       : _M_impl(__a)</span><span class="lineNum">     136 </span><span class="lineCov">         36 :       { _M_create_storage(__n); }</span><span class="lineNum">     137 </span>            : <span class="lineNum">     138 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     139 </span>            :       _Vector_base(_Tp_alloc_type&amp;&amp; __a)<span class="lineNum">     140 </span>            :       : _M_impl(std::move(__a)) { }<span class="lineNum">     141 </span>            : <span class="lineNum">     142 </span>            :       _Vector_base(_Vector_base&amp;&amp; __x)<span class="lineNum">     143 </span>            :       : _M_impl(std::move(__x._M_get_Tp_allocator()))<span class="lineNum">     144 </span>            :       { this-&gt;_M_impl._M_swap_data(__x._M_impl); }<span class="lineNum">     145 </span>            : <span class="lineNum">     146 </span>            :       _Vector_base(_Vector_base&amp;&amp; __x, const allocator_type&amp; __a)<span class="lineNum">     147 </span>            :       : _M_impl(__a)<span class="lineNum">     148 </span>            :       {<span class="lineNum">     149 </span>            :         if (__x.get_allocator() == __a)<span class="lineNum">     150 </span>            :           this-&gt;_M_impl._M_swap_data(__x._M_impl);<span class="lineNum">     151 </span>            :         else<span class="lineNum">     152 </span>            :           {<span class="lineNum">     153 </span>            :             size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;<span class="lineNum">     154 </span>            :             _M_create_storage(__n);<span class="lineNum">     155 </span>            :           }<span class="lineNum">     156 </span>            :       }<a name="157"><span class="lineNum">     157 </span>            : #endif</a><span class="lineNum">     158 </span>            : <span class="lineNum">     159 </span><span class="lineCov">         36 :       ~_Vector_base()</span><span class="lineNum">     160 </span><span class="lineCov">         36 :       { _M_deallocate(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_end_of_storage</span><span class="lineNum">     161 </span><span class="lineCov">         72 :                       - this-&gt;_M_impl._M_start); }</span><span class="lineNum">     162 </span>            : <span class="lineNum">     163 </span>            :     public:<span class="lineNum">     164 </span>            :       _Vector_impl _M_impl;<a name="165"><span class="lineNum">     165 </span>            : </a><span class="lineNum">     166 </span>            :       pointer<span class="lineNum">     167 </span><span class="lineCov">        128 :       _M_allocate(size_t __n)</span><span class="lineNum">     168 </span><span class="lineCov">        128 :       { return __n != 0 ? _M_impl.allocate(__n) : 0; }</span><a name="169"><span class="lineNum">     169 </span>            : </a><span class="lineNum">     170 </span>            :       void<span class="lineNum">     171 </span><span class="lineCov">        128 :       _M_deallocate(pointer __p, size_t __n)</span><span class="lineNum">     172 </span>            :       {<span class="lineNum">     173 </span><span class="lineCov">        128 :         if (__p)</span><span class="lineNum">     174 </span><span class="lineCov">        116 :           _M_impl.deallocate(__p, __n);</span><span class="lineNum">     175 </span><span class="lineCov">        128 :       }</span><span class="lineNum">     176 </span>            : <a name="177"><span class="lineNum">     177 </span>            :     private:</a><span class="lineNum">     178 </span>            :       void<span class="lineNum">     179 </span><span class="lineCov">         36 :       _M_create_storage(size_t __n)</span><span class="lineNum">     180 </span>            :       {<span class="lineNum">     181 </span><span class="lineCov">         36 :         this-&gt;_M_impl._M_start = this-&gt;_M_allocate(__n);</span><span class="lineNum">     182 </span><span class="lineCov">         36 :         this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_start;</span><span class="lineNum">     183 </span><span class="lineCov">         36 :         this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __n;</span><span class="lineNum">     184 </span><span class="lineCov">         36 :       }</span><span class="lineNum">     185 </span>            :     };<span class="lineNum">     186 </span>            : <span class="lineNum">     187 </span>            : <span class="lineNum">     188 </span>            :   /**<span class="lineNum">     189 </span>            :    *  @brief A standard container which offers fixed time access to<span class="lineNum">     190 </span>            :    *  individual elements in any order.<span class="lineNum">     191 </span>            :    *<span class="lineNum">     192 </span>            :    *  @ingroup sequences<span class="lineNum">     193 </span>            :    *<span class="lineNum">     194 </span>            :    *  @tparam _Tp  Type of element.<span class="lineNum">     195 </span>            :    *  @tparam _Alloc  Allocator type, defaults to allocator&lt;_Tp&gt;.<span class="lineNum">     196 </span>            :    *<span class="lineNum">     197 </span>            :    *  Meets the requirements of a &lt;a href=&quot;tables.html#65&quot;&gt;container&lt;/a&gt;, a<span class="lineNum">     198 </span>            :    *  &lt;a href=&quot;tables.html#66&quot;&gt;reversible container&lt;/a&gt;, and a<span class="lineNum">     199 </span>            :    *  &lt;a href=&quot;tables.html#67&quot;&gt;sequence&lt;/a&gt;, including the<span class="lineNum">     200 </span>            :    *  &lt;a href=&quot;tables.html#68&quot;&gt;optional sequence requirements&lt;/a&gt; with the<span class="lineNum">     201 </span>            :    *  %exception of @c push_front and @c pop_front.<span class="lineNum">     202 </span>            :    *<span class="lineNum">     203 </span>            :    *  In some terminology a %vector can be described as a dynamic<span class="lineNum">     204 </span>            :    *  C-style array, it offers fast and efficient access to individual<span class="lineNum">     205 </span>            :    *  elements in any order and saves the user from worrying about<span class="lineNum">     206 </span>            :    *  memory and size allocation.  Subscripting ( @c [] ) access is<span class="lineNum">     207 </span>            :    *  also provided as with C-style arrays.<span class="lineNum">     208 </span>            :   */<span class="lineNum">     209 </span>            :   template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;<span class="lineNum">     210 </span>            :     class vector : protected _Vector_base&lt;_Tp, _Alloc&gt;<span class="lineNum">     211 </span>            :     {<span class="lineNum">     212 </span>            :       // Concept requirements.<span class="lineNum">     213 </span>            :       typedef typename _Alloc::value_type                _Alloc_value_type;<span class="lineNum">     214 </span>            :       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)<span class="lineNum">     215 </span>            :       __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)<span class="lineNum">     216 </span>            :       <span class="lineNum">     217 </span>            :       typedef _Vector_base&lt;_Tp, _Alloc&gt;                    _Base;<span class="lineNum">     218 </span>            :       typedef typename _Base::_Tp_alloc_type             _Tp_alloc_type;<span class="lineNum">     219 </span>            :       typedef __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;  _Alloc_traits;<span class="lineNum">     220 </span>            : <span class="lineNum">     221 </span>            :     public:<span class="lineNum">     222 </span>            :       typedef _Tp                                        value_type;<span class="lineNum">     223 </span>            :       typedef typename _Base::pointer                    pointer;<span class="lineNum">     224 </span>            :       typedef typename _Alloc_traits::const_pointer      const_pointer;<span class="lineNum">     225 </span>            :       typedef typename _Alloc_traits::reference          reference;<span class="lineNum">     226 </span>            :       typedef typename _Alloc_traits::const_reference    const_reference;<span class="lineNum">     227 </span>            :       typedef __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator;<span class="lineNum">     228 </span>            :       typedef __gnu_cxx::__normal_iterator&lt;const_pointer, vector&gt;<span class="lineNum">     229 </span>            :       const_iterator;<span class="lineNum">     230 </span>            :       typedef std::reverse_iterator&lt;const_iterator&gt;  const_reverse_iterator;<span class="lineNum">     231 </span>            :       typedef std::reverse_iterator&lt;iterator&gt;              reverse_iterator;<span class="lineNum">     232 </span>            :       typedef size_t                                     size_type;<span class="lineNum">     233 </span>            :       typedef ptrdiff_t                                  difference_type;<span class="lineNum">     234 </span>            :       typedef _Alloc                                     allocator_type;<span class="lineNum">     235 </span>            : <span class="lineNum">     236 </span>            :     protected:<span class="lineNum">     237 </span>            :       using _Base::_M_allocate;<span class="lineNum">     238 </span>            :       using _Base::_M_deallocate;<span class="lineNum">     239 </span>            :       using _Base::_M_impl;<span class="lineNum">     240 </span>            :       using _Base::_M_get_Tp_allocator;<span class="lineNum">     241 </span>            : <span class="lineNum">     242 </span>            :     public:<span class="lineNum">     243 </span>            :       // [23.2.4.1] construct/copy/destroy<span class="lineNum">     244 </span>            :       // (assign() and get_allocator() are also listed in this section)<span class="lineNum">     245 </span>            :       /**<span class="lineNum">     246 </span>            :        *  @brief  Default constructor creates no elements.<span class="lineNum">     247 </span>            :        */<span class="lineNum">     248 </span>            :       vector()<span class="lineNum">     249 </span>            :       : _Base() { }<span class="lineNum">     250 </span>            : <span class="lineNum">     251 </span>            :       /**<span class="lineNum">     252 </span>            :        *  @brief  Creates a %vector with no elements.<span class="lineNum">     253 </span>            :        *  @param  __a  An allocator object.<span class="lineNum">     254 </span>            :        */<span class="lineNum">     255 </span>            :       explicit<span class="lineNum">     256 </span>            :       vector(const allocator_type&amp; __a)<span class="lineNum">     257 </span>            :       : _Base(__a) { }<span class="lineNum">     258 </span>            : <span class="lineNum">     259 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     260 </span>            :       /**<span class="lineNum">     261 </span>            :        *  @brief  Creates a %vector with default constructed elements.<span class="lineNum">     262 </span>            :        *  @param  __n  The number of elements to initially create.<span class="lineNum">     263 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     264 </span>            :        *<span class="lineNum">     265 </span>            :        *  This constructor fills the %vector with @a __n default<span class="lineNum">     266 </span>            :        *  constructed elements.<a name="267"><span class="lineNum">     267 </span>            :        */</a><span class="lineNum">     268 </span>            :       explicit<span class="lineNum">     269 </span><span class="lineCov">         12 :       vector(size_type __n, const allocator_type&amp; __a = allocator_type())</span><span class="lineNum">     270 </span><span class="lineCov">         12 :       : _Base(__n, __a)</span><span class="lineNum">     271 </span><span class="lineCov">         12 :       { _M_default_initialize(__n); }</span><span class="lineNum">     272 </span>            : <span class="lineNum">     273 </span>            :       /**<span class="lineNum">     274 </span>            :        *  @brief  Creates a %vector with copies of an exemplar element.<span class="lineNum">     275 </span>            :        *  @param  __n  The number of elements to initially create.<span class="lineNum">     276 </span>            :        *  @param  __value  An element to copy.<span class="lineNum">     277 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     278 </span>            :        *<a name="279"><span class="lineNum">     279 </span>            :        *  This constructor fills the %vector with @a __n copies of @a __value.</a><span class="lineNum">     280 </span>            :        */<span class="lineNum">     281 </span><span class="lineCov">         24 :       vector(size_type __n, const value_type&amp; __value,</span><span class="lineNum">     282 </span>            :              const allocator_type&amp; __a = allocator_type())<span class="lineNum">     283 </span><span class="lineCov">         24 :       : _Base(__n, __a)</span><span class="lineNum">     284 </span><span class="lineCov">         24 :       { _M_fill_initialize(__n, __value); }</span><span class="lineNum">     285 </span>            : #else<span class="lineNum">     286 </span>            :       /**<span class="lineNum">     287 </span>            :        *  @brief  Creates a %vector with copies of an exemplar element.<span class="lineNum">     288 </span>            :        *  @param  __n  The number of elements to initially create.<span class="lineNum">     289 </span>            :        *  @param  __value  An element to copy.<span class="lineNum">     290 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     291 </span>            :        *<span class="lineNum">     292 </span>            :        *  This constructor fills the %vector with @a __n copies of @a __value.<span class="lineNum">     293 </span>            :        */<span class="lineNum">     294 </span>            :       explicit<span class="lineNum">     295 </span>            :       vector(size_type __n, const value_type&amp; __value = value_type(),<span class="lineNum">     296 </span>            :              const allocator_type&amp; __a = allocator_type())<span class="lineNum">     297 </span>            :       : _Base(__n, __a)<span class="lineNum">     298 </span>            :       { _M_fill_initialize(__n, __value); }<span class="lineNum">     299 </span>            : #endif<span class="lineNum">     300 </span>            : <span class="lineNum">     301 </span>            :       /**<span class="lineNum">     302 </span>            :        *  @brief  %Vector copy constructor.<span class="lineNum">     303 </span>            :        *  @param  __x  A %vector of identical element and allocator types.<span class="lineNum">     304 </span>            :        *<span class="lineNum">     305 </span>            :        *  The newly-created %vector uses a copy of the allocation<span class="lineNum">     306 </span>            :        *  object used by @a __x.  All the elements of @a __x are copied,<span class="lineNum">     307 </span>            :        *  but any extra memory in<span class="lineNum">     308 </span>            :        *  @a __x (for fast expansion) will not be copied.<span class="lineNum">     309 </span>            :        */<span class="lineNum">     310 </span>            :       vector(const vector&amp; __x)<span class="lineNum">     311 </span>            :       : _Base(__x.size(),<span class="lineNum">     312 </span>            :         _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))<span class="lineNum">     313 </span>            :       { this-&gt;_M_impl._M_finish =<span class="lineNum">     314 </span>            :           std::__uninitialized_copy_a(__x.begin(), __x.end(),<span class="lineNum">     315 </span>            :                                       this-&gt;_M_impl._M_start,<span class="lineNum">     316 </span>            :                                       _M_get_Tp_allocator());<span class="lineNum">     317 </span>            :       }<span class="lineNum">     318 </span>            : <span class="lineNum">     319 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     320 </span>            :       /**<span class="lineNum">     321 </span>            :        *  @brief  %Vector move constructor.<span class="lineNum">     322 </span>            :        *  @param  __x  A %vector of identical element and allocator types.<span class="lineNum">     323 </span>            :        *<span class="lineNum">     324 </span>            :        *  The newly-created %vector contains the exact contents of @a __x.<span class="lineNum">     325 </span>            :        *  The contents of @a __x are a valid, but unspecified %vector.<span class="lineNum">     326 </span>            :        */<span class="lineNum">     327 </span>            :       vector(vector&amp;&amp; __x) noexcept<span class="lineNum">     328 </span>            :       : _Base(std::move(__x)) { }<span class="lineNum">     329 </span>            : <span class="lineNum">     330 </span>            :       /// Copy constructor with alternative allocator<span class="lineNum">     331 </span>            :       vector(const vector&amp; __x, const allocator_type&amp; __a)<span class="lineNum">     332 </span>            :       : _Base(__x.size(), __a)<span class="lineNum">     333 </span>            :       { this-&gt;_M_impl._M_finish =<span class="lineNum">     334 </span>            :           std::__uninitialized_copy_a(__x.begin(), __x.end(),<span class="lineNum">     335 </span>            :                                       this-&gt;_M_impl._M_start,<span class="lineNum">     336 </span>            :                                       _M_get_Tp_allocator());<span class="lineNum">     337 </span>            :       }<span class="lineNum">     338 </span>            : <span class="lineNum">     339 </span>            :       /// Move constructor with alternative allocator<span class="lineNum">     340 </span>            :       vector(vector&amp;&amp; __rv, const allocator_type&amp; __m)<span class="lineNum">     341 </span>            :       : _Base(std::move(__rv), __m)<span class="lineNum">     342 </span>            :       {<span class="lineNum">     343 </span>            :         if (__rv.get_allocator() != __m)<span class="lineNum">     344 </span>            :           {<span class="lineNum">     345 </span>            :             this-&gt;_M_impl._M_finish =<span class="lineNum">     346 </span>            :               std::__uninitialized_move_a(__rv.begin(), __rv.end(),<span class="lineNum">     347 </span>            :                                           this-&gt;_M_impl._M_start,<span class="lineNum">     348 </span>            :                                           _M_get_Tp_allocator());<span class="lineNum">     349 </span>            :             __rv.clear();<span class="lineNum">     350 </span>            :           }<span class="lineNum">     351 </span>            :       }<span class="lineNum">     352 </span>            : <span class="lineNum">     353 </span>            :       /**<span class="lineNum">     354 </span>            :        *  @brief  Builds a %vector from an initializer list.<span class="lineNum">     355 </span>            :        *  @param  __l  An initializer_list.<span class="lineNum">     356 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     357 </span>            :        *<span class="lineNum">     358 </span>            :        *  Create a %vector consisting of copies of the elements in the<span class="lineNum">     359 </span>            :        *  initializer_list @a __l.<span class="lineNum">     360 </span>            :        *<span class="lineNum">     361 </span>            :        *  This will call the element type's copy constructor N times<span class="lineNum">     362 </span>            :        *  (where N is @a __l.size()) and do no memory reallocation.<span class="lineNum">     363 </span>            :        */<span class="lineNum">     364 </span>            :       vector(initializer_list&lt;value_type&gt; __l,<span class="lineNum">     365 </span>            :              const allocator_type&amp; __a = allocator_type())<span class="lineNum">     366 </span>            :       : _Base(__a)<span class="lineNum">     367 </span>            :       {<span class="lineNum">     368 </span>            :         _M_range_initialize(__l.begin(), __l.end(),<span class="lineNum">     369 </span>            :                             random_access_iterator_tag());<span class="lineNum">     370 </span>            :       }<span class="lineNum">     371 </span>            : #endif<span class="lineNum">     372 </span>            : <span class="lineNum">     373 </span>            :       /**<span class="lineNum">     374 </span>            :        *  @brief  Builds a %vector from a range.<span class="lineNum">     375 </span>            :        *  @param  __first  An input iterator.<span class="lineNum">     376 </span>            :        *  @param  __last  An input iterator.<span class="lineNum">     377 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     378 </span>            :        *<span class="lineNum">     379 </span>            :        *  Create a %vector consisting of copies of the elements from<span class="lineNum">     380 </span>            :        *  [first,last).<span class="lineNum">     381 </span>            :        *<span class="lineNum">     382 </span>            :        *  If the iterators are forward, bidirectional, or<span class="lineNum">     383 </span>            :        *  random-access, then this will call the elements' copy<span class="lineNum">     384 </span>            :        *  constructor N times (where N is distance(first,last)) and do<span class="lineNum">     385 </span>            :        *  no memory reallocation.  But if only input iterators are<span class="lineNum">     386 </span>            :        *  used, then this will do at most 2N calls to the copy<span class="lineNum">     387 </span>            :        *  constructor, and logN memory reallocations.<span class="lineNum">     388 </span>            :        */<span class="lineNum">     389 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     390 </span>            :       template&lt;typename _InputIterator,<span class="lineNum">     391 </span>            :                typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt;<span class="lineNum">     392 </span>            :         vector(_InputIterator __first, _InputIterator __last,<span class="lineNum">     393 </span>            :                const allocator_type&amp; __a = allocator_type())<span class="lineNum">     394 </span>            :         : _Base(__a)<span class="lineNum">     395 </span>            :         { _M_initialize_dispatch(__first, __last, __false_type()); }<span class="lineNum">     396 </span>            : #else<span class="lineNum">     397 </span>            :       template&lt;typename _InputIterator&gt;<span class="lineNum">     398 </span>            :         vector(_InputIterator __first, _InputIterator __last,<span class="lineNum">     399 </span>            :                const allocator_type&amp; __a = allocator_type())<span class="lineNum">     400 </span>            :         : _Base(__a)<span class="lineNum">     401 </span>            :         {<span class="lineNum">     402 </span>            :           // Check whether it's an integral type.  If so, it's not an iterator.<span class="lineNum">     403 </span>            :           typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral;<span class="lineNum">     404 </span>            :           _M_initialize_dispatch(__first, __last, _Integral());<span class="lineNum">     405 </span>            :         }<span class="lineNum">     406 </span>            : #endif<span class="lineNum">     407 </span>            : <span class="lineNum">     408 </span>            :       /**<span class="lineNum">     409 </span>            :        *  The dtor only erases the elements, and note that if the<span class="lineNum">     410 </span>            :        *  elements themselves are pointers, the pointed-to memory is<span class="lineNum">     411 </span>            :        *  not touched in any way.  Managing the pointer is the user's<a name="412"><span class="lineNum">     412 </span>            :        *  responsibility.</a><span class="lineNum">     413 </span>            :        */<span class="lineNum">     414 </span><span class="lineCov">         36 :       ~vector() _GLIBCXX_NOEXCEPT</span><span class="lineNum">     415 </span><span class="lineCov">         36 :       { std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,</span><span class="lineNum">     416 </span><span class="lineCov">         72 :                       _M_get_Tp_allocator()); }</span><span class="lineNum">     417 </span>            : <span class="lineNum">     418 </span>            :       /**<span class="lineNum">     419 </span>            :        *  @brief  %Vector assignment operator.<span class="lineNum">     420 </span>            :        *  @param  __x  A %vector of identical element and allocator types.<span class="lineNum">     421 </span>            :        *<span class="lineNum">     422 </span>            :        *  All the elements of @a __x are copied, but any extra memory in<span class="lineNum">     423 </span>            :        *  @a __x (for fast expansion) will not be copied.  Unlike the<span class="lineNum">     424 </span>            :        *  copy constructor, the allocator object is not copied.<span class="lineNum">     425 </span>            :        */<span class="lineNum">     426 </span>            :       vector&amp;<span class="lineNum">     427 </span>            :       operator=(const vector&amp; __x);<span class="lineNum">     428 </span>            : <span class="lineNum">     429 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     430 </span>            :       /**<span class="lineNum">     431 </span>            :        *  @brief  %Vector move assignment operator.<span class="lineNum">     432 </span>            :        *  @param  __x  A %vector of identical element and allocator types.<span class="lineNum">     433 </span>            :        *<span class="lineNum">     434 </span>            :        *  The contents of @a __x are moved into this %vector (without copying,<span class="lineNum">     435 </span>            :        *  if the allocators permit it).<span class="lineNum">     436 </span>            :        *  @a __x is a valid, but unspecified %vector.<span class="lineNum">     437 </span>            :        */<span class="lineNum">     438 </span>            :       vector&amp;<span class="lineNum">     439 </span>            :       operator=(vector&amp;&amp; __x) noexcept(_Alloc_traits::_S_nothrow_move())<span class="lineNum">     440 </span>            :       {<span class="lineNum">     441 </span>            :         constexpr bool __move_storage =<span class="lineNum">     442 </span>            :           _Alloc_traits::_S_propagate_on_move_assign()<span class="lineNum">     443 </span>            :           || _Alloc_traits::_S_always_equal();<span class="lineNum">     444 </span>            :         _M_move_assign(std::move(__x),<span class="lineNum">     445 </span>            :                        integral_constant&lt;bool, __move_storage&gt;());<span class="lineNum">     446 </span>            :         return *this;<span class="lineNum">     447 </span>            :       }<span class="lineNum">     448 </span>            : <span class="lineNum">     449 </span>            :       /**<span class="lineNum">     450 </span>            :        *  @brief  %Vector list assignment operator.<span class="lineNum">     451 </span>            :        *  @param  __l  An initializer_list.<span class="lineNum">     452 </span>            :        *<span class="lineNum">     453 </span>            :        *  This function fills a %vector with copies of the elements in the<span class="lineNum">     454 </span>            :        *  initializer list @a __l.<span class="lineNum">     455 </span>            :        *<span class="lineNum">     456 </span>            :        *  Note that the assignment completely changes the %vector and<span class="lineNum">     457 </span>            :        *  that the resulting %vector's size is the same as the number<span class="lineNum">     458 </span>            :        *  of elements assigned.  Old data may be lost.<span class="lineNum">     459 </span>            :        */<span class="lineNum">     460 </span>            :       vector&amp;<span class="lineNum">     461 </span>            :       operator=(initializer_list&lt;value_type&gt; __l)<span class="lineNum">     462 </span>            :       {<span class="lineNum">     463 </span>            :         this-&gt;assign(__l.begin(), __l.end());<span class="lineNum">     464 </span>            :         return *this;<span class="lineNum">     465 </span>            :       }<span class="lineNum">     466 </span>            : #endif<span class="lineNum">     467 </span>            : <span class="lineNum">     468 </span>            :       /**<span class="lineNum">     469 </span>            :        *  @brief  Assigns a given value to a %vector.<span class="lineNum">     470 </span>            :        *  @param  __n  Number of elements to be assigned.<span class="lineNum">     471 </span>            :        *  @param  __val  Value to be assigned.<span class="lineNum">     472 </span>            :        *<span class="lineNum">     473 </span>            :        *  This function fills a %vector with @a __n copies of the given<span class="lineNum">     474 </span>            :        *  value.  Note that the assignment completely changes the<span class="lineNum">     475 </span>            :        *  %vector and that the resulting %vector's size is the same as<span class="lineNum">     476 </span>            :        *  the number of elements assigned.  Old data may be lost.<a name="477"><span class="lineNum">     477 </span>            :        */</a><span class="lineNum">     478 </span>            :       void<span class="lineNum">     479 </span><span class="lineCov">        140 :       assign(size_type __n, const value_type&amp; __val)</span><span class="lineNum">     480 </span><span class="lineCov">        140 :       { _M_fill_assign(__n, __val); }</span><span class="lineNum">     481 </span>            : <span class="lineNum">     482 </span>            :       /**<span class="lineNum">     483 </span>            :        *  @brief  Assigns a range to a %vector.<span class="lineNum">     484 </span>            :        *  @param  __first  An input iterator.<span class="lineNum">     485 </span>            :        *  @param  __last   An input iterator.<span class="lineNum">     486 </span>            :        *<span class="lineNum">     487 </span>            :        *  This function fills a %vector with copies of the elements in the<span class="lineNum">     488 </span>            :        *  range [__first,__last).<span class="lineNum">     489 </span>            :        *<span class="lineNum">     490 </span>            :        *  Note that the assignment completely changes the %vector and<span class="lineNum">     491 </span>            :        *  that the resulting %vector's size is the same as the number<span class="lineNum">     492 </span>            :        *  of elements assigned.  Old data may be lost.<span class="lineNum">     493 </span>            :        */<span class="lineNum">     494 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     495 </span>            :       template&lt;typename _InputIterator,<span class="lineNum">     496 </span>            :                typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt;<span class="lineNum">     497 </span>            :         void<span class="lineNum">     498 </span>            :         assign(_InputIterator __first, _InputIterator __last)<span class="lineNum">     499 </span>            :         { _M_assign_dispatch(__first, __last, __false_type()); }<span class="lineNum">     500 </span>            : #else<span class="lineNum">     501 </span>            :       template&lt;typename _InputIterator&gt;<span class="lineNum">     502 </span>            :         void<span class="lineNum">     503 </span>            :         assign(_InputIterator __first, _InputIterator __last)<span class="lineNum">     504 </span>            :         {<span class="lineNum">     505 </span>            :           // Check whether it's an integral type.  If so, it's not an iterator.<span class="lineNum">     506 </span>            :           typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral;<span class="lineNum">     507 </span>            :           _M_assign_dispatch(__first, __last, _Integral());<span class="lineNum">     508 </span>            :         }<span class="lineNum">     509 </span>            : #endif<span class="lineNum">     510 </span>            : <span class="lineNum">     511 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     512 </span>            :       /**<span class="lineNum">     513 </span>            :        *  @brief  Assigns an initializer list to a %vector.<span class="lineNum">     514 </span>            :        *  @param  __l  An initializer_list.<span class="lineNum">     515 </span>            :        *<span class="lineNum">     516 </span>            :        *  This function fills a %vector with copies of the elements in the<span class="lineNum">     517 </span>            :        *  initializer list @a __l.<span class="lineNum">     518 </span>            :        *<span class="lineNum">     519 </span>            :        *  Note that the assignment completely changes the %vector and<span class="lineNum">     520 </span>            :        *  that the resulting %vector's size is the same as the number<span class="lineNum">     521 </span>            :        *  of elements assigned.  Old data may be lost.<span class="lineNum">     522 </span>            :        */<span class="lineNum">     523 </span>            :       void<span class="lineNum">     524 </span>            :       assign(initializer_list&lt;value_type&gt; __l)<span class="lineNum">     525 </span>            :       { this-&gt;assign(__l.begin(), __l.end()); }<span class="lineNum">     526 </span>            : #endif<span class="lineNum">     527 </span>            : <span class="lineNum">     528 </span>            :       /// Get a copy of the memory allocation object.<span class="lineNum">     529 </span>            :       using _Base::get_allocator;<span class="lineNum">     530 </span>            : <span class="lineNum">     531 </span>            :       // iterators<span class="lineNum">     532 </span>            :       /**<span class="lineNum">     533 </span>            :        *  Returns a read/write iterator that points to the first<span class="lineNum">     534 </span>            :        *  element in the %vector.  Iteration is done in ordinary<span class="lineNum">     535 </span>            :        *  element order.<a name="536"><span class="lineNum">     536 </span>            :        */</a><span class="lineNum">     537 </span>            :       iterator<span class="lineNum">     538 </span><span class="lineCov">          2 :       begin() _GLIBCXX_NOEXCEPT</span><span class="lineNum">     539 </span><span class="lineCov">          2 :       { return iterator(this-&gt;_M_impl._M_start); }</span><span class="lineNum">     540 </span>            : <span class="lineNum">     541 </span>            :       /**<span class="lineNum">     542 </span>            :        *  Returns a read-only (constant) iterator that points to the<span class="lineNum">     543 </span>            :        *  first element in the %vector.  Iteration is done in ordinary<span class="lineNum">     544 </span>            :        *  element order.<span class="lineNum">     545 </span>            :        */<span class="lineNum">     546 </span>            :       const_iterator<span class="lineNum">     547 </span>            :       begin() const _GLIBCXX_NOEXCEPT<span class="lineNum">     548 </span>            :       { return const_iterator(this-&gt;_M_impl._M_start); }<span class="lineNum">     549 </span>            : <span class="lineNum">     550 </span>            :       /**<span class="lineNum">     551 </span>            :        *  Returns a read/write iterator that points one past the last<span class="lineNum">     552 </span>            :        *  element in the %vector.  Iteration is done in ordinary<span class="lineNum">     553 </span>            :        *  element order.<a name="554"><span class="lineNum">     554 </span>            :        */</a><span class="lineNum">     555 </span>            :       iterator<span class="lineNum">     556 </span><span class="lineCov">          2 :       end() _GLIBCXX_NOEXCEPT</span><span class="lineNum">     557 </span><span class="lineCov">          2 :       { return iterator(this-&gt;_M_impl._M_finish); }</span><span class="lineNum">     558 </span>            : <span class="lineNum">     559 </span>            :       /**<span class="lineNum">     560 </span>            :        *  Returns a read-only (constant) iterator that points one past<span class="lineNum">     561 </span>            :        *  the last element in the %vector.  Iteration is done in<span class="lineNum">     562 </span>            :        *  ordinary element order.<span class="lineNum">     563 </span>            :        */<span class="lineNum">     564 </span>            :       const_iterator<span class="lineNum">     565 </span>            :       end() const _GLIBCXX_NOEXCEPT<span class="lineNum">     566 </span>            :       { return const_iterator(this-&gt;_M_impl._M_finish); }<span class="lineNum">     567 </span>            : <span class="lineNum">     568 </span>            :       /**<span class="lineNum">     569 </span>            :        *  Returns a read/write reverse iterator that points to the<span class="lineNum">     570 </span>            :        *  last element in the %vector.  Iteration is done in reverse<span class="lineNum">     571 </span>            :        *  element order.<span class="lineNum">     572 </span>            :        */<span class="lineNum">     573 </span>            :       reverse_iterator<span class="lineNum">     574 </span>            :       rbegin() _GLIBCXX_NOEXCEPT<span class="lineNum">     575 </span>            :       { return reverse_iterator(end()); }<span class="lineNum">     576 </span>            : <span class="lineNum">     577 </span>            :       /**<span class="lineNum">     578 </span>            :        *  Returns a read-only (constant) reverse iterator that points<span class="lineNum">     579 </span>            :        *  to the last element in the %vector.  Iteration is done in<span class="lineNum">     580 </span>            :        *  reverse element order.<span class="lineNum">     581 </span>            :        */<span class="lineNum">     582 </span>            :       const_reverse_iterator<span class="lineNum">     583 </span>            :       rbegin() const _GLIBCXX_NOEXCEPT<span class="lineNum">     584 </span>            :       { return const_reverse_iterator(end()); }<span class="lineNum">     585 </span>            : <span class="lineNum">     586 </span>            :       /**<span class="lineNum">     587 </span>            :        *  Returns a read/write reverse iterator that points to one<span class="lineNum">     588 </span>            :        *  before the first element in the %vector.  Iteration is done<span class="lineNum">     589 </span>            :        *  in reverse element order.<span class="lineNum">     590 </span>            :        */<span class="lineNum">     591 </span>            :       reverse_iterator<span class="lineNum">     592 </span>            :       rend() _GLIBCXX_NOEXCEPT<span class="lineNum">     593 </span>            :       { return reverse_iterator(begin()); }<span class="lineNum">     594 </span>            : <span class="lineNum">     595 </span>            :       /**<span class="lineNum">     596 </span>            :        *  Returns a read-only (constant) reverse iterator that points<span class="lineNum">     597 </span>            :        *  to one before the first element in the %vector.  Iteration<span class="lineNum">     598 </span>            :        *  is done in reverse element order.<span class="lineNum">     599 </span>            :        */<span class="lineNum">     600 </span>            :       const_reverse_iterator<span class="lineNum">     601 </span>            :       rend() const _GLIBCXX_NOEXCEPT<span class="lineNum">     602 </span>            :       { return const_reverse_iterator(begin()); }<span class="lineNum">     603 </span>            : <span class="lineNum">     604 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     605 </span>            :       /**<span class="lineNum">     606 </span>            :        *  Returns a read-only (constant) iterator that points to the<span class="lineNum">     607 </span>            :        *  first element in the %vector.  Iteration is done in ordinary<span class="lineNum">     608 </span>            :        *  element order.<span class="lineNum">     609 </span>            :        */<span class="lineNum">     610 </span>            :       const_iterator<span class="lineNum">     611 </span>            :       cbegin() const noexcept<span class="lineNum">     612 </span>            :       { return const_iterator(this-&gt;_M_impl._M_start); }<span class="lineNum">     613 </span>            : <span class="lineNum">     614 </span>            :       /**<span class="lineNum">     615 </span>            :        *  Returns a read-only (constant) iterator that points one past<span class="lineNum">     616 </span>            :        *  the last element in the %vector.  Iteration is done in<span class="lineNum">     617 </span>            :        *  ordinary element order.<span class="lineNum">     618 </span>            :        */<span class="lineNum">     619 </span>            :       const_iterator<span class="lineNum">     620 </span>            :       cend() const noexcept<span class="lineNum">     621 </span>            :       { return const_iterator(this-&gt;_M_impl._M_finish); }<span class="lineNum">     622 </span>            : <span class="lineNum">     623 </span>            :       /**<span class="lineNum">     624 </span>            :        *  Returns a read-only (constant) reverse iterator that points<span class="lineNum">     625 </span>            :        *  to the last element in the %vector.  Iteration is done in<span class="lineNum">     626 </span>            :        *  reverse element order.<span class="lineNum">     627 </span>            :        */<span class="lineNum">     628 </span>            :       const_reverse_iterator<span class="lineNum">     629 </span>            :       crbegin() const noexcept<span class="lineNum">     630 </span>            :       { return const_reverse_iterator(end()); }<span class="lineNum">     631 </span>            : <span class="lineNum">     632 </span>            :       /**<span class="lineNum">     633 </span>            :        *  Returns a read-only (constant) reverse iterator that points<span class="lineNum">     634 </span>            :        *  to one before the first element in the %vector.  Iteration<span class="lineNum">     635 </span>            :        *  is done in reverse element order.<span class="lineNum">     636 </span>            :        */<span class="lineNum">     637 </span>            :       const_reverse_iterator<span class="lineNum">     638 </span>            :       crend() const noexcept<span class="lineNum">     639 </span>            :       { return const_reverse_iterator(begin()); }<span class="lineNum">     640 </span>            : #endif<span class="lineNum">     641 </span>            : <span class="lineNum">     642 </span>            :       // [23.2.4.2] capacity<a name="643"><span class="lineNum">     643 </span>            :       /**  Returns the number of elements in the %vector.  */</a><span class="lineNum">     644 </span>            :       size_type<span class="lineNum">     645 </span><span class="lineCov">        608 :       size() const _GLIBCXX_NOEXCEPT</span><span class="lineNum">     646 </span><span class="lineCov">        608 :       { return size_type(this-&gt;_M_impl._M_finish - this-&gt;_M_impl._M_start); }</span><span class="lineNum">     647 </span>            : <a name="648"><span class="lineNum">     648 </span>            :       /**  Returns the size() of the largest possible %vector.  */</a><span class="lineNum">     649 </span>            :       size_type<span class="lineNum">     650 </span><span class="lineCov">        184 :       max_size() const _GLIBCXX_NOEXCEPT</span><span class="lineNum">     651 </span><span class="lineCov">        184 :       { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }</span><span class="lineNum">     652 </span>            : <span class="lineNum">     653 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     654 </span>            :       /**<span class="lineNum">     655 </span>            :        *  @brief  Resizes the %vector to the specified number of elements.<span class="lineNum">     656 </span>            :        *  @param  __new_size  Number of elements the %vector should contain.<span class="lineNum">     657 </span>            :        *<span class="lineNum">     658 </span>            :        *  This function will %resize the %vector to the specified<span class="lineNum">     659 </span>            :        *  number of elements.  If the number is smaller than the<span class="lineNum">     660 </span>            :        *  %vector's current size the %vector is truncated, otherwise<span class="lineNum">     661 </span>            :        *  default constructed elements are appended.<span class="lineNum">     662 </span>            :        */<span class="lineNum">     663 </span>            :       void<span class="lineNum">     664 </span>            :       resize(size_type __new_size)<span class="lineNum">     665 </span>            :       {<span class="lineNum">     666 </span>            :         if (__new_size &gt; size())<span class="lineNum">     667 </span>            :           _M_default_append(__new_size - size());<span class="lineNum">     668 </span>            :         else if (__new_size &lt; size())<span class="lineNum">     669 </span>            :           _M_erase_at_end(this-&gt;_M_impl._M_start + __new_size);<span class="lineNum">     670 </span>            :       }<span class="lineNum">     671 </span>            : <span class="lineNum">     672 </span>            :       /**<span class="lineNum">     673 </span>            :        *  @brief  Resizes the %vector to the specified number of elements.<span class="lineNum">     674 </span>            :        *  @param  __new_size  Number of elements the %vector should contain.<span class="lineNum">     675 </span>            :        *  @param  __x  Data with which new elements should be populated.<span class="lineNum">     676 </span>            :        *<span class="lineNum">     677 </span>            :        *  This function will %resize the %vector to the specified<span class="lineNum">     678 </span>            :        *  number of elements.  If the number is smaller than the<span class="lineNum">     679 </span>            :        *  %vector's current size the %vector is truncated, otherwise<span class="lineNum">     680 </span>            :        *  the %vector is extended and new elements are populated with<span class="lineNum">     681 </span>            :        *  given data.<a name="682"><span class="lineNum">     682 </span>            :        */</a><span class="lineNum">     683 </span>            :       void<span class="lineNum">     684 </span><span class="lineCov">          2 :       resize(size_type __new_size, const value_type&amp; __x)</span><span class="lineNum">     685 </span>            :       {<span class="lineNum">     686 </span><span class="lineCov">          2 :         if (__new_size &gt; size())</span><span class="lineNum">     687 </span><span class="lineCov">          2 :           insert(end(), __new_size - size(), __x);</span><span class="lineNum">     688 </span><span class="lineNoCov">          0 :         else if (__new_size &lt; size())</span><span class="lineNum">     689 </span><span class="lineNoCov">          0 :           _M_erase_at_end(this-&gt;_M_impl._M_start + __new_size);</span><span class="lineNum">     690 </span><span class="lineCov">          2 :       }</span><span class="lineNum">     691 </span>            : #else<span class="lineNum">     692 </span>            :       /**<span class="lineNum">     693 </span>            :        *  @brief  Resizes the %vector to the specified number of elements.<span class="lineNum">     694 </span>            :        *  @param  __new_size  Number of elements the %vector should contain.<span class="lineNum">     695 </span>            :        *  @param  __x  Data with which new elements should be populated.<span class="lineNum">     696 </span>            :        *<span class="lineNum">     697 </span>            :        *  This function will %resize the %vector to the specified<span class="lineNum">     698 </span>            :        *  number of elements.  If the number is smaller than the<span class="lineNum">     699 </span>            :        *  %vector's current size the %vector is truncated, otherwise<span class="lineNum">     700 </span>            :        *  the %vector is extended and new elements are populated with<span class="lineNum">     701 </span>            :        *  given data.<span class="lineNum">     702 </span>            :        */<span class="lineNum">     703 </span>            :       void<span class="lineNum">     704 </span>            :       resize(size_type __new_size, value_type __x = value_type())<span class="lineNum">     705 </span>            :       {<span class="lineNum">     706 </span>            :         if (__new_size &gt; size())<span class="lineNum">     707 </span>            :           insert(end(), __new_size - size(), __x);<span class="lineNum">     708 </span>            :         else if (__new_size &lt; size())<span class="lineNum">     709 </span>            :           _M_erase_at_end(this-&gt;_M_impl._M_start + __new_size);<span class="lineNum">     710 </span>            :       }<span class="lineNum">     711 </span>            : #endif<span class="lineNum">     712 </span>            : <span class="lineNum">     713 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     714 </span>            :       /**  A non-binding request to reduce capacity() to size().  */<span class="lineNum">     715 </span>            :       void<span class="lineNum">     716 </span>            :       shrink_to_fit()<span class="lineNum">     717 </span>            :       { _M_shrink_to_fit(); }<span class="lineNum">     718 </span>            : #endif<span class="lineNum">     719 </span>            : <span class="lineNum">     720 </span>            :       /**<span class="lineNum">     721 </span>            :        *  Returns the total number of elements that the %vector can<span class="lineNum">     722 </span>            :        *  hold before needing to allocate more memory.<a name="723"><span class="lineNum">     723 </span>            :        */</a><span class="lineNum">     724 </span>            :       size_type<span class="lineNum">     725 </span><span class="lineCov">        140 :       capacity() const _GLIBCXX_NOEXCEPT</span><span class="lineNum">     726 </span>            :       { return size_type(this-&gt;_M_impl._M_end_of_storage<span class="lineNum">     727 </span><span class="lineCov">        140 :                          - this-&gt;_M_impl._M_start); }</span><span class="lineNum">     728 </span>            : <span class="lineNum">     729 </span>            :       /**<span class="lineNum">     730 </span>            :        *  Returns true if the %vector is empty.  (Thus begin() would<span class="lineNum">     731 </span>            :        *  equal end().)<span class="lineNum">     732 </span>            :        */<span class="lineNum">     733 </span>            :       bool<span class="lineNum">     734 </span>            :       empty() const _GLIBCXX_NOEXCEPT<span class="lineNum">     735 </span>            :       { return begin() == end(); }<span class="lineNum">     736 </span>            : <span class="lineNum">     737 </span>            :       /**<span class="lineNum">     738 </span>            :        *  @brief  Attempt to preallocate enough memory for specified number of<span class="lineNum">     739 </span>            :        *          elements.<span class="lineNum">     740 </span>            :        *  @param  __n  Number of elements required.<span class="lineNum">     741 </span>            :        *  @throw  std::length_error  If @a n exceeds @c max_size().<span class="lineNum">     742 </span>            :        *<span class="lineNum">     743 </span>            :        *  This function attempts to reserve enough memory for the<span class="lineNum">     744 </span>            :        *  %vector to hold the specified number of elements.  If the<span class="lineNum">     745 </span>            :        *  number requested is more than max_size(), length_error is<span class="lineNum">     746 </span>            :        *  thrown.<span class="lineNum">     747 </span>            :        *<span class="lineNum">     748 </span>            :        *  The advantage of this function is that if optimal code is a<span class="lineNum">     749 </span>            :        *  necessity and the user can determine the number of elements<span class="lineNum">     750 </span>            :        *  that will be required, the user can reserve the memory in<span class="lineNum">     751 </span>            :        *  %advance, and thus prevent a possible reallocation of memory<span class="lineNum">     752 </span>            :        *  and copying of %vector data.<span class="lineNum">     753 </span>            :        */<span class="lineNum">     754 </span>            :       void<span class="lineNum">     755 </span>            :       reserve(size_type __n);<span class="lineNum">     756 </span>            : <span class="lineNum">     757 </span>            :       // element access<span class="lineNum">     758 </span>            :       /**<span class="lineNum">     759 </span>            :        *  @brief  Subscript access to the data contained in the %vector.<span class="lineNum">     760 </span>            :        *  @param __n The index of the element for which data should be<span class="lineNum">     761 </span>            :        *  accessed.<span class="lineNum">     762 </span>            :        *  @return  Read/write reference to data.<span class="lineNum">     763 </span>            :        *<span class="lineNum">     764 </span>            :        *  This operator allows for easy, array-style, data access.<span class="lineNum">     765 </span>            :        *  Note that data access with this operator is unchecked and<span class="lineNum">     766 </span>            :        *  out_of_range lookups are not defined. (For checked lookups<span class="lineNum">     767 </span>            :        *  see at().)<a name="768"><span class="lineNum">     768 </span>            :        */</a><span class="lineNum">     769 </span>            :       reference<span class="lineNum">     770 </span><span class="lineCov">14511200244 :       operator[](size_type __n)</span><span class="lineNum">     771 </span><span class="lineCov">14511200244 :       { return *(this-&gt;_M_impl._M_start + __n); }</span><span class="lineNum">     772 </span>            : <span class="lineNum">     773 </span>            :       /**<span class="lineNum">     774 </span>            :        *  @brief  Subscript access to the data contained in the %vector.<span class="lineNum">     775 </span>            :        *  @param __n The index of the element for which data should be<span class="lineNum">     776 </span>            :        *  accessed.<span class="lineNum">     777 </span>            :        *  @return  Read-only (constant) reference to data.<span class="lineNum">     778 </span>            :        *<span class="lineNum">     779 </span>            :        *  This operator allows for easy, array-style, data access.<span class="lineNum">     780 </span>            :        *  Note that data access with this operator is unchecked and<span class="lineNum">     781 </span>            :        *  out_of_range lookups are not defined. (For checked lookups<span class="lineNum">     782 </span>            :        *  see at().)<a name="783"><span class="lineNum">     783 </span>            :        */</a><span class="lineNum">     784 </span>            :       const_reference<span class="lineNum">     785 </span><span class="lineCov">       6272 :       operator[](size_type __n) const</span><span class="lineNum">     786 </span><span class="lineCov">       6272 :       { return *(this-&gt;_M_impl._M_start + __n); }</span><span class="lineNum">     787 </span>            : <span class="lineNum">     788 </span>            :     protected:<span class="lineNum">     789 </span>            :       /// Safety check used only from at().<span class="lineNum">     790 </span>            :       void<span class="lineNum">     791 </span>            :       _M_range_check(size_type __n) const<span class="lineNum">     792 </span>            :       {<span class="lineNum">     793 </span>            :         if (__n &gt;= this-&gt;size())<span class="lineNum">     794 </span>            :           __throw_out_of_range(__N(&quot;vector::_M_range_check&quot;));<span class="lineNum">     795 </span>            :       }<span class="lineNum">     796 </span>            : <span class="lineNum">     797 </span>            :     public:<span class="lineNum">     798 </span>            :       /**<span class="lineNum">     799 </span>            :        *  @brief  Provides access to the data contained in the %vector.<span class="lineNum">     800 </span>            :        *  @param __n The index of the element for which data should be<span class="lineNum">     801 </span>            :        *  accessed.<span class="lineNum">     802 </span>            :        *  @return  Read/write reference to data.<span class="lineNum">     803 </span>            :        *  @throw  std::out_of_range  If @a __n is an invalid index.<span class="lineNum">     804 </span>            :        *<span class="lineNum">     805 </span>            :        *  This function provides for safer data access.  The parameter<span class="lineNum">     806 </span>            :        *  is first checked that it is in the range of the vector.  The<span class="lineNum">     807 </span>            :        *  function throws out_of_range if the check fails.<span class="lineNum">     808 </span>            :        */<span class="lineNum">     809 </span>            :       reference<span class="lineNum">     810 </span>            :       at(size_type __n)<span class="lineNum">     811 </span>            :       {<span class="lineNum">     812 </span>            :         _M_range_check(__n);<span class="lineNum">     813 </span>            :         return (*this)[__n]; <span class="lineNum">     814 </span>            :       }<span class="lineNum">     815 </span>            : <span class="lineNum">     816 </span>            :       /**<span class="lineNum">     817 </span>            :        *  @brief  Provides access to the data contained in the %vector.<span class="lineNum">     818 </span>            :        *  @param __n The index of the element for which data should be<span class="lineNum">     819 </span>            :        *  accessed.<span class="lineNum">     820 </span>            :        *  @return  Read-only (constant) reference to data.<span class="lineNum">     821 </span>            :        *  @throw  std::out_of_range  If @a __n is an invalid index.<span class="lineNum">     822 </span>            :        *<span class="lineNum">     823 </span>            :        *  This function provides for safer data access.  The parameter<span class="lineNum">     824 </span>            :        *  is first checked that it is in the range of the vector.  The<span class="lineNum">     825 </span>            :        *  function throws out_of_range if the check fails.<span class="lineNum">     826 </span>            :        */<span class="lineNum">     827 </span>            :       const_reference<span class="lineNum">     828 </span>            :       at(size_type __n) const<span class="lineNum">     829 </span>            :       {<span class="lineNum">     830 </span>            :         _M_range_check(__n);<span class="lineNum">     831 </span>            :         return (*this)[__n];<span class="lineNum">     832 </span>            :       }<span class="lineNum">     833 </span>            : <span class="lineNum">     834 </span>            :       /**<span class="lineNum">     835 </span>            :        *  Returns a read/write reference to the data at the first<span class="lineNum">     836 </span>            :        *  element of the %vector.<span class="lineNum">     837 </span>            :        */<span class="lineNum">     838 </span>            :       reference<span class="lineNum">     839 </span>            :       front()<span class="lineNum">     840 </span>            :       { return *begin(); }<span class="lineNum">     841 </span>            : <span class="lineNum">     842 </span>            :       /**<span class="lineNum">     843 </span>            :        *  Returns a read-only (constant) reference to the data at the first<span class="lineNum">     844 </span>            :        *  element of the %vector.<span class="lineNum">     845 </span>            :        */<span class="lineNum">     846 </span>            :       const_reference<span class="lineNum">     847 </span>            :       front() const<span class="lineNum">     848 </span>            :       { return *begin(); }<span class="lineNum">     849 </span>            : <span class="lineNum">     850 </span>            :       /**<span class="lineNum">     851 </span>            :        *  Returns a read/write reference to the data at the last<span class="lineNum">     852 </span>            :        *  element of the %vector.<span class="lineNum">     853 </span>            :        */<span class="lineNum">     854 </span>            :       reference<span class="lineNum">     855 </span>            :       back()<span class="lineNum">     856 </span>            :       { return *(end() - 1); }<span class="lineNum">     857 </span>            :       <span class="lineNum">     858 </span>            :       /**<span class="lineNum">     859 </span>            :        *  Returns a read-only (constant) reference to the data at the<span class="lineNum">     860 </span>            :        *  last element of the %vector.<span class="lineNum">     861 </span>            :        */<span class="lineNum">     862 </span>            :       const_reference<span class="lineNum">     863 </span>            :       back() const<span class="lineNum">     864 </span>            :       { return *(end() - 1); }<span class="lineNum">     865 </span>            : <span class="lineNum">     866 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     867 </span>            :       // DR 464. Suggestion for new member functions in standard containers.<span class="lineNum">     868 </span>            :       // data access<span class="lineNum">     869 </span>            :       /**<span class="lineNum">     870 </span>            :        *   Returns a pointer such that [data(), data() + size()) is a valid<span class="lineNum">     871 </span>            :        *   range.  For a non-empty %vector, data() == &amp;front().<span class="lineNum">     872 </span>            :        */<span class="lineNum">     873 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     874 </span>            :       _Tp*<span class="lineNum">     875 </span>            : #else<span class="lineNum">     876 </span>            :       pointer<span class="lineNum">     877 </span>            : #endif<span class="lineNum">     878 </span>            :       data() _GLIBCXX_NOEXCEPT<span class="lineNum">     879 </span>            :       { return std::__addressof(front()); }<span class="lineNum">     880 </span>            : <span class="lineNum">     881 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     882 </span>            :       const _Tp*<span class="lineNum">     883 </span>            : #else<span class="lineNum">     884 </span>            :       const_pointer<span class="lineNum">     885 </span>            : #endif<span class="lineNum">     886 </span>            :       data() const _GLIBCXX_NOEXCEPT<span class="lineNum">     887 </span>            :       { return std::__addressof(front()); }<span class="lineNum">     888 </span>            : <span class="lineNum">     889 </span>            :       // [23.2.4.3] modifiers<span class="lineNum">     890 </span>            :       /**<span class="lineNum">     891 </span>            :        *  @brief  Add data to the end of the %vector.<span class="lineNum">     892 </span>            :        *  @param  __x  Data to be added.<span class="lineNum">     893 </span>            :        *<span class="lineNum">     894 </span>            :        *  This is a typical stack operation.  The function creates an<span class="lineNum">     895 </span>            :        *  element at the end of the %vector and assigns the given data<span class="lineNum">     896 </span>            :        *  to it.  Due to the nature of a %vector this operation can be<span class="lineNum">     897 </span>            :        *  done in constant time if the %vector has preallocated space<span class="lineNum">     898 </span>            :        *  available.<a name="899"><span class="lineNum">     899 </span>            :        */</a><span class="lineNum">     900 </span>            :       void<span class="lineNum">     901 </span><span class="lineCov">       1176 :       push_back(const value_type&amp; __x)</span><span class="lineNum">     902 </span>            :       {<span class="lineNum">     903 </span><span class="lineCov">       1176 :         if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)</span><span class="lineNum">     904 </span>            :           {<span class="lineNum">     905 </span><span class="lineCov">       1122 :             _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,</span><span class="lineNum">     906 </span><span class="lineCov">       1122 :                                      __x);</span><span class="lineNum">     907 </span><span class="lineCov">       1122 :             ++this-&gt;_M_impl._M_finish;</span><span class="lineNum">     908 </span>            :           }<span class="lineNum">     909 </span>            :         else<span class="lineNum">     910 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     911 </span><span class="lineCov">         54 :           _M_emplace_back_aux(__x);</span><span class="lineNum">     912 </span>            : #else<span class="lineNum">     913 </span>            :           _M_insert_aux(end(), __x);<span class="lineNum">     914 </span>            : #endif<span class="lineNum">     915 </span><span class="lineCov">       1176 :       }</span><span class="lineNum">     916 </span>            : <a name="917"><span class="lineNum">     917 </span>            : #if __cplusplus &gt;= 201103L</a><span class="lineNum">     918 </span>            :       void<span class="lineNum">     919 </span><span class="lineCov">        784 :       push_back(value_type&amp;&amp; __x)</span><span class="lineNum">     920 </span><span class="lineCov">        784 :       { emplace_back(std::move(__x)); }</span><span class="lineNum">     921 </span>            : <span class="lineNum">     922 </span>            :       template&lt;typename... _Args&gt;<span class="lineNum">     923 </span>            :         void<span class="lineNum">     924 </span>            :         emplace_back(_Args&amp;&amp;... __args);<span class="lineNum">     925 </span>            : #endif<span class="lineNum">     926 </span>            : <span class="lineNum">     927 </span>            :       /**<span class="lineNum">     928 </span>            :        *  @brief  Removes last element.<span class="lineNum">     929 </span>            :        *<span class="lineNum">     930 </span>            :        *  This is a typical stack operation. It shrinks the %vector by one.<span class="lineNum">     931 </span>            :        *<span class="lineNum">     932 </span>            :        *  Note that no data is returned, and if the last element's<span class="lineNum">     933 </span>            :        *  data is needed, it should be retrieved before pop_back() is<span class="lineNum">     934 </span>            :        *  called.<span class="lineNum">     935 </span>            :        */<span class="lineNum">     936 </span>            :       void<span class="lineNum">     937 </span>            :       pop_back()<span class="lineNum">     938 </span>            :       {<span class="lineNum">     939 </span>            :         --this-&gt;_M_impl._M_finish;<span class="lineNum">     940 </span>            :         _Alloc_traits::destroy(this-&gt;_M_impl, this-&gt;_M_impl._M_finish);<span class="lineNum">     941 </span>            :       }<span class="lineNum">     942 </span>            : <span class="lineNum">     943 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     944 </span>            :       /**<span class="lineNum">     945 </span>            :        *  @brief  Inserts an object in %vector before specified iterator.<span class="lineNum">     946 </span>            :        *  @param  __position  An iterator into the %vector.<span class="lineNum">     947 </span>            :        *  @param  __args  Arguments.<span class="lineNum">     948 </span>            :        *  @return  An iterator that points to the inserted data.<span class="lineNum">     949 </span>            :        *<span class="lineNum">     950 </span>            :        *  This function will insert an object of type T constructed<span class="lineNum">     951 </span>            :        *  with T(std::forward&lt;Args&gt;(args)...) before the specified location.<span class="lineNum">     952 </span>            :        *  Note that this kind of operation could be expensive for a %vector<span class="lineNum">     953 </span>            :        *  and if it is frequently used the user should consider using<span class="lineNum">     954 </span>            :        *  std::list.<span class="lineNum">     955 </span>            :        */<span class="lineNum">     956 </span>            :       template&lt;typename... _Args&gt;<span class="lineNum">     957 </span>            :         iterator<span class="lineNum">     958 </span>            :         emplace(iterator __position, _Args&amp;&amp;... __args);<span class="lineNum">     959 </span>            : #endif<span class="lineNum">     960 </span>            : <span class="lineNum">     961 </span>            :       /**<span class="lineNum">     962 </span>            :        *  @brief  Inserts given value into %vector before specified iterator.<span class="lineNum">     963 </span>            :        *  @param  __position  An iterator into the %vector.<span class="lineNum">     964 </span>            :        *  @param  __x  Data to be inserted.<span class="lineNum">     965 </span>            :        *  @return  An iterator that points to the inserted data.<span class="lineNum">     966 </span>            :        *<span class="lineNum">     967 </span>            :        *  This function will insert a copy of the given value before<span class="lineNum">     968 </span>            :        *  the specified location.  Note that this kind of operation<span class="lineNum">     969 </span>            :        *  could be expensive for a %vector and if it is frequently<span class="lineNum">     970 </span>            :        *  used the user should consider using std::list.<span class="lineNum">     971 </span>            :        */<span class="lineNum">     972 </span>            :       iterator<span class="lineNum">     973 </span>            :       insert(iterator __position, const value_type&amp; __x);<span class="lineNum">     974 </span>            : <span class="lineNum">     975 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     976 </span>            :       /**<span class="lineNum">     977 </span>            :        *  @brief  Inserts given rvalue into %vector before specified iterator.<span class="lineNum">     978 </span>            :        *  @param  __position  An iterator into the %vector.<span class="lineNum">     979 </span>            :        *  @param  __x  Data to be inserted.<span class="lineNum">     980 </span>            :        *  @return  An iterator that points to the inserted data.<span class="lineNum">     981 </span>            :        *<span class="lineNum">     982 </span>            :        *  This function will insert a copy of the given rvalue before<span class="lineNum">     983 </span>            :        *  the specified location.  Note that this kind of operation<span class="lineNum">     984 </span>            :        *  could be expensive for a %vector and if it is frequently<span class="lineNum">     985 </span>            :        *  used the user should consider using std::list.<span class="lineNum">     986 </span>            :        */<span class="lineNum">     987 </span>            :       iterator<span class="lineNum">     988 </span>            :       insert(iterator __position, value_type&amp;&amp; __x)<span class="lineNum">     989 </span>            :       { return emplace(__position, std::move(__x)); }<span class="lineNum">     990 </span>            : <span class="lineNum">     991 </span>            :       /**<span class="lineNum">     992 </span>            :        *  @brief  Inserts an initializer_list into the %vector.<span class="lineNum">     993 </span>            :        *  @param  __position  An iterator into the %vector.<span class="lineNum">     994 </span>            :        *  @param  __l  An initializer_list.<span class="lineNum">     995 </span>            :        *<span class="lineNum">     996 </span>            :        *  This function will insert copies of the data in the <span class="lineNum">     997 </span>            :        *  initializer_list @a l into the %vector before the location<span class="lineNum">     998 </span>            :        *  specified by @a position.<span class="lineNum">     999 </span>            :        *<span class="lineNum">    1000 </span>            :        *  Note that this kind of operation could be expensive for a<span class="lineNum">    1001 </span>            :        *  %vector and if it is frequently used the user should<span class="lineNum">    1002 </span>            :        *  consider using std::list.<span class="lineNum">    1003 </span>            :        */<span class="lineNum">    1004 </span>            :       void<span class="lineNum">    1005 </span>            :       insert(iterator __position, initializer_list&lt;value_type&gt; __l)<span class="lineNum">    1006 </span>            :       { this-&gt;insert(__position, __l.begin(), __l.end()); }<span class="lineNum">    1007 </span>            : #endif<span class="lineNum">    1008 </span>            : <span class="lineNum">    1009 </span>            :       /**<span class="lineNum">    1010 </span>            :        *  @brief  Inserts a number of copies of given data into the %vector.<span class="lineNum">    1011 </span>            :        *  @param  __position  An iterator into the %vector.<span class="lineNum">    1012 </span>            :        *  @param  __n  Number of elements to be inserted.<span class="lineNum">    1013 </span>            :        *  @param  __x  Data to be inserted.<span class="lineNum">    1014 </span>            :        *<span class="lineNum">    1015 </span>            :        *  This function will insert a specified number of copies of<span class="lineNum">    1016 </span>            :        *  the given data before the location specified by @a position.<span class="lineNum">    1017 </span>            :        *<span class="lineNum">    1018 </span>            :        *  Note that this kind of operation could be expensive for a<span class="lineNum">    1019 </span>            :        *  %vector and if it is frequently used the user should<span class="lineNum">    1020 </span>            :        *  consider using std::list.<a name="1021"><span class="lineNum">    1021 </span>            :        */</a><span class="lineNum">    1022 </span>            :       void<span class="lineNum">    1023 </span><span class="lineCov">          2 :       insert(iterator __position, size_type __n, const value_type&amp; __x)</span><span class="lineNum">    1024 </span><span class="lineCov">          2 :       { _M_fill_insert(__position, __n, __x); }</span><span class="lineNum">    1025 </span>            : <span class="lineNum">    1026 </span>            :       /**<span class="lineNum">    1027 </span>            :        *  @brief  Inserts a range into the %vector.<span class="lineNum">    1028 </span>            :        *  @param  __position  An iterator into the %vector.<span class="lineNum">    1029 </span>            :        *  @param  __first  An input iterator.<span class="lineNum">    1030 </span>            :        *  @param  __last   An input iterator.<span class="lineNum">    1031 </span>            :        *<span class="lineNum">    1032 </span>            :        *  This function will insert copies of the data in the range<span class="lineNum">    1033 </span>            :        *  [__first,__last) into the %vector before the location specified<span class="lineNum">    1034 </span>            :        *  by @a pos.<span class="lineNum">    1035 </span>            :        *<span class="lineNum">    1036 </span>            :        *  Note that this kind of operation could be expensive for a<span class="lineNum">    1037 </span>            :        *  %vector and if it is frequently used the user should<span class="lineNum">    1038 </span>            :        *  consider using std::list.<span class="lineNum">    1039 </span>            :        */<span class="lineNum">    1040 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">    1041 </span>            :       template&lt;typename _InputIterator,<span class="lineNum">    1042 </span>            :                typename = std::_RequireInputIter&lt;_InputIterator&gt;&gt;<span class="lineNum">    1043 </span>            :         void<span class="lineNum">    1044 </span>            :         insert(iterator __position, _InputIterator __first,<span class="lineNum">    1045 </span>            :                _InputIterator __last)<span class="lineNum">    1046 </span>            :         { _M_insert_dispatch(__position, __first, __last, __false_type()); }<span class="lineNum">    1047 </span>            : #else<span class="lineNum">    1048 </span>            :       template&lt;typename _InputIterator&gt;<span class="lineNum">    1049 </span>            :         void<span class="lineNum">    1050 </span>            :         insert(iterator __position, _InputIterator __first,<span class="lineNum">    1051 </span>            :                _InputIterator __last)<span class="lineNum">    1052 </span>            :         {<span class="lineNum">    1053 </span>            :           // Check whether it's an integral type.  If so, it's not an iterator.<span class="lineNum">    1054 </span>            :           typedef typename std::__is_integer&lt;_InputIterator&gt;::__type _Integral;<span class="lineNum">    1055 </span>            :           _M_insert_dispatch(__position, __first, __last, _Integral());<span class="lineNum">    1056 </span>            :         }<span class="lineNum">    1057 </span>            : #endif<span class="lineNum">    1058 </span>            : <span class="lineNum">    1059 </span>            :       /**<span class="lineNum">    1060 </span>            :        *  @brief  Remove element at given position.<span class="lineNum">    1061 </span>            :        *  @param  __position  Iterator pointing to element to be erased.<span class="lineNum">    1062 </span>            :        *  @return  An iterator pointing to the next element (or end()).<span class="lineNum">    1063 </span>            :        *<span class="lineNum">    1064 </span>            :        *  This function will erase the element at the given position and thus<span class="lineNum">    1065 </span>            :        *  shorten the %vector by one.<span class="lineNum">    1066 </span>            :        *<span class="lineNum">    1067 </span>            :        *  Note This operation could be expensive and if it is<span class="lineNum">    1068 </span>            :        *  frequently used the user should consider using std::list.<span class="lineNum">    1069 </span>            :        *  The user is also cautioned that this function only erases<span class="lineNum">    1070 </span>            :        *  the element, and that if the element is itself a pointer,<span class="lineNum">    1071 </span>            :        *  the pointed-to memory is not touched in any way.  Managing<span class="lineNum">    1072 </span>            :        *  the pointer is the user's responsibility.<span class="lineNum">    1073 </span>            :        */<span class="lineNum">    1074 </span>            :       iterator<span class="lineNum">    1075 </span>            :       erase(iterator __position);<span class="lineNum">    1076 </span>            : <span class="lineNum">    1077 </span>            :       /**<span class="lineNum">    1078 </span>            :        *  @brief  Remove a range of elements.<span class="lineNum">    1079 </span>            :        *  @param  __first  Iterator pointing to the first element to be erased.<span class="lineNum">    1080 </span>            :        *  @param  __last  Iterator pointing to one past the last element to be<span class="lineNum">    1081 </span>            :        *                  erased.<span class="lineNum">    1082 </span>            :        *  @return  An iterator pointing to the element pointed to by @a __last<span class="lineNum">    1083 </span>            :        *           prior to erasing (or end()).<span class="lineNum">    1084 </span>            :        *<span class="lineNum">    1085 </span>            :        *  This function will erase the elements in the range<span class="lineNum">    1086 </span>            :        *  [__first,__last) and shorten the %vector accordingly.<span class="lineNum">    1087 </span>            :        *<span class="lineNum">    1088 </span>            :        *  Note This operation could be expensive and if it is<span class="lineNum">    1089 </span>            :        *  frequently used the user should consider using std::list.<span class="lineNum">    1090 </span>            :        *  The user is also cautioned that this function only erases<span class="lineNum">    1091 </span>            :        *  the elements, and that if the elements themselves are<span class="lineNum">    1092 </span>            :        *  pointers, the pointed-to memory is not touched in any way.<span class="lineNum">    1093 </span>            :        *  Managing the pointer is the user's responsibility.<span class="lineNum">    1094 </span>            :        */<span class="lineNum">    1095 </span>            :       iterator<span class="lineNum">    1096 </span>            :       erase(iterator __first, iterator __last);<span class="lineNum">    1097 </span>            : <span class="lineNum">    1098 </span>            :       /**<span class="lineNum">    1099 </span>            :        *  @brief  Swaps data with another %vector.<span class="lineNum">    1100 </span>            :        *  @param  __x  A %vector of the same element and allocator types.<span class="lineNum">    1101 </span>            :        *<span class="lineNum">    1102 </span>            :        *  This exchanges the elements between two vectors in constant time.<span class="lineNum">    1103 </span>            :        *  (Three pointers, so it should be quite fast.)<span class="lineNum">    1104 </span>            :        *  Note that the global std::swap() function is specialized such that<span class="lineNum">    1105 </span>            :        *  std::swap(v1,v2) will feed to this function.<a name="1106"><span class="lineNum">    1106 </span>            :        */</a><span class="lineNum">    1107 </span>            :       void<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :       swap(vector&amp; __x)</span><span class="lineNum">    1109 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">    1110 </span>            :                         noexcept(_Alloc_traits::_S_nothrow_swap())<span class="lineNum">    1111 </span>            : #endif<span class="lineNum">    1112 </span>            :       {<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :         this-&gt;_M_impl._M_swap_data(__x._M_impl);</span><span class="lineNum">    1114 </span><span class="lineNoCov">          0 :         _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),</span><span class="lineNum">    1115 </span><span class="lineNoCov">          0 :                                   __x._M_get_Tp_allocator());</span><span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       }</span><span class="lineNum">    1117 </span>            : <span class="lineNum">    1118 </span>            :       /**<span class="lineNum">    1119 </span>            :        *  Erases all the elements.  Note that this function only erases the<span class="lineNum">    1120 </span>            :        *  elements, and that if the elements themselves are pointers, the<span class="lineNum">    1121 </span>            :        *  pointed-to memory is not touched in any way.  Managing the pointer is<span class="lineNum">    1122 </span>            :        *  the user's responsibility.<span class="lineNum">    1123 </span>            :        */<span class="lineNum">    1124 </span>            :       void<span class="lineNum">    1125 </span>            :       clear() _GLIBCXX_NOEXCEPT<span class="lineNum">    1126 </span>            :       { _M_erase_at_end(this-&gt;_M_impl._M_start); }<span class="lineNum">    1127 </span>            : <span class="lineNum">    1128 </span>            :     protected:<span class="lineNum">    1129 </span>            :       /**<span class="lineNum">    1130 </span>            :        *  Memory expansion handler.  Uses the member allocation function to<span class="lineNum">    1131 </span>            :        *  obtain @a n bytes of memory, and then copies [first,last) into it.<span class="lineNum">    1132 </span>            :        */<span class="lineNum">    1133 </span>            :       template&lt;typename _ForwardIterator&gt;<span class="lineNum">    1134 </span>            :         pointer<span class="lineNum">    1135 </span>            :         _M_allocate_and_copy(size_type __n,<span class="lineNum">    1136 </span>            :                              _ForwardIterator __first, _ForwardIterator __last)<span class="lineNum">    1137 </span>            :         {<span class="lineNum">    1138 </span>            :           pointer __result = this-&gt;_M_allocate(__n);<span class="lineNum">    1139 </span>            :           __try<span class="lineNum">    1140 </span>            :             {<span class="lineNum">    1141 </span>            :               std::__uninitialized_copy_a(__first, __last, __result,<span class="lineNum">    1142 </span>            :                                           _M_get_Tp_allocator());<span class="lineNum">    1143 </span>            :               return __result;<span class="lineNum">    1144 </span>            :             }<span class="lineNum">    1145 </span>            :           __catch(...)<span class="lineNum">    1146 </span>            :             {<span class="lineNum">    1147 </span>            :               _M_deallocate(__result, __n);<span class="lineNum">    1148 </span>            :               __throw_exception_again;<span class="lineNum">    1149 </span>            :             }<span class="lineNum">    1150 </span>            :         }<span class="lineNum">    1151 </span>            : <span class="lineNum">    1152 </span>            : <span class="lineNum">    1153 </span>            :       // Internal constructor functions follow.<span class="lineNum">    1154 </span>            : <span class="lineNum">    1155 </span>            :       // Called by the range constructor to implement [23.1.1]/9<span class="lineNum">    1156 </span>            : <span class="lineNum">    1157 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">    1158 </span>            :       // 438. Ambiguity in the &quot;do the right thing&quot; clause<span class="lineNum">    1159 </span>            :       template&lt;typename _Integer&gt;<span class="lineNum">    1160 </span>            :         void<span class="lineNum">    1161 </span>            :         _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)<span class="lineNum">    1162 </span>            :         {<span class="lineNum">    1163 </span>            :           this-&gt;_M_impl._M_start = _M_allocate(static_cast&lt;size_type&gt;(__n));<span class="lineNum">    1164 </span>            :           this-&gt;_M_impl._M_end_of_storage =<span class="lineNum">    1165 </span>            :             this-&gt;_M_impl._M_start + static_cast&lt;size_type&gt;(__n);<span class="lineNum">    1166 </span>            :           _M_fill_initialize(static_cast&lt;size_type&gt;(__n), __value);<span class="lineNum">    1167 </span>            :         }<span class="lineNum">    1168 </span>            : <span class="lineNum">    1169 </span>            :       // Called by the range constructor to implement [23.1.1]/9<span class="lineNum">    1170 </span>            :       template&lt;typename _InputIterator&gt;<span class="lineNum">    1171 </span>            :         void<span class="lineNum">    1172 </span>            :         _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,<span class="lineNum">    1173 </span>            :                                __false_type)<span class="lineNum">    1174 </span>            :         {<span class="lineNum">    1175 </span>            :           typedef typename std::iterator_traits&lt;_InputIterator&gt;::<span class="lineNum">    1176 </span>            :             iterator_category _IterCategory;<span class="lineNum">    1177 </span>            :           _M_range_initialize(__first, __last, _IterCategory());<span class="lineNum">    1178 </span>            :         }<span class="lineNum">    1179 </span>            : <span class="lineNum">    1180 </span>            :       // Called by the second initialize_dispatch above<span class="lineNum">    1181 </span>            :       template&lt;typename _InputIterator&gt;<span class="lineNum">    1182 </span>            :         void<span class="lineNum">    1183 </span>            :         _M_range_initialize(_InputIterator __first,<span class="lineNum">    1184 </span>            :                             _InputIterator __last, std::input_iterator_tag)<span class="lineNum">    1185 </span>            :         {<span class="lineNum">    1186 </span>            :           for (; __first != __last; ++__first)<span class="lineNum">    1187 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">    1188 </span>            :             emplace_back(*__first);<span class="lineNum">    1189 </span>            : #else<span class="lineNum">    1190 </span>            :             push_back(*__first);<span class="lineNum">    1191 </span>            : #endif<span class="lineNum">    1192 </span>            :         }<span class="lineNum">    1193 </span>            : <span class="lineNum">    1194 </span>            :       // Called by the second initialize_dispatch above<span class="lineNum">    1195 </span>            :       template&lt;typename _ForwardIterator&gt;<span class="lineNum">    1196 </span>            :         void<span class="lineNum">    1197 </span>            :         _M_range_initialize(_ForwardIterator __first,<span class="lineNum">    1198 </span>            :                             _ForwardIterator __last, std::forward_iterator_tag)<span class="lineNum">    1199 </span>            :         {<span class="lineNum">    1200 </span>            :           const size_type __n = std::distance(__first, __last);<span class="lineNum">    1201 </span>            :           this-&gt;_M_impl._M_start = this-&gt;_M_allocate(__n);<span class="lineNum">    1202 </span>            :           this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __n;<span class="lineNum">    1203 </span>            :           this-&gt;_M_impl._M_finish =<span class="lineNum">    1204 </span>            :             std::__uninitialized_copy_a(__first, __last,<span class="lineNum">    1205 </span>            :                                         this-&gt;_M_impl._M_start,<span class="lineNum">    1206 </span>            :                                         _M_get_Tp_allocator());<span class="lineNum">    1207 </span>            :         }<span class="lineNum">    1208 </span>            : <span class="lineNum">    1209 </span>            :       // Called by the first initialize_dispatch above and by the<a name="1210"><span class="lineNum">    1210 </span>            :       // vector(n,value,a) constructor.</a><span class="lineNum">    1211 </span>            :       void<span class="lineNum">    1212 </span><span class="lineCov">         24 :       _M_fill_initialize(size_type __n, const value_type&amp; __value)</span><span class="lineNum">    1213 </span>            :       {<span class="lineNum">    1214 </span><span class="lineCov">         24 :         std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_start, __n, __value, </span><span class="lineNum">    1215 </span><span class="lineCov">         24 :                                       _M_get_Tp_allocator());</span><span class="lineNum">    1216 </span><span class="lineCov">         24 :         this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_end_of_storage;</span><span class="lineNum">    1217 </span><span class="lineCov">         24 :       }</span><span class="lineNum">    1218 </span>            : <span class="lineNum">    1219 </span>            : #if __cplusplus &gt;= 201103L<a name="1220"><span class="lineNum">    1220 </span>            :       // Called by the vector(n) constructor.</a><span class="lineNum">    1221 </span>            :       void<span class="lineNum">    1222 </span><span class="lineCov">         12 :       _M_default_initialize(size_type __n)</span><span class="lineNum">    1223 </span>            :       {<span class="lineNum">    1224 </span><span class="lineCov">         12 :         std::__uninitialized_default_n_a(this-&gt;_M_impl._M_start, __n, </span><span class="lineNum">    1225 </span><span class="lineCov">         12 :                                          _M_get_Tp_allocator());</span><span class="lineNum">    1226 </span><span class="lineCov">         12 :         this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_end_of_storage;</span><span class="lineNum">    1227 </span><span class="lineCov">         12 :       }</span><span class="lineNum">    1228 </span>            : #endif<span class="lineNum">    1229 </span>            : <span class="lineNum">    1230 </span>            :       // Internal assign functions follow.  The *_aux functions do the actual<span class="lineNum">    1231 </span>            :       // assignment work for the range versions.<span class="lineNum">    1232 </span>            : <span class="lineNum">    1233 </span>            :       // Called by the range assign to implement [23.1.1]/9<span class="lineNum">    1234 </span>            : <span class="lineNum">    1235 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">    1236 </span>            :       // 438. Ambiguity in the &quot;do the right thing&quot; clause<span class="lineNum">    1237 </span>            :       template&lt;typename _Integer&gt;<span class="lineNum">    1238 </span>            :         void<span class="lineNum">    1239 </span>            :         _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)<span class="lineNum">    1240 </span>            :         { _M_fill_assign(__n, __val); }<span class="lineNum">    1241 </span>            : <span class="lineNum">    1242 </span>            :       // Called by the range assign to implement [23.1.1]/9<span class="lineNum">    1243 </span>            :       template&lt;typename _InputIterator&gt;<span class="lineNum">    1244 </span>            :         void<span class="lineNum">    1245 </span>            :         _M_assign_dispatch(_InputIterator __first, _InputIterator __last,<span class="lineNum">    1246 </span>            :                            __false_type)<span class="lineNum">    1247 </span>            :         {<span class="lineNum">    1248 </span>            :           typedef typename std::iterator_traits&lt;_InputIterator&gt;::<span class="lineNum">    1249 </span>            :             iterator_category _IterCategory;<span class="lineNum">    1250 </span>            :           _M_assign_aux(__first, __last, _IterCategory());<span class="lineNum">    1251 </span>            :         }<span class="lineNum">    1252 </span>            : <span class="lineNum">    1253 </span>            :       // Called by the second assign_dispatch above<span class="lineNum">    1254 </span>            :       template&lt;typename _InputIterator&gt;<span class="lineNum">    1255 </span>            :         void<span class="lineNum">    1256 </span>            :         _M_assign_aux(_InputIterator __first, _InputIterator __last,<span class="lineNum">    1257 </span>            :                       std::input_iterator_tag);<span class="lineNum">    1258 </span>            : <span class="lineNum">    1259 </span>            :       // Called by the second assign_dispatch above<span class="lineNum">    1260 </span>            :       template&lt;typename _ForwardIterator&gt;<span class="lineNum">    1261 </span>            :         void<span class="lineNum">    1262 </span>            :         _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,<span class="lineNum">    1263 </span>            :                       std::forward_iterator_tag);<span class="lineNum">    1264 </span>            : <span class="lineNum">    1265 </span>            :       // Called by assign(n,t), and the range assign when it turns out<span class="lineNum">    1266 </span>            :       // to be the same thing.<span class="lineNum">    1267 </span>            :       void<span class="lineNum">    1268 </span>            :       _M_fill_assign(size_type __n, const value_type&amp; __val);<span class="lineNum">    1269 </span>            : <span class="lineNum">    1270 </span>            : <span class="lineNum">    1271 </span>            :       // Internal insert functions follow.<span class="lineNum">    1272 </span>            : <span class="lineNum">    1273 </span>            :       // Called by the range insert to implement [23.1.1]/9<span class="lineNum">    1274 </span>            : <span class="lineNum">    1275 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">    1276 </span>            :       // 438. Ambiguity in the &quot;do the right thing&quot; clause<span class="lineNum">    1277 </span>            :       template&lt;typename _Integer&gt;<span class="lineNum">    1278 </span>            :         void<span class="lineNum">    1279 </span>            :         _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,<span class="lineNum">    1280 </span>            :                            __true_type)<span class="lineNum">    1281 </span>            :         { _M_fill_insert(__pos, __n, __val); }<span class="lineNum">    1282 </span>            : <span class="lineNum">    1283 </span>            :       // Called by the range insert to implement [23.1.1]/9<span class="lineNum">    1284 </span>            :       template&lt;typename _InputIterator&gt;<span class="lineNum">    1285 </span>            :         void<span class="lineNum">    1286 </span>            :         _M_insert_dispatch(iterator __pos, _InputIterator __first,<span class="lineNum">    1287 </span>            :                            _InputIterator __last, __false_type)<span class="lineNum">    1288 </span>            :         {<span class="lineNum">    1289 </span>            :           typedef typename std::iterator_traits&lt;_InputIterator&gt;::<span class="lineNum">    1290 </span>            :             iterator_category _IterCategory;<span class="lineNum">    1291 </span>            :           _M_range_insert(__pos, __first, __last, _IterCategory());<span class="lineNum">    1292 </span>            :         }<span class="lineNum">    1293 </span>            : <span class="lineNum">    1294 </span>            :       // Called by the second insert_dispatch above<span class="lineNum">    1295 </span>            :       template&lt;typename _InputIterator&gt;<span class="lineNum">    1296 </span>            :         void<span class="lineNum">    1297 </span>            :         _M_range_insert(iterator __pos, _InputIterator __first,<span class="lineNum">    1298 </span>            :                         _InputIterator __last, std::input_iterator_tag);<span class="lineNum">    1299 </span>            : <span class="lineNum">    1300 </span>            :       // Called by the second insert_dispatch above<span class="lineNum">    1301 </span>            :       template&lt;typename _ForwardIterator&gt;<span class="lineNum">    1302 </span>            :         void<span class="lineNum">    1303 </span>            :         _M_range_insert(iterator __pos, _ForwardIterator __first,<span class="lineNum">    1304 </span>            :                         _ForwardIterator __last, std::forward_iterator_tag);<span class="lineNum">    1305 </span>            : <span class="lineNum">    1306 </span>            :       // Called by insert(p,n,x), and the range insert when it turns out to be<span class="lineNum">    1307 </span>            :       // the same thing.<span class="lineNum">    1308 </span>            :       void<span class="lineNum">    1309 </span>            :       _M_fill_insert(iterator __pos, size_type __n, const value_type&amp; __x);<span class="lineNum">    1310 </span>            : <span class="lineNum">    1311 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">    1312 </span>            :       // Called by resize(n).<span class="lineNum">    1313 </span>            :       void<span class="lineNum">    1314 </span>            :       _M_default_append(size_type __n);<span class="lineNum">    1315 </span>            : <span class="lineNum">    1316 </span>            :       bool<span class="lineNum">    1317 </span>            :       _M_shrink_to_fit();<span class="lineNum">    1318 </span>            : #endif<span class="lineNum">    1319 </span>            : <span class="lineNum">    1320 </span>            :       // Called by insert(p,x)<span class="lineNum">    1321 </span>            : #if __cplusplus &lt; 201103L<span class="lineNum">    1322 </span>            :       void<span class="lineNum">    1323 </span>            :       _M_insert_aux(iterator __position, const value_type&amp; __x);<span class="lineNum">    1324 </span>            : #else<span class="lineNum">    1325 </span>            :       template&lt;typename... _Args&gt;<span class="lineNum">    1326 </span>            :         void<span class="lineNum">    1327 </span>            :         _M_insert_aux(iterator __position, _Args&amp;&amp;... __args);<span class="lineNum">    1328 </span>            : <span class="lineNum">    1329 </span>            :       template&lt;typename... _Args&gt;<span class="lineNum">    1330 </span>            :         void<span class="lineNum">    1331 </span>            :         _M_emplace_back_aux(_Args&amp;&amp;... __args);<span class="lineNum">    1332 </span>            : #endif<span class="lineNum">    1333 </span>            : <a name="1334"><span class="lineNum">    1334 </span>            :       // Called by the latter.</a><span class="lineNum">    1335 </span>            :       size_type<span class="lineNum">    1336 </span><span class="lineCov">         92 :       _M_check_len(size_type __n, const char* __s) const</span><span class="lineNum">    1337 </span>            :       {<span class="lineNum">    1338 </span><span class="lineCov">         92 :         if (max_size() - size() &lt; __n)</span><span class="lineNum">    1339 </span><span class="lineNoCov">          0 :           __throw_length_error(__N(__s));</span><span class="lineNum">    1340 </span>            : <span class="lineNum">    1341 </span><span class="lineCov">         92 :         const size_type __len = size() + std::max(size(), __n);</span><span class="lineNum">    1342 </span><span class="lineCov">         92 :         return (__len &lt; size() || __len &gt; max_size()) ? max_size() : __len;</span><span class="lineNum">    1343 </span>            :       }<span class="lineNum">    1344 </span>            : <span class="lineNum">    1345 </span>            :       // Internal erase functions follow.<span class="lineNum">    1346 </span>            : <span class="lineNum">    1347 </span>            :       // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,<a name="1348"><span class="lineNum">    1348 </span>            :       // _M_assign_aux.</a><span class="lineNum">    1349 </span>            :       void<span class="lineNum">    1350 </span><span class="lineCov">        140 :       _M_erase_at_end(pointer __pos)</span><span class="lineNum">    1351 </span>            :       {<span class="lineNum">    1352 </span><span class="lineCov">        140 :         std::_Destroy(__pos, this-&gt;_M_impl._M_finish, _M_get_Tp_allocator());</span><span class="lineNum">    1353 </span><span class="lineCov">        140 :         this-&gt;_M_impl._M_finish = __pos;</span><span class="lineNum">    1354 </span><span class="lineCov">        140 :       }</span><span class="lineNum">    1355 </span>            : <span class="lineNum">    1356 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">    1357 </span>            :     private:<span class="lineNum">    1358 </span>            :       // Constant-time move assignment when source object's memory can be<span class="lineNum">    1359 </span>            :       // moved, either because the source's allocator will move too<span class="lineNum">    1360 </span>            :       // or because the allocators are equal.<span class="lineNum">    1361 </span>            :       void<span class="lineNum">    1362 </span>            :       _M_move_assign(vector&amp;&amp; __x, std::true_type) noexcept<span class="lineNum">    1363 </span>            :       {<span class="lineNum">    1364 </span>            :         vector __tmp(get_allocator());<span class="lineNum">    1365 </span>            :         this-&gt;_M_impl._M_swap_data(__tmp._M_impl);<span class="lineNum">    1366 </span>            :         this-&gt;_M_impl._M_swap_data(__x._M_impl);<span class="lineNum">    1367 </span>            :         if (_Alloc_traits::_S_propagate_on_move_assign())<span class="lineNum">    1368 </span>            :           std::__alloc_on_move(_M_get_Tp_allocator(),<span class="lineNum">    1369 </span>            :                                __x._M_get_Tp_allocator());<span class="lineNum">    1370 </span>            :       }<span class="lineNum">    1371 </span>            : <span class="lineNum">    1372 </span>            :       // Do move assignment when it might not be possible to move source<span class="lineNum">    1373 </span>            :       // object's memory, resulting in a linear-time operation.<span class="lineNum">    1374 </span>            :       void<span class="lineNum">    1375 </span>            :       _M_move_assign(vector&amp;&amp; __x, std::false_type)<span class="lineNum">    1376 </span>            :       {<span class="lineNum">    1377 </span>            :         if (__x._M_get_Tp_allocator() == this-&gt;_M_get_Tp_allocator())<span class="lineNum">    1378 </span>            :           _M_move_assign(std::move(__x), std::true_type());<span class="lineNum">    1379 </span>            :         else<span class="lineNum">    1380 </span>            :           {<span class="lineNum">    1381 </span>            :             // The rvalue's allocator cannot be moved and is not equal,<span class="lineNum">    1382 </span>            :             // so we need to individually move each element.<span class="lineNum">    1383 </span>            :             this-&gt;assign(std::__make_move_if_noexcept_iterator(__x.begin()),<span class="lineNum">    1384 </span>            :                          std::__make_move_if_noexcept_iterator(__x.end()));<span class="lineNum">    1385 </span>            :             __x.clear();<span class="lineNum">    1386 </span>            :           }<span class="lineNum">    1387 </span>            :       }<span class="lineNum">    1388 </span>            : #endif<span class="lineNum">    1389 </span>            :     };<span class="lineNum">    1390 </span>            : <span class="lineNum">    1391 </span>            : <span class="lineNum">    1392 </span>            :   /**<span class="lineNum">    1393 </span>            :    *  @brief  Vector equality comparison.<span class="lineNum">    1394 </span>            :    *  @param  __x  A %vector.<span class="lineNum">    1395 </span>            :    *  @param  __y  A %vector of the same type as @a __x.<span class="lineNum">    1396 </span>            :    *  @return  True iff the size and elements of the vectors are equal.<span class="lineNum">    1397 </span>            :    *<span class="lineNum">    1398 </span>            :    *  This is an equivalence relation.  It is linear in the size of the<span class="lineNum">    1399 </span>            :    *  vectors.  Vectors are considered equivalent if their sizes are equal,<span class="lineNum">    1400 </span>            :    *  and if corresponding elements compare equal.<span class="lineNum">    1401 </span>            :   */<span class="lineNum">    1402 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">    1403 </span>            :     inline bool<span class="lineNum">    1404 </span>            :     operator==(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)<span class="lineNum">    1405 </span>            :     { return (__x.size() == __y.size()<span class="lineNum">    1406 </span>            :               &amp;&amp; std::equal(__x.begin(), __x.end(), __y.begin())); }<span class="lineNum">    1407 </span>            : <span class="lineNum">    1408 </span>            :   /**<span class="lineNum">    1409 </span>            :    *  @brief  Vector ordering relation.<span class="lineNum">    1410 </span>            :    *  @param  __x  A %vector.<span class="lineNum">    1411 </span>            :    *  @param  __y  A %vector of the same type as @a __x.<span class="lineNum">    1412 </span>            :    *  @return  True iff @a __x is lexicographically less than @a __y.<span class="lineNum">    1413 </span>            :    *<span class="lineNum">    1414 </span>            :    *  This is a total ordering relation.  It is linear in the size of the<span class="lineNum">    1415 </span>            :    *  vectors.  The elements must be comparable with @c &lt;.<span class="lineNum">    1416 </span>            :    *<span class="lineNum">    1417 </span>            :    *  See std::lexicographical_compare() for how the determination is made.<span class="lineNum">    1418 </span>            :   */<span class="lineNum">    1419 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">    1420 </span>            :     inline bool<span class="lineNum">    1421 </span>            :     operator&lt;(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)<span class="lineNum">    1422 </span>            :     { return std::lexicographical_compare(__x.begin(), __x.end(),<span class="lineNum">    1423 </span>            :                                           __y.begin(), __y.end()); }<span class="lineNum">    1424 </span>            : <span class="lineNum">    1425 </span>            :   /// Based on operator==<span class="lineNum">    1426 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">    1427 </span>            :     inline bool<span class="lineNum">    1428 </span>            :     operator!=(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)<span class="lineNum">    1429 </span>            :     { return !(__x == __y); }<span class="lineNum">    1430 </span>            : <span class="lineNum">    1431 </span>            :   /// Based on operator&lt;<span class="lineNum">    1432 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">    1433 </span>            :     inline bool<span class="lineNum">    1434 </span>            :     operator&gt;(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)<span class="lineNum">    1435 </span>            :     { return __y &lt; __x; }<span class="lineNum">    1436 </span>            : <span class="lineNum">    1437 </span>            :   /// Based on operator&lt;<span class="lineNum">    1438 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">    1439 </span>            :     inline bool<span class="lineNum">    1440 </span>            :     operator&lt;=(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)<span class="lineNum">    1441 </span>            :     { return !(__y &lt; __x); }<span class="lineNum">    1442 </span>            : <span class="lineNum">    1443 </span>            :   /// Based on operator&lt;<span class="lineNum">    1444 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">    1445 </span>            :     inline bool<span class="lineNum">    1446 </span>            :     operator&gt;=(const vector&lt;_Tp, _Alloc&gt;&amp; __x, const vector&lt;_Tp, _Alloc&gt;&amp; __y)<span class="lineNum">    1447 </span>            :     { return !(__x &lt; __y); }<span class="lineNum">    1448 </span>            : <span class="lineNum">    1449 </span>            :   /// See std::vector::swap().<span class="lineNum">    1450 </span>            :   template&lt;typename _Tp, typename _Alloc&gt;<span class="lineNum">    1451 </span>            :     inline void<span class="lineNum">    1452 </span>            :     swap(vector&lt;_Tp, _Alloc&gt;&amp; __x, vector&lt;_Tp, _Alloc&gt;&amp; __y)<span class="lineNum">    1453 </span>            :     { __x.swap(__y); }<span class="lineNum">    1454 </span>            : <span class="lineNum">    1455 </span>            : _GLIBCXX_END_NAMESPACE_CONTAINER<span class="lineNum">    1456 </span>            : } // namespace std<span class="lineNum">    1457 </span>            : <span class="lineNum">    1458 </span>            : #endif /* _STL_VECTOR_H */</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_vector.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_vector.h<span style="font-size: 80%;"> (<a href="stl_vector.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">83</td>            <td class="headerCovTableEntry">96</td>            <td class="headerCovTableEntryMed">86.5 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">44</td>            <td class="headerCovTableEntry">50</td>            <td class="headerCovTableEntryMed">88.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="stl_vector.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#115">_ZNKSt12_Vector_baseIdSaIdEE19_M_get_Tp_allocatorEv</a></td>              <td class="coverFnHi">92</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1334">_ZNKSt6vectorIdSaIdEE12_M_check_lenEmPKc</a></td>              <td class="coverFnHi">46</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#643">_ZNKSt6vectorIdSaIdEE4sizeEv</a></td>              <td class="coverFnHi">294</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#723">_ZNKSt6vectorIdSaIdEE8capacityEv</a></td>              <td class="coverFnHi">60</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#648">_ZNKSt6vectorIdSaIdEE8max_sizeEv</a></td>              <td class="coverFnHi">92</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#783">_ZNKSt6vectorIdSaIdEEixEm</a></td>              <td class="coverFnHi">3136</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#643">_ZNKSt6vectorIiSaIiEE4sizeEv</a></td>              <td class="coverFnHi">10</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#723">_ZNKSt6vectorIiSaIiEE8capacityEv</a></td>              <td class="coverFnHi">10</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#165">_ZNSt12_Vector_baseIdSaIdEE11_M_allocateEm</a></td>              <td class="coverFnHi">63</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#99">_ZNSt12_Vector_baseIdSaIdEE12_Vector_impl12_M_swap_dataERS2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#88">_ZNSt12_Vector_baseIdSaIdEE12_Vector_implC2ERKS0_</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#77">_ZNSt12_Vector_baseIdSaIdEE12_Vector_implD2Ev</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#169">_ZNSt12_Vector_baseIdSaIdEE13_M_deallocateEPdm</a></td>              <td class="coverFnHi">63</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#177">_ZNSt12_Vector_baseIdSaIdEE17_M_create_storageEm</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#111">_ZNSt12_Vector_baseIdSaIdEE19_M_get_Tp_allocatorEv</a></td>              <td class="coverFnHi">188</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#132">_ZNSt12_Vector_baseIdSaIdEEC2EmRKS0_</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#157">_ZNSt12_Vector_baseIdSaIdEED2Ev</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#165">_ZNSt12_Vector_baseIiSaIiEE11_M_allocateEm</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#99">_ZNSt12_Vector_baseIiSaIiEE12_Vector_impl12_M_swap_dataERS2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#88">_ZNSt12_Vector_baseIiSaIiEE12_Vector_implC2ERKS0_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#77">_ZNSt12_Vector_baseIiSaIiEE12_Vector_implD2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#169">_ZNSt12_Vector_baseIiSaIiEE13_M_deallocateEPim</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#177">_ZNSt12_Vector_baseIiSaIiEE17_M_create_storageEm</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#111">_ZNSt12_Vector_baseIiSaIiEE19_M_get_Tp_allocatorEv</a></td>              <td class="coverFnHi">12</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#132">_ZNSt12_Vector_baseIiSaIiEEC2EmRKS0_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#157">_ZNSt12_Vector_baseIiSaIiEED2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1348">_ZNSt6vectorIdSaIdEE15_M_erase_at_endEPd</a></td>              <td class="coverFnHi">60</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1210">_ZNSt6vectorIdSaIdEE18_M_fill_initializeEmRKd</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1220">_ZNSt6vectorIdSaIdEE21_M_default_initializeEm</a></td>              <td class="coverFnHi">6</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#554">_ZNSt6vectorIdSaIdEE3endEv</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1106">_ZNSt6vectorIdSaIdEE4swapERS1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#536">_ZNSt6vectorIdSaIdEE5beginEv</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#477">_ZNSt6vectorIdSaIdEE6assignEmRKd</a></td>              <td class="coverFnHi">60</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1021">_ZNSt6vectorIdSaIdEE6insertEN9__gnu_cxx17__normal_iteratorIPdS1_EEmRKd</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#682">_ZNSt6vectorIdSaIdEE6resizeEmRKd</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#917">_ZNSt6vectorIdSaIdEE9push_backEOd</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#899">_ZNSt6vectorIdSaIdEE9push_backERKd</a></td>              <td class="coverFnHi">588</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#267">_ZNSt6vectorIdSaIdEEC2EmRKS0_</a></td>              <td class="coverFnHi">6</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#279">_ZNSt6vectorIdSaIdEEC2EmRKdRKS0_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#412">_ZNSt6vectorIdSaIdEED2Ev</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#768">_ZNSt6vectorIdSaIdEEixEm</a></td>              <td class="coverFnHi">7154287182</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1348">_ZNSt6vectorIiSaIiEE15_M_erase_at_endEPi</a></td>              <td class="coverFnHi">10</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1210">_ZNSt6vectorIiSaIiEE18_M_fill_initializeEmRKi</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#554">_ZNSt6vectorIiSaIiEE3endEv</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1106">_ZNSt6vectorIiSaIiEE4swapERS1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#536">_ZNSt6vectorIiSaIiEE5beginEv</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#477">_ZNSt6vectorIiSaIiEE6assignEmRKi</a></td>              <td class="coverFnHi">10</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#279">_ZNSt6vectorIiSaIiEEC2EmRKiRKS0_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#412">_ZNSt6vectorIiSaIiEED2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#768">_ZNSt6vectorIiSaIiEEixEm</a></td>              <td class="coverFnHi">101312940</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_vector.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_vector.h<span style="font-size: 80%;"> (<a href="stl_vector.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">83</td>            <td class="headerCovTableEntry">96</td>            <td class="headerCovTableEntryMed">86.5 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">44</td>            <td class="headerCovTableEntry">50</td>            <td class="headerCovTableEntryMed">88.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="stl_vector.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#99">_ZNSt12_Vector_baseIdSaIdEE12_Vector_impl12_M_swap_dataERS2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#99">_ZNSt12_Vector_baseIiSaIiEE12_Vector_impl12_M_swap_dataERS2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1106">_ZNSt6vectorIdSaIdEE4swapERS1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#554">_ZNSt6vectorIiSaIiEE3endEv</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1106">_ZNSt6vectorIiSaIiEE4swapERS1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#536">_ZNSt6vectorIiSaIiEE5beginEv</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#165">_ZNSt12_Vector_baseIiSaIiEE11_M_allocateEm</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#88">_ZNSt12_Vector_baseIiSaIiEE12_Vector_implC2ERKS0_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#77">_ZNSt12_Vector_baseIiSaIiEE12_Vector_implD2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#169">_ZNSt12_Vector_baseIiSaIiEE13_M_deallocateEPim</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#177">_ZNSt12_Vector_baseIiSaIiEE17_M_create_storageEm</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#132">_ZNSt12_Vector_baseIiSaIiEEC2EmRKS0_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#157">_ZNSt12_Vector_baseIiSaIiEED2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#554">_ZNSt6vectorIdSaIdEE3endEv</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#536">_ZNSt6vectorIdSaIdEE5beginEv</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1021">_ZNSt6vectorIdSaIdEE6insertEN9__gnu_cxx17__normal_iteratorIPdS1_EEmRKd</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#682">_ZNSt6vectorIdSaIdEE6resizeEmRKd</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1210">_ZNSt6vectorIiSaIiEE18_M_fill_initializeEmRKi</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#279">_ZNSt6vectorIiSaIiEEC2EmRKiRKS0_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#412">_ZNSt6vectorIiSaIiEED2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1220">_ZNSt6vectorIdSaIdEE21_M_default_initializeEm</a></td>              <td class="coverFnHi">6</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#267">_ZNSt6vectorIdSaIdEEC2EmRKS0_</a></td>              <td class="coverFnHi">6</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#643">_ZNKSt6vectorIiSaIiEE4sizeEv</a></td>              <td class="coverFnHi">10</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#723">_ZNKSt6vectorIiSaIiEE8capacityEv</a></td>              <td class="coverFnHi">10</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1348">_ZNSt6vectorIiSaIiEE15_M_erase_at_endEPi</a></td>              <td class="coverFnHi">10</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#477">_ZNSt6vectorIiSaIiEE6assignEmRKi</a></td>              <td class="coverFnHi">10</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1210">_ZNSt6vectorIdSaIdEE18_M_fill_initializeEmRKd</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#279">_ZNSt6vectorIdSaIdEEC2EmRKdRKS0_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#111">_ZNSt12_Vector_baseIiSaIiEE19_M_get_Tp_allocatorEv</a></td>              <td class="coverFnHi">12</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#88">_ZNSt12_Vector_baseIdSaIdEE12_Vector_implC2ERKS0_</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#77">_ZNSt12_Vector_baseIdSaIdEE12_Vector_implD2Ev</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#177">_ZNSt12_Vector_baseIdSaIdEE17_M_create_storageEm</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#132">_ZNSt12_Vector_baseIdSaIdEEC2EmRKS0_</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#157">_ZNSt12_Vector_baseIdSaIdEED2Ev</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#412">_ZNSt6vectorIdSaIdEED2Ev</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1334">_ZNKSt6vectorIdSaIdEE12_M_check_lenEmPKc</a></td>              <td class="coverFnHi">46</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#723">_ZNKSt6vectorIdSaIdEE8capacityEv</a></td>              <td class="coverFnHi">60</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#1348">_ZNSt6vectorIdSaIdEE15_M_erase_at_endEPd</a></td>              <td class="coverFnHi">60</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#477">_ZNSt6vectorIdSaIdEE6assignEmRKd</a></td>              <td class="coverFnHi">60</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#165">_ZNSt12_Vector_baseIdSaIdEE11_M_allocateEm</a></td>              <td class="coverFnHi">63</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#169">_ZNSt12_Vector_baseIdSaIdEE13_M_deallocateEPdm</a></td>              <td class="coverFnHi">63</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#115">_ZNKSt12_Vector_baseIdSaIdEE19_M_get_Tp_allocatorEv</a></td>              <td class="coverFnHi">92</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#648">_ZNKSt6vectorIdSaIdEE8max_sizeEv</a></td>              <td class="coverFnHi">92</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#111">_ZNSt12_Vector_baseIdSaIdEE19_M_get_Tp_allocatorEv</a></td>              <td class="coverFnHi">188</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#643">_ZNKSt6vectorIdSaIdEE4sizeEv</a></td>              <td class="coverFnHi">294</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#917">_ZNSt6vectorIdSaIdEE9push_backEOd</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#899">_ZNSt6vectorIdSaIdEE9push_backERKd</a></td>              <td class="coverFnHi">588</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#783">_ZNKSt6vectorIdSaIdEEixEm</a></td>              <td class="coverFnHi">3136</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#768">_ZNSt6vectorIiSaIiEEixEm</a></td>              <td class="coverFnHi">101312940</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_vector.h.gcov.html#768">_ZNSt6vectorIdSaIdEEixEm</a></td>              <td class="coverFnHi">7154287182</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_vector.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_uninitialized.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_uninitialized.h<span style="font-size: 80%;"> (source / <a href="stl_uninitialized.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">23</td>            <td class="headerCovTableEntry">25</td>            <td class="headerCovTableEntryHi">92.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">13</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntryHi">92.9 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Raw memory manipulators -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2001-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /*<span class="lineNum">      26 </span>            :  *<span class="lineNum">      27 </span>            :  * Copyright (c) 1994<span class="lineNum">      28 </span>            :  * Hewlett-Packard Company<span class="lineNum">      29 </span>            :  *<span class="lineNum">      30 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      31 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      32 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      33 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      34 </span>            :  * in supporting documentation.  Hewlett-Packard Company makes no<span class="lineNum">      35 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      36 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      37 </span>            :  *<span class="lineNum">      38 </span>            :  *<span class="lineNum">      39 </span>            :  * Copyright (c) 1996,1997<span class="lineNum">      40 </span>            :  * Silicon Graphics Computer Systems, Inc.<span class="lineNum">      41 </span>            :  *<span class="lineNum">      42 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      43 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      44 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      45 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      46 </span>            :  * in supporting documentation.  Silicon Graphics makes no<span class="lineNum">      47 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      48 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      49 </span>            :  */<span class="lineNum">      50 </span>            : <span class="lineNum">      51 </span>            : /** @file bits/stl_uninitialized.h<span class="lineNum">      52 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      53 </span>            :  *  Do not attempt to use it directly. @headername{memory}<span class="lineNum">      54 </span>            :  */<span class="lineNum">      55 </span>            : <span class="lineNum">      56 </span>            : #ifndef _STL_UNINITIALIZED_H<span class="lineNum">      57 </span>            : #define _STL_UNINITIALIZED_H 1<span class="lineNum">      58 </span>            : <span class="lineNum">      59 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      60 </span>            : {<span class="lineNum">      61 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      62 </span>            : <span class="lineNum">      63 </span>            :   template&lt;bool _TrivialValueTypes&gt;<span class="lineNum">      64 </span>            :     struct __uninitialized_copy<span class="lineNum">      65 </span>            :     {<span class="lineNum">      66 </span>            :       template&lt;typename _InputIterator, typename _ForwardIterator&gt;<span class="lineNum">      67 </span>            :         static _ForwardIterator<span class="lineNum">      68 </span>            :         __uninit_copy(_InputIterator __first, _InputIterator __last,<span class="lineNum">      69 </span>            :                       _ForwardIterator __result)<span class="lineNum">      70 </span>            :         {<span class="lineNum">      71 </span>            :           _ForwardIterator __cur = __result;<span class="lineNum">      72 </span>            :           __try<span class="lineNum">      73 </span>            :             {<span class="lineNum">      74 </span>            :               for (; __first != __last; ++__first, ++__cur)<span class="lineNum">      75 </span>            :                 std::_Construct(std::__addressof(*__cur), *__first);<span class="lineNum">      76 </span>            :               return __cur;<span class="lineNum">      77 </span>            :             }<span class="lineNum">      78 </span>            :           __catch(...)<span class="lineNum">      79 </span>            :             {<span class="lineNum">      80 </span>            :               std::_Destroy(__result, __cur);<span class="lineNum">      81 </span>            :               __throw_exception_again;<span class="lineNum">      82 </span>            :             }<span class="lineNum">      83 </span>            :         }<span class="lineNum">      84 </span>            :     };<span class="lineNum">      85 </span>            : <span class="lineNum">      86 </span>            :   template&lt;&gt;<span class="lineNum">      87 </span>            :     struct __uninitialized_copy&lt;true&gt;<span class="lineNum">      88 </span>            :     {<a name="89"><span class="lineNum">      89 </span>            :       template&lt;typename _InputIterator, typename _ForwardIterator&gt;</a><span class="lineNum">      90 </span>            :         static _ForwardIterator<span class="lineNum">      91 </span><span class="lineCov">         94 :         __uninit_copy(_InputIterator __first, _InputIterator __last,</span><span class="lineNum">      92 </span>            :                       _ForwardIterator __result)<span class="lineNum">      93 </span><span class="lineCov">         94 :         { return std::copy(__first, __last, __result); }</span><span class="lineNum">      94 </span>            :     };<span class="lineNum">      95 </span>            : <span class="lineNum">      96 </span>            :   /**<span class="lineNum">      97 </span>            :    *  @brief Copies the range [first,last) into result.<span class="lineNum">      98 </span>            :    *  @param  __first  An input iterator.<span class="lineNum">      99 </span>            :    *  @param  __last   An input iterator.<span class="lineNum">     100 </span>            :    *  @param  __result An output iterator.<span class="lineNum">     101 </span>            :    *  @return   __result + (__first - __last)<span class="lineNum">     102 </span>            :    *<span class="lineNum">     103 </span>            :    *  Like copy(), but does not require an initialized output range.<span class="lineNum">     104 </span>            :   */<a name="105"><span class="lineNum">     105 </span>            :   template&lt;typename _InputIterator, typename _ForwardIterator&gt;</a><span class="lineNum">     106 </span>            :     inline _ForwardIterator<span class="lineNum">     107 </span><span class="lineCov">         94 :     uninitialized_copy(_InputIterator __first, _InputIterator __last,</span><span class="lineNum">     108 </span>            :                        _ForwardIterator __result)<span class="lineNum">     109 </span>            :     {<span class="lineNum">     110 </span>            :       typedef typename iterator_traits&lt;_InputIterator&gt;::value_type<span class="lineNum">     111 </span>            :         _ValueType1;<span class="lineNum">     112 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type<span class="lineNum">     113 </span>            :         _ValueType2;<span class="lineNum">     114 </span>            : <span class="lineNum">     115 </span>            :       return std::__uninitialized_copy&lt;(__is_trivial(_ValueType1)<span class="lineNum">     116 </span>            :                                         &amp;&amp; __is_trivial(_ValueType2))&gt;::<span class="lineNum">     117 </span><span class="lineCov">         94 :         __uninit_copy(__first, __last, __result);</span><span class="lineNum">     118 </span>            :     }<span class="lineNum">     119 </span>            : <span class="lineNum">     120 </span>            : <span class="lineNum">     121 </span>            :   template&lt;bool _TrivialValueType&gt;<span class="lineNum">     122 </span>            :     struct __uninitialized_fill<span class="lineNum">     123 </span>            :     {<span class="lineNum">     124 </span>            :       template&lt;typename _ForwardIterator, typename _Tp&gt;<span class="lineNum">     125 </span>            :         static void<span class="lineNum">     126 </span>            :         __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,<span class="lineNum">     127 </span>            :                       const _Tp&amp; __x)<span class="lineNum">     128 </span>            :         {<span class="lineNum">     129 </span>            :           _ForwardIterator __cur = __first;<span class="lineNum">     130 </span>            :           __try<span class="lineNum">     131 </span>            :             {<span class="lineNum">     132 </span>            :               for (; __cur != __last; ++__cur)<span class="lineNum">     133 </span>            :                 std::_Construct(std::__addressof(*__cur), __x);<span class="lineNum">     134 </span>            :             }<span class="lineNum">     135 </span>            :           __catch(...)<span class="lineNum">     136 </span>            :             {<span class="lineNum">     137 </span>            :               std::_Destroy(__first, __cur);<span class="lineNum">     138 </span>            :               __throw_exception_again;<span class="lineNum">     139 </span>            :             }<span class="lineNum">     140 </span>            :         }<span class="lineNum">     141 </span>            :     };<span class="lineNum">     142 </span>            : <span class="lineNum">     143 </span>            :   template&lt;&gt;<span class="lineNum">     144 </span>            :     struct __uninitialized_fill&lt;true&gt;<span class="lineNum">     145 </span>            :     {<span class="lineNum">     146 </span>            :       template&lt;typename _ForwardIterator, typename _Tp&gt;<span class="lineNum">     147 </span>            :         static void<span class="lineNum">     148 </span>            :         __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,<span class="lineNum">     149 </span>            :                       const _Tp&amp; __x)<span class="lineNum">     150 </span>            :         { std::fill(__first, __last, __x); }<span class="lineNum">     151 </span>            :     };<span class="lineNum">     152 </span>            : <span class="lineNum">     153 </span>            :   /**<span class="lineNum">     154 </span>            :    *  @brief Copies the value x into the range [first,last).<span class="lineNum">     155 </span>            :    *  @param  __first  An input iterator.<span class="lineNum">     156 </span>            :    *  @param  __last   An input iterator.<span class="lineNum">     157 </span>            :    *  @param  __x      The source value.<span class="lineNum">     158 </span>            :    *  @return   Nothing.<span class="lineNum">     159 </span>            :    *<span class="lineNum">     160 </span>            :    *  Like fill(), but does not require an initialized output range.<span class="lineNum">     161 </span>            :   */<span class="lineNum">     162 </span>            :   template&lt;typename _ForwardIterator, typename _Tp&gt;<span class="lineNum">     163 </span>            :     inline void<span class="lineNum">     164 </span>            :     uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,<span class="lineNum">     165 </span>            :                        const _Tp&amp; __x)<span class="lineNum">     166 </span>            :     {<span class="lineNum">     167 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type<span class="lineNum">     168 </span>            :         _ValueType;<span class="lineNum">     169 </span>            : <span class="lineNum">     170 </span>            :       std::__uninitialized_fill&lt;__is_trivial(_ValueType)&gt;::<span class="lineNum">     171 </span>            :         __uninit_fill(__first, __last, __x);<span class="lineNum">     172 </span>            :     }<span class="lineNum">     173 </span>            : <span class="lineNum">     174 </span>            : <span class="lineNum">     175 </span>            :   template&lt;bool _TrivialValueType&gt;<span class="lineNum">     176 </span>            :     struct __uninitialized_fill_n<span class="lineNum">     177 </span>            :     {<span class="lineNum">     178 </span>            :       template&lt;typename _ForwardIterator, typename _Size, typename _Tp&gt;<span class="lineNum">     179 </span>            :         static void<span class="lineNum">     180 </span>            :         __uninit_fill_n(_ForwardIterator __first, _Size __n,<span class="lineNum">     181 </span>            :                         const _Tp&amp; __x)<span class="lineNum">     182 </span>            :         {<span class="lineNum">     183 </span>            :           _ForwardIterator __cur = __first;<span class="lineNum">     184 </span>            :           __try<span class="lineNum">     185 </span>            :             {<span class="lineNum">     186 </span>            :               for (; __n &gt; 0; --__n, ++__cur)<span class="lineNum">     187 </span>            :                 std::_Construct(std::__addressof(*__cur), __x);<span class="lineNum">     188 </span>            :             }<span class="lineNum">     189 </span>            :           __catch(...)<span class="lineNum">     190 </span>            :             {<span class="lineNum">     191 </span>            :               std::_Destroy(__first, __cur);<span class="lineNum">     192 </span>            :               __throw_exception_again;<span class="lineNum">     193 </span>            :             }<span class="lineNum">     194 </span>            :         }<span class="lineNum">     195 </span>            :     };<span class="lineNum">     196 </span>            : <span class="lineNum">     197 </span>            :   template&lt;&gt;<span class="lineNum">     198 </span>            :     struct __uninitialized_fill_n&lt;true&gt;<span class="lineNum">     199 </span>            :     {<a name="200"><span class="lineNum">     200 </span>            :       template&lt;typename _ForwardIterator, typename _Size, typename _Tp&gt;</a><span class="lineNum">     201 </span>            :         static void<span class="lineNum">     202 </span><span class="lineCov">         26 :         __uninit_fill_n(_ForwardIterator __first, _Size __n,</span><span class="lineNum">     203 </span>            :                         const _Tp&amp; __x)<span class="lineNum">     204 </span><span class="lineCov">         26 :         { std::fill_n(__first, __n, __x); }</span><span class="lineNum">     205 </span>            :     };<span class="lineNum">     206 </span>            : <span class="lineNum">     207 </span>            :   /**<span class="lineNum">     208 </span>            :    *  @brief Copies the value x into the range [first,first+n).<span class="lineNum">     209 </span>            :    *  @param  __first  An input iterator.<span class="lineNum">     210 </span>            :    *  @param  __n      The number of copies to make.<span class="lineNum">     211 </span>            :    *  @param  __x      The source value.<span class="lineNum">     212 </span>            :    *  @return   Nothing.<span class="lineNum">     213 </span>            :    *<span class="lineNum">     214 </span>            :    *  Like fill_n(), but does not require an initialized output range.<span class="lineNum">     215 </span>            :   */<a name="216"><span class="lineNum">     216 </span>            :   template&lt;typename _ForwardIterator, typename _Size, typename _Tp&gt;</a><span class="lineNum">     217 </span>            :     inline void<span class="lineNum">     218 </span><span class="lineCov">         26 :     uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp&amp; __x)</span><span class="lineNum">     219 </span>            :     {<span class="lineNum">     220 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type<span class="lineNum">     221 </span>            :         _ValueType;<span class="lineNum">     222 </span>            : <span class="lineNum">     223 </span><span class="lineCov">         26 :       std::__uninitialized_fill_n&lt;__is_trivial(_ValueType)&gt;::</span><span class="lineNum">     224 </span>            :         __uninit_fill_n(__first, __n, __x);<span class="lineNum">     225 </span><span class="lineCov">         26 :     }</span><span class="lineNum">     226 </span>            : <span class="lineNum">     227 </span>            :   // Extensions: versions of uninitialized_copy, uninitialized_fill,<span class="lineNum">     228 </span>            :   //  and uninitialized_fill_n that take an allocator parameter.<span class="lineNum">     229 </span>            :   //  We dispatch back to the standard versions when we're given the<span class="lineNum">     230 </span>            :   //  default allocator.  For nondefault allocators we do not use <span class="lineNum">     231 </span>            :   //  any of the POD optimizations.<span class="lineNum">     232 </span>            : <span class="lineNum">     233 </span>            :   template&lt;typename _InputIterator, typename _ForwardIterator,<span class="lineNum">     234 </span>            :            typename _Allocator&gt;<span class="lineNum">     235 </span>            :     _ForwardIterator<span class="lineNum">     236 </span>            :     __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,<span class="lineNum">     237 </span>            :                            _ForwardIterator __result, _Allocator&amp; __alloc)<span class="lineNum">     238 </span>            :     {<span class="lineNum">     239 </span>            :       _ForwardIterator __cur = __result;<span class="lineNum">     240 </span>            :       __try<span class="lineNum">     241 </span>            :         {<span class="lineNum">     242 </span>            :           typedef __gnu_cxx::__alloc_traits&lt;_Allocator&gt; __traits;<span class="lineNum">     243 </span>            :           for (; __first != __last; ++__first, ++__cur)<span class="lineNum">     244 </span>            :             __traits::construct(__alloc, std::__addressof(*__cur), *__first);<span class="lineNum">     245 </span>            :           return __cur;<span class="lineNum">     246 </span>            :         }<span class="lineNum">     247 </span>            :       __catch(...)<span class="lineNum">     248 </span>            :         {<span class="lineNum">     249 </span>            :           std::_Destroy(__result, __cur, __alloc);<span class="lineNum">     250 </span>            :           __throw_exception_again;<span class="lineNum">     251 </span>            :         }<span class="lineNum">     252 </span>            :     }<span class="lineNum">     253 </span>            : <a name="254"><span class="lineNum">     254 </span>            :   template&lt;typename _InputIterator, typename _ForwardIterator, typename _Tp&gt;</a><span class="lineNum">     255 </span>            :     inline _ForwardIterator<span class="lineNum">     256 </span><span class="lineCov">         94 :     __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,</span><span class="lineNum">     257 </span>            :                            _ForwardIterator __result, allocator&lt;_Tp&gt;&amp;)<span class="lineNum">     258 </span><span class="lineCov">         94 :     { return std::uninitialized_copy(__first, __last, __result); }</span><span class="lineNum">     259 </span>            : <span class="lineNum">     260 </span>            :   template&lt;typename _InputIterator, typename _ForwardIterator,<a name="261"><span class="lineNum">     261 </span>            :            typename _Allocator&gt;</a><span class="lineNum">     262 </span>            :     inline _ForwardIterator<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     __uninitialized_move_a(_InputIterator __first, _InputIterator __last,</span><span class="lineNum">     264 </span>            :                            _ForwardIterator __result, _Allocator&amp; __alloc)<span class="lineNum">     265 </span>            :     {<span class="lineNum">     266 </span>            :       return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),<span class="lineNum">     267 </span>            :                                          _GLIBCXX_MAKE_MOVE_ITERATOR(__last),<span class="lineNum">     268 </span><span class="lineNoCov">          0 :                                          __result, __alloc);</span><span class="lineNum">     269 </span>            :     }<span class="lineNum">     270 </span>            : <span class="lineNum">     271 </span>            :   template&lt;typename _InputIterator, typename _ForwardIterator,<a name="272"><span class="lineNum">     272 </span>            :            typename _Allocator&gt;</a><span class="lineNum">     273 </span>            :     inline _ForwardIterator<span class="lineNum">     274 </span><span class="lineCov">         94 :     __uninitialized_move_if_noexcept_a(_InputIterator __first,</span><span class="lineNum">     275 </span>            :                                        _InputIterator __last,<span class="lineNum">     276 </span>            :                                        _ForwardIterator __result,<span class="lineNum">     277 </span>            :                                        _Allocator&amp; __alloc)<span class="lineNum">     278 </span>            :     {<span class="lineNum">     279 </span>            :       return std::__uninitialized_copy_a<span class="lineNum">     280 </span>            :         (_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),<span class="lineNum">     281 </span><span class="lineCov">         94 :          _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);</span><span class="lineNum">     282 </span>            :     }<span class="lineNum">     283 </span>            : <span class="lineNum">     284 </span>            :   template&lt;typename _ForwardIterator, typename _Tp, typename _Allocator&gt;<span class="lineNum">     285 </span>            :     void<span class="lineNum">     286 </span>            :     __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,<span class="lineNum">     287 </span>            :                            const _Tp&amp; __x, _Allocator&amp; __alloc)<span class="lineNum">     288 </span>            :     {<span class="lineNum">     289 </span>            :       _ForwardIterator __cur = __first;<span class="lineNum">     290 </span>            :       __try<span class="lineNum">     291 </span>            :         {<span class="lineNum">     292 </span>            :           typedef __gnu_cxx::__alloc_traits&lt;_Allocator&gt; __traits;<span class="lineNum">     293 </span>            :           for (; __cur != __last; ++__cur)<span class="lineNum">     294 </span>            :             __traits::construct(__alloc, std::__addressof(*__cur), __x);<span class="lineNum">     295 </span>            :         }<span class="lineNum">     296 </span>            :       __catch(...)<span class="lineNum">     297 </span>            :         {<span class="lineNum">     298 </span>            :           std::_Destroy(__first, __cur, __alloc);<span class="lineNum">     299 </span>            :           __throw_exception_again;<span class="lineNum">     300 </span>            :         }<span class="lineNum">     301 </span>            :     }<span class="lineNum">     302 </span>            : <span class="lineNum">     303 </span>            :   template&lt;typename _ForwardIterator, typename _Tp, typename _Tp2&gt;<span class="lineNum">     304 </span>            :     inline void<span class="lineNum">     305 </span>            :     __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,<span class="lineNum">     306 </span>            :                            const _Tp&amp; __x, allocator&lt;_Tp2&gt;&amp;)<span class="lineNum">     307 </span>            :     { std::uninitialized_fill(__first, __last, __x); }<span class="lineNum">     308 </span>            : <span class="lineNum">     309 </span>            :   template&lt;typename _ForwardIterator, typename _Size, typename _Tp,<span class="lineNum">     310 </span>            :            typename _Allocator&gt;<span class="lineNum">     311 </span>            :     void<span class="lineNum">     312 </span>            :     __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, <span class="lineNum">     313 </span>            :                              const _Tp&amp; __x, _Allocator&amp; __alloc)<span class="lineNum">     314 </span>            :     {<span class="lineNum">     315 </span>            :       _ForwardIterator __cur = __first;<span class="lineNum">     316 </span>            :       __try<span class="lineNum">     317 </span>            :         {<span class="lineNum">     318 </span>            :           typedef __gnu_cxx::__alloc_traits&lt;_Allocator&gt; __traits;<span class="lineNum">     319 </span>            :           for (; __n &gt; 0; --__n, ++__cur)<span class="lineNum">     320 </span>            :             __traits::construct(__alloc, std::__addressof(*__cur), __x);<span class="lineNum">     321 </span>            :         }<span class="lineNum">     322 </span>            :       __catch(...)<span class="lineNum">     323 </span>            :         {<span class="lineNum">     324 </span>            :           std::_Destroy(__first, __cur, __alloc);<span class="lineNum">     325 </span>            :           __throw_exception_again;<span class="lineNum">     326 </span>            :         }<span class="lineNum">     327 </span>            :     }<span class="lineNum">     328 </span>            : <span class="lineNum">     329 </span>            :   template&lt;typename _ForwardIterator, typename _Size, typename _Tp,<a name="330"><span class="lineNum">     330 </span>            :            typename _Tp2&gt;</a><span class="lineNum">     331 </span>            :     inline void<span class="lineNum">     332 </span><span class="lineCov">         26 :     __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, </span><span class="lineNum">     333 </span>            :                              const _Tp&amp; __x, allocator&lt;_Tp2&gt;&amp;)<span class="lineNum">     334 </span><span class="lineCov">         26 :     { std::uninitialized_fill_n(__first, __n, __x); }</span><span class="lineNum">     335 </span>            : <span class="lineNum">     336 </span>            : <span class="lineNum">     337 </span>            :   // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,<span class="lineNum">     338 </span>            :   // __uninitialized_fill_move, __uninitialized_move_fill.<span class="lineNum">     339 </span>            :   // All of these algorithms take a user-supplied allocator, which is used<span class="lineNum">     340 </span>            :   // for construction and destruction.<span class="lineNum">     341 </span>            : <span class="lineNum">     342 </span>            :   // __uninitialized_copy_move<span class="lineNum">     343 </span>            :   // Copies [first1, last1) into [result, result + (last1 - first1)), and<span class="lineNum">     344 </span>            :   //  move [first2, last2) into<span class="lineNum">     345 </span>            :   //  [result, result + (last1 - first1) + (last2 - first2)).<span class="lineNum">     346 </span>            :   template&lt;typename _InputIterator1, typename _InputIterator2,<span class="lineNum">     347 </span>            :            typename _ForwardIterator, typename _Allocator&gt;<span class="lineNum">     348 </span>            :     inline _ForwardIterator<span class="lineNum">     349 </span>            :     __uninitialized_copy_move(_InputIterator1 __first1,<span class="lineNum">     350 </span>            :                               _InputIterator1 __last1,<span class="lineNum">     351 </span>            :                               _InputIterator2 __first2,<span class="lineNum">     352 </span>            :                               _InputIterator2 __last2,<span class="lineNum">     353 </span>            :                               _ForwardIterator __result,<span class="lineNum">     354 </span>            :                               _Allocator&amp; __alloc)<span class="lineNum">     355 </span>            :     {<span class="lineNum">     356 </span>            :       _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,<span class="lineNum">     357 </span>            :                                                            __result,<span class="lineNum">     358 </span>            :                                                            __alloc);<span class="lineNum">     359 </span>            :       __try<span class="lineNum">     360 </span>            :         {<span class="lineNum">     361 </span>            :           return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);<span class="lineNum">     362 </span>            :         }<span class="lineNum">     363 </span>            :       __catch(...)<span class="lineNum">     364 </span>            :         {<span class="lineNum">     365 </span>            :           std::_Destroy(__result, __mid, __alloc);<span class="lineNum">     366 </span>            :           __throw_exception_again;<span class="lineNum">     367 </span>            :         }<span class="lineNum">     368 </span>            :     }<span class="lineNum">     369 </span>            : <span class="lineNum">     370 </span>            :   // __uninitialized_move_copy<span class="lineNum">     371 </span>            :   // Moves [first1, last1) into [result, result + (last1 - first1)), and<span class="lineNum">     372 </span>            :   //  copies [first2, last2) into<span class="lineNum">     373 </span>            :   //  [result, result + (last1 - first1) + (last2 - first2)).<span class="lineNum">     374 </span>            :   template&lt;typename _InputIterator1, typename _InputIterator2,<span class="lineNum">     375 </span>            :            typename _ForwardIterator, typename _Allocator&gt;<span class="lineNum">     376 </span>            :     inline _ForwardIterator<span class="lineNum">     377 </span>            :     __uninitialized_move_copy(_InputIterator1 __first1,<span class="lineNum">     378 </span>            :                               _InputIterator1 __last1,<span class="lineNum">     379 </span>            :                               _InputIterator2 __first2,<span class="lineNum">     380 </span>            :                               _InputIterator2 __last2,<span class="lineNum">     381 </span>            :                               _ForwardIterator __result,<span class="lineNum">     382 </span>            :                               _Allocator&amp; __alloc)<span class="lineNum">     383 </span>            :     {<span class="lineNum">     384 </span>            :       _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,<span class="lineNum">     385 </span>            :                                                            __result,<span class="lineNum">     386 </span>            :                                                            __alloc);<span class="lineNum">     387 </span>            :       __try<span class="lineNum">     388 </span>            :         {<span class="lineNum">     389 </span>            :           return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);<span class="lineNum">     390 </span>            :         }<span class="lineNum">     391 </span>            :       __catch(...)<span class="lineNum">     392 </span>            :         {<span class="lineNum">     393 </span>            :           std::_Destroy(__result, __mid, __alloc);<span class="lineNum">     394 </span>            :           __throw_exception_again;<span class="lineNum">     395 </span>            :         }<span class="lineNum">     396 </span>            :     }<span class="lineNum">     397 </span>            :   <span class="lineNum">     398 </span>            :   // __uninitialized_fill_move<span class="lineNum">     399 </span>            :   // Fills [result, mid) with x, and moves [first, last) into<span class="lineNum">     400 </span>            :   //  [mid, mid + (last - first)).<span class="lineNum">     401 </span>            :   template&lt;typename _ForwardIterator, typename _Tp, typename _InputIterator,<span class="lineNum">     402 </span>            :            typename _Allocator&gt;<span class="lineNum">     403 </span>            :     inline _ForwardIterator<span class="lineNum">     404 </span>            :     __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,<span class="lineNum">     405 </span>            :                               const _Tp&amp; __x, _InputIterator __first,<span class="lineNum">     406 </span>            :                               _InputIterator __last, _Allocator&amp; __alloc)<span class="lineNum">     407 </span>            :     {<span class="lineNum">     408 </span>            :       std::__uninitialized_fill_a(__result, __mid, __x, __alloc);<span class="lineNum">     409 </span>            :       __try<span class="lineNum">     410 </span>            :         {<span class="lineNum">     411 </span>            :           return std::__uninitialized_move_a(__first, __last, __mid, __alloc);<span class="lineNum">     412 </span>            :         }<span class="lineNum">     413 </span>            :       __catch(...)<span class="lineNum">     414 </span>            :         {<span class="lineNum">     415 </span>            :           std::_Destroy(__result, __mid, __alloc);<span class="lineNum">     416 </span>            :           __throw_exception_again;<span class="lineNum">     417 </span>            :         }<span class="lineNum">     418 </span>            :     }<span class="lineNum">     419 </span>            : <span class="lineNum">     420 </span>            :   // __uninitialized_move_fill<span class="lineNum">     421 </span>            :   // Moves [first1, last1) into [first2, first2 + (last1 - first1)), and<span class="lineNum">     422 </span>            :   //  fills [first2 + (last1 - first1), last2) with x.<span class="lineNum">     423 </span>            :   template&lt;typename _InputIterator, typename _ForwardIterator, typename _Tp,<span class="lineNum">     424 </span>            :            typename _Allocator&gt;<span class="lineNum">     425 </span>            :     inline void<span class="lineNum">     426 </span>            :     __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,<span class="lineNum">     427 </span>            :                               _ForwardIterator __first2,<span class="lineNum">     428 </span>            :                               _ForwardIterator __last2, const _Tp&amp; __x,<span class="lineNum">     429 </span>            :                               _Allocator&amp; __alloc)<span class="lineNum">     430 </span>            :     {<span class="lineNum">     431 </span>            :       _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,<span class="lineNum">     432 </span>            :                                                             __first2,<span class="lineNum">     433 </span>            :                                                             __alloc);<span class="lineNum">     434 </span>            :       __try<span class="lineNum">     435 </span>            :         {<span class="lineNum">     436 </span>            :           std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);<span class="lineNum">     437 </span>            :         }<span class="lineNum">     438 </span>            :       __catch(...)<span class="lineNum">     439 </span>            :         {<span class="lineNum">     440 </span>            :           std::_Destroy(__first2, __mid2, __alloc);<span class="lineNum">     441 </span>            :           __throw_exception_again;<span class="lineNum">     442 </span>            :         }<span class="lineNum">     443 </span>            :     }<span class="lineNum">     444 </span>            : <span class="lineNum">     445 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     446 </span>            :   // Extensions: __uninitialized_default, __uninitialized_default_n,<span class="lineNum">     447 </span>            :   // __uninitialized_default_a, __uninitialized_default_n_a.<span class="lineNum">     448 </span>            : <span class="lineNum">     449 </span>            :   template&lt;bool _TrivialValueType&gt;<span class="lineNum">     450 </span>            :     struct __uninitialized_default_1<span class="lineNum">     451 </span>            :     {<span class="lineNum">     452 </span>            :       template&lt;typename _ForwardIterator&gt;<span class="lineNum">     453 </span>            :         static void<span class="lineNum">     454 </span>            :         __uninit_default(_ForwardIterator __first, _ForwardIterator __last)<span class="lineNum">     455 </span>            :         {<span class="lineNum">     456 </span>            :           _ForwardIterator __cur = __first;<span class="lineNum">     457 </span>            :           __try<span class="lineNum">     458 </span>            :             {<span class="lineNum">     459 </span>            :               for (; __cur != __last; ++__cur)<span class="lineNum">     460 </span>            :                 std::_Construct(std::__addressof(*__cur));<span class="lineNum">     461 </span>            :             }<span class="lineNum">     462 </span>            :           __catch(...)<span class="lineNum">     463 </span>            :             {<span class="lineNum">     464 </span>            :               std::_Destroy(__first, __cur);<span class="lineNum">     465 </span>            :               __throw_exception_again;<span class="lineNum">     466 </span>            :             }<span class="lineNum">     467 </span>            :         }<span class="lineNum">     468 </span>            :     };<span class="lineNum">     469 </span>            : <span class="lineNum">     470 </span>            :   template&lt;&gt;<span class="lineNum">     471 </span>            :     struct __uninitialized_default_1&lt;true&gt;<span class="lineNum">     472 </span>            :     {<span class="lineNum">     473 </span>            :       template&lt;typename _ForwardIterator&gt;<span class="lineNum">     474 </span>            :         static void<span class="lineNum">     475 </span>            :         __uninit_default(_ForwardIterator __first, _ForwardIterator __last)<span class="lineNum">     476 </span>            :         {<span class="lineNum">     477 </span>            :           typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type<span class="lineNum">     478 </span>            :             _ValueType;<span class="lineNum">     479 </span>            : <span class="lineNum">     480 </span>            :           std::fill(__first, __last, _ValueType());<span class="lineNum">     481 </span>            :         }<span class="lineNum">     482 </span>            :     };<span class="lineNum">     483 </span>            : <span class="lineNum">     484 </span>            :   template&lt;bool _TrivialValueType&gt;<span class="lineNum">     485 </span>            :     struct __uninitialized_default_n_1<span class="lineNum">     486 </span>            :     {<span class="lineNum">     487 </span>            :       template&lt;typename _ForwardIterator, typename _Size&gt;<span class="lineNum">     488 </span>            :         static void<span class="lineNum">     489 </span>            :         __uninit_default_n(_ForwardIterator __first, _Size __n)<span class="lineNum">     490 </span>            :         {<span class="lineNum">     491 </span>            :           _ForwardIterator __cur = __first;<span class="lineNum">     492 </span>            :           __try<span class="lineNum">     493 </span>            :             {<span class="lineNum">     494 </span>            :               for (; __n &gt; 0; --__n, ++__cur)<span class="lineNum">     495 </span>            :                 std::_Construct(std::__addressof(*__cur));<span class="lineNum">     496 </span>            :             }<span class="lineNum">     497 </span>            :           __catch(...)<span class="lineNum">     498 </span>            :             {<span class="lineNum">     499 </span>            :               std::_Destroy(__first, __cur);<span class="lineNum">     500 </span>            :               __throw_exception_again;<span class="lineNum">     501 </span>            :             }<span class="lineNum">     502 </span>            :         }<span class="lineNum">     503 </span>            :     };<span class="lineNum">     504 </span>            : <span class="lineNum">     505 </span>            :   template&lt;&gt;<span class="lineNum">     506 </span>            :     struct __uninitialized_default_n_1&lt;true&gt;<span class="lineNum">     507 </span>            :     {<a name="508"><span class="lineNum">     508 </span>            :       template&lt;typename _ForwardIterator, typename _Size&gt;</a><span class="lineNum">     509 </span>            :         static void<span class="lineNum">     510 </span><span class="lineCov">         12 :         __uninit_default_n(_ForwardIterator __first, _Size __n)</span><span class="lineNum">     511 </span>            :         {<span class="lineNum">     512 </span>            :           typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type<span class="lineNum">     513 </span>            :             _ValueType;<span class="lineNum">     514 </span>            : <span class="lineNum">     515 </span><span class="lineCov">         12 :           std::fill_n(__first, __n, _ValueType());</span><span class="lineNum">     516 </span><span class="lineCov">         12 :         }</span><span class="lineNum">     517 </span>            :     };<span class="lineNum">     518 </span>            : <span class="lineNum">     519 </span>            :   // __uninitialized_default<span class="lineNum">     520 </span>            :   // Fills [first, last) with std::distance(first, last) default<span class="lineNum">     521 </span>            :   // constructed value_types(s).<span class="lineNum">     522 </span>            :   template&lt;typename _ForwardIterator&gt;<span class="lineNum">     523 </span>            :     inline void<span class="lineNum">     524 </span>            :     __uninitialized_default(_ForwardIterator __first,<span class="lineNum">     525 </span>            :                             _ForwardIterator __last)<span class="lineNum">     526 </span>            :     {<span class="lineNum">     527 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type<span class="lineNum">     528 </span>            :         _ValueType;<span class="lineNum">     529 </span>            : <span class="lineNum">     530 </span>            :       std::__uninitialized_default_1&lt;__is_trivial(_ValueType)&gt;::<span class="lineNum">     531 </span>            :         __uninit_default(__first, __last);<span class="lineNum">     532 </span>            :     }<span class="lineNum">     533 </span>            : <span class="lineNum">     534 </span>            :   // __uninitialized_default_n<span class="lineNum">     535 </span>            :   // Fills [first, first + n) with n default constructed value_type(s).<a name="536"><span class="lineNum">     536 </span>            :   template&lt;typename _ForwardIterator, typename _Size&gt;</a><span class="lineNum">     537 </span>            :     inline void<span class="lineNum">     538 </span><span class="lineCov">         12 :     __uninitialized_default_n(_ForwardIterator __first, _Size __n)</span><span class="lineNum">     539 </span>            :     {<span class="lineNum">     540 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type<span class="lineNum">     541 </span>            :         _ValueType;<span class="lineNum">     542 </span>            : <span class="lineNum">     543 </span><span class="lineCov">         12 :       std::__uninitialized_default_n_1&lt;__is_trivial(_ValueType)&gt;::</span><span class="lineNum">     544 </span>            :         __uninit_default_n(__first, __n);<span class="lineNum">     545 </span><span class="lineCov">         12 :     }</span><span class="lineNum">     546 </span>            : <span class="lineNum">     547 </span>            : <span class="lineNum">     548 </span>            :   // __uninitialized_default_a<span class="lineNum">     549 </span>            :   // Fills [first, last) with std::distance(first, last) default<span class="lineNum">     550 </span>            :   // constructed value_types(s), constructed with the allocator alloc.<span class="lineNum">     551 </span>            :   template&lt;typename _ForwardIterator, typename _Allocator&gt;<span class="lineNum">     552 </span>            :     void<span class="lineNum">     553 </span>            :     __uninitialized_default_a(_ForwardIterator __first,<span class="lineNum">     554 </span>            :                               _ForwardIterator __last,<span class="lineNum">     555 </span>            :                               _Allocator&amp; __alloc)<span class="lineNum">     556 </span>            :     {<span class="lineNum">     557 </span>            :       _ForwardIterator __cur = __first;<span class="lineNum">     558 </span>            :       __try<span class="lineNum">     559 </span>            :         {<span class="lineNum">     560 </span>            :           typedef __gnu_cxx::__alloc_traits&lt;_Allocator&gt; __traits;<span class="lineNum">     561 </span>            :           for (; __cur != __last; ++__cur)<span class="lineNum">     562 </span>            :             __traits::construct(__alloc, std::__addressof(*__cur));<span class="lineNum">     563 </span>            :         }<span class="lineNum">     564 </span>            :       __catch(...)<span class="lineNum">     565 </span>            :         {<span class="lineNum">     566 </span>            :           std::_Destroy(__first, __cur, __alloc);<span class="lineNum">     567 </span>            :           __throw_exception_again;<span class="lineNum">     568 </span>            :         }<span class="lineNum">     569 </span>            :     }<span class="lineNum">     570 </span>            : <span class="lineNum">     571 </span>            :   template&lt;typename _ForwardIterator, typename _Tp&gt;<span class="lineNum">     572 </span>            :     inline void<span class="lineNum">     573 </span>            :     __uninitialized_default_a(_ForwardIterator __first,<span class="lineNum">     574 </span>            :                               _ForwardIterator __last,<span class="lineNum">     575 </span>            :                               allocator&lt;_Tp&gt;&amp;)<span class="lineNum">     576 </span>            :     { std::__uninitialized_default(__first, __last); }<span class="lineNum">     577 </span>            : <span class="lineNum">     578 </span>            : <span class="lineNum">     579 </span>            :   // __uninitialized_default_n_a<span class="lineNum">     580 </span>            :   // Fills [first, first + n) with n default constructed value_types(s),<span class="lineNum">     581 </span>            :   // constructed with the allocator alloc.<span class="lineNum">     582 </span>            :   template&lt;typename _ForwardIterator, typename _Size, typename _Allocator&gt;<span class="lineNum">     583 </span>            :     void<span class="lineNum">     584 </span>            :     __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, <span class="lineNum">     585 </span>            :                                 _Allocator&amp; __alloc)<span class="lineNum">     586 </span>            :     {<span class="lineNum">     587 </span>            :       _ForwardIterator __cur = __first;<span class="lineNum">     588 </span>            :       __try<span class="lineNum">     589 </span>            :         {<span class="lineNum">     590 </span>            :           typedef __gnu_cxx::__alloc_traits&lt;_Allocator&gt; __traits;<span class="lineNum">     591 </span>            :           for (; __n &gt; 0; --__n, ++__cur)<span class="lineNum">     592 </span>            :             __traits::construct(__alloc, std::__addressof(*__cur));<span class="lineNum">     593 </span>            :         }<span class="lineNum">     594 </span>            :       __catch(...)<span class="lineNum">     595 </span>            :         {<span class="lineNum">     596 </span>            :           std::_Destroy(__first, __cur, __alloc);<span class="lineNum">     597 </span>            :           __throw_exception_again;<span class="lineNum">     598 </span>            :         }<span class="lineNum">     599 </span>            :     }<span class="lineNum">     600 </span>            : <a name="601"><span class="lineNum">     601 </span>            :   template&lt;typename _ForwardIterator, typename _Size, typename _Tp&gt;</a><span class="lineNum">     602 </span>            :     inline void<span class="lineNum">     603 </span><span class="lineCov">         12 :     __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, </span><span class="lineNum">     604 </span>            :                                 allocator&lt;_Tp&gt;&amp;)<span class="lineNum">     605 </span><span class="lineCov">         12 :     { std::__uninitialized_default_n(__first, __n); }</span><span class="lineNum">     606 </span>            : <span class="lineNum">     607 </span>            : <span class="lineNum">     608 </span>            :   template&lt;typename _InputIterator, typename _Size,<span class="lineNum">     609 </span>            :            typename _ForwardIterator&gt;<span class="lineNum">     610 </span>            :     _ForwardIterator<span class="lineNum">     611 </span>            :     __uninitialized_copy_n(_InputIterator __first, _Size __n,<span class="lineNum">     612 </span>            :                            _ForwardIterator __result, input_iterator_tag)<span class="lineNum">     613 </span>            :     {<span class="lineNum">     614 </span>            :       _ForwardIterator __cur = __result;<span class="lineNum">     615 </span>            :       __try<span class="lineNum">     616 </span>            :         {<span class="lineNum">     617 </span>            :           for (; __n &gt; 0; --__n, ++__first, ++__cur)<span class="lineNum">     618 </span>            :             std::_Construct(std::__addressof(*__cur), *__first);<span class="lineNum">     619 </span>            :           return __cur;<span class="lineNum">     620 </span>            :         }<span class="lineNum">     621 </span>            :       __catch(...)<span class="lineNum">     622 </span>            :         {<span class="lineNum">     623 </span>            :           std::_Destroy(__result, __cur);<span class="lineNum">     624 </span>            :           __throw_exception_again;<span class="lineNum">     625 </span>            :         }<span class="lineNum">     626 </span>            :     }<span class="lineNum">     627 </span>            : <span class="lineNum">     628 </span>            :   template&lt;typename _RandomAccessIterator, typename _Size,<span class="lineNum">     629 </span>            :            typename _ForwardIterator&gt;<span class="lineNum">     630 </span>            :     inline _ForwardIterator<span class="lineNum">     631 </span>            :     __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,<span class="lineNum">     632 </span>            :                            _ForwardIterator __result,<span class="lineNum">     633 </span>            :                            random_access_iterator_tag)<span class="lineNum">     634 </span>            :     { return std::uninitialized_copy(__first, __first + __n, __result); }<span class="lineNum">     635 </span>            : <span class="lineNum">     636 </span>            :   /**<span class="lineNum">     637 </span>            :    *  @brief Copies the range [first,first+n) into result.<span class="lineNum">     638 </span>            :    *  @param  __first  An input iterator.<span class="lineNum">     639 </span>            :    *  @param  __n      The number of elements to copy.<span class="lineNum">     640 </span>            :    *  @param  __result An output iterator.<span class="lineNum">     641 </span>            :    *  @return  __result + __n<span class="lineNum">     642 </span>            :    *<span class="lineNum">     643 </span>            :    *  Like copy_n(), but does not require an initialized output range.<span class="lineNum">     644 </span>            :   */<span class="lineNum">     645 </span>            :   template&lt;typename _InputIterator, typename _Size, typename _ForwardIterator&gt;<span class="lineNum">     646 </span>            :     inline _ForwardIterator<span class="lineNum">     647 </span>            :     uninitialized_copy_n(_InputIterator __first, _Size __n,<span class="lineNum">     648 </span>            :                          _ForwardIterator __result)<span class="lineNum">     649 </span>            :     { return std::__uninitialized_copy_n(__first, __n, __result,<span class="lineNum">     650 </span>            :                                          std::__iterator_category(__first)); }<span class="lineNum">     651 </span>            : #endif<span class="lineNum">     652 </span>            : <span class="lineNum">     653 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     654 </span>            : } // namespace<span class="lineNum">     655 </span>            : <span class="lineNum">     656 </span>            : #endif /* _STL_UNINITIALIZED_H */</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_uninitialized.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_uninitialized.h<span style="font-size: 80%;"> (<a href="stl_uninitialized.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">23</td>            <td class="headerCovTableEntry">25</td>            <td class="headerCovTableEntryHi">92.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">13</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntryHi">92.9 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="stl_uninitialized.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#89">_ZNSt20__uninitialized_copyILb1EE13__uninit_copyISt13move_iteratorIPdES3_EET0_T_S6_S5_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#200">_ZNSt22__uninitialized_fill_nILb1EE15__uninit_fill_nIPdmdEEvT_T0_RKT1_</a></td>              <td class="coverFnHi">12</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#200">_ZNSt22__uninitialized_fill_nILb1EE15__uninit_fill_nIPimiEEvT_T0_RKT1_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#508">_ZNSt27__uninitialized_default_n_1ILb1EE18__uninit_default_nIPdmEEvT_T0_</a></td>              <td class="coverFnHi">6</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#105">_ZSt18uninitialized_copyISt13move_iteratorIPdES1_ET0_T_S4_S3_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#216">_ZSt20uninitialized_fill_nIPdmdEvT_T0_RKT1_</a></td>              <td class="coverFnHi">12</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#216">_ZSt20uninitialized_fill_nIPimiEvT_T0_RKT1_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#254">_ZSt22__uninitialized_copy_aISt13move_iteratorIPdES1_dET0_T_S4_S3_RSaIT1_E</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#261">_ZSt22__uninitialized_move_aIPdS0_SaIdEET0_T_S3_S2_RT1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#330">_ZSt24__uninitialized_fill_n_aIPdmddEvT_T0_RKT1_RSaIT2_E</a></td>              <td class="coverFnHi">12</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#330">_ZSt24__uninitialized_fill_n_aIPimiiEvT_T0_RKT1_RSaIT2_E</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#536">_ZSt25__uninitialized_default_nIPdmEvT_T0_</a></td>              <td class="coverFnHi">6</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#601">_ZSt27__uninitialized_default_n_aIPdmdEvT_T0_RSaIT1_E</a></td>              <td class="coverFnHi">6</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#272">_ZSt34__uninitialized_move_if_noexcept_aIPdS0_SaIdEET0_T_S3_S2_RT1_</a></td>              <td class="coverFnHi">47</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_uninitialized.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_uninitialized.h<span style="font-size: 80%;"> (<a href="stl_uninitialized.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">23</td>            <td class="headerCovTableEntry">25</td>            <td class="headerCovTableEntryHi">92.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">13</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntryHi">92.9 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="stl_uninitialized.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#261">_ZSt22__uninitialized_move_aIPdS0_SaIdEET0_T_S3_S2_RT1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#200">_ZNSt22__uninitialized_fill_nILb1EE15__uninit_fill_nIPimiEEvT_T0_RKT1_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#216">_ZSt20uninitialized_fill_nIPimiEvT_T0_RKT1_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#330">_ZSt24__uninitialized_fill_n_aIPimiiEvT_T0_RKT1_RSaIT2_E</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#508">_ZNSt27__uninitialized_default_n_1ILb1EE18__uninit_default_nIPdmEEvT_T0_</a></td>              <td class="coverFnHi">6</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#536">_ZSt25__uninitialized_default_nIPdmEvT_T0_</a></td>              <td class="coverFnHi">6</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#601">_ZSt27__uninitialized_default_n_aIPdmdEvT_T0_RSaIT1_E</a></td>              <td class="coverFnHi">6</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#200">_ZNSt22__uninitialized_fill_nILb1EE15__uninit_fill_nIPdmdEEvT_T0_RKT1_</a></td>              <td class="coverFnHi">12</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#216">_ZSt20uninitialized_fill_nIPdmdEvT_T0_RKT1_</a></td>              <td class="coverFnHi">12</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#330">_ZSt24__uninitialized_fill_n_aIPdmddEvT_T0_RKT1_RSaIT2_E</a></td>              <td class="coverFnHi">12</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#89">_ZNSt20__uninitialized_copyILb1EE13__uninit_copyISt13move_iteratorIPdES3_EET0_T_S6_S5_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#105">_ZSt18uninitialized_copyISt13move_iteratorIPdES1_ET0_T_S4_S3_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#254">_ZSt22__uninitialized_copy_aISt13move_iteratorIPdES1_dET0_T_S4_S3_RSaIT1_E</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_uninitialized.h.gcov.html#272">_ZSt34__uninitialized_move_if_noexcept_aIPdS0_SaIdEET0_T_S3_S2_RT1_</a></td>              <td class="coverFnHi">47</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_uninitialized.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_iterator_base_types.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_iterator_base_types.h<span style="font-size: 80%;"> (source / <a href="stl_iterator_base_types.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">3</td>            <td class="headerCovTableEntry">5</td>            <td class="headerCovTableEntryLo">60.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Types used in iterator implementation -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2001-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /*<span class="lineNum">      26 </span>            :  *<span class="lineNum">      27 </span>            :  * Copyright (c) 1994<span class="lineNum">      28 </span>            :  * Hewlett-Packard Company<span class="lineNum">      29 </span>            :  *<span class="lineNum">      30 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      31 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      32 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      33 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      34 </span>            :  * in supporting documentation.  Hewlett-Packard Company makes no<span class="lineNum">      35 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      36 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      37 </span>            :  *<span class="lineNum">      38 </span>            :  *<span class="lineNum">      39 </span>            :  * Copyright (c) 1996-1998<span class="lineNum">      40 </span>            :  * Silicon Graphics Computer Systems, Inc.<span class="lineNum">      41 </span>            :  *<span class="lineNum">      42 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      43 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      44 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      45 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      46 </span>            :  * in supporting documentation.  Silicon Graphics makes no<span class="lineNum">      47 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      48 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      49 </span>            :  */<span class="lineNum">      50 </span>            : <span class="lineNum">      51 </span>            : /** @file bits/stl_iterator_base_types.h<span class="lineNum">      52 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      53 </span>            :  *  Do not attempt to use it directly. @headername{iterator}<span class="lineNum">      54 </span>            :  *<span class="lineNum">      55 </span>            :  *  This file contains all of the general iterator-related utility types,<span class="lineNum">      56 </span>            :  *  such as iterator_traits and struct iterator.<span class="lineNum">      57 </span>            :  */<span class="lineNum">      58 </span>            : <span class="lineNum">      59 </span>            : #ifndef _STL_ITERATOR_BASE_TYPES_H<span class="lineNum">      60 </span>            : #define _STL_ITERATOR_BASE_TYPES_H 1<span class="lineNum">      61 </span>            : <span class="lineNum">      62 </span>            : #pragma GCC system_header<span class="lineNum">      63 </span>            : <span class="lineNum">      64 </span>            : #include &lt;bits/c++config.h&gt;<span class="lineNum">      65 </span>            : <span class="lineNum">      66 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      67 </span>            : # include &lt;type_traits&gt;  // For _GLIBCXX_HAS_NESTED_TYPE, is_convertible<span class="lineNum">      68 </span>            : #endif<span class="lineNum">      69 </span>            : <span class="lineNum">      70 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      71 </span>            : {<span class="lineNum">      72 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      73 </span>            : <span class="lineNum">      74 </span>            :   /**<span class="lineNum">      75 </span>            :    *  @defgroup iterators Iterators<span class="lineNum">      76 </span>            :    *  Abstractions for uniform iterating through various underlying types.<span class="lineNum">      77 </span>            :   */<span class="lineNum">      78 </span>            :   //@{ <span class="lineNum">      79 </span>            : <span class="lineNum">      80 </span>            :   /**<span class="lineNum">      81 </span>            :    *  @defgroup iterator_tags Iterator Tags<span class="lineNum">      82 </span>            :    *  These are empty types, used to distinguish different iterators.  The<span class="lineNum">      83 </span>            :    *  distinction is not made by what they contain, but simply by what they<span class="lineNum">      84 </span>            :    *  are.  Different underlying algorithms can then be used based on the<span class="lineNum">      85 </span>            :    *  different operations supported by different iterator types.<span class="lineNum">      86 </span>            :   */<span class="lineNum">      87 </span>            :   //@{ <span class="lineNum">      88 </span>            :   ///  Marking input iterators.<span class="lineNum">      89 </span>            :   struct input_iterator_tag { };<span class="lineNum">      90 </span>            : <span class="lineNum">      91 </span>            :   ///  Marking output iterators.<span class="lineNum">      92 </span>            :   struct output_iterator_tag { };<span class="lineNum">      93 </span>            : <span class="lineNum">      94 </span>            :   /// Forward iterators support a superset of input iterator operations.<span class="lineNum">      95 </span>            :   struct forward_iterator_tag : public input_iterator_tag { };<span class="lineNum">      96 </span>            : <span class="lineNum">      97 </span>            :   /// Bidirectional iterators support a superset of forward iterator<span class="lineNum">      98 </span>            :   /// operations.<span class="lineNum">      99 </span>            :   struct bidirectional_iterator_tag : public forward_iterator_tag { };<span class="lineNum">     100 </span>            : <span class="lineNum">     101 </span>            :   /// Random-access iterators support a superset of bidirectional<span class="lineNum">     102 </span>            :   /// iterator operations.<span class="lineNum">     103 </span>            :   struct random_access_iterator_tag : public bidirectional_iterator_tag { };<span class="lineNum">     104 </span>            :   //@}<span class="lineNum">     105 </span>            : <span class="lineNum">     106 </span>            :   /**<span class="lineNum">     107 </span>            :    *  @brief  Common %iterator class.<span class="lineNum">     108 </span>            :    *<span class="lineNum">     109 </span>            :    *  This class does nothing but define nested typedefs.  %Iterator classes<span class="lineNum">     110 </span>            :    *  can inherit from this class to save some work.  The typedefs are then<span class="lineNum">     111 </span>            :    *  used in specializations and overloading.<span class="lineNum">     112 </span>            :    *<span class="lineNum">     113 </span>            :    *  In particular, there are no default implementations of requirements<span class="lineNum">     114 </span>            :    *  such as @c operator++ and the like.  (How could there be?)<span class="lineNum">     115 </span>            :   */<span class="lineNum">     116 </span>            :   template&lt;typename _Category, typename _Tp, typename _Distance = ptrdiff_t,<span class="lineNum">     117 </span>            :            typename _Pointer = _Tp*, typename _Reference = _Tp&amp;&gt;<span class="lineNum">     118 </span>            :     struct iterator<span class="lineNum">     119 </span>            :     {<span class="lineNum">     120 </span>            :       /// One of the @link iterator_tags tag types@endlink.<span class="lineNum">     121 </span>            :       typedef _Category  iterator_category;<span class="lineNum">     122 </span>            :       /// The type &quot;pointed to&quot; by the iterator.<span class="lineNum">     123 </span>            :       typedef _Tp        value_type;<span class="lineNum">     124 </span>            :       /// Distance between iterators is represented as this type.<span class="lineNum">     125 </span>            :       typedef _Distance  difference_type;<span class="lineNum">     126 </span>            :       /// This type represents a pointer-to-value_type.<span class="lineNum">     127 </span>            :       typedef _Pointer   pointer;<span class="lineNum">     128 </span>            :       /// This type represents a reference-to-value_type.<span class="lineNum">     129 </span>            :       typedef _Reference reference;<span class="lineNum">     130 </span>            :     };<span class="lineNum">     131 </span>            : <span class="lineNum">     132 </span>            :   /**<span class="lineNum">     133 </span>            :    *  @brief  Traits class for iterators.<span class="lineNum">     134 </span>            :    *<span class="lineNum">     135 </span>            :    *  This class does nothing but define nested typedefs.  The general<span class="lineNum">     136 </span>            :    *  version simply @a forwards the nested typedefs from the Iterator<span class="lineNum">     137 </span>            :    *  argument.  Specialized versions for pointers and pointers-to-const<span class="lineNum">     138 </span>            :    *  provide tighter, more correct semantics.<span class="lineNum">     139 </span>            :   */<span class="lineNum">     140 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     141 </span>            : <span class="lineNum">     142 </span>            : _GLIBCXX_HAS_NESTED_TYPE(iterator_category)<span class="lineNum">     143 </span>            : <span class="lineNum">     144 </span>            :   template&lt;typename _Iterator,<span class="lineNum">     145 </span>            :            bool = __has_iterator_category&lt;_Iterator&gt;::value&gt;<span class="lineNum">     146 </span>            :     struct __iterator_traits { };<span class="lineNum">     147 </span>            : <span class="lineNum">     148 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     149 </span>            :     struct __iterator_traits&lt;_Iterator, true&gt;<span class="lineNum">     150 </span>            :     {<span class="lineNum">     151 </span>            :       typedef typename _Iterator::iterator_category iterator_category;<span class="lineNum">     152 </span>            :       typedef typename _Iterator::value_type        value_type;<span class="lineNum">     153 </span>            :       typedef typename _Iterator::difference_type   difference_type;<span class="lineNum">     154 </span>            :       typedef typename _Iterator::pointer           pointer;<span class="lineNum">     155 </span>            :       typedef typename _Iterator::reference         reference;<span class="lineNum">     156 </span>            :     };<span class="lineNum">     157 </span>            : <span class="lineNum">     158 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     159 </span>            :     struct iterator_traits<span class="lineNum">     160 </span>            :     : public __iterator_traits&lt;_Iterator&gt; { };<span class="lineNum">     161 </span>            : #else<span class="lineNum">     162 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     163 </span>            :     struct iterator_traits<span class="lineNum">     164 </span>            :     {<span class="lineNum">     165 </span>            :       typedef typename _Iterator::iterator_category iterator_category;<span class="lineNum">     166 </span>            :       typedef typename _Iterator::value_type        value_type;<span class="lineNum">     167 </span>            :       typedef typename _Iterator::difference_type   difference_type;<span class="lineNum">     168 </span>            :       typedef typename _Iterator::pointer           pointer;<span class="lineNum">     169 </span>            :       typedef typename _Iterator::reference         reference;<span class="lineNum">     170 </span>            :     };<span class="lineNum">     171 </span>            : #endif<span class="lineNum">     172 </span>            : <span class="lineNum">     173 </span>            :   /// Partial specialization for pointer types.<span class="lineNum">     174 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     175 </span>            :     struct iterator_traits&lt;_Tp*&gt;<span class="lineNum">     176 </span>            :     {<span class="lineNum">     177 </span>            :       typedef random_access_iterator_tag iterator_category;<span class="lineNum">     178 </span>            :       typedef _Tp                         value_type;<span class="lineNum">     179 </span>            :       typedef ptrdiff_t                   difference_type;<span class="lineNum">     180 </span>            :       typedef _Tp*                        pointer;<span class="lineNum">     181 </span>            :       typedef _Tp&amp;                        reference;<span class="lineNum">     182 </span>            :     };<span class="lineNum">     183 </span>            : <span class="lineNum">     184 </span>            :   /// Partial specialization for const pointer types.<span class="lineNum">     185 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     186 </span>            :     struct iterator_traits&lt;const _Tp*&gt;<span class="lineNum">     187 </span>            :     {<span class="lineNum">     188 </span>            :       typedef random_access_iterator_tag iterator_category;<span class="lineNum">     189 </span>            :       typedef _Tp                         value_type;<span class="lineNum">     190 </span>            :       typedef ptrdiff_t                   difference_type;<span class="lineNum">     191 </span>            :       typedef const _Tp*                  pointer;<span class="lineNum">     192 </span>            :       typedef const _Tp&amp;                  reference;<span class="lineNum">     193 </span>            :     };<span class="lineNum">     194 </span>            : <span class="lineNum">     195 </span>            :   /**<span class="lineNum">     196 </span>            :    *  This function is not a part of the C++ standard but is syntactic<span class="lineNum">     197 </span>            :    *  sugar for internal library use only.<span class="lineNum">     198 </span>            :   */<span class="lineNum">     199 </span>            :   template&lt;typename _Iter&gt;<span class="lineNum">     200 </span>            :     inline typename iterator_traits&lt;_Iter&gt;::iterator_category<span class="lineNum">     201 </span>            :     __iterator_category(const _Iter&amp;)<span class="lineNum">     202 </span>            :     { return typename iterator_traits&lt;_Iter&gt;::iterator_category(); }<span class="lineNum">     203 </span>            : <span class="lineNum">     204 </span>            :   //@}<span class="lineNum">     205 </span>            : <span class="lineNum">     206 </span>            :   // If _Iterator has a base returns it otherwise _Iterator is returned<span class="lineNum">     207 </span>            :   // untouched<span class="lineNum">     208 </span>            :   template&lt;typename _Iterator, bool _HasBase&gt;<span class="lineNum">     209 </span>            :     struct _Iter_base<a name="210"><span class="lineNum">     210 </span>            :     {</a><span class="lineNum">     211 </span>            :       typedef _Iterator iterator_type;<span class="lineNum">     212 </span><span class="lineCov">        460 :       static iterator_type _S_base(_Iterator __it)</span><span class="lineNum">     213 </span><span class="lineCov">        460 :       { return __it; }</span><span class="lineNum">     214 </span>            :     };<span class="lineNum">     215 </span>            : <span class="lineNum">     216 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     217 </span>            :     struct _Iter_base&lt;_Iterator, true&gt;<a name="218"><span class="lineNum">     218 </span>            :     {</a><span class="lineNum">     219 </span>            :       typedef typename _Iterator::iterator_type iterator_type;<span class="lineNum">     220 </span><span class="lineCov">        188 :       static iterator_type _S_base(_Iterator __it)</span><span class="lineNum">     221 </span><span class="lineCov">        188 :       { return __it.base(); }</span><span class="lineNum">     222 </span>            :     };<span class="lineNum">     223 </span>            : <span class="lineNum">     224 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     225 </span>            :   template&lt;typename _InIter&gt;<span class="lineNum">     226 </span>            :     using _RequireInputIter = typename<span class="lineNum">     227 </span>            :       enable_if&lt;is_convertible&lt;typename<span class="lineNum">     228 </span>            :                 iterator_traits&lt;_InIter&gt;::iterator_category,<span class="lineNum">     229 </span>            :                                input_iterator_tag&gt;::value&gt;::type;<span class="lineNum">     230 </span>            : #endif<span class="lineNum">     231 </span>            : <span class="lineNum">     232 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     233 </span>            : } // namespace<span class="lineNum">     234 </span>            : <span class="lineNum">     235 </span>            : #endif /* _STL_ITERATOR_BASE_TYPES_H */<span class="lineNum">     236 </span>            : </pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_iterator_base_types.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_iterator_base_types.h<span style="font-size: 80%;"> (<a href="stl_iterator_base_types.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">3</td>            <td class="headerCovTableEntry">5</td>            <td class="headerCovTableEntryLo">60.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="stl_iterator_base_types.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_iterator_base_types.h.gcov.html#218">_ZNSt10_Iter_baseIN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEELb1EE7_S_baseES6_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator_base_types.h.gcov.html#218">_ZNSt10_Iter_baseIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEELb1EE7_S_baseES6_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator_base_types.h.gcov.html#210">_ZNSt10_Iter_baseIPdLb0EE7_S_baseES0_</a></td>              <td class="coverFnHi">219</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator_base_types.h.gcov.html#210">_ZNSt10_Iter_baseIPiLb0EE7_S_baseES0_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator_base_types.h.gcov.html#218">_ZNSt10_Iter_baseISt13move_iteratorIPdELb1EE7_S_baseES2_</a></td>              <td class="coverFnHi">94</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_iterator_base_types.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_iterator_base_types.h<span style="font-size: 80%;"> (<a href="stl_iterator_base_types.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">3</td>            <td class="headerCovTableEntry">5</td>            <td class="headerCovTableEntryLo">60.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="stl_iterator_base_types.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_iterator_base_types.h.gcov.html#218">_ZNSt10_Iter_baseIN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEELb1EE7_S_baseES6_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator_base_types.h.gcov.html#218">_ZNSt10_Iter_baseIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEELb1EE7_S_baseES6_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator_base_types.h.gcov.html#210">_ZNSt10_Iter_baseIPiLb0EE7_S_baseES0_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator_base_types.h.gcov.html#218">_ZNSt10_Iter_baseISt13move_iteratorIPdELb1EE7_S_baseES2_</a></td>              <td class="coverFnHi">94</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator_base_types.h.gcov.html#210">_ZNSt10_Iter_baseIPdLb0EE7_S_baseES0_</a></td>              <td class="coverFnHi">219</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator_base_types.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_iterator.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_iterator.h<span style="font-size: 80%;"> (source / <a href="stl_iterator.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">11</td>            <td class="headerCovTableEntry">13</td>            <td class="headerCovTableEntryMed">84.6 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntryLo">66.7 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Iterators -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2001-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /*<span class="lineNum">      26 </span>            :  *<span class="lineNum">      27 </span>            :  * Copyright (c) 1994<span class="lineNum">      28 </span>            :  * Hewlett-Packard Company<span class="lineNum">      29 </span>            :  *<span class="lineNum">      30 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      31 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      32 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      33 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      34 </span>            :  * in supporting documentation.  Hewlett-Packard Company makes no<span class="lineNum">      35 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      36 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      37 </span>            :  *<span class="lineNum">      38 </span>            :  *<span class="lineNum">      39 </span>            :  * Copyright (c) 1996-1998<span class="lineNum">      40 </span>            :  * Silicon Graphics Computer Systems, Inc.<span class="lineNum">      41 </span>            :  *<span class="lineNum">      42 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      43 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      44 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      45 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      46 </span>            :  * in supporting documentation.  Silicon Graphics makes no<span class="lineNum">      47 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      48 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      49 </span>            :  */<span class="lineNum">      50 </span>            : <span class="lineNum">      51 </span>            : /** @file bits/stl_iterator.h<span class="lineNum">      52 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      53 </span>            :  *  Do not attempt to use it directly. @headername{iterator}<span class="lineNum">      54 </span>            :  *<span class="lineNum">      55 </span>            :  *  This file implements reverse_iterator, back_insert_iterator,<span class="lineNum">      56 </span>            :  *  front_insert_iterator, insert_iterator, __normal_iterator, and their<span class="lineNum">      57 </span>            :  *  supporting functions and overloaded operators.<span class="lineNum">      58 </span>            :  */<span class="lineNum">      59 </span>            : <span class="lineNum">      60 </span>            : #ifndef _STL_ITERATOR_H<span class="lineNum">      61 </span>            : #define _STL_ITERATOR_H 1<span class="lineNum">      62 </span>            : <span class="lineNum">      63 </span>            : #include &lt;bits/cpp_type_traits.h&gt;<span class="lineNum">      64 </span>            : #include &lt;ext/type_traits.h&gt;<span class="lineNum">      65 </span>            : #include &lt;bits/move.h&gt;<span class="lineNum">      66 </span>            : <span class="lineNum">      67 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      68 </span>            : {<span class="lineNum">      69 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      70 </span>            : <span class="lineNum">      71 </span>            :   /**<span class="lineNum">      72 </span>            :    * @addtogroup iterators<span class="lineNum">      73 </span>            :    * @{<span class="lineNum">      74 </span>            :    */<span class="lineNum">      75 </span>            : <span class="lineNum">      76 </span>            :   // 24.4.1 Reverse iterators<span class="lineNum">      77 </span>            :   /**<span class="lineNum">      78 </span>            :    *  Bidirectional and random access iterators have corresponding reverse<span class="lineNum">      79 </span>            :    *  %iterator adaptors that iterate through the data structure in the<span class="lineNum">      80 </span>            :    *  opposite direction.  They have the same signatures as the corresponding<span class="lineNum">      81 </span>            :    *  iterators.  The fundamental relation between a reverse %iterator and its<span class="lineNum">      82 </span>            :    *  corresponding %iterator @c i is established by the identity:<span class="lineNum">      83 </span>            :    *  @code<span class="lineNum">      84 </span>            :    *      &amp;*(reverse_iterator(i)) == &amp;*(i - 1)<span class="lineNum">      85 </span>            :    *  @endcode<span class="lineNum">      86 </span>            :    *<span class="lineNum">      87 </span>            :    *  &lt;em&gt;This mapping is dictated by the fact that while there is always a<span class="lineNum">      88 </span>            :    *  pointer past the end of an array, there might not be a valid pointer<span class="lineNum">      89 </span>            :    *  before the beginning of an array.&lt;/em&gt; [24.4.1]/1,2<span class="lineNum">      90 </span>            :    *<span class="lineNum">      91 </span>            :    *  Reverse iterators can be tricky and surprising at first.  Their<span class="lineNum">      92 </span>            :    *  semantics make sense, however, and the trickiness is a side effect of<span class="lineNum">      93 </span>            :    *  the requirement that the iterators must be safe.<span class="lineNum">      94 </span>            :   */<span class="lineNum">      95 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">      96 </span>            :     class reverse_iterator<span class="lineNum">      97 </span>            :     : public iterator&lt;typename iterator_traits&lt;_Iterator&gt;::iterator_category,<span class="lineNum">      98 </span>            :                       typename iterator_traits&lt;_Iterator&gt;::value_type,<span class="lineNum">      99 </span>            :                       typename iterator_traits&lt;_Iterator&gt;::difference_type,<span class="lineNum">     100 </span>            :                       typename iterator_traits&lt;_Iterator&gt;::pointer,<span class="lineNum">     101 </span>            :                       typename iterator_traits&lt;_Iterator&gt;::reference&gt;<span class="lineNum">     102 </span>            :     {<span class="lineNum">     103 </span>            :     protected:<span class="lineNum">     104 </span>            :       _Iterator current;<span class="lineNum">     105 </span>            : <span class="lineNum">     106 </span>            :       typedef iterator_traits&lt;_Iterator&gt;          __traits_type;<span class="lineNum">     107 </span>            : <span class="lineNum">     108 </span>            :     public:<span class="lineNum">     109 </span>            :       typedef _Iterator                                 iterator_type;<span class="lineNum">     110 </span>            :       typedef typename __traits_type::difference_type   difference_type;<span class="lineNum">     111 </span>            :       typedef typename __traits_type::pointer           pointer;<span class="lineNum">     112 </span>            :       typedef typename __traits_type::reference         reference;<span class="lineNum">     113 </span>            : <span class="lineNum">     114 </span>            :       /**<span class="lineNum">     115 </span>            :        *  The default constructor value-initializes member @p current.<span class="lineNum">     116 </span>            :        *  If it is a pointer, that means it is zero-initialized.<span class="lineNum">     117 </span>            :       */<span class="lineNum">     118 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     119 </span>            :       // 235 No specification of default ctor for reverse_iterator<span class="lineNum">     120 </span>            :       reverse_iterator() : current() { }<span class="lineNum">     121 </span>            : <span class="lineNum">     122 </span>            :       /**<span class="lineNum">     123 </span>            :        *  This %iterator will move in the opposite direction that @p x does.<span class="lineNum">     124 </span>            :       */<span class="lineNum">     125 </span>            :       explicit<span class="lineNum">     126 </span>            :       reverse_iterator(iterator_type __x) : current(__x) { }<span class="lineNum">     127 </span>            : <span class="lineNum">     128 </span>            :       /**<span class="lineNum">     129 </span>            :        *  The copy constructor is normal.<span class="lineNum">     130 </span>            :       */<span class="lineNum">     131 </span>            :       reverse_iterator(const reverse_iterator&amp; __x)<span class="lineNum">     132 </span>            :       : current(__x.current) { }<span class="lineNum">     133 </span>            : <span class="lineNum">     134 </span>            :       /**<span class="lineNum">     135 </span>            :        *  A %reverse_iterator across other types can be copied if the<span class="lineNum">     136 </span>            :        *  underlying %iterator can be converted to the type of @c current.<span class="lineNum">     137 </span>            :       */<span class="lineNum">     138 </span>            :       template&lt;typename _Iter&gt;<span class="lineNum">     139 </span>            :         reverse_iterator(const reverse_iterator&lt;_Iter&gt;&amp; __x)<span class="lineNum">     140 </span>            :         : current(__x.base()) { }<span class="lineNum">     141 </span>            : <span class="lineNum">     142 </span>            :       /**<span class="lineNum">     143 </span>            :        *  @return  @c current, the %iterator used for underlying work.<span class="lineNum">     144 </span>            :       */<span class="lineNum">     145 </span>            :       iterator_type<span class="lineNum">     146 </span>            :       base() const<span class="lineNum">     147 </span>            :       { return current; }<span class="lineNum">     148 </span>            : <span class="lineNum">     149 </span>            :       /**<span class="lineNum">     150 </span>            :        *  @return  A reference to the value at @c --current<span class="lineNum">     151 </span>            :        *<span class="lineNum">     152 </span>            :        *  This requires that @c --current is dereferenceable.<span class="lineNum">     153 </span>            :        *<span class="lineNum">     154 </span>            :        *  @warning This implementation requires that for an iterator of the<span class="lineNum">     155 </span>            :        *           underlying iterator type, @c x, a reference obtained by<span class="lineNum">     156 </span>            :        *           @c *x remains valid after @c x has been modified or<span class="lineNum">     157 </span>            :        *           destroyed. This is a bug: http://gcc.gnu.org/PR51823<span class="lineNum">     158 </span>            :       */<span class="lineNum">     159 </span>            :       reference<span class="lineNum">     160 </span>            :       operator*() const<span class="lineNum">     161 </span>            :       {<span class="lineNum">     162 </span>            :         _Iterator __tmp = current;<span class="lineNum">     163 </span>            :         return *--__tmp;<span class="lineNum">     164 </span>            :       }<span class="lineNum">     165 </span>            : <span class="lineNum">     166 </span>            :       /**<span class="lineNum">     167 </span>            :        *  @return  A pointer to the value at @c --current<span class="lineNum">     168 </span>            :        *<span class="lineNum">     169 </span>            :        *  This requires that @c --current is dereferenceable.<span class="lineNum">     170 </span>            :       */<span class="lineNum">     171 </span>            :       pointer<span class="lineNum">     172 </span>            :       operator-&gt;() const<span class="lineNum">     173 </span>            :       { return &amp;(operator*()); }<span class="lineNum">     174 </span>            : <span class="lineNum">     175 </span>            :       /**<span class="lineNum">     176 </span>            :        *  @return  @c *this<span class="lineNum">     177 </span>            :        *<span class="lineNum">     178 </span>            :        *  Decrements the underlying iterator.<span class="lineNum">     179 </span>            :       */<span class="lineNum">     180 </span>            :       reverse_iterator&amp;<span class="lineNum">     181 </span>            :       operator++()<span class="lineNum">     182 </span>            :       {<span class="lineNum">     183 </span>            :         --current;<span class="lineNum">     184 </span>            :         return *this;<span class="lineNum">     185 </span>            :       }<span class="lineNum">     186 </span>            : <span class="lineNum">     187 </span>            :       /**<span class="lineNum">     188 </span>            :        *  @return  The original value of @c *this<span class="lineNum">     189 </span>            :        *<span class="lineNum">     190 </span>            :        *  Decrements the underlying iterator.<span class="lineNum">     191 </span>            :       */<span class="lineNum">     192 </span>            :       reverse_iterator<span class="lineNum">     193 </span>            :       operator++(int)<span class="lineNum">     194 </span>            :       {<span class="lineNum">     195 </span>            :         reverse_iterator __tmp = *this;<span class="lineNum">     196 </span>            :         --current;<span class="lineNum">     197 </span>            :         return __tmp;<span class="lineNum">     198 </span>            :       }<span class="lineNum">     199 </span>            : <span class="lineNum">     200 </span>            :       /**<span class="lineNum">     201 </span>            :        *  @return  @c *this<span class="lineNum">     202 </span>            :        *<span class="lineNum">     203 </span>            :        *  Increments the underlying iterator.<span class="lineNum">     204 </span>            :       */<span class="lineNum">     205 </span>            :       reverse_iterator&amp;<span class="lineNum">     206 </span>            :       operator--()<span class="lineNum">     207 </span>            :       {<span class="lineNum">     208 </span>            :         ++current;<span class="lineNum">     209 </span>            :         return *this;<span class="lineNum">     210 </span>            :       }<span class="lineNum">     211 </span>            : <span class="lineNum">     212 </span>            :       /**<span class="lineNum">     213 </span>            :        *  @return  A reverse_iterator with the previous value of @c *this<span class="lineNum">     214 </span>            :        *<span class="lineNum">     215 </span>            :        *  Increments the underlying iterator.<span class="lineNum">     216 </span>            :       */<span class="lineNum">     217 </span>            :       reverse_iterator<span class="lineNum">     218 </span>            :       operator--(int)<span class="lineNum">     219 </span>            :       {<span class="lineNum">     220 </span>            :         reverse_iterator __tmp = *this;<span class="lineNum">     221 </span>            :         ++current;<span class="lineNum">     222 </span>            :         return __tmp;<span class="lineNum">     223 </span>            :       }<span class="lineNum">     224 </span>            : <span class="lineNum">     225 </span>            :       /**<span class="lineNum">     226 </span>            :        *  @return  A reverse_iterator that refers to @c current - @a __n<span class="lineNum">     227 </span>            :        *<span class="lineNum">     228 </span>            :        *  The underlying iterator must be a Random Access Iterator.<span class="lineNum">     229 </span>            :       */<span class="lineNum">     230 </span>            :       reverse_iterator<span class="lineNum">     231 </span>            :       operator+(difference_type __n) const<span class="lineNum">     232 </span>            :       { return reverse_iterator(current - __n); }<span class="lineNum">     233 </span>            : <span class="lineNum">     234 </span>            :       /**<span class="lineNum">     235 </span>            :        *  @return  *this<span class="lineNum">     236 </span>            :        *<span class="lineNum">     237 </span>            :        *  Moves the underlying iterator backwards @a __n steps.<span class="lineNum">     238 </span>            :        *  The underlying iterator must be a Random Access Iterator.<span class="lineNum">     239 </span>            :       */<span class="lineNum">     240 </span>            :       reverse_iterator&amp;<span class="lineNum">     241 </span>            :       operator+=(difference_type __n)<span class="lineNum">     242 </span>            :       {<span class="lineNum">     243 </span>            :         current -= __n;<span class="lineNum">     244 </span>            :         return *this;<span class="lineNum">     245 </span>            :       }<span class="lineNum">     246 </span>            : <span class="lineNum">     247 </span>            :       /**<span class="lineNum">     248 </span>            :        *  @return  A reverse_iterator that refers to @c current - @a __n<span class="lineNum">     249 </span>            :        *<span class="lineNum">     250 </span>            :        *  The underlying iterator must be a Random Access Iterator.<span class="lineNum">     251 </span>            :       */<span class="lineNum">     252 </span>            :       reverse_iterator<span class="lineNum">     253 </span>            :       operator-(difference_type __n) const<span class="lineNum">     254 </span>            :       { return reverse_iterator(current + __n); }<span class="lineNum">     255 </span>            : <span class="lineNum">     256 </span>            :       /**<span class="lineNum">     257 </span>            :        *  @return  *this<span class="lineNum">     258 </span>            :        *<span class="lineNum">     259 </span>            :        *  Moves the underlying iterator forwards @a __n steps.<span class="lineNum">     260 </span>            :        *  The underlying iterator must be a Random Access Iterator.<span class="lineNum">     261 </span>            :       */<span class="lineNum">     262 </span>            :       reverse_iterator&amp;<span class="lineNum">     263 </span>            :       operator-=(difference_type __n)<span class="lineNum">     264 </span>            :       {<span class="lineNum">     265 </span>            :         current += __n;<span class="lineNum">     266 </span>            :         return *this;<span class="lineNum">     267 </span>            :       }<span class="lineNum">     268 </span>            : <span class="lineNum">     269 </span>            :       /**<span class="lineNum">     270 </span>            :        *  @return  The value at @c current - @a __n - 1<span class="lineNum">     271 </span>            :        *<span class="lineNum">     272 </span>            :        *  The underlying iterator must be a Random Access Iterator.<span class="lineNum">     273 </span>            :       */<span class="lineNum">     274 </span>            :       reference<span class="lineNum">     275 </span>            :       operator[](difference_type __n) const<span class="lineNum">     276 </span>            :       { return *(*this + __n); }<span class="lineNum">     277 </span>            :     };<span class="lineNum">     278 </span>            : <span class="lineNum">     279 </span>            :   //@{<span class="lineNum">     280 </span>            :   /**<span class="lineNum">     281 </span>            :    *  @param  __x  A %reverse_iterator.<span class="lineNum">     282 </span>            :    *  @param  __y  A %reverse_iterator.<span class="lineNum">     283 </span>            :    *  @return  A simple bool.<span class="lineNum">     284 </span>            :    *<span class="lineNum">     285 </span>            :    *  Reverse iterators forward many operations to their underlying base()<span class="lineNum">     286 </span>            :    *  iterators.  Others are implemented in terms of one another.<span class="lineNum">     287 </span>            :    *<span class="lineNum">     288 </span>            :   */<span class="lineNum">     289 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     290 </span>            :     inline bool<span class="lineNum">     291 </span>            :     operator==(const reverse_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">     292 </span>            :                const reverse_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">     293 </span>            :     { return __x.base() == __y.base(); }<span class="lineNum">     294 </span>            : <span class="lineNum">     295 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     296 </span>            :     inline bool<span class="lineNum">     297 </span>            :     operator&lt;(const reverse_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">     298 </span>            :               const reverse_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">     299 </span>            :     { return __y.base() &lt; __x.base(); }<span class="lineNum">     300 </span>            : <span class="lineNum">     301 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     302 </span>            :     inline bool<span class="lineNum">     303 </span>            :     operator!=(const reverse_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">     304 </span>            :                const reverse_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">     305 </span>            :     { return !(__x == __y); }<span class="lineNum">     306 </span>            : <span class="lineNum">     307 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     308 </span>            :     inline bool<span class="lineNum">     309 </span>            :     operator&gt;(const reverse_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">     310 </span>            :               const reverse_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">     311 </span>            :     { return __y &lt; __x; }<span class="lineNum">     312 </span>            : <span class="lineNum">     313 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     314 </span>            :     inline bool<span class="lineNum">     315 </span>            :     operator&lt;=(const reverse_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">     316 </span>            :                const reverse_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">     317 </span>            :     { return !(__y &lt; __x); }<span class="lineNum">     318 </span>            : <span class="lineNum">     319 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     320 </span>            :     inline bool<span class="lineNum">     321 </span>            :     operator&gt;=(const reverse_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">     322 </span>            :                const reverse_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">     323 </span>            :     { return !(__x &lt; __y); }<span class="lineNum">     324 </span>            : <span class="lineNum">     325 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     326 </span>            :     inline typename reverse_iterator&lt;_Iterator&gt;::difference_type<span class="lineNum">     327 </span>            :     operator-(const reverse_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">     328 </span>            :               const reverse_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">     329 </span>            :     { return __y.base() - __x.base(); }<span class="lineNum">     330 </span>            : <span class="lineNum">     331 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     332 </span>            :     inline reverse_iterator&lt;_Iterator&gt;<span class="lineNum">     333 </span>            :     operator+(typename reverse_iterator&lt;_Iterator&gt;::difference_type __n,<span class="lineNum">     334 </span>            :               const reverse_iterator&lt;_Iterator&gt;&amp; __x)<span class="lineNum">     335 </span>            :     { return reverse_iterator&lt;_Iterator&gt;(__x.base() - __n); }<span class="lineNum">     336 </span>            : <span class="lineNum">     337 </span>            :   // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     338 </span>            :   // DR 280. Comparison of reverse_iterator to const reverse_iterator.<span class="lineNum">     339 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">     340 </span>            :     inline bool<span class="lineNum">     341 </span>            :     operator==(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">     342 </span>            :                const reverse_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">     343 </span>            :     { return __x.base() == __y.base(); }<span class="lineNum">     344 </span>            : <span class="lineNum">     345 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">     346 </span>            :     inline bool<span class="lineNum">     347 </span>            :     operator&lt;(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">     348 </span>            :               const reverse_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">     349 </span>            :     { return __y.base() &lt; __x.base(); }<span class="lineNum">     350 </span>            : <span class="lineNum">     351 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">     352 </span>            :     inline bool<span class="lineNum">     353 </span>            :     operator!=(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">     354 </span>            :                const reverse_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">     355 </span>            :     { return !(__x == __y); }<span class="lineNum">     356 </span>            : <span class="lineNum">     357 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">     358 </span>            :     inline bool<span class="lineNum">     359 </span>            :     operator&gt;(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">     360 </span>            :               const reverse_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">     361 </span>            :     { return __y &lt; __x; }<span class="lineNum">     362 </span>            : <span class="lineNum">     363 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">     364 </span>            :     inline bool<span class="lineNum">     365 </span>            :     operator&lt;=(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">     366 </span>            :                const reverse_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">     367 </span>            :     { return !(__y &lt; __x); }<span class="lineNum">     368 </span>            : <span class="lineNum">     369 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">     370 </span>            :     inline bool<span class="lineNum">     371 </span>            :     operator&gt;=(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">     372 </span>            :                const reverse_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">     373 </span>            :     { return !(__x &lt; __y); }<span class="lineNum">     374 </span>            : <span class="lineNum">     375 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">     376 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     377 </span>            :     // DR 685.<span class="lineNum">     378 </span>            :     inline auto<span class="lineNum">     379 </span>            :     operator-(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">     380 </span>            :               const reverse_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">     381 </span>            :     -&gt; decltype(__y.base() - __x.base())<span class="lineNum">     382 </span>            : #else<span class="lineNum">     383 </span>            :     inline typename reverse_iterator&lt;_IteratorL&gt;::difference_type<span class="lineNum">     384 </span>            :     operator-(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">     385 </span>            :               const reverse_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">     386 </span>            : #endif<span class="lineNum">     387 </span>            :     { return __y.base() - __x.base(); }<span class="lineNum">     388 </span>            :   //@}<span class="lineNum">     389 </span>            : <span class="lineNum">     390 </span>            :   // 24.4.2.2.1 back_insert_iterator<span class="lineNum">     391 </span>            :   /**<span class="lineNum">     392 </span>            :    *  @brief  Turns assignment into insertion.<span class="lineNum">     393 </span>            :    *<span class="lineNum">     394 </span>            :    *  These are output iterators, constructed from a container-of-T.<span class="lineNum">     395 </span>            :    *  Assigning a T to the iterator appends it to the container using<span class="lineNum">     396 </span>            :    *  push_back.<span class="lineNum">     397 </span>            :    *<span class="lineNum">     398 </span>            :    *  Tip:  Using the back_inserter function to create these iterators can<span class="lineNum">     399 </span>            :    *  save typing.<span class="lineNum">     400 </span>            :   */<span class="lineNum">     401 </span>            :   template&lt;typename _Container&gt;<span class="lineNum">     402 </span>            :     class back_insert_iterator<span class="lineNum">     403 </span>            :     : public iterator&lt;output_iterator_tag, void, void, void, void&gt;<span class="lineNum">     404 </span>            :     {<span class="lineNum">     405 </span>            :     protected:<span class="lineNum">     406 </span>            :       _Container* container;<span class="lineNum">     407 </span>            : <span class="lineNum">     408 </span>            :     public:<span class="lineNum">     409 </span>            :       /// A nested typedef for the type of whatever container you used.<span class="lineNum">     410 </span>            :       typedef _Container          container_type;<span class="lineNum">     411 </span>            : <span class="lineNum">     412 </span>            :       /// The only way to create this %iterator is with a container.<span class="lineNum">     413 </span>            :       explicit<span class="lineNum">     414 </span>            :       back_insert_iterator(_Container&amp; __x) : container(&amp;__x) { }<span class="lineNum">     415 </span>            : <span class="lineNum">     416 </span>            :       /**<span class="lineNum">     417 </span>            :        *  @param  __value  An instance of whatever type<span class="lineNum">     418 </span>            :        *                 container_type::const_reference is; presumably a<span class="lineNum">     419 </span>            :        *                 reference-to-const T for container&lt;T&gt;.<span class="lineNum">     420 </span>            :        *  @return  This %iterator, for chained operations.<span class="lineNum">     421 </span>            :        *<span class="lineNum">     422 </span>            :        *  This kind of %iterator doesn't really have a @a position in the<span class="lineNum">     423 </span>            :        *  container (you can think of the position as being permanently at<span class="lineNum">     424 </span>            :        *  the end, if you like).  Assigning a value to the %iterator will<span class="lineNum">     425 </span>            :        *  always append the value to the end of the container.<span class="lineNum">     426 </span>            :       */<span class="lineNum">     427 </span>            : #if __cplusplus &lt; 201103L<span class="lineNum">     428 </span>            :       back_insert_iterator&amp;<span class="lineNum">     429 </span>            :       operator=(typename _Container::const_reference __value)<span class="lineNum">     430 </span>            :       {<span class="lineNum">     431 </span>            :         container-&gt;push_back(__value);<span class="lineNum">     432 </span>            :         return *this;<span class="lineNum">     433 </span>            :       }<span class="lineNum">     434 </span>            : #else<span class="lineNum">     435 </span>            :       back_insert_iterator&amp;<span class="lineNum">     436 </span>            :       operator=(const typename _Container::value_type&amp; __value)<span class="lineNum">     437 </span>            :       {<span class="lineNum">     438 </span>            :         container-&gt;push_back(__value);<span class="lineNum">     439 </span>            :         return *this;<span class="lineNum">     440 </span>            :       }<span class="lineNum">     441 </span>            : <span class="lineNum">     442 </span>            :       back_insert_iterator&amp;<span class="lineNum">     443 </span>            :       operator=(typename _Container::value_type&amp;&amp; __value)<span class="lineNum">     444 </span>            :       {<span class="lineNum">     445 </span>            :         container-&gt;push_back(std::move(__value));<span class="lineNum">     446 </span>            :         return *this;<span class="lineNum">     447 </span>            :       }<span class="lineNum">     448 </span>            : #endif<span class="lineNum">     449 </span>            : <span class="lineNum">     450 </span>            :       /// Simply returns *this.<span class="lineNum">     451 </span>            :       back_insert_iterator&amp;<span class="lineNum">     452 </span>            :       operator*()<span class="lineNum">     453 </span>            :       { return *this; }<span class="lineNum">     454 </span>            : <span class="lineNum">     455 </span>            :       /// Simply returns *this.  (This %iterator does not @a move.)<span class="lineNum">     456 </span>            :       back_insert_iterator&amp;<span class="lineNum">     457 </span>            :       operator++()<span class="lineNum">     458 </span>            :       { return *this; }<span class="lineNum">     459 </span>            : <span class="lineNum">     460 </span>            :       /// Simply returns *this.  (This %iterator does not @a move.)<span class="lineNum">     461 </span>            :       back_insert_iterator<span class="lineNum">     462 </span>            :       operator++(int)<span class="lineNum">     463 </span>            :       { return *this; }<span class="lineNum">     464 </span>            :     };<span class="lineNum">     465 </span>            : <span class="lineNum">     466 </span>            :   /**<span class="lineNum">     467 </span>            :    *  @param  __x  A container of arbitrary type.<span class="lineNum">     468 </span>            :    *  @return  An instance of back_insert_iterator working on @p __x.<span class="lineNum">     469 </span>            :    *<span class="lineNum">     470 </span>            :    *  This wrapper function helps in creating back_insert_iterator instances.<span class="lineNum">     471 </span>            :    *  Typing the name of the %iterator requires knowing the precise full<span class="lineNum">     472 </span>            :    *  type of the container, which can be tedious and impedes generic<span class="lineNum">     473 </span>            :    *  programming.  Using this function lets you take advantage of automatic<span class="lineNum">     474 </span>            :    *  template parameter deduction, making the compiler match the correct<span class="lineNum">     475 </span>            :    *  types for you.<span class="lineNum">     476 </span>            :   */<span class="lineNum">     477 </span>            :   template&lt;typename _Container&gt;<span class="lineNum">     478 </span>            :     inline back_insert_iterator&lt;_Container&gt;<span class="lineNum">     479 </span>            :     back_inserter(_Container&amp; __x)<span class="lineNum">     480 </span>            :     { return back_insert_iterator&lt;_Container&gt;(__x); }<span class="lineNum">     481 </span>            : <span class="lineNum">     482 </span>            :   /**<span class="lineNum">     483 </span>            :    *  @brief  Turns assignment into insertion.<span class="lineNum">     484 </span>            :    *<span class="lineNum">     485 </span>            :    *  These are output iterators, constructed from a container-of-T.<span class="lineNum">     486 </span>            :    *  Assigning a T to the iterator prepends it to the container using<span class="lineNum">     487 </span>            :    *  push_front.<span class="lineNum">     488 </span>            :    *<span class="lineNum">     489 </span>            :    *  Tip:  Using the front_inserter function to create these iterators can<span class="lineNum">     490 </span>            :    *  save typing.<span class="lineNum">     491 </span>            :   */<span class="lineNum">     492 </span>            :   template&lt;typename _Container&gt;<span class="lineNum">     493 </span>            :     class front_insert_iterator<span class="lineNum">     494 </span>            :     : public iterator&lt;output_iterator_tag, void, void, void, void&gt;<span class="lineNum">     495 </span>            :     {<span class="lineNum">     496 </span>            :     protected:<span class="lineNum">     497 </span>            :       _Container* container;<span class="lineNum">     498 </span>            : <span class="lineNum">     499 </span>            :     public:<span class="lineNum">     500 </span>            :       /// A nested typedef for the type of whatever container you used.<span class="lineNum">     501 </span>            :       typedef _Container          container_type;<span class="lineNum">     502 </span>            : <span class="lineNum">     503 </span>            :       /// The only way to create this %iterator is with a container.<span class="lineNum">     504 </span>            :       explicit front_insert_iterator(_Container&amp; __x) : container(&amp;__x) { }<span class="lineNum">     505 </span>            : <span class="lineNum">     506 </span>            :       /**<span class="lineNum">     507 </span>            :        *  @param  __value  An instance of whatever type<span class="lineNum">     508 </span>            :        *                 container_type::const_reference is; presumably a<span class="lineNum">     509 </span>            :        *                 reference-to-const T for container&lt;T&gt;.<span class="lineNum">     510 </span>            :        *  @return  This %iterator, for chained operations.<span class="lineNum">     511 </span>            :        *<span class="lineNum">     512 </span>            :        *  This kind of %iterator doesn't really have a @a position in the<span class="lineNum">     513 </span>            :        *  container (you can think of the position as being permanently at<span class="lineNum">     514 </span>            :        *  the front, if you like).  Assigning a value to the %iterator will<span class="lineNum">     515 </span>            :        *  always prepend the value to the front of the container.<span class="lineNum">     516 </span>            :       */<span class="lineNum">     517 </span>            : #if __cplusplus &lt; 201103L<span class="lineNum">     518 </span>            :       front_insert_iterator&amp;<span class="lineNum">     519 </span>            :       operator=(typename _Container::const_reference __value)<span class="lineNum">     520 </span>            :       {<span class="lineNum">     521 </span>            :         container-&gt;push_front(__value);<span class="lineNum">     522 </span>            :         return *this;<span class="lineNum">     523 </span>            :       }<span class="lineNum">     524 </span>            : #else<span class="lineNum">     525 </span>            :       front_insert_iterator&amp;<span class="lineNum">     526 </span>            :       operator=(const typename _Container::value_type&amp; __value)<span class="lineNum">     527 </span>            :       {<span class="lineNum">     528 </span>            :         container-&gt;push_front(__value);<span class="lineNum">     529 </span>            :         return *this;<span class="lineNum">     530 </span>            :       }<span class="lineNum">     531 </span>            : <span class="lineNum">     532 </span>            :       front_insert_iterator&amp;<span class="lineNum">     533 </span>            :       operator=(typename _Container::value_type&amp;&amp; __value)<span class="lineNum">     534 </span>            :       {<span class="lineNum">     535 </span>            :         container-&gt;push_front(std::move(__value));<span class="lineNum">     536 </span>            :         return *this;<span class="lineNum">     537 </span>            :       }<span class="lineNum">     538 </span>            : #endif<span class="lineNum">     539 </span>            : <span class="lineNum">     540 </span>            :       /// Simply returns *this.<span class="lineNum">     541 </span>            :       front_insert_iterator&amp;<span class="lineNum">     542 </span>            :       operator*()<span class="lineNum">     543 </span>            :       { return *this; }<span class="lineNum">     544 </span>            : <span class="lineNum">     545 </span>            :       /// Simply returns *this.  (This %iterator does not @a move.)<span class="lineNum">     546 </span>            :       front_insert_iterator&amp;<span class="lineNum">     547 </span>            :       operator++()<span class="lineNum">     548 </span>            :       { return *this; }<span class="lineNum">     549 </span>            : <span class="lineNum">     550 </span>            :       /// Simply returns *this.  (This %iterator does not @a move.)<span class="lineNum">     551 </span>            :       front_insert_iterator<span class="lineNum">     552 </span>            :       operator++(int)<span class="lineNum">     553 </span>            :       { return *this; }<span class="lineNum">     554 </span>            :     };<span class="lineNum">     555 </span>            : <span class="lineNum">     556 </span>            :   /**<span class="lineNum">     557 </span>            :    *  @param  __x  A container of arbitrary type.<span class="lineNum">     558 </span>            :    *  @return  An instance of front_insert_iterator working on @p x.<span class="lineNum">     559 </span>            :    *<span class="lineNum">     560 </span>            :    *  This wrapper function helps in creating front_insert_iterator instances.<span class="lineNum">     561 </span>            :    *  Typing the name of the %iterator requires knowing the precise full<span class="lineNum">     562 </span>            :    *  type of the container, which can be tedious and impedes generic<span class="lineNum">     563 </span>            :    *  programming.  Using this function lets you take advantage of automatic<span class="lineNum">     564 </span>            :    *  template parameter deduction, making the compiler match the correct<span class="lineNum">     565 </span>            :    *  types for you.<span class="lineNum">     566 </span>            :   */<span class="lineNum">     567 </span>            :   template&lt;typename _Container&gt;<span class="lineNum">     568 </span>            :     inline front_insert_iterator&lt;_Container&gt;<span class="lineNum">     569 </span>            :     front_inserter(_Container&amp; __x)<span class="lineNum">     570 </span>            :     { return front_insert_iterator&lt;_Container&gt;(__x); }<span class="lineNum">     571 </span>            : <span class="lineNum">     572 </span>            :   /**<span class="lineNum">     573 </span>            :    *  @brief  Turns assignment into insertion.<span class="lineNum">     574 </span>            :    *<span class="lineNum">     575 </span>            :    *  These are output iterators, constructed from a container-of-T.<span class="lineNum">     576 </span>            :    *  Assigning a T to the iterator inserts it in the container at the<span class="lineNum">     577 </span>            :    *  %iterator's position, rather than overwriting the value at that<span class="lineNum">     578 </span>            :    *  position.<span class="lineNum">     579 </span>            :    *<span class="lineNum">     580 </span>            :    *  (Sequences will actually insert a @e copy of the value before the<span class="lineNum">     581 </span>            :    *  %iterator's position.)<span class="lineNum">     582 </span>            :    *<span class="lineNum">     583 </span>            :    *  Tip:  Using the inserter function to create these iterators can<span class="lineNum">     584 </span>            :    *  save typing.<span class="lineNum">     585 </span>            :   */<span class="lineNum">     586 </span>            :   template&lt;typename _Container&gt;<span class="lineNum">     587 </span>            :     class insert_iterator<span class="lineNum">     588 </span>            :     : public iterator&lt;output_iterator_tag, void, void, void, void&gt;<span class="lineNum">     589 </span>            :     {<span class="lineNum">     590 </span>            :     protected:<span class="lineNum">     591 </span>            :       _Container* container;<span class="lineNum">     592 </span>            :       typename _Container::iterator iter;<span class="lineNum">     593 </span>            : <span class="lineNum">     594 </span>            :     public:<span class="lineNum">     595 </span>            :       /// A nested typedef for the type of whatever container you used.<span class="lineNum">     596 </span>            :       typedef _Container          container_type;<span class="lineNum">     597 </span>            : <span class="lineNum">     598 </span>            :       /**<span class="lineNum">     599 </span>            :        *  The only way to create this %iterator is with a container and an<span class="lineNum">     600 </span>            :        *  initial position (a normal %iterator into the container).<span class="lineNum">     601 </span>            :       */<span class="lineNum">     602 </span>            :       insert_iterator(_Container&amp; __x, typename _Container::iterator __i)<span class="lineNum">     603 </span>            :       : container(&amp;__x), iter(__i) {}<span class="lineNum">     604 </span>            : <span class="lineNum">     605 </span>            :       /**<span class="lineNum">     606 </span>            :        *  @param  __value  An instance of whatever type<span class="lineNum">     607 </span>            :        *                 container_type::const_reference is; presumably a<span class="lineNum">     608 </span>            :        *                 reference-to-const T for container&lt;T&gt;.<span class="lineNum">     609 </span>            :        *  @return  This %iterator, for chained operations.<span class="lineNum">     610 </span>            :        *<span class="lineNum">     611 </span>            :        *  This kind of %iterator maintains its own position in the<span class="lineNum">     612 </span>            :        *  container.  Assigning a value to the %iterator will insert the<span class="lineNum">     613 </span>            :        *  value into the container at the place before the %iterator.<span class="lineNum">     614 </span>            :        *<span class="lineNum">     615 </span>            :        *  The position is maintained such that subsequent assignments will<span class="lineNum">     616 </span>            :        *  insert values immediately after one another.  For example,<span class="lineNum">     617 </span>            :        *  @code<span class="lineNum">     618 </span>            :        *     // vector v contains A and Z<span class="lineNum">     619 </span>            :        *<span class="lineNum">     620 </span>            :        *     insert_iterator i (v, ++v.begin());<span class="lineNum">     621 </span>            :        *     i = 1;<span class="lineNum">     622 </span>            :        *     i = 2;<span class="lineNum">     623 </span>            :        *     i = 3;<span class="lineNum">     624 </span>            :        *<span class="lineNum">     625 </span>            :        *     // vector v contains A, 1, 2, 3, and Z<span class="lineNum">     626 </span>            :        *  @endcode<span class="lineNum">     627 </span>            :       */<span class="lineNum">     628 </span>            : #if __cplusplus &lt; 201103L<span class="lineNum">     629 </span>            :       insert_iterator&amp;<span class="lineNum">     630 </span>            :       operator=(typename _Container::const_reference __value)<span class="lineNum">     631 </span>            :       {<span class="lineNum">     632 </span>            :         iter = container-&gt;insert(iter, __value);<span class="lineNum">     633 </span>            :         ++iter;<span class="lineNum">     634 </span>            :         return *this;<span class="lineNum">     635 </span>            :       }<span class="lineNum">     636 </span>            : #else<span class="lineNum">     637 </span>            :       insert_iterator&amp;<span class="lineNum">     638 </span>            :       operator=(const typename _Container::value_type&amp; __value)<span class="lineNum">     639 </span>            :       {<span class="lineNum">     640 </span>            :         iter = container-&gt;insert(iter, __value);<span class="lineNum">     641 </span>            :         ++iter;<span class="lineNum">     642 </span>            :         return *this;<span class="lineNum">     643 </span>            :       }<span class="lineNum">     644 </span>            : <span class="lineNum">     645 </span>            :       insert_iterator&amp;<span class="lineNum">     646 </span>            :       operator=(typename _Container::value_type&amp;&amp; __value)<span class="lineNum">     647 </span>            :       {<span class="lineNum">     648 </span>            :         iter = container-&gt;insert(iter, std::move(__value));<span class="lineNum">     649 </span>            :         ++iter;<span class="lineNum">     650 </span>            :         return *this;<span class="lineNum">     651 </span>            :       }<span class="lineNum">     652 </span>            : #endif<span class="lineNum">     653 </span>            : <span class="lineNum">     654 </span>            :       /// Simply returns *this.<span class="lineNum">     655 </span>            :       insert_iterator&amp;<span class="lineNum">     656 </span>            :       operator*()<span class="lineNum">     657 </span>            :       { return *this; }<span class="lineNum">     658 </span>            : <span class="lineNum">     659 </span>            :       /// Simply returns *this.  (This %iterator does not @a move.)<span class="lineNum">     660 </span>            :       insert_iterator&amp;<span class="lineNum">     661 </span>            :       operator++()<span class="lineNum">     662 </span>            :       { return *this; }<span class="lineNum">     663 </span>            : <span class="lineNum">     664 </span>            :       /// Simply returns *this.  (This %iterator does not @a move.)<span class="lineNum">     665 </span>            :       insert_iterator&amp;<span class="lineNum">     666 </span>            :       operator++(int)<span class="lineNum">     667 </span>            :       { return *this; }<span class="lineNum">     668 </span>            :     };<span class="lineNum">     669 </span>            : <span class="lineNum">     670 </span>            :   /**<span class="lineNum">     671 </span>            :    *  @param __x  A container of arbitrary type.<span class="lineNum">     672 </span>            :    *  @return  An instance of insert_iterator working on @p __x.<span class="lineNum">     673 </span>            :    *<span class="lineNum">     674 </span>            :    *  This wrapper function helps in creating insert_iterator instances.<span class="lineNum">     675 </span>            :    *  Typing the name of the %iterator requires knowing the precise full<span class="lineNum">     676 </span>            :    *  type of the container, which can be tedious and impedes generic<span class="lineNum">     677 </span>            :    *  programming.  Using this function lets you take advantage of automatic<span class="lineNum">     678 </span>            :    *  template parameter deduction, making the compiler match the correct<span class="lineNum">     679 </span>            :    *  types for you.<span class="lineNum">     680 </span>            :   */<span class="lineNum">     681 </span>            :   template&lt;typename _Container, typename _Iterator&gt;<span class="lineNum">     682 </span>            :     inline insert_iterator&lt;_Container&gt;<span class="lineNum">     683 </span>            :     inserter(_Container&amp; __x, _Iterator __i)<span class="lineNum">     684 </span>            :     {<span class="lineNum">     685 </span>            :       return insert_iterator&lt;_Container&gt;(__x,<span class="lineNum">     686 </span>            :                                          typename _Container::iterator(__i));<span class="lineNum">     687 </span>            :     }<span class="lineNum">     688 </span>            : <span class="lineNum">     689 </span>            :   // @} group iterators<span class="lineNum">     690 </span>            : <span class="lineNum">     691 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     692 </span>            : } // namespace<span class="lineNum">     693 </span>            : <span class="lineNum">     694 </span>            : namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)<span class="lineNum">     695 </span>            : {<span class="lineNum">     696 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">     697 </span>            : <span class="lineNum">     698 </span>            :   // This iterator adapter is @a normal in the sense that it does not<span class="lineNum">     699 </span>            :   // change the semantics of any of the operators of its iterator<span class="lineNum">     700 </span>            :   // parameter.  Its primary purpose is to convert an iterator that is<span class="lineNum">     701 </span>            :   // not a class, e.g. a pointer, into an iterator that is a class.<span class="lineNum">     702 </span>            :   // The _Container parameter exists solely so that different containers<span class="lineNum">     703 </span>            :   // using this template can instantiate different types, even if the<span class="lineNum">     704 </span>            :   // _Iterator parameter is the same.<span class="lineNum">     705 </span>            :   using std::iterator_traits;<span class="lineNum">     706 </span>            :   using std::iterator;<span class="lineNum">     707 </span>            :   template&lt;typename _Iterator, typename _Container&gt;<span class="lineNum">     708 </span>            :     class __normal_iterator<span class="lineNum">     709 </span>            :     {<span class="lineNum">     710 </span>            :     protected:<span class="lineNum">     711 </span>            :       _Iterator _M_current;<span class="lineNum">     712 </span>            : <span class="lineNum">     713 </span>            :       typedef iterator_traits&lt;_Iterator&gt;          __traits_type;<span class="lineNum">     714 </span>            : <span class="lineNum">     715 </span>            :     public:<span class="lineNum">     716 </span>            :       typedef _Iterator                                 iterator_type;<span class="lineNum">     717 </span>            :       typedef typename __traits_type::iterator_category iterator_category;<span class="lineNum">     718 </span>            :       typedef typename __traits_type::value_type        value_type;<span class="lineNum">     719 </span>            :       typedef typename __traits_type::difference_type   difference_type;<span class="lineNum">     720 </span>            :       typedef typename __traits_type::reference         reference;<span class="lineNum">     721 </span>            :       typedef typename __traits_type::pointer           pointer;<span class="lineNum">     722 </span>            : <span class="lineNum">     723 </span>            :       _GLIBCXX_CONSTEXPR __normal_iterator() : _M_current(_Iterator()) { }<a name="724"><span class="lineNum">     724 </span>            : </a><span class="lineNum">     725 </span>            :       explicit<span class="lineNum">     726 </span><span class="lineCov">          4 :       __normal_iterator(const _Iterator&amp; __i) : _M_current(__i) { }</span><span class="lineNum">     727 </span>            : <span class="lineNum">     728 </span>            :       // Allow iterator to const_iterator conversion<span class="lineNum">     729 </span>            :       template&lt;typename _Iter&gt;<span class="lineNum">     730 </span>            :         __normal_iterator(const __normal_iterator&lt;_Iter,<span class="lineNum">     731 </span>            :                           typename __enable_if&lt;<span class="lineNum">     732 </span>            :                (std::__are_same&lt;_Iter, typename _Container::pointer&gt;::__value),<span class="lineNum">     733 </span>            :                       _Container&gt;::__type&gt;&amp; __i)<span class="lineNum">     734 </span>            :         : _M_current(__i.base()) { }<span class="lineNum">     735 </span>            : <span class="lineNum">     736 </span>            :       // Forward iterator requirements<span class="lineNum">     737 </span>            :       reference<span class="lineNum">     738 </span>            :       operator*() const<span class="lineNum">     739 </span>            :       { return *_M_current; }<span class="lineNum">     740 </span>            : <span class="lineNum">     741 </span>            :       pointer<span class="lineNum">     742 </span>            :       operator-&gt;() const<span class="lineNum">     743 </span>            :       { return _M_current; }<span class="lineNum">     744 </span>            : <span class="lineNum">     745 </span>            :       __normal_iterator&amp;<span class="lineNum">     746 </span>            :       operator++()<span class="lineNum">     747 </span>            :       {<span class="lineNum">     748 </span>            :         ++_M_current;<span class="lineNum">     749 </span>            :         return *this;<span class="lineNum">     750 </span>            :       }<span class="lineNum">     751 </span>            : <span class="lineNum">     752 </span>            :       __normal_iterator<span class="lineNum">     753 </span>            :       operator++(int)<span class="lineNum">     754 </span>            :       { return __normal_iterator(_M_current++); }<span class="lineNum">     755 </span>            : <span class="lineNum">     756 </span>            :       // Bidirectional iterator requirements<span class="lineNum">     757 </span>            :       __normal_iterator&amp;<span class="lineNum">     758 </span>            :       operator--()<span class="lineNum">     759 </span>            :       {<span class="lineNum">     760 </span>            :         --_M_current;<span class="lineNum">     761 </span>            :         return *this;<span class="lineNum">     762 </span>            :       }<span class="lineNum">     763 </span>            : <span class="lineNum">     764 </span>            :       __normal_iterator<span class="lineNum">     765 </span>            :       operator--(int)<span class="lineNum">     766 </span>            :       { return __normal_iterator(_M_current--); }<span class="lineNum">     767 </span>            : <span class="lineNum">     768 </span>            :       // Random access iterator requirements<span class="lineNum">     769 </span>            :       reference<span class="lineNum">     770 </span>            :       operator[](const difference_type&amp; __n) const<span class="lineNum">     771 </span>            :       { return _M_current[__n]; }<span class="lineNum">     772 </span>            : <span class="lineNum">     773 </span>            :       __normal_iterator&amp;<span class="lineNum">     774 </span>            :       operator+=(const difference_type&amp; __n)<span class="lineNum">     775 </span>            :       { _M_current += __n; return *this; }<span class="lineNum">     776 </span>            : <span class="lineNum">     777 </span>            :       __normal_iterator<span class="lineNum">     778 </span>            :       operator+(const difference_type&amp; __n) const<span class="lineNum">     779 </span>            :       { return __normal_iterator(_M_current + __n); }<span class="lineNum">     780 </span>            : <span class="lineNum">     781 </span>            :       __normal_iterator&amp;<span class="lineNum">     782 </span>            :       operator-=(const difference_type&amp; __n)<span class="lineNum">     783 </span>            :       { _M_current -= __n; return *this; }<span class="lineNum">     784 </span>            : <span class="lineNum">     785 </span>            :       __normal_iterator<span class="lineNum">     786 </span>            :       operator-(const difference_type&amp; __n) const<span class="lineNum">     787 </span>            :       { return __normal_iterator(_M_current - __n); }<a name="788"><span class="lineNum">     788 </span>            : </a><span class="lineNum">     789 </span>            :       const _Iterator&amp;<span class="lineNum">     790 </span><span class="lineCov">          8 :       base() const</span><span class="lineNum">     791 </span><span class="lineCov">          8 :       { return _M_current; }</span><span class="lineNum">     792 </span>            :     };<span class="lineNum">     793 </span>            : <span class="lineNum">     794 </span>            :   // Note: In what follows, the left- and right-hand-side iterators are<span class="lineNum">     795 </span>            :   // allowed to vary in types (conceptually in cv-qualification) so that<span class="lineNum">     796 </span>            :   // comparison between cv-qualified and non-cv-qualified iterators be<span class="lineNum">     797 </span>            :   // valid.  However, the greedy and unfriendly operators in std::rel_ops<span class="lineNum">     798 </span>            :   // will make overload resolution ambiguous (when in scope) if we don't<span class="lineNum">     799 </span>            :   // provide overloads whose operands are of the same type.  Can someone<span class="lineNum">     800 </span>            :   // remind me what generic programming is about? -- Gaby<span class="lineNum">     801 </span>            : <span class="lineNum">     802 </span>            :   // Forward iterator requirements<span class="lineNum">     803 </span>            :   template&lt;typename _IteratorL, typename _IteratorR, typename _Container&gt;<span class="lineNum">     804 </span>            :     inline bool<span class="lineNum">     805 </span>            :     operator==(const __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,<span class="lineNum">     806 </span>            :                const __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)<span class="lineNum">     807 </span>            :     { return __lhs.base() == __rhs.base(); }<span class="lineNum">     808 </span>            : <span class="lineNum">     809 </span>            :   template&lt;typename _Iterator, typename _Container&gt;<span class="lineNum">     810 </span>            :     inline bool<span class="lineNum">     811 </span>            :     operator==(const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __lhs,<span class="lineNum">     812 </span>            :                const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __rhs)<span class="lineNum">     813 </span>            :     { return __lhs.base() == __rhs.base(); }<span class="lineNum">     814 </span>            : <span class="lineNum">     815 </span>            :   template&lt;typename _IteratorL, typename _IteratorR, typename _Container&gt;<span class="lineNum">     816 </span>            :     inline bool<span class="lineNum">     817 </span>            :     operator!=(const __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,<span class="lineNum">     818 </span>            :                const __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)<span class="lineNum">     819 </span>            :     { return __lhs.base() != __rhs.base(); }<span class="lineNum">     820 </span>            : <span class="lineNum">     821 </span>            :   template&lt;typename _Iterator, typename _Container&gt;<span class="lineNum">     822 </span>            :     inline bool<span class="lineNum">     823 </span>            :     operator!=(const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __lhs,<span class="lineNum">     824 </span>            :                const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __rhs)<span class="lineNum">     825 </span>            :     { return __lhs.base() != __rhs.base(); }<span class="lineNum">     826 </span>            : <span class="lineNum">     827 </span>            :   // Random access iterator requirements<span class="lineNum">     828 </span>            :   template&lt;typename _IteratorL, typename _IteratorR, typename _Container&gt;<span class="lineNum">     829 </span>            :     inline bool<span class="lineNum">     830 </span>            :     operator&lt;(const __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,<span class="lineNum">     831 </span>            :               const __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)<span class="lineNum">     832 </span>            :     { return __lhs.base() &lt; __rhs.base(); }<span class="lineNum">     833 </span>            : <span class="lineNum">     834 </span>            :   template&lt;typename _Iterator, typename _Container&gt;<span class="lineNum">     835 </span>            :     inline bool<span class="lineNum">     836 </span>            :     operator&lt;(const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __lhs,<span class="lineNum">     837 </span>            :               const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __rhs)<span class="lineNum">     838 </span>            :     { return __lhs.base() &lt; __rhs.base(); }<span class="lineNum">     839 </span>            : <span class="lineNum">     840 </span>            :   template&lt;typename _IteratorL, typename _IteratorR, typename _Container&gt;<span class="lineNum">     841 </span>            :     inline bool<span class="lineNum">     842 </span>            :     operator&gt;(const __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,<span class="lineNum">     843 </span>            :               const __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)<span class="lineNum">     844 </span>            :     { return __lhs.base() &gt; __rhs.base(); }<span class="lineNum">     845 </span>            : <span class="lineNum">     846 </span>            :   template&lt;typename _Iterator, typename _Container&gt;<span class="lineNum">     847 </span>            :     inline bool<span class="lineNum">     848 </span>            :     operator&gt;(const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __lhs,<span class="lineNum">     849 </span>            :               const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __rhs)<span class="lineNum">     850 </span>            :     { return __lhs.base() &gt; __rhs.base(); }<span class="lineNum">     851 </span>            : <span class="lineNum">     852 </span>            :   template&lt;typename _IteratorL, typename _IteratorR, typename _Container&gt;<span class="lineNum">     853 </span>            :     inline bool<span class="lineNum">     854 </span>            :     operator&lt;=(const __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,<span class="lineNum">     855 </span>            :                const __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)<span class="lineNum">     856 </span>            :     { return __lhs.base() &lt;= __rhs.base(); }<span class="lineNum">     857 </span>            : <span class="lineNum">     858 </span>            :   template&lt;typename _Iterator, typename _Container&gt;<span class="lineNum">     859 </span>            :     inline bool<span class="lineNum">     860 </span>            :     operator&lt;=(const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __lhs,<span class="lineNum">     861 </span>            :                const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __rhs)<span class="lineNum">     862 </span>            :     { return __lhs.base() &lt;= __rhs.base(); }<span class="lineNum">     863 </span>            : <span class="lineNum">     864 </span>            :   template&lt;typename _IteratorL, typename _IteratorR, typename _Container&gt;<span class="lineNum">     865 </span>            :     inline bool<span class="lineNum">     866 </span>            :     operator&gt;=(const __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,<span class="lineNum">     867 </span>            :                const __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)<span class="lineNum">     868 </span>            :     { return __lhs.base() &gt;= __rhs.base(); }<span class="lineNum">     869 </span>            : <span class="lineNum">     870 </span>            :   template&lt;typename _Iterator, typename _Container&gt;<span class="lineNum">     871 </span>            :     inline bool<span class="lineNum">     872 </span>            :     operator&gt;=(const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __lhs,<span class="lineNum">     873 </span>            :                const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __rhs)<span class="lineNum">     874 </span>            :     { return __lhs.base() &gt;= __rhs.base(); }<span class="lineNum">     875 </span>            : <span class="lineNum">     876 </span>            :   // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     877 </span>            :   // According to the resolution of DR179 not only the various comparison<span class="lineNum">     878 </span>            :   // operators but also operator- must accept mixed iterator/const_iterator<span class="lineNum">     879 </span>            :   // parameters.<span class="lineNum">     880 </span>            :   template&lt;typename _IteratorL, typename _IteratorR, typename _Container&gt;<span class="lineNum">     881 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     882 </span>            :     // DR 685.<span class="lineNum">     883 </span>            :     inline auto<span class="lineNum">     884 </span>            :     operator-(const __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,<span class="lineNum">     885 </span>            :               const __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)<span class="lineNum">     886 </span>            :     -&gt; decltype(__lhs.base() - __rhs.base())<span class="lineNum">     887 </span>            : #else<span class="lineNum">     888 </span>            :     inline typename __normal_iterator&lt;_IteratorL, _Container&gt;::difference_type<span class="lineNum">     889 </span>            :     operator-(const __normal_iterator&lt;_IteratorL, _Container&gt;&amp; __lhs,<span class="lineNum">     890 </span>            :               const __normal_iterator&lt;_IteratorR, _Container&gt;&amp; __rhs)<span class="lineNum">     891 </span>            : #endif<span class="lineNum">     892 </span>            :     { return __lhs.base() - __rhs.base(); }<span class="lineNum">     893 </span>            : <a name="894"><span class="lineNum">     894 </span>            :   template&lt;typename _Iterator, typename _Container&gt;</a><span class="lineNum">     895 </span>            :     inline typename __normal_iterator&lt;_Iterator, _Container&gt;::difference_type<span class="lineNum">     896 </span><span class="lineCov">          2 :     operator-(const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __lhs,</span><span class="lineNum">     897 </span>            :               const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __rhs)<span class="lineNum">     898 </span><span class="lineCov">          2 :     { return __lhs.base() - __rhs.base(); }</span><span class="lineNum">     899 </span>            : <span class="lineNum">     900 </span>            :   template&lt;typename _Iterator, typename _Container&gt;<span class="lineNum">     901 </span>            :     inline __normal_iterator&lt;_Iterator, _Container&gt;<span class="lineNum">     902 </span>            :     operator+(typename __normal_iterator&lt;_Iterator, _Container&gt;::difference_type<span class="lineNum">     903 </span>            :               __n, const __normal_iterator&lt;_Iterator, _Container&gt;&amp; __i)<span class="lineNum">     904 </span>            :     { return __normal_iterator&lt;_Iterator, _Container&gt;(__i.base() + __n); }<span class="lineNum">     905 </span>            : <span class="lineNum">     906 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     907 </span>            : } // namespace<span class="lineNum">     908 </span>            : <span class="lineNum">     909 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     910 </span>            : <span class="lineNum">     911 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">     912 </span>            : {<span class="lineNum">     913 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">     914 </span>            : <span class="lineNum">     915 </span>            :   /**<span class="lineNum">     916 </span>            :    * @addtogroup iterators<span class="lineNum">     917 </span>            :    * @{<span class="lineNum">     918 </span>            :    */<span class="lineNum">     919 </span>            : <span class="lineNum">     920 </span>            :   // 24.4.3  Move iterators<span class="lineNum">     921 </span>            :   /**<span class="lineNum">     922 </span>            :    *  Class template move_iterator is an iterator adapter with the same<span class="lineNum">     923 </span>            :    *  behavior as the underlying iterator except that its dereference<span class="lineNum">     924 </span>            :    *  operator implicitly converts the value returned by the underlying<span class="lineNum">     925 </span>            :    *  iterator's dereference operator to an rvalue reference.  Some<span class="lineNum">     926 </span>            :    *  generic algorithms can be called with move iterators to replace<span class="lineNum">     927 </span>            :    *  copying with moving.<span class="lineNum">     928 </span>            :    */<span class="lineNum">     929 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     930 </span>            :     class move_iterator<span class="lineNum">     931 </span>            :     {<span class="lineNum">     932 </span>            :     protected:<span class="lineNum">     933 </span>            :       _Iterator _M_current;<span class="lineNum">     934 </span>            : <span class="lineNum">     935 </span>            :       typedef iterator_traits&lt;_Iterator&gt;          __traits_type;<span class="lineNum">     936 </span>            : <span class="lineNum">     937 </span>            :     public:<span class="lineNum">     938 </span>            :       typedef _Iterator                                 iterator_type;<span class="lineNum">     939 </span>            :       typedef typename __traits_type::iterator_category iterator_category;<span class="lineNum">     940 </span>            :       typedef typename __traits_type::value_type        value_type;<span class="lineNum">     941 </span>            :       typedef typename __traits_type::difference_type   difference_type;<span class="lineNum">     942 </span>            :       // NB: DR 680.<span class="lineNum">     943 </span>            :       typedef _Iterator                                 pointer;<span class="lineNum">     944 </span>            :       typedef value_type&amp;&amp;                              reference;<span class="lineNum">     945 </span>            : <span class="lineNum">     946 </span>            :       move_iterator()<span class="lineNum">     947 </span>            :       : _M_current() { }<a name="948"><span class="lineNum">     948 </span>            : </a><span class="lineNum">     949 </span>            :       explicit<span class="lineNum">     950 </span><span class="lineCov">        188 :       move_iterator(iterator_type __i)</span><span class="lineNum">     951 </span><span class="lineCov">        188 :       : _M_current(__i) { }</span><span class="lineNum">     952 </span>            : <span class="lineNum">     953 </span>            :       template&lt;typename _Iter&gt;<span class="lineNum">     954 </span>            :         move_iterator(const move_iterator&lt;_Iter&gt;&amp; __i)<span class="lineNum">     955 </span>            :         : _M_current(__i.base()) { }<a name="956"><span class="lineNum">     956 </span>            : </a><span class="lineNum">     957 </span>            :       iterator_type<span class="lineNum">     958 </span><span class="lineCov">        188 :       base() const</span><span class="lineNum">     959 </span><span class="lineCov">        188 :       { return _M_current; }</span><span class="lineNum">     960 </span>            : <span class="lineNum">     961 </span>            :       reference<span class="lineNum">     962 </span>            :       operator*() const<span class="lineNum">     963 </span>            :       { return std::move(*_M_current); }<span class="lineNum">     964 </span>            : <span class="lineNum">     965 </span>            :       pointer<span class="lineNum">     966 </span>            :       operator-&gt;() const<span class="lineNum">     967 </span>            :       { return _M_current; }<span class="lineNum">     968 </span>            : <span class="lineNum">     969 </span>            :       move_iterator&amp;<span class="lineNum">     970 </span>            :       operator++()<span class="lineNum">     971 </span>            :       {<span class="lineNum">     972 </span>            :         ++_M_current;<span class="lineNum">     973 </span>            :         return *this;<span class="lineNum">     974 </span>            :       }<span class="lineNum">     975 </span>            : <span class="lineNum">     976 </span>            :       move_iterator<span class="lineNum">     977 </span>            :       operator++(int)<span class="lineNum">     978 </span>            :       {<span class="lineNum">     979 </span>            :         move_iterator __tmp = *this;<span class="lineNum">     980 </span>            :         ++_M_current;<span class="lineNum">     981 </span>            :         return __tmp;<span class="lineNum">     982 </span>            :       }<span class="lineNum">     983 </span>            : <span class="lineNum">     984 </span>            :       move_iterator&amp;<span class="lineNum">     985 </span>            :       operator--()<span class="lineNum">     986 </span>            :       {<span class="lineNum">     987 </span>            :         --_M_current;<span class="lineNum">     988 </span>            :         return *this;<span class="lineNum">     989 </span>            :       }<span class="lineNum">     990 </span>            : <span class="lineNum">     991 </span>            :       move_iterator<span class="lineNum">     992 </span>            :       operator--(int)<span class="lineNum">     993 </span>            :       {<span class="lineNum">     994 </span>            :         move_iterator __tmp = *this;<span class="lineNum">     995 </span>            :         --_M_current;<span class="lineNum">     996 </span>            :         return __tmp;<span class="lineNum">     997 </span>            :       }<span class="lineNum">     998 </span>            : <span class="lineNum">     999 </span>            :       move_iterator<span class="lineNum">    1000 </span>            :       operator+(difference_type __n) const<span class="lineNum">    1001 </span>            :       { return move_iterator(_M_current + __n); }<span class="lineNum">    1002 </span>            : <span class="lineNum">    1003 </span>            :       move_iterator&amp;<span class="lineNum">    1004 </span>            :       operator+=(difference_type __n)<span class="lineNum">    1005 </span>            :       {<span class="lineNum">    1006 </span>            :         _M_current += __n;<span class="lineNum">    1007 </span>            :         return *this;<span class="lineNum">    1008 </span>            :       }<span class="lineNum">    1009 </span>            : <span class="lineNum">    1010 </span>            :       move_iterator<span class="lineNum">    1011 </span>            :       operator-(difference_type __n) const<span class="lineNum">    1012 </span>            :       { return move_iterator(_M_current - __n); }<span class="lineNum">    1013 </span>            :     <span class="lineNum">    1014 </span>            :       move_iterator&amp;<span class="lineNum">    1015 </span>            :       operator-=(difference_type __n)<span class="lineNum">    1016 </span>            :       { <span class="lineNum">    1017 </span>            :         _M_current -= __n;<span class="lineNum">    1018 </span>            :         return *this;<span class="lineNum">    1019 </span>            :       }<span class="lineNum">    1020 </span>            : <span class="lineNum">    1021 </span>            :       reference<span class="lineNum">    1022 </span>            :       operator[](difference_type __n) const<span class="lineNum">    1023 </span>            :       { return std::move(_M_current[__n]); }<span class="lineNum">    1024 </span>            :     };<span class="lineNum">    1025 </span>            : <span class="lineNum">    1026 </span>            :   // Note: See __normal_iterator operators note from Gaby to understand<span class="lineNum">    1027 </span>            :   // why there are always 2 versions for most of the move_iterator<span class="lineNum">    1028 </span>            :   // operators.<span class="lineNum">    1029 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">    1030 </span>            :     inline bool<span class="lineNum">    1031 </span>            :     operator==(const move_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">    1032 </span>            :                const move_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">    1033 </span>            :     { return __x.base() == __y.base(); }<span class="lineNum">    1034 </span>            : <span class="lineNum">    1035 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">    1036 </span>            :     inline bool<span class="lineNum">    1037 </span>            :     operator==(const move_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">    1038 </span>            :                const move_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">    1039 </span>            :     { return __x.base() == __y.base(); }<span class="lineNum">    1040 </span>            : <span class="lineNum">    1041 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">    1042 </span>            :     inline bool<span class="lineNum">    1043 </span>            :     operator!=(const move_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">    1044 </span>            :                const move_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">    1045 </span>            :     { return !(__x == __y); }<span class="lineNum">    1046 </span>            : <span class="lineNum">    1047 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">    1048 </span>            :     inline bool<span class="lineNum">    1049 </span>            :     operator!=(const move_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">    1050 </span>            :                const move_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">    1051 </span>            :     { return !(__x == __y); }<span class="lineNum">    1052 </span>            : <span class="lineNum">    1053 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">    1054 </span>            :     inline bool<span class="lineNum">    1055 </span>            :     operator&lt;(const move_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">    1056 </span>            :               const move_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">    1057 </span>            :     { return __x.base() &lt; __y.base(); }<span class="lineNum">    1058 </span>            : <span class="lineNum">    1059 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">    1060 </span>            :     inline bool<span class="lineNum">    1061 </span>            :     operator&lt;(const move_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">    1062 </span>            :               const move_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">    1063 </span>            :     { return __x.base() &lt; __y.base(); }<span class="lineNum">    1064 </span>            : <span class="lineNum">    1065 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">    1066 </span>            :     inline bool<span class="lineNum">    1067 </span>            :     operator&lt;=(const move_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">    1068 </span>            :                const move_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">    1069 </span>            :     { return !(__y &lt; __x); }<span class="lineNum">    1070 </span>            : <span class="lineNum">    1071 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">    1072 </span>            :     inline bool<span class="lineNum">    1073 </span>            :     operator&lt;=(const move_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">    1074 </span>            :                const move_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">    1075 </span>            :     { return !(__y &lt; __x); }<span class="lineNum">    1076 </span>            : <span class="lineNum">    1077 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">    1078 </span>            :     inline bool<span class="lineNum">    1079 </span>            :     operator&gt;(const move_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">    1080 </span>            :               const move_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">    1081 </span>            :     { return __y &lt; __x; }<span class="lineNum">    1082 </span>            : <span class="lineNum">    1083 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">    1084 </span>            :     inline bool<span class="lineNum">    1085 </span>            :     operator&gt;(const move_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">    1086 </span>            :               const move_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">    1087 </span>            :     { return __y &lt; __x; }<span class="lineNum">    1088 </span>            : <span class="lineNum">    1089 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">    1090 </span>            :     inline bool<span class="lineNum">    1091 </span>            :     operator&gt;=(const move_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">    1092 </span>            :                const move_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">    1093 </span>            :     { return !(__x &lt; __y); }<span class="lineNum">    1094 </span>            : <span class="lineNum">    1095 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">    1096 </span>            :     inline bool<span class="lineNum">    1097 </span>            :     operator&gt;=(const move_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">    1098 </span>            :                const move_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">    1099 </span>            :     { return !(__x &lt; __y); }<span class="lineNum">    1100 </span>            : <span class="lineNum">    1101 </span>            :   // DR 685.<span class="lineNum">    1102 </span>            :   template&lt;typename _IteratorL, typename _IteratorR&gt;<span class="lineNum">    1103 </span>            :     inline auto<span class="lineNum">    1104 </span>            :     operator-(const move_iterator&lt;_IteratorL&gt;&amp; __x,<span class="lineNum">    1105 </span>            :               const move_iterator&lt;_IteratorR&gt;&amp; __y)<span class="lineNum">    1106 </span>            :     -&gt; decltype(__x.base() - __y.base())<span class="lineNum">    1107 </span>            :     { return __x.base() - __y.base(); }<span class="lineNum">    1108 </span>            : <span class="lineNum">    1109 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">    1110 </span>            :     inline auto<span class="lineNum">    1111 </span>            :     operator-(const move_iterator&lt;_Iterator&gt;&amp; __x,<span class="lineNum">    1112 </span>            :               const move_iterator&lt;_Iterator&gt;&amp; __y)<span class="lineNum">    1113 </span>            :     -&gt; decltype(__x.base() - __y.base())<span class="lineNum">    1114 </span>            :     { return __x.base() - __y.base(); }<span class="lineNum">    1115 </span>            : <span class="lineNum">    1116 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">    1117 </span>            :     inline move_iterator&lt;_Iterator&gt;<span class="lineNum">    1118 </span>            :     operator+(typename move_iterator&lt;_Iterator&gt;::difference_type __n,<span class="lineNum">    1119 </span>            :               const move_iterator&lt;_Iterator&gt;&amp; __x)<span class="lineNum">    1120 </span>            :     { return __x + __n; }<span class="lineNum">    1121 </span>            : <a name="1122"><span class="lineNum">    1122 </span>            :   template&lt;typename _Iterator&gt;</a><span class="lineNum">    1123 </span>            :     inline move_iterator&lt;_Iterator&gt;<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     make_move_iterator(_Iterator __i)</span><span class="lineNum">    1125 </span><span class="lineNoCov">          0 :     { return move_iterator&lt;_Iterator&gt;(__i); }</span><span class="lineNum">    1126 </span>            : <span class="lineNum">    1127 </span>            :   template&lt;typename _Iterator, typename _ReturnType<span class="lineNum">    1128 </span>            :     = typename conditional&lt;__move_if_noexcept_cond<span class="lineNum">    1129 </span>            :       &lt;typename iterator_traits&lt;_Iterator&gt;::value_type&gt;::value,<a name="1130"><span class="lineNum">    1130 </span>            :                 _Iterator, move_iterator&lt;_Iterator&gt;&gt;::type&gt;</a><span class="lineNum">    1131 </span>            :     inline _ReturnType<span class="lineNum">    1132 </span><span class="lineCov">        188 :     __make_move_if_noexcept_iterator(_Iterator __i)</span><span class="lineNum">    1133 </span><span class="lineCov">        188 :     { return _ReturnType(__i); }</span><span class="lineNum">    1134 </span>            : <span class="lineNum">    1135 </span>            :   // @} group iterators<span class="lineNum">    1136 </span>            : <span class="lineNum">    1137 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">    1138 </span>            : } // namespace<span class="lineNum">    1139 </span>            : <span class="lineNum">    1140 </span>            : #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)<span class="lineNum">    1141 </span>            : #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) \<span class="lineNum">    1142 </span>            :   std::__make_move_if_noexcept_iterator(_Iter)<span class="lineNum">    1143 </span>            : #else<span class="lineNum">    1144 </span>            : #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)<span class="lineNum">    1145 </span>            : #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter)<span class="lineNum">    1146 </span>            : #endif // C++11<span class="lineNum">    1147 </span>            : <span class="lineNum">    1148 </span>            : #endif</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_iterator.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_iterator.h<span style="font-size: 80%;"> (<a href="stl_iterator.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">11</td>            <td class="headerCovTableEntry">13</td>            <td class="headerCovTableEntryMed">84.6 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntryLo">66.7 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="stl_iterator.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#724">_ZN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEC2ERKS1_</a></td>              <td class="coverFnHi">2</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#724">_ZN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEC2ERKS1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#894">_ZN9__gnu_cxxmiIPdSt6vectorIdSaIdEEEENS_17__normal_iteratorIT_T0_E15difference_typeERKS8_SB_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#788">_ZNK9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEE4baseEv</a></td>              <td class="coverFnHi">4</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#788">_ZNK9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEE4baseEv</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#956">_ZNKSt13move_iteratorIPdE4baseEv</a></td>              <td class="coverFnHi">94</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#948">_ZNSt13move_iteratorIPdEC2ES0_</a></td>              <td class="coverFnHi">94</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#1122">_ZSt18make_move_iteratorIPdESt13move_iteratorIT_ES2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#1130">_ZSt32__make_move_if_noexcept_iteratorIPdSt13move_iteratorIS0_EET0_T_</a></td>              <td class="coverFnHi">94</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_iterator.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_iterator.h<span style="font-size: 80%;"> (<a href="stl_iterator.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">11</td>            <td class="headerCovTableEntry">13</td>            <td class="headerCovTableEntryMed">84.6 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntryLo">66.7 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="stl_iterator.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#724">_ZN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEC2ERKS1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#788">_ZNK9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEE4baseEv</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#1122">_ZSt18make_move_iteratorIPdESt13move_iteratorIT_ES2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#894">_ZN9__gnu_cxxmiIPdSt6vectorIdSaIdEEEENS_17__normal_iteratorIT_T0_E15difference_typeERKS8_SB_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#724">_ZN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEC2ERKS1_</a></td>              <td class="coverFnHi">2</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#788">_ZNK9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEE4baseEv</a></td>              <td class="coverFnHi">4</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#956">_ZNKSt13move_iteratorIPdE4baseEv</a></td>              <td class="coverFnHi">94</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#948">_ZNSt13move_iteratorIPdEC2ES0_</a></td>              <td class="coverFnHi">94</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_iterator.h.gcov.html#1130">_ZSt32__make_move_if_noexcept_iteratorIPdSt13move_iteratorIS0_EET0_T_</a></td>              <td class="coverFnHi">94</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_iterator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_construct.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_construct.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_construct.h<span style="font-size: 80%;"> (source / <a href="stl_construct.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">7</td>            <td class="headerCovTableEntry">7</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // nonstandard construct and destroy functions -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2001-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /*<span class="lineNum">      26 </span>            :  *<span class="lineNum">      27 </span>            :  * Copyright (c) 1994<span class="lineNum">      28 </span>            :  * Hewlett-Packard Company<span class="lineNum">      29 </span>            :  *<span class="lineNum">      30 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      31 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      32 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      33 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      34 </span>            :  * in supporting documentation.  Hewlett-Packard Company makes no<span class="lineNum">      35 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      36 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      37 </span>            :  *<span class="lineNum">      38 </span>            :  *<span class="lineNum">      39 </span>            :  * Copyright (c) 1996,1997<span class="lineNum">      40 </span>            :  * Silicon Graphics Computer Systems, Inc.<span class="lineNum">      41 </span>            :  *<span class="lineNum">      42 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      43 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      44 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      45 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      46 </span>            :  * in supporting documentation.  Silicon Graphics makes no<span class="lineNum">      47 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      48 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      49 </span>            :  */<span class="lineNum">      50 </span>            : <span class="lineNum">      51 </span>            : /** @file bits/stl_construct.h<span class="lineNum">      52 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      53 </span>            :  *  Do not attempt to use it directly. @headername{memory}<span class="lineNum">      54 </span>            :  */<span class="lineNum">      55 </span>            : <span class="lineNum">      56 </span>            : #ifndef _STL_CONSTRUCT_H<span class="lineNum">      57 </span>            : #define _STL_CONSTRUCT_H 1<span class="lineNum">      58 </span>            : <span class="lineNum">      59 </span>            : #include &lt;new&gt;<span class="lineNum">      60 </span>            : #include &lt;bits/move.h&gt;<span class="lineNum">      61 </span>            : #include &lt;ext/alloc_traits.h&gt;<span class="lineNum">      62 </span>            : <span class="lineNum">      63 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      64 </span>            : {<span class="lineNum">      65 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      66 </span>            : <span class="lineNum">      67 </span>            :   /**<span class="lineNum">      68 </span>            :    * Constructs an object in existing memory by invoking an allocated<span class="lineNum">      69 </span>            :    * object's constructor with an initializer.<span class="lineNum">      70 </span>            :    */<span class="lineNum">      71 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      72 </span>            :   template&lt;typename _T1, typename... _Args&gt;<span class="lineNum">      73 </span>            :     inline void<span class="lineNum">      74 </span>            :     _Construct(_T1* __p, _Args&amp;&amp;... __args)<span class="lineNum">      75 </span>            :     { ::new(static_cast&lt;void*&gt;(__p)) _T1(std::forward&lt;_Args&gt;(__args)...); }<span class="lineNum">      76 </span>            : #else<span class="lineNum">      77 </span>            :   template&lt;typename _T1, typename _T2&gt;<span class="lineNum">      78 </span>            :     inline void<span class="lineNum">      79 </span>            :     _Construct(_T1* __p, const _T2&amp; __value)<span class="lineNum">      80 </span>            :     {<span class="lineNum">      81 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">      82 </span>            :       // 402. wrong new expression in [some_]allocator::construct<span class="lineNum">      83 </span>            :       ::new(static_cast&lt;void*&gt;(__p)) _T1(__value);<span class="lineNum">      84 </span>            :     }<span class="lineNum">      85 </span>            : #endif<span class="lineNum">      86 </span>            : <span class="lineNum">      87 </span>            :   /**<span class="lineNum">      88 </span>            :    * Destroy the object pointed to by a pointer type.<span class="lineNum">      89 </span>            :    */<span class="lineNum">      90 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      91 </span>            :     inline void<span class="lineNum">      92 </span>            :     _Destroy(_Tp* __pointer)<span class="lineNum">      93 </span>            :     { __pointer-&gt;~_Tp(); }<span class="lineNum">      94 </span>            : <span class="lineNum">      95 </span>            :   template&lt;bool&gt;<span class="lineNum">      96 </span>            :     struct _Destroy_aux<span class="lineNum">      97 </span>            :     {<span class="lineNum">      98 </span>            :       template&lt;typename _ForwardIterator&gt;<span class="lineNum">      99 </span>            :         static void<span class="lineNum">     100 </span>            :         __destroy(_ForwardIterator __first, _ForwardIterator __last)<span class="lineNum">     101 </span>            :         {<span class="lineNum">     102 </span>            :           for (; __first != __last; ++__first)<span class="lineNum">     103 </span>            :             std::_Destroy(std::__addressof(*__first));<span class="lineNum">     104 </span>            :         }<span class="lineNum">     105 </span>            :     };<span class="lineNum">     106 </span>            : <span class="lineNum">     107 </span>            :   template&lt;&gt;<span class="lineNum">     108 </span>            :     struct _Destroy_aux&lt;true&gt;<span class="lineNum">     109 </span>            :     {<a name="110"><span class="lineNum">     110 </span>            :       template&lt;typename _ForwardIterator&gt;</a><span class="lineNum">     111 </span>            :         static void<span class="lineNum">     112 </span><span class="lineCov">        268 :         __destroy(_ForwardIterator, _ForwardIterator) { }</span><span class="lineNum">     113 </span>            :     };<span class="lineNum">     114 </span>            : <span class="lineNum">     115 </span>            :   /**<span class="lineNum">     116 </span>            :    * Destroy a range of objects.  If the value_type of the object has<span class="lineNum">     117 </span>            :    * a trivial destructor, the compiler should optimize all of this<span class="lineNum">     118 </span>            :    * away, otherwise the objects' destructors must be invoked.<span class="lineNum">     119 </span>            :    */<a name="120"><span class="lineNum">     120 </span>            :   template&lt;typename _ForwardIterator&gt;</a><span class="lineNum">     121 </span>            :     inline void<span class="lineNum">     122 </span><span class="lineCov">        268 :     _Destroy(_ForwardIterator __first, _ForwardIterator __last)</span><span class="lineNum">     123 </span>            :     {<span class="lineNum">     124 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type<span class="lineNum">     125 </span>            :                        _Value_type;<span class="lineNum">     126 </span><span class="lineCov">        268 :       std::_Destroy_aux&lt;__has_trivial_destructor(_Value_type)&gt;::</span><span class="lineNum">     127 </span>            :         __destroy(__first, __last);<span class="lineNum">     128 </span><span class="lineCov">        268 :     }</span><span class="lineNum">     129 </span>            : <span class="lineNum">     130 </span>            :   /**<span class="lineNum">     131 </span>            :    * Destroy a range of objects using the supplied allocator.  For<span class="lineNum">     132 </span>            :    * nondefault allocators we do not optimize away invocation of <span class="lineNum">     133 </span>            :    * destroy() even if _Tp has a trivial destructor.<span class="lineNum">     134 </span>            :    */<span class="lineNum">     135 </span>            : <span class="lineNum">     136 </span>            :   template&lt;typename _ForwardIterator, typename _Allocator&gt;<span class="lineNum">     137 </span>            :     void<span class="lineNum">     138 </span>            :     _Destroy(_ForwardIterator __first, _ForwardIterator __last,<span class="lineNum">     139 </span>            :              _Allocator&amp; __alloc)<span class="lineNum">     140 </span>            :     {<span class="lineNum">     141 </span>            :       typedef __gnu_cxx::__alloc_traits&lt;_Allocator&gt; __traits;<span class="lineNum">     142 </span>            :       for (; __first != __last; ++__first)<span class="lineNum">     143 </span>            :         __traits::destroy(__alloc, std::__addressof(*__first));<span class="lineNum">     144 </span>            :     }<span class="lineNum">     145 </span>            : <a name="146"><span class="lineNum">     146 </span>            :   template&lt;typename _ForwardIterator, typename _Tp&gt;</a><span class="lineNum">     147 </span>            :     inline void<span class="lineNum">     148 </span><span class="lineCov">        268 :     _Destroy(_ForwardIterator __first, _ForwardIterator __last,</span><span class="lineNum">     149 </span>            :              allocator&lt;_Tp&gt;&amp;)<span class="lineNum">     150 </span>            :     {<span class="lineNum">     151 </span><span class="lineCov">        268 :       _Destroy(__first, __last);</span><span class="lineNum">     152 </span><span class="lineCov">        268 :     }</span><span class="lineNum">     153 </span>            : <span class="lineNum">     154 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     155 </span>            : } // namespace std<span class="lineNum">     156 </span>            : <span class="lineNum">     157 </span>            : #endif /* _STL_CONSTRUCT_H */<span class="lineNum">     158 </span>            : </pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_construct.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_construct.h<span style="font-size: 80%;"> (<a href="stl_construct.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">7</td>            <td class="headerCovTableEntry">7</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="stl_construct.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#110">_ZNSt12_Destroy_auxILb1EE9__destroyIPdEEvT_S3_</a></td>              <td class="coverFnHi">123</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#110">_ZNSt12_Destroy_auxILb1EE9__destroyIPiEEvT_S3_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#120">_ZSt8_DestroyIPdEvT_S1_</a></td>              <td class="coverFnHi">123</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#146">_ZSt8_DestroyIPddEvT_S1_RSaIT0_E</a></td>              <td class="coverFnHi">123</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#120">_ZSt8_DestroyIPiEvT_S1_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#146">_ZSt8_DestroyIPiiEvT_S1_RSaIT0_E</a></td>              <td class="coverFnHi">11</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_construct.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_construct.h<span style="font-size: 80%;"> (<a href="stl_construct.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">7</td>            <td class="headerCovTableEntry">7</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="stl_construct.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#110">_ZNSt12_Destroy_auxILb1EE9__destroyIPiEEvT_S3_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#120">_ZSt8_DestroyIPiEvT_S1_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#146">_ZSt8_DestroyIPiiEvT_S1_RSaIT0_E</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#110">_ZNSt12_Destroy_auxILb1EE9__destroyIPdEEvT_S3_</a></td>              <td class="coverFnHi">123</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#120">_ZSt8_DestroyIPdEvT_S1_</a></td>              <td class="coverFnHi">123</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_construct.h.gcov.html#146">_ZSt8_DestroyIPddEvT_S1_RSaIT0_E</a></td>              <td class="coverFnHi">123</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_construct.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_algobase.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_algobase.h<span style="font-size: 80%;"> (source / <a href="stl_algobase.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">31</td>            <td class="headerCovTableEntry">52</td>            <td class="headerCovTableEntryLo">59.6 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">26</td>            <td class="headerCovTableEntryLo">53.8 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Core algorithmic facilities -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2001-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /*<span class="lineNum">      26 </span>            :  *<span class="lineNum">      27 </span>            :  * Copyright (c) 1994<span class="lineNum">      28 </span>            :  * Hewlett-Packard Company<span class="lineNum">      29 </span>            :  *<span class="lineNum">      30 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      31 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      32 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      33 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      34 </span>            :  * in supporting documentation.  Hewlett-Packard Company makes no<span class="lineNum">      35 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      36 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      37 </span>            :  *<span class="lineNum">      38 </span>            :  *<span class="lineNum">      39 </span>            :  * Copyright (c) 1996-1998<span class="lineNum">      40 </span>            :  * Silicon Graphics Computer Systems, Inc.<span class="lineNum">      41 </span>            :  *<span class="lineNum">      42 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      43 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      44 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      45 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      46 </span>            :  * in supporting documentation.  Silicon Graphics makes no<span class="lineNum">      47 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      48 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      49 </span>            :  */<span class="lineNum">      50 </span>            : <span class="lineNum">      51 </span>            : /** @file bits/stl_algobase.h<span class="lineNum">      52 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      53 </span>            :  *  Do not attempt to use it directly. @headername{algorithm}<span class="lineNum">      54 </span>            :  */<span class="lineNum">      55 </span>            : <span class="lineNum">      56 </span>            : #ifndef _STL_ALGOBASE_H<span class="lineNum">      57 </span>            : #define _STL_ALGOBASE_H 1<span class="lineNum">      58 </span>            : <span class="lineNum">      59 </span>            : #include &lt;bits/c++config.h&gt;<span class="lineNum">      60 </span>            : #include &lt;bits/functexcept.h&gt;<span class="lineNum">      61 </span>            : #include &lt;bits/cpp_type_traits.h&gt;<span class="lineNum">      62 </span>            : #include &lt;ext/type_traits.h&gt;<span class="lineNum">      63 </span>            : #include &lt;ext/numeric_traits.h&gt;<span class="lineNum">      64 </span>            : #include &lt;bits/stl_pair.h&gt;<span class="lineNum">      65 </span>            : #include &lt;bits/stl_iterator_base_types.h&gt;<span class="lineNum">      66 </span>            : #include &lt;bits/stl_iterator_base_funcs.h&gt;<span class="lineNum">      67 </span>            : #include &lt;bits/stl_iterator.h&gt;<span class="lineNum">      68 </span>            : #include &lt;bits/concept_check.h&gt;<span class="lineNum">      69 </span>            : #include &lt;debug/debug.h&gt;<span class="lineNum">      70 </span>            : #include &lt;bits/move.h&gt; // For std::swap and _GLIBCXX_MOVE<span class="lineNum">      71 </span>            : <span class="lineNum">      72 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      73 </span>            : {<span class="lineNum">      74 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      75 </span>            : <span class="lineNum">      76 </span>            : #if __cplusplus &lt; 201103L<span class="lineNum">      77 </span>            :   // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a<span class="lineNum">      78 </span>            :   // nutshell, we are partially implementing the resolution of DR 187,<span class="lineNum">      79 </span>            :   // when it's safe, i.e., the value_types are equal.<span class="lineNum">      80 </span>            :   template&lt;bool _BoolType&gt;<span class="lineNum">      81 </span>            :     struct __iter_swap<span class="lineNum">      82 </span>            :     {<span class="lineNum">      83 </span>            :       template&lt;typename _ForwardIterator1, typename _ForwardIterator2&gt;<span class="lineNum">      84 </span>            :         static void<span class="lineNum">      85 </span>            :         iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)<span class="lineNum">      86 </span>            :         {<span class="lineNum">      87 </span>            :           typedef typename iterator_traits&lt;_ForwardIterator1&gt;::value_type<span class="lineNum">      88 </span>            :             _ValueType1;<span class="lineNum">      89 </span>            :           _ValueType1 __tmp = _GLIBCXX_MOVE(*__a);<span class="lineNum">      90 </span>            :           *__a = _GLIBCXX_MOVE(*__b);<span class="lineNum">      91 </span>            :           *__b = _GLIBCXX_MOVE(__tmp);<span class="lineNum">      92 </span>            :         }<span class="lineNum">      93 </span>            :     };<span class="lineNum">      94 </span>            : <span class="lineNum">      95 </span>            :   template&lt;&gt;<span class="lineNum">      96 </span>            :     struct __iter_swap&lt;true&gt;<span class="lineNum">      97 </span>            :     {<span class="lineNum">      98 </span>            :       template&lt;typename _ForwardIterator1, typename _ForwardIterator2&gt;<span class="lineNum">      99 </span>            :         static void <span class="lineNum">     100 </span>            :         iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)<span class="lineNum">     101 </span>            :         {<span class="lineNum">     102 </span>            :           swap(*__a, *__b);<span class="lineNum">     103 </span>            :         }<span class="lineNum">     104 </span>            :     };<span class="lineNum">     105 </span>            : #endif<span class="lineNum">     106 </span>            : <span class="lineNum">     107 </span>            :   /**<span class="lineNum">     108 </span>            :    *  @brief Swaps the contents of two iterators.<span class="lineNum">     109 </span>            :    *  @ingroup mutating_algorithms<span class="lineNum">     110 </span>            :    *  @param  __a  An iterator.<span class="lineNum">     111 </span>            :    *  @param  __b  Another iterator.<span class="lineNum">     112 </span>            :    *  @return   Nothing.<span class="lineNum">     113 </span>            :    *<span class="lineNum">     114 </span>            :    *  This function swaps the values pointed to by two iterators, not the<span class="lineNum">     115 </span>            :    *  iterators themselves.<span class="lineNum">     116 </span>            :   */<span class="lineNum">     117 </span>            :   template&lt;typename _ForwardIterator1, typename _ForwardIterator2&gt;<span class="lineNum">     118 </span>            :     inline void<span class="lineNum">     119 </span>            :     iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)<span class="lineNum">     120 </span>            :     {<span class="lineNum">     121 </span>            :       // concept requirements<span class="lineNum">     122 </span>            :       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept&lt;<span class="lineNum">     123 </span>            :                                   _ForwardIterator1&gt;)<span class="lineNum">     124 </span>            :       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept&lt;<span class="lineNum">     125 </span>            :                                   _ForwardIterator2&gt;)<span class="lineNum">     126 </span>            : <span class="lineNum">     127 </span>            : #if __cplusplus &lt; 201103L<span class="lineNum">     128 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator1&gt;::value_type<span class="lineNum">     129 </span>            :         _ValueType1;<span class="lineNum">     130 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator2&gt;::value_type<span class="lineNum">     131 </span>            :         _ValueType2;<span class="lineNum">     132 </span>            : <span class="lineNum">     133 </span>            :       __glibcxx_function_requires(_ConvertibleConcept&lt;_ValueType1,<span class="lineNum">     134 </span>            :                                   _ValueType2&gt;)<span class="lineNum">     135 </span>            :       __glibcxx_function_requires(_ConvertibleConcept&lt;_ValueType2,<span class="lineNum">     136 </span>            :                                   _ValueType1&gt;)<span class="lineNum">     137 </span>            : <span class="lineNum">     138 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator1&gt;::reference<span class="lineNum">     139 </span>            :         _ReferenceType1;<span class="lineNum">     140 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator2&gt;::reference<span class="lineNum">     141 </span>            :         _ReferenceType2;<span class="lineNum">     142 </span>            :       std::__iter_swap&lt;__are_same&lt;_ValueType1, _ValueType2&gt;::__value<span class="lineNum">     143 </span>            :         &amp;&amp; __are_same&lt;_ValueType1&amp;, _ReferenceType1&gt;::__value<span class="lineNum">     144 </span>            :         &amp;&amp; __are_same&lt;_ValueType2&amp;, _ReferenceType2&gt;::__value&gt;::<span class="lineNum">     145 </span>            :         iter_swap(__a, __b);<span class="lineNum">     146 </span>            : #else<span class="lineNum">     147 </span>            :       swap(*__a, *__b);<span class="lineNum">     148 </span>            : #endif<span class="lineNum">     149 </span>            :     }<span class="lineNum">     150 </span>            : <span class="lineNum">     151 </span>            :   /**<span class="lineNum">     152 </span>            :    *  @brief Swap the elements of two sequences.<span class="lineNum">     153 </span>            :    *  @ingroup mutating_algorithms<span class="lineNum">     154 </span>            :    *  @param  __first1  A forward iterator.<span class="lineNum">     155 </span>            :    *  @param  __last1   A forward iterator.<span class="lineNum">     156 </span>            :    *  @param  __first2  A forward iterator.<span class="lineNum">     157 </span>            :    *  @return   An iterator equal to @p first2+(last1-first1).<span class="lineNum">     158 </span>            :    *<span class="lineNum">     159 </span>            :    *  Swaps each element in the range @p [first1,last1) with the<span class="lineNum">     160 </span>            :    *  corresponding element in the range @p [first2,(last1-first1)).<span class="lineNum">     161 </span>            :    *  The ranges must not overlap.<span class="lineNum">     162 </span>            :   */<span class="lineNum">     163 </span>            :   template&lt;typename _ForwardIterator1, typename _ForwardIterator2&gt;<span class="lineNum">     164 </span>            :     _ForwardIterator2<span class="lineNum">     165 </span>            :     swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,<span class="lineNum">     166 </span>            :                 _ForwardIterator2 __first2)<span class="lineNum">     167 </span>            :     {<span class="lineNum">     168 </span>            :       // concept requirements<span class="lineNum">     169 </span>            :       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept&lt;<span class="lineNum">     170 </span>            :                                   _ForwardIterator1&gt;)<span class="lineNum">     171 </span>            :       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept&lt;<span class="lineNum">     172 </span>            :                                   _ForwardIterator2&gt;)<span class="lineNum">     173 </span>            :       __glibcxx_requires_valid_range(__first1, __last1);<span class="lineNum">     174 </span>            : <span class="lineNum">     175 </span>            :       for (; __first1 != __last1; ++__first1, ++__first2)<span class="lineNum">     176 </span>            :         std::iter_swap(__first1, __first2);<span class="lineNum">     177 </span>            :       return __first2;<span class="lineNum">     178 </span>            :     }<span class="lineNum">     179 </span>            : <span class="lineNum">     180 </span>            :   /**<span class="lineNum">     181 </span>            :    *  @brief This does what you think it does.<span class="lineNum">     182 </span>            :    *  @ingroup sorting_algorithms<span class="lineNum">     183 </span>            :    *  @param  __a  A thing of arbitrary type.<span class="lineNum">     184 </span>            :    *  @param  __b  Another thing of arbitrary type.<span class="lineNum">     185 </span>            :    *  @return   The lesser of the parameters.<span class="lineNum">     186 </span>            :    *<span class="lineNum">     187 </span>            :    *  This is the simple classic generic implementation.  It will work on<span class="lineNum">     188 </span>            :    *  temporary expressions, since they are only evaluated once, unlike a<span class="lineNum">     189 </span>            :    *  preprocessor macro.<span class="lineNum">     190 </span>            :   */<a name="191"><span class="lineNum">     191 </span>            :   template&lt;typename _Tp&gt;</a><span class="lineNum">     192 </span>            :     inline const _Tp&amp;<span class="lineNum">     193 </span><span class="lineCov">       7840 :     min(const _Tp&amp; __a, const _Tp&amp; __b)</span><span class="lineNum">     194 </span>            :     {<span class="lineNum">     195 </span>            :       // concept requirements<span class="lineNum">     196 </span>            :       __glibcxx_function_requires(_LessThanComparableConcept&lt;_Tp&gt;)<span class="lineNum">     197 </span>            :       //return __b &lt; __a ? __b : __a;<span class="lineNum">     198 </span><span class="lineCov">       7840 :       if (__b &lt; __a)</span><span class="lineNum">     199 </span><span class="lineCov">       7214 :         return __b;</span><span class="lineNum">     200 </span><span class="lineCov">        626 :       return __a;</span><span class="lineNum">     201 </span>            :     }<span class="lineNum">     202 </span>            : <span class="lineNum">     203 </span>            :   /**<span class="lineNum">     204 </span>            :    *  @brief This does what you think it does.<span class="lineNum">     205 </span>            :    *  @ingroup sorting_algorithms<span class="lineNum">     206 </span>            :    *  @param  __a  A thing of arbitrary type.<span class="lineNum">     207 </span>            :    *  @param  __b  Another thing of arbitrary type.<span class="lineNum">     208 </span>            :    *  @return   The greater of the parameters.<span class="lineNum">     209 </span>            :    *<span class="lineNum">     210 </span>            :    *  This is the simple classic generic implementation.  It will work on<span class="lineNum">     211 </span>            :    *  temporary expressions, since they are only evaluated once, unlike a<span class="lineNum">     212 </span>            :    *  preprocessor macro.<span class="lineNum">     213 </span>            :   */<a name="214"><span class="lineNum">     214 </span>            :   template&lt;typename _Tp&gt;</a><span class="lineNum">     215 </span>            :     inline const _Tp&amp;<span class="lineNum">     216 </span><span class="lineCov">       7932 :     max(const _Tp&amp; __a, const _Tp&amp; __b)</span><span class="lineNum">     217 </span>            :     {<span class="lineNum">     218 </span>            :       // concept requirements<span class="lineNum">     219 </span>            :       __glibcxx_function_requires(_LessThanComparableConcept&lt;_Tp&gt;)<span class="lineNum">     220 </span>            :       //return  __a &lt; __b ? __b : __a;<span class="lineNum">     221 </span><span class="lineCov">       7932 :       if (__a &lt; __b)</span><span class="lineNum">     222 </span><span class="lineCov">       7292 :         return __b;</span><span class="lineNum">     223 </span><span class="lineCov">        640 :       return __a;</span><span class="lineNum">     224 </span>            :     }<span class="lineNum">     225 </span>            : <span class="lineNum">     226 </span>            :   /**<span class="lineNum">     227 </span>            :    *  @brief This does what you think it does.<span class="lineNum">     228 </span>            :    *  @ingroup sorting_algorithms<span class="lineNum">     229 </span>            :    *  @param  __a  A thing of arbitrary type.<span class="lineNum">     230 </span>            :    *  @param  __b  Another thing of arbitrary type.<span class="lineNum">     231 </span>            :    *  @param  __comp  A @link comparison_functors comparison functor@endlink.<span class="lineNum">     232 </span>            :    *  @return   The lesser of the parameters.<span class="lineNum">     233 </span>            :    *<span class="lineNum">     234 </span>            :    *  This will work on temporary expressions, since they are only evaluated<span class="lineNum">     235 </span>            :    *  once, unlike a preprocessor macro.<span class="lineNum">     236 </span>            :   */<span class="lineNum">     237 </span>            :   template&lt;typename _Tp, typename _Compare&gt;<span class="lineNum">     238 </span>            :     inline const _Tp&amp;<span class="lineNum">     239 </span>            :     min(const _Tp&amp; __a, const _Tp&amp; __b, _Compare __comp)<span class="lineNum">     240 </span>            :     {<span class="lineNum">     241 </span>            :       //return __comp(__b, __a) ? __b : __a;<span class="lineNum">     242 </span>            :       if (__comp(__b, __a))<span class="lineNum">     243 </span>            :         return __b;<span class="lineNum">     244 </span>            :       return __a;<span class="lineNum">     245 </span>            :     }<span class="lineNum">     246 </span>            : <span class="lineNum">     247 </span>            :   /**<span class="lineNum">     248 </span>            :    *  @brief This does what you think it does.<span class="lineNum">     249 </span>            :    *  @ingroup sorting_algorithms<span class="lineNum">     250 </span>            :    *  @param  __a  A thing of arbitrary type.<span class="lineNum">     251 </span>            :    *  @param  __b  Another thing of arbitrary type.<span class="lineNum">     252 </span>            :    *  @param  __comp  A @link comparison_functors comparison functor@endlink.<span class="lineNum">     253 </span>            :    *  @return   The greater of the parameters.<span class="lineNum">     254 </span>            :    *<span class="lineNum">     255 </span>            :    *  This will work on temporary expressions, since they are only evaluated<span class="lineNum">     256 </span>            :    *  once, unlike a preprocessor macro.<span class="lineNum">     257 </span>            :   */<span class="lineNum">     258 </span>            :   template&lt;typename _Tp, typename _Compare&gt;<span class="lineNum">     259 </span>            :     inline const _Tp&amp;<span class="lineNum">     260 </span>            :     max(const _Tp&amp; __a, const _Tp&amp; __b, _Compare __comp)<span class="lineNum">     261 </span>            :     {<span class="lineNum">     262 </span>            :       //return __comp(__a, __b) ? __b : __a;<span class="lineNum">     263 </span>            :       if (__comp(__a, __b))<span class="lineNum">     264 </span>            :         return __b;<span class="lineNum">     265 </span>            :       return __a;<span class="lineNum">     266 </span>            :     }<span class="lineNum">     267 </span>            : <span class="lineNum">     268 </span>            :   // If _Iterator is a __normal_iterator return its base (a plain pointer,<span class="lineNum">     269 </span>            :   // normally) otherwise return it untouched.  See copy, fill, ... <span class="lineNum">     270 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     271 </span>            :     struct _Niter_base<span class="lineNum">     272 </span>            :     : _Iter_base&lt;_Iterator, __is_normal_iterator&lt;_Iterator&gt;::__value&gt;<span class="lineNum">     273 </span>            :     { };<span class="lineNum">     274 </span>            : <a name="275"><span class="lineNum">     275 </span>            :   template&lt;typename _Iterator&gt;</a><span class="lineNum">     276 </span>            :     inline typename _Niter_base&lt;_Iterator&gt;::iterator_type<span class="lineNum">     277 </span><span class="lineCov">        460 :     __niter_base(_Iterator __it)</span><span class="lineNum">     278 </span><span class="lineCov">        460 :     { return std::_Niter_base&lt;_Iterator&gt;::_S_base(__it); }</span><span class="lineNum">     279 </span>            : <span class="lineNum">     280 </span>            :   // Likewise, for move_iterator.<span class="lineNum">     281 </span>            :   template&lt;typename _Iterator&gt;<span class="lineNum">     282 </span>            :     struct _Miter_base<span class="lineNum">     283 </span>            :     : _Iter_base&lt;_Iterator, __is_move_iterator&lt;_Iterator&gt;::__value&gt;<span class="lineNum">     284 </span>            :     { };<span class="lineNum">     285 </span>            : <a name="286"><span class="lineNum">     286 </span>            :   template&lt;typename _Iterator&gt;</a><span class="lineNum">     287 </span>            :     inline typename _Miter_base&lt;_Iterator&gt;::iterator_type<span class="lineNum">     288 </span><span class="lineCov">        188 :     __miter_base(_Iterator __it)</span><span class="lineNum">     289 </span><span class="lineCov">        188 :     { return std::_Miter_base&lt;_Iterator&gt;::_S_base(__it); }</span><span class="lineNum">     290 </span>            : <span class="lineNum">     291 </span>            :   // All of these auxiliary structs serve two purposes.  (1) Replace<span class="lineNum">     292 </span>            :   // calls to copy with memmove whenever possible.  (Memmove, not memcpy,<span class="lineNum">     293 </span>            :   // because the input and output ranges are permitted to overlap.)<span class="lineNum">     294 </span>            :   // (2) If we're using random access iterators, then write the loop as<span class="lineNum">     295 </span>            :   // a for loop with an explicit count.<span class="lineNum">     296 </span>            : <span class="lineNum">     297 </span>            :   template&lt;bool, bool, typename&gt;<span class="lineNum">     298 </span>            :     struct __copy_move<span class="lineNum">     299 </span>            :     {<span class="lineNum">     300 </span>            :       template&lt;typename _II, typename _OI&gt;<span class="lineNum">     301 </span>            :         static _OI<span class="lineNum">     302 </span>            :         __copy_m(_II __first, _II __last, _OI __result)<span class="lineNum">     303 </span>            :         {<span class="lineNum">     304 </span>            :           for (; __first != __last; ++__result, ++__first)<span class="lineNum">     305 </span>            :             *__result = *__first;<span class="lineNum">     306 </span>            :           return __result;<span class="lineNum">     307 </span>            :         }<span class="lineNum">     308 </span>            :     };<span class="lineNum">     309 </span>            : <span class="lineNum">     310 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     311 </span>            :   template&lt;typename _Category&gt;<span class="lineNum">     312 </span>            :     struct __copy_move&lt;true, false, _Category&gt;<span class="lineNum">     313 </span>            :     {<span class="lineNum">     314 </span>            :       template&lt;typename _II, typename _OI&gt;<span class="lineNum">     315 </span>            :         static _OI<span class="lineNum">     316 </span>            :         __copy_m(_II __first, _II __last, _OI __result)<span class="lineNum">     317 </span>            :         {<span class="lineNum">     318 </span>            :           for (; __first != __last; ++__result, ++__first)<span class="lineNum">     319 </span>            :             *__result = std::move(*__first);<span class="lineNum">     320 </span>            :           return __result;<span class="lineNum">     321 </span>            :         }<span class="lineNum">     322 </span>            :     };<span class="lineNum">     323 </span>            : #endif<span class="lineNum">     324 </span>            : <span class="lineNum">     325 </span>            :   template&lt;&gt;<span class="lineNum">     326 </span>            :     struct __copy_move&lt;false, false, random_access_iterator_tag&gt;<span class="lineNum">     327 </span>            :     {<span class="lineNum">     328 </span>            :       template&lt;typename _II, typename _OI&gt;<span class="lineNum">     329 </span>            :         static _OI<span class="lineNum">     330 </span>            :         __copy_m(_II __first, _II __last, _OI __result)<span class="lineNum">     331 </span>            :         { <span class="lineNum">     332 </span>            :           typedef typename iterator_traits&lt;_II&gt;::difference_type _Distance;<span class="lineNum">     333 </span>            :           for(_Distance __n = __last - __first; __n &gt; 0; --__n)<span class="lineNum">     334 </span>            :             {<span class="lineNum">     335 </span>            :               *__result = *__first;<span class="lineNum">     336 </span>            :               ++__first;<span class="lineNum">     337 </span>            :               ++__result;<span class="lineNum">     338 </span>            :             }<span class="lineNum">     339 </span>            :           return __result;<span class="lineNum">     340 </span>            :         }<span class="lineNum">     341 </span>            :     };<span class="lineNum">     342 </span>            : <span class="lineNum">     343 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     344 </span>            :   template&lt;&gt;<span class="lineNum">     345 </span>            :     struct __copy_move&lt;true, false, random_access_iterator_tag&gt;<span class="lineNum">     346 </span>            :     {<span class="lineNum">     347 </span>            :       template&lt;typename _II, typename _OI&gt;<span class="lineNum">     348 </span>            :         static _OI<span class="lineNum">     349 </span>            :         __copy_m(_II __first, _II __last, _OI __result)<span class="lineNum">     350 </span>            :         { <span class="lineNum">     351 </span>            :           typedef typename iterator_traits&lt;_II&gt;::difference_type _Distance;<span class="lineNum">     352 </span>            :           for(_Distance __n = __last - __first; __n &gt; 0; --__n)<span class="lineNum">     353 </span>            :             {<span class="lineNum">     354 </span>            :               *__result = std::move(*__first);<span class="lineNum">     355 </span>            :               ++__first;<span class="lineNum">     356 </span>            :               ++__result;<span class="lineNum">     357 </span>            :             }<span class="lineNum">     358 </span>            :           return __result;<span class="lineNum">     359 </span>            :         }<span class="lineNum">     360 </span>            :     };<span class="lineNum">     361 </span>            : #endif<span class="lineNum">     362 </span>            : <span class="lineNum">     363 </span>            :   template&lt;bool _IsMove&gt;<span class="lineNum">     364 </span>            :     struct __copy_move&lt;_IsMove, true, random_access_iterator_tag&gt;<span class="lineNum">     365 </span>            :     {<a name="366"><span class="lineNum">     366 </span>            :       template&lt;typename _Tp&gt;</a><span class="lineNum">     367 </span>            :         static _Tp*<span class="lineNum">     368 </span><span class="lineCov">         94 :         __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)</span><span class="lineNum">     369 </span>            :         {<span class="lineNum">     370 </span><span class="lineCov">         94 :           const ptrdiff_t _Num = __last - __first;</span><span class="lineNum">     371 </span><span class="lineCov">         94 :           if (_Num)</span><span class="lineNum">     372 </span><span class="lineCov">         80 :             __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);</span><span class="lineNum">     373 </span><span class="lineCov">         94 :           return __result + _Num;</span><span class="lineNum">     374 </span>            :         }<span class="lineNum">     375 </span>            :     };<span class="lineNum">     376 </span>            : <a name="377"><span class="lineNum">     377 </span>            :   template&lt;bool _IsMove, typename _II, typename _OI&gt;</a><span class="lineNum">     378 </span>            :     inline _OI<span class="lineNum">     379 </span><span class="lineCov">         94 :     __copy_move_a(_II __first, _II __last, _OI __result)</span><span class="lineNum">     380 </span>            :     {<span class="lineNum">     381 </span>            :       typedef typename iterator_traits&lt;_II&gt;::value_type _ValueTypeI;<span class="lineNum">     382 </span>            :       typedef typename iterator_traits&lt;_OI&gt;::value_type _ValueTypeO;<span class="lineNum">     383 </span>            :       typedef typename iterator_traits&lt;_II&gt;::iterator_category _Category;<span class="lineNum">     384 </span>            :       const bool __simple = (__is_trivial(_ValueTypeI)<span class="lineNum">     385 </span>            :                              &amp;&amp; __is_pointer&lt;_II&gt;::__value<span class="lineNum">     386 </span>            :                              &amp;&amp; __is_pointer&lt;_OI&gt;::__value<span class="lineNum">     387 </span><span class="lineCov">         94 :                              &amp;&amp; __are_same&lt;_ValueTypeI, _ValueTypeO&gt;::__value);</span><span class="lineNum">     388 </span>            : <span class="lineNum">     389 </span>            :       return std::__copy_move&lt;_IsMove, __simple,<span class="lineNum">     390 </span><span class="lineCov">         94 :                               _Category&gt;::__copy_m(__first, __last, __result);</span><span class="lineNum">     391 </span>            :     }<span class="lineNum">     392 </span>            : <span class="lineNum">     393 </span>            :   // Helpers for streambuf iterators (either istream or ostream).<span class="lineNum">     394 </span>            :   // NB: avoid including &lt;iosfwd&gt;, relatively large.<span class="lineNum">     395 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     396 </span>            :     struct char_traits;<span class="lineNum">     397 </span>            : <span class="lineNum">     398 </span>            :   template&lt;typename _CharT, typename _Traits&gt;<span class="lineNum">     399 </span>            :     class istreambuf_iterator;<span class="lineNum">     400 </span>            : <span class="lineNum">     401 </span>            :   template&lt;typename _CharT, typename _Traits&gt;<span class="lineNum">     402 </span>            :     class ostreambuf_iterator;<span class="lineNum">     403 </span>            : <span class="lineNum">     404 </span>            :   template&lt;bool _IsMove, typename _CharT&gt;<span class="lineNum">     405 </span>            :     typename __gnu_cxx::__enable_if&lt;__is_char&lt;_CharT&gt;::__value, <span class="lineNum">     406 </span>            :              ostreambuf_iterator&lt;_CharT, char_traits&lt;_CharT&gt; &gt; &gt;::__type<span class="lineNum">     407 </span>            :     __copy_move_a2(_CharT*, _CharT*,<span class="lineNum">     408 </span>            :                    ostreambuf_iterator&lt;_CharT, char_traits&lt;_CharT&gt; &gt;);<span class="lineNum">     409 </span>            : <span class="lineNum">     410 </span>            :   template&lt;bool _IsMove, typename _CharT&gt;<span class="lineNum">     411 </span>            :     typename __gnu_cxx::__enable_if&lt;__is_char&lt;_CharT&gt;::__value, <span class="lineNum">     412 </span>            :              ostreambuf_iterator&lt;_CharT, char_traits&lt;_CharT&gt; &gt; &gt;::__type<span class="lineNum">     413 </span>            :     __copy_move_a2(const _CharT*, const _CharT*,<span class="lineNum">     414 </span>            :                    ostreambuf_iterator&lt;_CharT, char_traits&lt;_CharT&gt; &gt;);<span class="lineNum">     415 </span>            : <span class="lineNum">     416 </span>            :   template&lt;bool _IsMove, typename _CharT&gt;<span class="lineNum">     417 </span>            :     typename __gnu_cxx::__enable_if&lt;__is_char&lt;_CharT&gt;::__value,<span class="lineNum">     418 </span>            :                                     _CharT*&gt;::__type<span class="lineNum">     419 </span>            :     __copy_move_a2(istreambuf_iterator&lt;_CharT, char_traits&lt;_CharT&gt; &gt;,<span class="lineNum">     420 </span>            :                    istreambuf_iterator&lt;_CharT, char_traits&lt;_CharT&gt; &gt;, _CharT*);<span class="lineNum">     421 </span>            : <a name="422"><span class="lineNum">     422 </span>            :   template&lt;bool _IsMove, typename _II, typename _OI&gt;</a><span class="lineNum">     423 </span>            :     inline _OI<span class="lineNum">     424 </span><span class="lineCov">         94 :     __copy_move_a2(_II __first, _II __last, _OI __result)</span><span class="lineNum">     425 </span>            :     {<span class="lineNum">     426 </span>            :       return _OI(std::__copy_move_a&lt;_IsMove&gt;(std::__niter_base(__first),<span class="lineNum">     427 </span>            :                                              std::__niter_base(__last),<span class="lineNum">     428 </span><span class="lineCov">         94 :                                              std::__niter_base(__result)));</span><span class="lineNum">     429 </span>            :     }<span class="lineNum">     430 </span>            : <span class="lineNum">     431 </span>            :   /**<span class="lineNum">     432 </span>            :    *  @brief Copies the range [first,last) into result.<span class="lineNum">     433 </span>            :    *  @ingroup mutating_algorithms<span class="lineNum">     434 </span>            :    *  @param  __first  An input iterator.<span class="lineNum">     435 </span>            :    *  @param  __last   An input iterator.<span class="lineNum">     436 </span>            :    *  @param  __result An output iterator.<span class="lineNum">     437 </span>            :    *  @return   result + (first - last)<span class="lineNum">     438 </span>            :    *<span class="lineNum">     439 </span>            :    *  This inline function will boil down to a call to @c memmove whenever<span class="lineNum">     440 </span>            :    *  possible.  Failing that, if random access iterators are passed, then the<span class="lineNum">     441 </span>            :    *  loop count will be known (and therefore a candidate for compiler<span class="lineNum">     442 </span>            :    *  optimizations such as unrolling).  Result may not be contained within<span class="lineNum">     443 </span>            :    *  [first,last); the copy_backward function should be used instead.<span class="lineNum">     444 </span>            :    *<span class="lineNum">     445 </span>            :    *  Note that the end of the output range is permitted to be contained<span class="lineNum">     446 </span>            :    *  within [first,last).<span class="lineNum">     447 </span>            :   */<a name="448"><span class="lineNum">     448 </span>            :   template&lt;typename _II, typename _OI&gt;</a><span class="lineNum">     449 </span>            :     inline _OI<span class="lineNum">     450 </span><span class="lineCov">         94 :     copy(_II __first, _II __last, _OI __result)</span><span class="lineNum">     451 </span>            :     {<span class="lineNum">     452 </span>            :       // concept requirements<span class="lineNum">     453 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_II&gt;)<span class="lineNum">     454 </span>            :       __glibcxx_function_requires(_OutputIteratorConcept&lt;_OI,<span class="lineNum">     455 </span>            :             typename iterator_traits&lt;_II&gt;::value_type&gt;)<span class="lineNum">     456 </span>            :       __glibcxx_requires_valid_range(__first, __last);<span class="lineNum">     457 </span>            : <span class="lineNum">     458 </span>            :       return (std::__copy_move_a2&lt;__is_move_iterator&lt;_II&gt;::__value&gt;<span class="lineNum">     459 </span>            :               (std::__miter_base(__first), std::__miter_base(__last),<span class="lineNum">     460 </span><span class="lineCov">         94 :                __result));</span><span class="lineNum">     461 </span>            :     }<span class="lineNum">     462 </span>            : <span class="lineNum">     463 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     464 </span>            :   /**<span class="lineNum">     465 </span>            :    *  @brief Moves the range [first,last) into result.<span class="lineNum">     466 </span>            :    *  @ingroup mutating_algorithms<span class="lineNum">     467 </span>            :    *  @param  __first  An input iterator.<span class="lineNum">     468 </span>            :    *  @param  __last   An input iterator.<span class="lineNum">     469 </span>            :    *  @param  __result An output iterator.<span class="lineNum">     470 </span>            :    *  @return   result + (first - last)<span class="lineNum">     471 </span>            :    *<span class="lineNum">     472 </span>            :    *  This inline function will boil down to a call to @c memmove whenever<span class="lineNum">     473 </span>            :    *  possible.  Failing that, if random access iterators are passed, then the<span class="lineNum">     474 </span>            :    *  loop count will be known (and therefore a candidate for compiler<span class="lineNum">     475 </span>            :    *  optimizations such as unrolling).  Result may not be contained within<span class="lineNum">     476 </span>            :    *  [first,last); the move_backward function should be used instead.<span class="lineNum">     477 </span>            :    *<span class="lineNum">     478 </span>            :    *  Note that the end of the output range is permitted to be contained<span class="lineNum">     479 </span>            :    *  within [first,last).<span class="lineNum">     480 </span>            :   */<span class="lineNum">     481 </span>            :   template&lt;typename _II, typename _OI&gt;<span class="lineNum">     482 </span>            :     inline _OI<span class="lineNum">     483 </span>            :     move(_II __first, _II __last, _OI __result)<span class="lineNum">     484 </span>            :     {<span class="lineNum">     485 </span>            :       // concept requirements<span class="lineNum">     486 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_II&gt;)<span class="lineNum">     487 </span>            :       __glibcxx_function_requires(_OutputIteratorConcept&lt;_OI,<span class="lineNum">     488 </span>            :             typename iterator_traits&lt;_II&gt;::value_type&gt;)<span class="lineNum">     489 </span>            :       __glibcxx_requires_valid_range(__first, __last);<span class="lineNum">     490 </span>            : <span class="lineNum">     491 </span>            :       return std::__copy_move_a2&lt;true&gt;(std::__miter_base(__first),<span class="lineNum">     492 </span>            :                                        std::__miter_base(__last), __result);<span class="lineNum">     493 </span>            :     }<span class="lineNum">     494 </span>            : <span class="lineNum">     495 </span>            : #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)<span class="lineNum">     496 </span>            : #else<span class="lineNum">     497 </span>            : #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)<span class="lineNum">     498 </span>            : #endif<span class="lineNum">     499 </span>            : <span class="lineNum">     500 </span>            :   template&lt;bool, bool, typename&gt;<span class="lineNum">     501 </span>            :     struct __copy_move_backward<span class="lineNum">     502 </span>            :     {<span class="lineNum">     503 </span>            :       template&lt;typename _BI1, typename _BI2&gt;<span class="lineNum">     504 </span>            :         static _BI2<span class="lineNum">     505 </span>            :         __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)<span class="lineNum">     506 </span>            :         {<span class="lineNum">     507 </span>            :           while (__first != __last)<span class="lineNum">     508 </span>            :             *--__result = *--__last;<span class="lineNum">     509 </span>            :           return __result;<span class="lineNum">     510 </span>            :         }<span class="lineNum">     511 </span>            :     };<span class="lineNum">     512 </span>            : <span class="lineNum">     513 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     514 </span>            :   template&lt;typename _Category&gt;<span class="lineNum">     515 </span>            :     struct __copy_move_backward&lt;true, false, _Category&gt;<span class="lineNum">     516 </span>            :     {<span class="lineNum">     517 </span>            :       template&lt;typename _BI1, typename _BI2&gt;<span class="lineNum">     518 </span>            :         static _BI2<span class="lineNum">     519 </span>            :         __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)<span class="lineNum">     520 </span>            :         {<span class="lineNum">     521 </span>            :           while (__first != __last)<span class="lineNum">     522 </span>            :             *--__result = std::move(*--__last);<span class="lineNum">     523 </span>            :           return __result;<span class="lineNum">     524 </span>            :         }<span class="lineNum">     525 </span>            :     };<span class="lineNum">     526 </span>            : #endif<span class="lineNum">     527 </span>            : <span class="lineNum">     528 </span>            :   template&lt;&gt;<span class="lineNum">     529 </span>            :     struct __copy_move_backward&lt;false, false, random_access_iterator_tag&gt;<span class="lineNum">     530 </span>            :     {<span class="lineNum">     531 </span>            :       template&lt;typename _BI1, typename _BI2&gt;<span class="lineNum">     532 </span>            :         static _BI2<span class="lineNum">     533 </span>            :         __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)<span class="lineNum">     534 </span>            :         {<span class="lineNum">     535 </span>            :           typename iterator_traits&lt;_BI1&gt;::difference_type __n;<span class="lineNum">     536 </span>            :           for (__n = __last - __first; __n &gt; 0; --__n)<span class="lineNum">     537 </span>            :             *--__result = *--__last;<span class="lineNum">     538 </span>            :           return __result;<span class="lineNum">     539 </span>            :         }<span class="lineNum">     540 </span>            :     };<span class="lineNum">     541 </span>            : <span class="lineNum">     542 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     543 </span>            :   template&lt;&gt;<span class="lineNum">     544 </span>            :     struct __copy_move_backward&lt;true, false, random_access_iterator_tag&gt;<span class="lineNum">     545 </span>            :     {<span class="lineNum">     546 </span>            :       template&lt;typename _BI1, typename _BI2&gt;<span class="lineNum">     547 </span>            :         static _BI2<span class="lineNum">     548 </span>            :         __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)<span class="lineNum">     549 </span>            :         {<span class="lineNum">     550 </span>            :           typename iterator_traits&lt;_BI1&gt;::difference_type __n;<span class="lineNum">     551 </span>            :           for (__n = __last - __first; __n &gt; 0; --__n)<span class="lineNum">     552 </span>            :             *--__result = std::move(*--__last);<span class="lineNum">     553 </span>            :           return __result;<span class="lineNum">     554 </span>            :         }<span class="lineNum">     555 </span>            :     };<span class="lineNum">     556 </span>            : #endif<span class="lineNum">     557 </span>            : <span class="lineNum">     558 </span>            :   template&lt;bool _IsMove&gt;<span class="lineNum">     559 </span>            :     struct __copy_move_backward&lt;_IsMove, true, random_access_iterator_tag&gt;<span class="lineNum">     560 </span>            :     {<a name="561"><span class="lineNum">     561 </span>            :       template&lt;typename _Tp&gt;</a><span class="lineNum">     562 </span>            :         static _Tp*<span class="lineNum">     563 </span><span class="lineNoCov">          0 :         __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)</span><span class="lineNum">     564 </span>            :         {<span class="lineNum">     565 </span><span class="lineNoCov">          0 :           const ptrdiff_t _Num = __last - __first;</span><span class="lineNum">     566 </span><span class="lineNoCov">          0 :           if (_Num)</span><span class="lineNum">     567 </span><span class="lineNoCov">          0 :             __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);</span><span class="lineNum">     568 </span><span class="lineNoCov">          0 :           return __result - _Num;</span><span class="lineNum">     569 </span>            :         }<span class="lineNum">     570 </span>            :     };<span class="lineNum">     571 </span>            : <a name="572"><span class="lineNum">     572 </span>            :   template&lt;bool _IsMove, typename _BI1, typename _BI2&gt;</a><span class="lineNum">     573 </span>            :     inline _BI2<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)</span><span class="lineNum">     575 </span>            :     {<span class="lineNum">     576 </span>            :       typedef typename iterator_traits&lt;_BI1&gt;::value_type _ValueType1;<span class="lineNum">     577 </span>            :       typedef typename iterator_traits&lt;_BI2&gt;::value_type _ValueType2;<span class="lineNum">     578 </span>            :       typedef typename iterator_traits&lt;_BI1&gt;::iterator_category _Category;<span class="lineNum">     579 </span>            :       const bool __simple = (__is_trivial(_ValueType1)<span class="lineNum">     580 </span>            :                              &amp;&amp; __is_pointer&lt;_BI1&gt;::__value<span class="lineNum">     581 </span>            :                              &amp;&amp; __is_pointer&lt;_BI2&gt;::__value<span class="lineNum">     582 </span><span class="lineNoCov">          0 :                              &amp;&amp; __are_same&lt;_ValueType1, _ValueType2&gt;::__value);</span><span class="lineNum">     583 </span>            : <span class="lineNum">     584 </span>            :       return std::__copy_move_backward&lt;_IsMove, __simple,<span class="lineNum">     585 </span>            :                                        _Category&gt;::__copy_move_b(__first,<span class="lineNum">     586 </span>            :                                                                  __last,<span class="lineNum">     587 </span><span class="lineNoCov">          0 :                                                                  __result);</span><span class="lineNum">     588 </span>            :     }<span class="lineNum">     589 </span>            : <a name="590"><span class="lineNum">     590 </span>            :   template&lt;bool _IsMove, typename _BI1, typename _BI2&gt;</a><span class="lineNum">     591 </span>            :     inline _BI2<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)</span><span class="lineNum">     593 </span>            :     {<span class="lineNum">     594 </span>            :       return _BI2(std::__copy_move_backward_a&lt;_IsMove&gt;<span class="lineNum">     595 </span>            :                   (std::__niter_base(__first), std::__niter_base(__last),<span class="lineNum">     596 </span><span class="lineNoCov">          0 :                    std::__niter_base(__result)));</span><span class="lineNum">     597 </span>            :     }<span class="lineNum">     598 </span>            : <span class="lineNum">     599 </span>            :   /**<span class="lineNum">     600 </span>            :    *  @brief Copies the range [first,last) into result.<span class="lineNum">     601 </span>            :    *  @ingroup mutating_algorithms<span class="lineNum">     602 </span>            :    *  @param  __first  A bidirectional iterator.<span class="lineNum">     603 </span>            :    *  @param  __last   A bidirectional iterator.<span class="lineNum">     604 </span>            :    *  @param  __result A bidirectional iterator.<span class="lineNum">     605 </span>            :    *  @return   result - (first - last)<span class="lineNum">     606 </span>            :    *<span class="lineNum">     607 </span>            :    *  The function has the same effect as copy, but starts at the end of the<span class="lineNum">     608 </span>            :    *  range and works its way to the start, returning the start of the result.<span class="lineNum">     609 </span>            :    *  This inline function will boil down to a call to @c memmove whenever<span class="lineNum">     610 </span>            :    *  possible.  Failing that, if random access iterators are passed, then the<span class="lineNum">     611 </span>            :    *  loop count will be known (and therefore a candidate for compiler<span class="lineNum">     612 </span>            :    *  optimizations such as unrolling).<span class="lineNum">     613 </span>            :    *<span class="lineNum">     614 </span>            :    *  Result may not be in the range (first,last].  Use copy instead.  Note<span class="lineNum">     615 </span>            :    *  that the start of the output range may overlap [first,last).<span class="lineNum">     616 </span>            :   */<span class="lineNum">     617 </span>            :   template&lt;typename _BI1, typename _BI2&gt;<span class="lineNum">     618 </span>            :     inline _BI2<span class="lineNum">     619 </span>            :     copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)<span class="lineNum">     620 </span>            :     {<span class="lineNum">     621 </span>            :       // concept requirements<span class="lineNum">     622 </span>            :       __glibcxx_function_requires(_BidirectionalIteratorConcept&lt;_BI1&gt;)<span class="lineNum">     623 </span>            :       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept&lt;_BI2&gt;)<span class="lineNum">     624 </span>            :       __glibcxx_function_requires(_ConvertibleConcept&lt;<span class="lineNum">     625 </span>            :             typename iterator_traits&lt;_BI1&gt;::value_type,<span class="lineNum">     626 </span>            :             typename iterator_traits&lt;_BI2&gt;::value_type&gt;)<span class="lineNum">     627 </span>            :       __glibcxx_requires_valid_range(__first, __last);<span class="lineNum">     628 </span>            : <span class="lineNum">     629 </span>            :       return (std::__copy_move_backward_a2&lt;__is_move_iterator&lt;_BI1&gt;::__value&gt;<span class="lineNum">     630 </span>            :               (std::__miter_base(__first), std::__miter_base(__last),<span class="lineNum">     631 </span>            :                __result));<span class="lineNum">     632 </span>            :     }<span class="lineNum">     633 </span>            : <span class="lineNum">     634 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     635 </span>            :   /**<span class="lineNum">     636 </span>            :    *  @brief Moves the range [first,last) into result.<span class="lineNum">     637 </span>            :    *  @ingroup mutating_algorithms<span class="lineNum">     638 </span>            :    *  @param  __first  A bidirectional iterator.<span class="lineNum">     639 </span>            :    *  @param  __last   A bidirectional iterator.<span class="lineNum">     640 </span>            :    *  @param  __result A bidirectional iterator.<span class="lineNum">     641 </span>            :    *  @return   result - (first - last)<span class="lineNum">     642 </span>            :    *<span class="lineNum">     643 </span>            :    *  The function has the same effect as move, but starts at the end of the<span class="lineNum">     644 </span>            :    *  range and works its way to the start, returning the start of the result.<span class="lineNum">     645 </span>            :    *  This inline function will boil down to a call to @c memmove whenever<span class="lineNum">     646 </span>            :    *  possible.  Failing that, if random access iterators are passed, then the<span class="lineNum">     647 </span>            :    *  loop count will be known (and therefore a candidate for compiler<span class="lineNum">     648 </span>            :    *  optimizations such as unrolling).<span class="lineNum">     649 </span>            :    *<span class="lineNum">     650 </span>            :    *  Result may not be in the range (first,last].  Use move instead.  Note<span class="lineNum">     651 </span>            :    *  that the start of the output range may overlap [first,last).<span class="lineNum">     652 </span>            :   */<a name="653"><span class="lineNum">     653 </span>            :   template&lt;typename _BI1, typename _BI2&gt;</a><span class="lineNum">     654 </span>            :     inline _BI2<span class="lineNum">     655 </span><span class="lineNoCov">          0 :     move_backward(_BI1 __first, _BI1 __last, _BI2 __result)</span><span class="lineNum">     656 </span>            :     {<span class="lineNum">     657 </span>            :       // concept requirements<span class="lineNum">     658 </span>            :       __glibcxx_function_requires(_BidirectionalIteratorConcept&lt;_BI1&gt;)<span class="lineNum">     659 </span>            :       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept&lt;_BI2&gt;)<span class="lineNum">     660 </span>            :       __glibcxx_function_requires(_ConvertibleConcept&lt;<span class="lineNum">     661 </span>            :             typename iterator_traits&lt;_BI1&gt;::value_type,<span class="lineNum">     662 </span>            :             typename iterator_traits&lt;_BI2&gt;::value_type&gt;)<span class="lineNum">     663 </span>            :       __glibcxx_requires_valid_range(__first, __last);<span class="lineNum">     664 </span>            : <span class="lineNum">     665 </span>            :       return std::__copy_move_backward_a2&lt;true&gt;(std::__miter_base(__first),<span class="lineNum">     666 </span>            :                                                 std::__miter_base(__last),<span class="lineNum">     667 </span><span class="lineNoCov">          0 :                                                 __result);</span><span class="lineNum">     668 </span>            :     }<span class="lineNum">     669 </span>            : <span class="lineNum">     670 </span>            : #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)<span class="lineNum">     671 </span>            : #else<span class="lineNum">     672 </span>            : #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)<span class="lineNum">     673 </span>            : #endif<span class="lineNum">     674 </span>            : <span class="lineNum">     675 </span>            :   template&lt;typename _ForwardIterator, typename _Tp&gt;<span class="lineNum">     676 </span>            :     inline typename<span class="lineNum">     677 </span>            :     __gnu_cxx::__enable_if&lt;!__is_scalar&lt;_Tp&gt;::__value, void&gt;::__type<span class="lineNum">     678 </span>            :     __fill_a(_ForwardIterator __first, _ForwardIterator __last,<span class="lineNum">     679 </span>            :              const _Tp&amp; __value)<span class="lineNum">     680 </span>            :     {<span class="lineNum">     681 </span>            :       for (; __first != __last; ++__first)<span class="lineNum">     682 </span>            :         *__first = __value;<span class="lineNum">     683 </span>            :     }<span class="lineNum">     684 </span>            :     <span class="lineNum">     685 </span>            :   template&lt;typename _ForwardIterator, typename _Tp&gt;<a name="686"><span class="lineNum">     686 </span>            :     inline typename</a><span class="lineNum">     687 </span>            :     __gnu_cxx::__enable_if&lt;__is_scalar&lt;_Tp&gt;::__value, void&gt;::__type<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     __fill_a(_ForwardIterator __first, _ForwardIterator __last,</span><span class="lineNum">     689 </span>            :              const _Tp&amp; __value)<span class="lineNum">     690 </span>            :     {<span class="lineNum">     691 </span><span class="lineNoCov">          0 :       const _Tp __tmp = __value;</span><span class="lineNum">     692 </span><span class="lineNoCov">          0 :       for (; __first != __last; ++__first)</span><span class="lineNum">     693 </span><span class="lineNoCov">          0 :         *__first = __tmp;</span><span class="lineNum">     694 </span><span class="lineNoCov">          0 :     }</span><span class="lineNum">     695 </span>            : <span class="lineNum">     696 </span>            :   // Specialization: for char types we can use memset.<span class="lineNum">     697 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     698 </span>            :     inline typename<span class="lineNum">     699 </span>            :     __gnu_cxx::__enable_if&lt;__is_byte&lt;_Tp&gt;::__value, void&gt;::__type<span class="lineNum">     700 </span>            :     __fill_a(_Tp* __first, _Tp* __last, const _Tp&amp; __c)<span class="lineNum">     701 </span>            :     {<span class="lineNum">     702 </span>            :       const _Tp __tmp = __c;<span class="lineNum">     703 </span>            :       __builtin_memset(__first, static_cast&lt;unsigned char&gt;(__tmp),<span class="lineNum">     704 </span>            :                        __last - __first);<span class="lineNum">     705 </span>            :     }<span class="lineNum">     706 </span>            : <span class="lineNum">     707 </span>            :   /**<span class="lineNum">     708 </span>            :    *  @brief Fills the range [first,last) with copies of value.<span class="lineNum">     709 </span>            :    *  @ingroup mutating_algorithms<span class="lineNum">     710 </span>            :    *  @param  __first  A forward iterator.<span class="lineNum">     711 </span>            :    *  @param  __last   A forward iterator.<span class="lineNum">     712 </span>            :    *  @param  __value  A reference-to-const of arbitrary type.<span class="lineNum">     713 </span>            :    *  @return   Nothing.<span class="lineNum">     714 </span>            :    *<span class="lineNum">     715 </span>            :    *  This function fills a range with copies of the same value.  For char<span class="lineNum">     716 </span>            :    *  types filling contiguous areas of memory, this becomes an inline call<span class="lineNum">     717 </span>            :    *  to @c memset or @c wmemset.<span class="lineNum">     718 </span>            :   */<a name="719"><span class="lineNum">     719 </span>            :   template&lt;typename _ForwardIterator, typename _Tp&gt;</a><span class="lineNum">     720 </span>            :     inline void<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp&amp; __value)</span><span class="lineNum">     722 </span>            :     {<span class="lineNum">     723 </span>            :       // concept requirements<span class="lineNum">     724 </span>            :       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept&lt;<span class="lineNum">     725 </span>            :                                   _ForwardIterator&gt;)<span class="lineNum">     726 </span>            :       __glibcxx_requires_valid_range(__first, __last);<span class="lineNum">     727 </span>            : <span class="lineNum">     728 </span><span class="lineNoCov">          0 :       std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),</span><span class="lineNum">     729 </span><span class="lineNoCov">          0 :                     __value);</span><span class="lineNum">     730 </span><span class="lineNoCov">          0 :     }</span><span class="lineNum">     731 </span>            : <span class="lineNum">     732 </span>            :   template&lt;typename _OutputIterator, typename _Size, typename _Tp&gt;<span class="lineNum">     733 </span>            :     inline typename<span class="lineNum">     734 </span>            :     __gnu_cxx::__enable_if&lt;!__is_scalar&lt;_Tp&gt;::__value, _OutputIterator&gt;::__type<span class="lineNum">     735 </span>            :     __fill_n_a(_OutputIterator __first, _Size __n, const _Tp&amp; __value)<span class="lineNum">     736 </span>            :     {<span class="lineNum">     737 </span>            :       for (__decltype(__n + 0) __niter = __n;<span class="lineNum">     738 </span>            :            __niter &gt; 0; --__niter, ++__first)<span class="lineNum">     739 </span>            :         *__first = __value;<span class="lineNum">     740 </span>            :       return __first;<span class="lineNum">     741 </span>            :     }<span class="lineNum">     742 </span>            : <span class="lineNum">     743 </span>            :   template&lt;typename _OutputIterator, typename _Size, typename _Tp&gt;<a name="744"><span class="lineNum">     744 </span>            :     inline typename</a><span class="lineNum">     745 </span>            :     __gnu_cxx::__enable_if&lt;__is_scalar&lt;_Tp&gt;::__value, _OutputIterator&gt;::__type<span class="lineNum">     746 </span><span class="lineCov">        178 :     __fill_n_a(_OutputIterator __first, _Size __n, const _Tp&amp; __value)</span><span class="lineNum">     747 </span>            :     {<span class="lineNum">     748 </span><span class="lineCov">        178 :       const _Tp __tmp = __value;</span><span class="lineNum">     749 </span><span class="lineCov">  283692482 :       for (__decltype(__n + 0) __niter = __n;</span><span class="lineNum">     750 </span>            :            __niter &gt; 0; --__niter, ++__first)<span class="lineNum">     751 </span><span class="lineCov">  283692304 :         *__first = __tmp;</span><span class="lineNum">     752 </span><span class="lineCov">        178 :       return __first;</span><span class="lineNum">     753 </span>            :     }<span class="lineNum">     754 </span>            : <span class="lineNum">     755 </span>            :   template&lt;typename _Size, typename _Tp&gt;<span class="lineNum">     756 </span>            :     inline typename<span class="lineNum">     757 </span>            :     __gnu_cxx::__enable_if&lt;__is_byte&lt;_Tp&gt;::__value, _Tp*&gt;::__type<span class="lineNum">     758 </span>            :     __fill_n_a(_Tp* __first, _Size __n, const _Tp&amp; __c)<span class="lineNum">     759 </span>            :     {<span class="lineNum">     760 </span>            :       std::__fill_a(__first, __first + __n, __c);<span class="lineNum">     761 </span>            :       return __first + __n;<span class="lineNum">     762 </span>            :     }<span class="lineNum">     763 </span>            : <span class="lineNum">     764 </span>            :   /**<span class="lineNum">     765 </span>            :    *  @brief Fills the range [first,first+n) with copies of value.<span class="lineNum">     766 </span>            :    *  @ingroup mutating_algorithms<span class="lineNum">     767 </span>            :    *  @param  __first  An output iterator.<span class="lineNum">     768 </span>            :    *  @param  __n      The count of copies to perform.<span class="lineNum">     769 </span>            :    *  @param  __value  A reference-to-const of arbitrary type.<span class="lineNum">     770 </span>            :    *  @return   The iterator at first+n.<span class="lineNum">     771 </span>            :    *<span class="lineNum">     772 </span>            :    *  This function fills a range with copies of the same value.  For char<span class="lineNum">     773 </span>            :    *  types filling contiguous areas of memory, this becomes an inline call<span class="lineNum">     774 </span>            :    *  to @c memset or @ wmemset.<span class="lineNum">     775 </span>            :    *<span class="lineNum">     776 </span>            :    *  _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     777 </span>            :    *  DR 865. More algorithms that throw away information<span class="lineNum">     778 </span>            :   */<a name="779"><span class="lineNum">     779 </span>            :   template&lt;typename _OI, typename _Size, typename _Tp&gt;</a><span class="lineNum">     780 </span>            :     inline _OI<span class="lineNum">     781 </span><span class="lineCov">        178 :     fill_n(_OI __first, _Size __n, const _Tp&amp; __value)</span><span class="lineNum">     782 </span>            :     {<span class="lineNum">     783 </span>            :       // concept requirements<span class="lineNum">     784 </span>            :       __glibcxx_function_requires(_OutputIteratorConcept&lt;_OI, _Tp&gt;)<span class="lineNum">     785 </span>            : <span class="lineNum">     786 </span><span class="lineCov">        178 :       return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));</span><span class="lineNum">     787 </span>            :     }<span class="lineNum">     788 </span>            : <span class="lineNum">     789 </span>            :   template&lt;bool _BoolType&gt;<span class="lineNum">     790 </span>            :     struct __equal<span class="lineNum">     791 </span>            :     {<span class="lineNum">     792 </span>            :       template&lt;typename _II1, typename _II2&gt;<span class="lineNum">     793 </span>            :         static bool<span class="lineNum">     794 </span>            :         equal(_II1 __first1, _II1 __last1, _II2 __first2)<span class="lineNum">     795 </span>            :         {<span class="lineNum">     796 </span>            :           for (; __first1 != __last1; ++__first1, ++__first2)<span class="lineNum">     797 </span>            :             if (!(*__first1 == *__first2))<span class="lineNum">     798 </span>            :               return false;<span class="lineNum">     799 </span>            :           return true;<span class="lineNum">     800 </span>            :         }<span class="lineNum">     801 </span>            :     };<span class="lineNum">     802 </span>            : <span class="lineNum">     803 </span>            :   template&lt;&gt;<span class="lineNum">     804 </span>            :     struct __equal&lt;true&gt;<span class="lineNum">     805 </span>            :     {<span class="lineNum">     806 </span>            :       template&lt;typename _Tp&gt;<span class="lineNum">     807 </span>            :         static bool<span class="lineNum">     808 </span>            :         equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)<span class="lineNum">     809 </span>            :         {<span class="lineNum">     810 </span>            :           return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)<span class="lineNum">     811 </span>            :                                    * (__last1 - __first1));<span class="lineNum">     812 </span>            :         }<span class="lineNum">     813 </span>            :     };<span class="lineNum">     814 </span>            : <span class="lineNum">     815 </span>            :   template&lt;typename _II1, typename _II2&gt;<span class="lineNum">     816 </span>            :     inline bool<span class="lineNum">     817 </span>            :     __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)<span class="lineNum">     818 </span>            :     {<span class="lineNum">     819 </span>            :       typedef typename iterator_traits&lt;_II1&gt;::value_type _ValueType1;<span class="lineNum">     820 </span>            :       typedef typename iterator_traits&lt;_II2&gt;::value_type _ValueType2;<span class="lineNum">     821 </span>            :       const bool __simple = ((__is_integer&lt;_ValueType1&gt;::__value<span class="lineNum">     822 </span>            :                               || __is_pointer&lt;_ValueType1&gt;::__value)<span class="lineNum">     823 </span>            :                              &amp;&amp; __is_pointer&lt;_II1&gt;::__value<span class="lineNum">     824 </span>            :                              &amp;&amp; __is_pointer&lt;_II2&gt;::__value<span class="lineNum">     825 </span>            :                              &amp;&amp; __are_same&lt;_ValueType1, _ValueType2&gt;::__value);<span class="lineNum">     826 </span>            : <span class="lineNum">     827 </span>            :       return std::__equal&lt;__simple&gt;::equal(__first1, __last1, __first2);<span class="lineNum">     828 </span>            :     }<span class="lineNum">     829 </span>            : <span class="lineNum">     830 </span>            : <span class="lineNum">     831 </span>            :   template&lt;typename, typename&gt;<span class="lineNum">     832 </span>            :     struct __lc_rai<span class="lineNum">     833 </span>            :     {<span class="lineNum">     834 </span>            :       template&lt;typename _II1, typename _II2&gt;<span class="lineNum">     835 </span>            :         static _II1<span class="lineNum">     836 </span>            :         __newlast1(_II1, _II1 __last1, _II2, _II2)<span class="lineNum">     837 </span>            :         { return __last1; }<span class="lineNum">     838 </span>            : <span class="lineNum">     839 </span>            :       template&lt;typename _II&gt;<span class="lineNum">     840 </span>            :         static bool<span class="lineNum">     841 </span>            :         __cnd2(_II __first, _II __last)<span class="lineNum">     842 </span>            :         { return __first != __last; }<span class="lineNum">     843 </span>            :     };<span class="lineNum">     844 </span>            : <span class="lineNum">     845 </span>            :   template&lt;&gt;<span class="lineNum">     846 </span>            :     struct __lc_rai&lt;random_access_iterator_tag, random_access_iterator_tag&gt;<span class="lineNum">     847 </span>            :     {<span class="lineNum">     848 </span>            :       template&lt;typename _RAI1, typename _RAI2&gt;<span class="lineNum">     849 </span>            :         static _RAI1<span class="lineNum">     850 </span>            :         __newlast1(_RAI1 __first1, _RAI1 __last1,<span class="lineNum">     851 </span>            :                    _RAI2 __first2, _RAI2 __last2)<span class="lineNum">     852 </span>            :         {<span class="lineNum">     853 </span>            :           const typename iterator_traits&lt;_RAI1&gt;::difference_type<span class="lineNum">     854 </span>            :             __diff1 = __last1 - __first1;<span class="lineNum">     855 </span>            :           const typename iterator_traits&lt;_RAI2&gt;::difference_type<span class="lineNum">     856 </span>            :             __diff2 = __last2 - __first2;<span class="lineNum">     857 </span>            :           return __diff2 &lt; __diff1 ? __first1 + __diff2 : __last1;<span class="lineNum">     858 </span>            :         }<span class="lineNum">     859 </span>            : <span class="lineNum">     860 </span>            :       template&lt;typename _RAI&gt;<span class="lineNum">     861 </span>            :         static bool<span class="lineNum">     862 </span>            :         __cnd2(_RAI, _RAI)<span class="lineNum">     863 </span>            :         { return true; }<span class="lineNum">     864 </span>            :     };<span class="lineNum">     865 </span>            : <span class="lineNum">     866 </span>            :   template&lt;bool _BoolType&gt;<span class="lineNum">     867 </span>            :     struct __lexicographical_compare<span class="lineNum">     868 </span>            :     {<span class="lineNum">     869 </span>            :       template&lt;typename _II1, typename _II2&gt;<span class="lineNum">     870 </span>            :         static bool __lc(_II1, _II1, _II2, _II2);<span class="lineNum">     871 </span>            :     };<span class="lineNum">     872 </span>            : <span class="lineNum">     873 </span>            :   template&lt;bool _BoolType&gt;<span class="lineNum">     874 </span>            :     template&lt;typename _II1, typename _II2&gt;<span class="lineNum">     875 </span>            :       bool<span class="lineNum">     876 </span>            :       __lexicographical_compare&lt;_BoolType&gt;::<span class="lineNum">     877 </span>            :       __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)<span class="lineNum">     878 </span>            :       {<span class="lineNum">     879 </span>            :         typedef typename iterator_traits&lt;_II1&gt;::iterator_category _Category1;<span class="lineNum">     880 </span>            :         typedef typename iterator_traits&lt;_II2&gt;::iterator_category _Category2;<span class="lineNum">     881 </span>            :         typedef std::__lc_rai&lt;_Category1, _Category2&gt;     __rai_type;<span class="lineNum">     882 </span>            :         <span class="lineNum">     883 </span>            :         __last1 = __rai_type::__newlast1(__first1, __last1,<span class="lineNum">     884 </span>            :                                          __first2, __last2);<span class="lineNum">     885 </span>            :         for (; __first1 != __last1 &amp;&amp; __rai_type::__cnd2(__first2, __last2);<span class="lineNum">     886 </span>            :              ++__first1, ++__first2)<span class="lineNum">     887 </span>            :           {<span class="lineNum">     888 </span>            :             if (*__first1 &lt; *__first2)<span class="lineNum">     889 </span>            :               return true;<span class="lineNum">     890 </span>            :             if (*__first2 &lt; *__first1)<span class="lineNum">     891 </span>            :               return false;<span class="lineNum">     892 </span>            :           }<span class="lineNum">     893 </span>            :         return __first1 == __last1 &amp;&amp; __first2 != __last2;<span class="lineNum">     894 </span>            :       }<span class="lineNum">     895 </span>            : <span class="lineNum">     896 </span>            :   template&lt;&gt;<span class="lineNum">     897 </span>            :     struct __lexicographical_compare&lt;true&gt;<span class="lineNum">     898 </span>            :     {<span class="lineNum">     899 </span>            :       template&lt;typename _Tp, typename _Up&gt;<span class="lineNum">     900 </span>            :         static bool<span class="lineNum">     901 </span>            :         __lc(const _Tp* __first1, const _Tp* __last1,<span class="lineNum">     902 </span>            :              const _Up* __first2, const _Up* __last2)<span class="lineNum">     903 </span>            :         {<span class="lineNum">     904 </span>            :           const size_t __len1 = __last1 - __first1;<span class="lineNum">     905 </span>            :           const size_t __len2 = __last2 - __first2;<span class="lineNum">     906 </span>            :           const int __result = __builtin_memcmp(__first1, __first2,<span class="lineNum">     907 </span>            :                                                 std::min(__len1, __len2));<span class="lineNum">     908 </span>            :           return __result != 0 ? __result &lt; 0 : __len1 &lt; __len2;<span class="lineNum">     909 </span>            :         }<span class="lineNum">     910 </span>            :     };<span class="lineNum">     911 </span>            : <span class="lineNum">     912 </span>            :   template&lt;typename _II1, typename _II2&gt;<span class="lineNum">     913 </span>            :     inline bool<span class="lineNum">     914 </span>            :     __lexicographical_compare_aux(_II1 __first1, _II1 __last1,<span class="lineNum">     915 </span>            :                                   _II2 __first2, _II2 __last2)<span class="lineNum">     916 </span>            :     {<span class="lineNum">     917 </span>            :       typedef typename iterator_traits&lt;_II1&gt;::value_type _ValueType1;<span class="lineNum">     918 </span>            :       typedef typename iterator_traits&lt;_II2&gt;::value_type _ValueType2;<span class="lineNum">     919 </span>            :       const bool __simple =<span class="lineNum">     920 </span>            :         (__is_byte&lt;_ValueType1&gt;::__value &amp;&amp; __is_byte&lt;_ValueType2&gt;::__value<span class="lineNum">     921 </span>            :          &amp;&amp; !__gnu_cxx::__numeric_traits&lt;_ValueType1&gt;::__is_signed<span class="lineNum">     922 </span>            :          &amp;&amp; !__gnu_cxx::__numeric_traits&lt;_ValueType2&gt;::__is_signed<span class="lineNum">     923 </span>            :          &amp;&amp; __is_pointer&lt;_II1&gt;::__value<span class="lineNum">     924 </span>            :          &amp;&amp; __is_pointer&lt;_II2&gt;::__value);<span class="lineNum">     925 </span>            : <span class="lineNum">     926 </span>            :       return std::__lexicographical_compare&lt;__simple&gt;::__lc(__first1, __last1,<span class="lineNum">     927 </span>            :                                                             __first2, __last2);<span class="lineNum">     928 </span>            :     }<span class="lineNum">     929 </span>            : <span class="lineNum">     930 </span>            :   /**<span class="lineNum">     931 </span>            :    *  @brief Finds the first position in which @a val could be inserted<span class="lineNum">     932 </span>            :    *         without changing the ordering.<span class="lineNum">     933 </span>            :    *  @param  __first   An iterator.<span class="lineNum">     934 </span>            :    *  @param  __last    Another iterator.<span class="lineNum">     935 </span>            :    *  @param  __val     The search term.<span class="lineNum">     936 </span>            :    *  @return         An iterator pointing to the first element &lt;em&gt;not less<span class="lineNum">     937 </span>            :    *                  than&lt;/em&gt; @a val, or end() if every element is less than <span class="lineNum">     938 </span>            :    *                  @a val.<span class="lineNum">     939 </span>            :    *  @ingroup binary_search_algorithms<span class="lineNum">     940 </span>            :   */<span class="lineNum">     941 </span>            :   template&lt;typename _ForwardIterator, typename _Tp&gt;<span class="lineNum">     942 </span>            :     _ForwardIterator<span class="lineNum">     943 </span>            :     lower_bound(_ForwardIterator __first, _ForwardIterator __last,<span class="lineNum">     944 </span>            :                 const _Tp&amp; __val)<span class="lineNum">     945 </span>            :     {<span class="lineNum">     946 </span>            : #ifdef _GLIBCXX_CONCEPT_CHECKS<span class="lineNum">     947 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type<span class="lineNum">     948 </span>            :         _ValueType;<span class="lineNum">     949 </span>            : #endif<span class="lineNum">     950 </span>            :       typedef typename iterator_traits&lt;_ForwardIterator&gt;::difference_type<span class="lineNum">     951 </span>            :         _DistanceType;<span class="lineNum">     952 </span>            : <span class="lineNum">     953 </span>            :       // concept requirements<span class="lineNum">     954 </span>            :       __glibcxx_function_requires(_ForwardIteratorConcept&lt;_ForwardIterator&gt;)<span class="lineNum">     955 </span>            :       __glibcxx_function_requires(_LessThanOpConcept&lt;_ValueType, _Tp&gt;)<span class="lineNum">     956 </span>            :       __glibcxx_requires_partitioned_lower(__first, __last, __val);<span class="lineNum">     957 </span>            : <span class="lineNum">     958 </span>            :       _DistanceType __len = std::distance(__first, __last);<span class="lineNum">     959 </span>            : <span class="lineNum">     960 </span>            :       while (__len &gt; 0)<span class="lineNum">     961 </span>            :         {<span class="lineNum">     962 </span>            :           _DistanceType __half = __len &gt;&gt; 1;<span class="lineNum">     963 </span>            :           _ForwardIterator __middle = __first;<span class="lineNum">     964 </span>            :           std::advance(__middle, __half);<span class="lineNum">     965 </span>            :           if (*__middle &lt; __val)<span class="lineNum">     966 </span>            :             {<span class="lineNum">     967 </span>            :               __first = __middle;<span class="lineNum">     968 </span>            :               ++__first;<span class="lineNum">     969 </span>            :               __len = __len - __half - 1;<span class="lineNum">     970 </span>            :             }<span class="lineNum">     971 </span>            :           else<span class="lineNum">     972 </span>            :             __len = __half;<span class="lineNum">     973 </span>            :         }<span class="lineNum">     974 </span>            :       return __first;<span class="lineNum">     975 </span>            :     }<span class="lineNum">     976 </span>            : <span class="lineNum">     977 </span>            :   /// This is a helper function for the sort routines and for random.tcc.<span class="lineNum">     978 </span>            :   //  Precondition: __n &gt; 0.<span class="lineNum">     979 </span>            :   inline _GLIBCXX_CONSTEXPR int<span class="lineNum">     980 </span>            :   __lg(int __n)<span class="lineNum">     981 </span>            :   { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }<span class="lineNum">     982 </span>            : <span class="lineNum">     983 </span>            :   inline _GLIBCXX_CONSTEXPR unsigned<span class="lineNum">     984 </span>            :   __lg(unsigned __n)<span class="lineNum">     985 </span>            :   { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }<span class="lineNum">     986 </span>            : <span class="lineNum">     987 </span>            :   inline _GLIBCXX_CONSTEXPR long<span class="lineNum">     988 </span>            :   __lg(long __n)<span class="lineNum">     989 </span>            :   { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }<span class="lineNum">     990 </span>            : <span class="lineNum">     991 </span>            :   inline _GLIBCXX_CONSTEXPR unsigned long<span class="lineNum">     992 </span>            :   __lg(unsigned long __n)<span class="lineNum">     993 </span>            :   { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }<span class="lineNum">     994 </span>            : <span class="lineNum">     995 </span>            :   inline _GLIBCXX_CONSTEXPR long long<span class="lineNum">     996 </span>            :   __lg(long long __n)<span class="lineNum">     997 </span>            :   { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }<span class="lineNum">     998 </span>            : <span class="lineNum">     999 </span>            :   inline _GLIBCXX_CONSTEXPR unsigned long long<span class="lineNum">    1000 </span>            :   __lg(unsigned long long __n)<span class="lineNum">    1001 </span>            :   { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }<span class="lineNum">    1002 </span>            : <span class="lineNum">    1003 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">    1004 </span>            : <span class="lineNum">    1005 </span>            : _GLIBCXX_BEGIN_NAMESPACE_ALGO<span class="lineNum">    1006 </span>            : <span class="lineNum">    1007 </span>            :   /**<span class="lineNum">    1008 </span>            :    *  @brief Tests a range for element-wise equality.<span class="lineNum">    1009 </span>            :    *  @ingroup non_mutating_algorithms<span class="lineNum">    1010 </span>            :    *  @param  __first1  An input iterator.<span class="lineNum">    1011 </span>            :    *  @param  __last1   An input iterator.<span class="lineNum">    1012 </span>            :    *  @param  __first2  An input iterator.<span class="lineNum">    1013 </span>            :    *  @return   A boolean true or false.<span class="lineNum">    1014 </span>            :    *<span class="lineNum">    1015 </span>            :    *  This compares the elements of two ranges using @c == and returns true or<span class="lineNum">    1016 </span>            :    *  false depending on whether all of the corresponding elements of the<span class="lineNum">    1017 </span>            :    *  ranges are equal.<span class="lineNum">    1018 </span>            :   */<span class="lineNum">    1019 </span>            :   template&lt;typename _II1, typename _II2&gt;<span class="lineNum">    1020 </span>            :     inline bool<span class="lineNum">    1021 </span>            :     equal(_II1 __first1, _II1 __last1, _II2 __first2)<span class="lineNum">    1022 </span>            :     {<span class="lineNum">    1023 </span>            :       // concept requirements<span class="lineNum">    1024 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_II1&gt;)<span class="lineNum">    1025 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_II2&gt;)<span class="lineNum">    1026 </span>            :       __glibcxx_function_requires(_EqualOpConcept&lt;<span class="lineNum">    1027 </span>            :             typename iterator_traits&lt;_II1&gt;::value_type,<span class="lineNum">    1028 </span>            :             typename iterator_traits&lt;_II2&gt;::value_type&gt;)<span class="lineNum">    1029 </span>            :       __glibcxx_requires_valid_range(__first1, __last1);<span class="lineNum">    1030 </span>            : <span class="lineNum">    1031 </span>            :       return std::__equal_aux(std::__niter_base(__first1),<span class="lineNum">    1032 </span>            :                               std::__niter_base(__last1),<span class="lineNum">    1033 </span>            :                               std::__niter_base(__first2));<span class="lineNum">    1034 </span>            :     }<span class="lineNum">    1035 </span>            : <span class="lineNum">    1036 </span>            :   /**<span class="lineNum">    1037 </span>            :    *  @brief Tests a range for element-wise equality.<span class="lineNum">    1038 </span>            :    *  @ingroup non_mutating_algorithms<span class="lineNum">    1039 </span>            :    *  @param  __first1  An input iterator.<span class="lineNum">    1040 </span>            :    *  @param  __last1   An input iterator.<span class="lineNum">    1041 </span>            :    *  @param  __first2  An input iterator.<span class="lineNum">    1042 </span>            :    *  @param __binary_pred A binary predicate @link functors<span class="lineNum">    1043 </span>            :    *                  functor@endlink.<span class="lineNum">    1044 </span>            :    *  @return         A boolean true or false.<span class="lineNum">    1045 </span>            :    *<span class="lineNum">    1046 </span>            :    *  This compares the elements of two ranges using the binary_pred<span class="lineNum">    1047 </span>            :    *  parameter, and returns true or<span class="lineNum">    1048 </span>            :    *  false depending on whether all of the corresponding elements of the<span class="lineNum">    1049 </span>            :    *  ranges are equal.<span class="lineNum">    1050 </span>            :   */<span class="lineNum">    1051 </span>            :   template&lt;typename _IIter1, typename _IIter2, typename _BinaryPredicate&gt;<span class="lineNum">    1052 </span>            :     inline bool<span class="lineNum">    1053 </span>            :     equal(_IIter1 __first1, _IIter1 __last1,<span class="lineNum">    1054 </span>            :           _IIter2 __first2, _BinaryPredicate __binary_pred)<span class="lineNum">    1055 </span>            :     {<span class="lineNum">    1056 </span>            :       // concept requirements<span class="lineNum">    1057 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_IIter1&gt;)<span class="lineNum">    1058 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_IIter2&gt;)<span class="lineNum">    1059 </span>            :       __glibcxx_requires_valid_range(__first1, __last1);<span class="lineNum">    1060 </span>            : <span class="lineNum">    1061 </span>            :       for (; __first1 != __last1; ++__first1, ++__first2)<span class="lineNum">    1062 </span>            :         if (!bool(__binary_pred(*__first1, *__first2)))<span class="lineNum">    1063 </span>            :           return false;<span class="lineNum">    1064 </span>            :       return true;<span class="lineNum">    1065 </span>            :     }<span class="lineNum">    1066 </span>            : <span class="lineNum">    1067 </span>            :   /**<span class="lineNum">    1068 </span>            :    *  @brief Performs @b dictionary comparison on ranges.<span class="lineNum">    1069 </span>            :    *  @ingroup sorting_algorithms<span class="lineNum">    1070 </span>            :    *  @param  __first1  An input iterator.<span class="lineNum">    1071 </span>            :    *  @param  __last1   An input iterator.<span class="lineNum">    1072 </span>            :    *  @param  __first2  An input iterator.<span class="lineNum">    1073 </span>            :    *  @param  __last2   An input iterator.<span class="lineNum">    1074 </span>            :    *  @return   A boolean true or false.<span class="lineNum">    1075 </span>            :    *<span class="lineNum">    1076 </span>            :    *  &lt;em&gt;Returns true if the sequence of elements defined by the range<span class="lineNum">    1077 </span>            :    *  [first1,last1) is lexicographically less than the sequence of elements<span class="lineNum">    1078 </span>            :    *  defined by the range [first2,last2).  Returns false otherwise.&lt;/em&gt;<span class="lineNum">    1079 </span>            :    *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,<span class="lineNum">    1080 </span>            :    *  then this is an inline call to @c memcmp.<span class="lineNum">    1081 </span>            :   */<span class="lineNum">    1082 </span>            :   template&lt;typename _II1, typename _II2&gt;<span class="lineNum">    1083 </span>            :     inline bool<span class="lineNum">    1084 </span>            :     lexicographical_compare(_II1 __first1, _II1 __last1,<span class="lineNum">    1085 </span>            :                             _II2 __first2, _II2 __last2)<span class="lineNum">    1086 </span>            :     {<span class="lineNum">    1087 </span>            : #ifdef _GLIBCXX_CONCEPT_CHECKS<span class="lineNum">    1088 </span>            :       // concept requirements<span class="lineNum">    1089 </span>            :       typedef typename iterator_traits&lt;_II1&gt;::value_type _ValueType1;<span class="lineNum">    1090 </span>            :       typedef typename iterator_traits&lt;_II2&gt;::value_type _ValueType2;<span class="lineNum">    1091 </span>            : #endif<span class="lineNum">    1092 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_II1&gt;)<span class="lineNum">    1093 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_II2&gt;)<span class="lineNum">    1094 </span>            :       __glibcxx_function_requires(_LessThanOpConcept&lt;_ValueType1, _ValueType2&gt;)<span class="lineNum">    1095 </span>            :       __glibcxx_function_requires(_LessThanOpConcept&lt;_ValueType2, _ValueType1&gt;)<span class="lineNum">    1096 </span>            :       __glibcxx_requires_valid_range(__first1, __last1);<span class="lineNum">    1097 </span>            :       __glibcxx_requires_valid_range(__first2, __last2);<span class="lineNum">    1098 </span>            : <span class="lineNum">    1099 </span>            :       return std::__lexicographical_compare_aux(std::__niter_base(__first1),<span class="lineNum">    1100 </span>            :                                                 std::__niter_base(__last1),<span class="lineNum">    1101 </span>            :                                                 std::__niter_base(__first2),<span class="lineNum">    1102 </span>            :                                                 std::__niter_base(__last2));<span class="lineNum">    1103 </span>            :     }<span class="lineNum">    1104 </span>            : <span class="lineNum">    1105 </span>            :   /**<span class="lineNum">    1106 </span>            :    *  @brief Performs @b dictionary comparison on ranges.<span class="lineNum">    1107 </span>            :    *  @ingroup sorting_algorithms<span class="lineNum">    1108 </span>            :    *  @param  __first1  An input iterator.<span class="lineNum">    1109 </span>            :    *  @param  __last1   An input iterator.<span class="lineNum">    1110 </span>            :    *  @param  __first2  An input iterator.<span class="lineNum">    1111 </span>            :    *  @param  __last2   An input iterator.<span class="lineNum">    1112 </span>            :    *  @param  __comp  A @link comparison_functors comparison functor@endlink.<span class="lineNum">    1113 </span>            :    *  @return   A boolean true or false.<span class="lineNum">    1114 </span>            :    *<span class="lineNum">    1115 </span>            :    *  The same as the four-parameter @c lexicographical_compare, but uses the<span class="lineNum">    1116 </span>            :    *  comp parameter instead of @c &lt;.<span class="lineNum">    1117 </span>            :   */<span class="lineNum">    1118 </span>            :   template&lt;typename _II1, typename _II2, typename _Compare&gt;<span class="lineNum">    1119 </span>            :     bool<span class="lineNum">    1120 </span>            :     lexicographical_compare(_II1 __first1, _II1 __last1,<span class="lineNum">    1121 </span>            :                             _II2 __first2, _II2 __last2, _Compare __comp)<span class="lineNum">    1122 </span>            :     {<span class="lineNum">    1123 </span>            :       typedef typename iterator_traits&lt;_II1&gt;::iterator_category _Category1;<span class="lineNum">    1124 </span>            :       typedef typename iterator_traits&lt;_II2&gt;::iterator_category _Category2;<span class="lineNum">    1125 </span>            :       typedef std::__lc_rai&lt;_Category1, _Category2&gt;       __rai_type;<span class="lineNum">    1126 </span>            : <span class="lineNum">    1127 </span>            :       // concept requirements<span class="lineNum">    1128 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_II1&gt;)<span class="lineNum">    1129 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_II2&gt;)<span class="lineNum">    1130 </span>            :       __glibcxx_requires_valid_range(__first1, __last1);<span class="lineNum">    1131 </span>            :       __glibcxx_requires_valid_range(__first2, __last2);<span class="lineNum">    1132 </span>            : <span class="lineNum">    1133 </span>            :       __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);<span class="lineNum">    1134 </span>            :       for (; __first1 != __last1 &amp;&amp; __rai_type::__cnd2(__first2, __last2);<span class="lineNum">    1135 </span>            :            ++__first1, ++__first2)<span class="lineNum">    1136 </span>            :         {<span class="lineNum">    1137 </span>            :           if (__comp(*__first1, *__first2))<span class="lineNum">    1138 </span>            :             return true;<span class="lineNum">    1139 </span>            :           if (__comp(*__first2, *__first1))<span class="lineNum">    1140 </span>            :             return false;<span class="lineNum">    1141 </span>            :         }<span class="lineNum">    1142 </span>            :       return __first1 == __last1 &amp;&amp; __first2 != __last2;<span class="lineNum">    1143 </span>            :     }<span class="lineNum">    1144 </span>            : <span class="lineNum">    1145 </span>            :   /**<span class="lineNum">    1146 </span>            :    *  @brief Finds the places in ranges which don't match.<span class="lineNum">    1147 </span>            :    *  @ingroup non_mutating_algorithms<span class="lineNum">    1148 </span>            :    *  @param  __first1  An input iterator.<span class="lineNum">    1149 </span>            :    *  @param  __last1   An input iterator.<span class="lineNum">    1150 </span>            :    *  @param  __first2  An input iterator.<span class="lineNum">    1151 </span>            :    *  @return   A pair of iterators pointing to the first mismatch.<span class="lineNum">    1152 </span>            :    *<span class="lineNum">    1153 </span>            :    *  This compares the elements of two ranges using @c == and returns a pair<span class="lineNum">    1154 </span>            :    *  of iterators.  The first iterator points into the first range, the<span class="lineNum">    1155 </span>            :    *  second iterator points into the second range, and the elements pointed<span class="lineNum">    1156 </span>            :    *  to by the iterators are not equal.<span class="lineNum">    1157 </span>            :   */<span class="lineNum">    1158 </span>            :   template&lt;typename _InputIterator1, typename _InputIterator2&gt;<span class="lineNum">    1159 </span>            :     pair&lt;_InputIterator1, _InputIterator2&gt;<span class="lineNum">    1160 </span>            :     mismatch(_InputIterator1 __first1, _InputIterator1 __last1,<span class="lineNum">    1161 </span>            :              _InputIterator2 __first2)<span class="lineNum">    1162 </span>            :     {<span class="lineNum">    1163 </span>            :       // concept requirements<span class="lineNum">    1164 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator1&gt;)<span class="lineNum">    1165 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator2&gt;)<span class="lineNum">    1166 </span>            :       __glibcxx_function_requires(_EqualOpConcept&lt;<span class="lineNum">    1167 </span>            :             typename iterator_traits&lt;_InputIterator1&gt;::value_type,<span class="lineNum">    1168 </span>            :             typename iterator_traits&lt;_InputIterator2&gt;::value_type&gt;)<span class="lineNum">    1169 </span>            :       __glibcxx_requires_valid_range(__first1, __last1);<span class="lineNum">    1170 </span>            : <span class="lineNum">    1171 </span>            :       while (__first1 != __last1 &amp;&amp; *__first1 == *__first2)<span class="lineNum">    1172 </span>            :         {<span class="lineNum">    1173 </span>            :           ++__first1;<span class="lineNum">    1174 </span>            :           ++__first2;<span class="lineNum">    1175 </span>            :         }<span class="lineNum">    1176 </span>            :       return pair&lt;_InputIterator1, _InputIterator2&gt;(__first1, __first2);<span class="lineNum">    1177 </span>            :     }<span class="lineNum">    1178 </span>            : <span class="lineNum">    1179 </span>            :   /**<span class="lineNum">    1180 </span>            :    *  @brief Finds the places in ranges which don't match.<span class="lineNum">    1181 </span>            :    *  @ingroup non_mutating_algorithms<span class="lineNum">    1182 </span>            :    *  @param  __first1  An input iterator.<span class="lineNum">    1183 </span>            :    *  @param  __last1   An input iterator.<span class="lineNum">    1184 </span>            :    *  @param  __first2  An input iterator.<span class="lineNum">    1185 </span>            :    *  @param __binary_pred A binary predicate @link functors<span class="lineNum">    1186 </span>            :    *         functor@endlink.<span class="lineNum">    1187 </span>            :    *  @return   A pair of iterators pointing to the first mismatch.<span class="lineNum">    1188 </span>            :    *<span class="lineNum">    1189 </span>            :    *  This compares the elements of two ranges using the binary_pred<span class="lineNum">    1190 </span>            :    *  parameter, and returns a pair<span class="lineNum">    1191 </span>            :    *  of iterators.  The first iterator points into the first range, the<span class="lineNum">    1192 </span>            :    *  second iterator points into the second range, and the elements pointed<span class="lineNum">    1193 </span>            :    *  to by the iterators are not equal.<span class="lineNum">    1194 </span>            :   */<span class="lineNum">    1195 </span>            :   template&lt;typename _InputIterator1, typename _InputIterator2,<span class="lineNum">    1196 </span>            :            typename _BinaryPredicate&gt;<span class="lineNum">    1197 </span>            :     pair&lt;_InputIterator1, _InputIterator2&gt;<span class="lineNum">    1198 </span>            :     mismatch(_InputIterator1 __first1, _InputIterator1 __last1,<span class="lineNum">    1199 </span>            :              _InputIterator2 __first2, _BinaryPredicate __binary_pred)<span class="lineNum">    1200 </span>            :     {<span class="lineNum">    1201 </span>            :       // concept requirements<span class="lineNum">    1202 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator1&gt;)<span class="lineNum">    1203 </span>            :       __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator2&gt;)<span class="lineNum">    1204 </span>            :       __glibcxx_requires_valid_range(__first1, __last1);<span class="lineNum">    1205 </span>            : <span class="lineNum">    1206 </span>            :       while (__first1 != __last1 &amp;&amp; bool(__binary_pred(*__first1, *__first2)))<span class="lineNum">    1207 </span>            :         {<span class="lineNum">    1208 </span>            :           ++__first1;<span class="lineNum">    1209 </span>            :           ++__first2;<span class="lineNum">    1210 </span>            :         }<span class="lineNum">    1211 </span>            :       return pair&lt;_InputIterator1, _InputIterator2&gt;(__first1, __first2);<span class="lineNum">    1212 </span>            :     }<span class="lineNum">    1213 </span>            : <span class="lineNum">    1214 </span>            : _GLIBCXX_END_NAMESPACE_ALGO<span class="lineNum">    1215 </span>            : } // namespace std<span class="lineNum">    1216 </span>            : <span class="lineNum">    1217 </span>            : // NB: This file is included within many other C++ includes, as a way<span class="lineNum">    1218 </span>            : // of getting the base algorithms. So, make sure that parallel bits<span class="lineNum">    1219 </span>            : // come in too if requested. <span class="lineNum">    1220 </span>            : #ifdef _GLIBCXX_PARALLEL<span class="lineNum">    1221 </span>            : # include &lt;parallel/algobase.h&gt;<span class="lineNum">    1222 </span>            : #endif<span class="lineNum">    1223 </span>            : <span class="lineNum">    1224 </span>            : #endif</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_algobase.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_algobase.h<span style="font-size: 80%;"> (<a href="stl_algobase.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">31</td>            <td class="headerCovTableEntry">52</td>            <td class="headerCovTableEntryLo">59.6 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">26</td>            <td class="headerCovTableEntryLo">53.8 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="stl_algobase.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#366">_ZNSt11__copy_moveILb1ELb1ESt26random_access_iterator_tagE8__copy_mIdEEPT_PKS3_S6_S4_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#561">_ZNSt20__copy_move_backwardILb1ELb1ESt26random_access_iterator_tagE13__copy_move_bIdEEPT_PKS3_S6_S4_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#744">_ZSt10__fill_n_aIPdmdEN9__gnu_cxx11__enable_ifIXsrSt11__is_scalarIT1_E7__valueET_E6__typeES6_T0_RKS4_</a></td>              <td class="coverFnHi">78</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#744">_ZSt10__fill_n_aIPimiEN9__gnu_cxx11__enable_ifIXsrSt11__is_scalarIT1_E7__valueET_E6__typeES6_T0_RKS4_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#286">_ZSt12__miter_baseIPdENSt11_Miter_baseIT_E13iterator_typeES2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#286">_ZSt12__miter_baseISt13move_iteratorIPdEENSt11_Miter_baseIT_E13iterator_typeES4_</a></td>              <td class="coverFnHi">94</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#275">_ZSt12__niter_baseIN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEEENSt11_Niter_baseIT_E13iterator_typeES8_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#275">_ZSt12__niter_baseIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEENSt11_Niter_baseIT_E13iterator_typeES8_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#275">_ZSt12__niter_baseIPdENSt11_Niter_baseIT_E13iterator_typeES2_</a></td>              <td class="coverFnHi">219</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#275">_ZSt12__niter_baseIPiENSt11_Niter_baseIT_E13iterator_typeES2_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#377">_ZSt13__copy_move_aILb1EPdS0_ET1_T0_S2_S1_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#653">_ZSt13move_backwardIPdS0_ET0_T_S2_S1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#422">_ZSt14__copy_move_a2ILb1EPdS0_ET1_T0_S2_S1_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#572">_ZSt22__copy_move_backward_aILb1EPdS0_ET1_T0_S2_S1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#590">_ZSt23__copy_move_backward_a2ILb1EPdS0_ET1_T0_S2_S1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#214">_ZSt3maxIiERKT_S2_S2_</a></td>              <td class="coverFnHi">3920</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#214">_ZSt3maxImERKT_S2_S2_</a></td>              <td class="coverFnHi">46</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#191">_ZSt3minIiERKT_S2_S2_</a></td>              <td class="coverFnHi">3920</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#448">_ZSt4copyISt13move_iteratorIPdES1_ET0_T_S4_S3_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#719">_ZSt4fillIN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEEdEvT_S7_RKT0_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#719">_ZSt4fillIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEiEvT_S7_RKT0_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#719">_ZSt4fillIPddEvT_S1_RKT0_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#779">_ZSt6fill_nIPdmdET_S1_T0_RKT1_</a></td>              <td class="coverFnHi">78</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#779">_ZSt6fill_nIPimiET_S1_T0_RKT1_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#686">_ZSt8__fill_aIPddEN9__gnu_cxx11__enable_ifIXsrSt11__is_scalarIT0_E7__valueEvE6__typeET_S8_RKS4_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#686">_ZSt8__fill_aIPiiEN9__gnu_cxx11__enable_ifIXsrSt11__is_scalarIT0_E7__valueEvE6__typeET_S8_RKS4_</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/stl_algobase.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - stl_algobase.h<span style="font-size: 80%;"> (<a href="stl_algobase.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">31</td>            <td class="headerCovTableEntry">52</td>            <td class="headerCovTableEntryLo">59.6 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">26</td>            <td class="headerCovTableEntryLo">53.8 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="stl_algobase.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#561">_ZNSt20__copy_move_backwardILb1ELb1ESt26random_access_iterator_tagE13__copy_move_bIdEEPT_PKS3_S6_S4_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#286">_ZSt12__miter_baseIPdENSt11_Miter_baseIT_E13iterator_typeES2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#275">_ZSt12__niter_baseIN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEEENSt11_Niter_baseIT_E13iterator_typeES8_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#275">_ZSt12__niter_baseIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEENSt11_Niter_baseIT_E13iterator_typeES8_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#653">_ZSt13move_backwardIPdS0_ET0_T_S2_S1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#572">_ZSt22__copy_move_backward_aILb1EPdS0_ET1_T0_S2_S1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#590">_ZSt23__copy_move_backward_a2ILb1EPdS0_ET1_T0_S2_S1_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#719">_ZSt4fillIN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEEdEvT_S7_RKT0_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#719">_ZSt4fillIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEiEvT_S7_RKT0_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#719">_ZSt4fillIPddEvT_S1_RKT0_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#686">_ZSt8__fill_aIPddEN9__gnu_cxx11__enable_ifIXsrSt11__is_scalarIT0_E7__valueEvE6__typeET_S8_RKS4_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#686">_ZSt8__fill_aIPiiEN9__gnu_cxx11__enable_ifIXsrSt11__is_scalarIT0_E7__valueEvE6__typeET_S8_RKS4_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#744">_ZSt10__fill_n_aIPimiEN9__gnu_cxx11__enable_ifIXsrSt11__is_scalarIT1_E7__valueET_E6__typeES6_T0_RKS4_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#275">_ZSt12__niter_baseIPiENSt11_Niter_baseIT_E13iterator_typeES2_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#779">_ZSt6fill_nIPimiET_S1_T0_RKT1_</a></td>              <td class="coverFnHi">11</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#214">_ZSt3maxImERKT_S2_S2_</a></td>              <td class="coverFnHi">46</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#366">_ZNSt11__copy_moveILb1ELb1ESt26random_access_iterator_tagE8__copy_mIdEEPT_PKS3_S6_S4_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#377">_ZSt13__copy_move_aILb1EPdS0_ET1_T0_S2_S1_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#422">_ZSt14__copy_move_a2ILb1EPdS0_ET1_T0_S2_S1_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#448">_ZSt4copyISt13move_iteratorIPdES1_ET0_T_S4_S3_</a></td>              <td class="coverFnHi">47</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#744">_ZSt10__fill_n_aIPdmdEN9__gnu_cxx11__enable_ifIXsrSt11__is_scalarIT1_E7__valueET_E6__typeES6_T0_RKS4_</a></td>              <td class="coverFnHi">78</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#779">_ZSt6fill_nIPdmdET_S1_T0_RKT1_</a></td>              <td class="coverFnHi">78</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#286">_ZSt12__miter_baseISt13move_iteratorIPdEENSt11_Miter_baseIT_E13iterator_typeES4_</a></td>              <td class="coverFnHi">94</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#275">_ZSt12__niter_baseIPdENSt11_Niter_baseIT_E13iterator_typeES2_</a></td>              <td class="coverFnHi">219</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#214">_ZSt3maxIiERKT_S2_S2_</a></td>              <td class="coverFnHi">3920</td>            </tr>    <tr>              <td class="coverFn"><a href="stl_algobase.h.gcov.html#191">_ZSt3minIiERKT_S2_S2_</a></td>              <td class="coverFnHi">3920</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/stl_algobase.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/move.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/move.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/move.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - move.h<span style="font-size: 80%;"> (source / <a href="move.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntryLo">44.4 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">3</td>            <td class="headerCovTableEntry">7</td>            <td class="headerCovTableEntryLo">42.9 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/move.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Move, forward and identity for C++0x + swap -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2007-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /** @file bits/move.h<span class="lineNum">      26 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      27 </span>            :  *  Do not attempt to use it directly. @headername{utility}<span class="lineNum">      28 </span>            :  */<span class="lineNum">      29 </span>            : <span class="lineNum">      30 </span>            : #ifndef _MOVE_H<span class="lineNum">      31 </span>            : #define _MOVE_H 1<span class="lineNum">      32 </span>            : <span class="lineNum">      33 </span>            : #include &lt;bits/c++config.h&gt;<span class="lineNum">      34 </span>            : #include &lt;bits/concept_check.h&gt;<span class="lineNum">      35 </span>            : <span class="lineNum">      36 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      37 </span>            : {<span class="lineNum">      38 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      39 </span>            : <span class="lineNum">      40 </span>            :   // Used, in C++03 mode too, by allocators, etc.<span class="lineNum">      41 </span>            :   /**<span class="lineNum">      42 </span>            :    *  @brief Same as C++11 std::addressof<span class="lineNum">      43 </span>            :    *  @ingroup utilities<span class="lineNum">      44 </span>            :    */<span class="lineNum">      45 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      46 </span>            :     inline _Tp*<span class="lineNum">      47 </span>            :     __addressof(_Tp&amp; __r) _GLIBCXX_NOEXCEPT<span class="lineNum">      48 </span>            :     {<span class="lineNum">      49 </span>            :       return reinterpret_cast&lt;_Tp*&gt;<span class="lineNum">      50 </span>            :         (&amp;const_cast&lt;char&amp;&gt;(reinterpret_cast&lt;const volatile char&amp;&gt;(__r)));<span class="lineNum">      51 </span>            :     }<span class="lineNum">      52 </span>            : <span class="lineNum">      53 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">      54 </span>            : } // namespace<span class="lineNum">      55 </span>            : <span class="lineNum">      56 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      57 </span>            : #include &lt;type_traits&gt; // Brings in std::declval too.<span class="lineNum">      58 </span>            : <span class="lineNum">      59 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      60 </span>            : {<span class="lineNum">      61 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      62 </span>            : <span class="lineNum">      63 </span>            :   /**<span class="lineNum">      64 </span>            :    *  @addtogroup utilities<span class="lineNum">      65 </span>            :    *  @{<span class="lineNum">      66 </span>            :    */<span class="lineNum">      67 </span>            : <span class="lineNum">      68 </span>            :   /**<span class="lineNum">      69 </span>            :    *  @brief  Forward an lvalue.<span class="lineNum">      70 </span>            :    *  @return The parameter cast to the specified type.<span class="lineNum">      71 </span>            :    *<span class="lineNum">      72 </span>            :    *  This function is used to implement &quot;perfect forwarding&quot;.<span class="lineNum">      73 </span>            :    */<a name="74"><span class="lineNum">      74 </span>            :   template&lt;typename _Tp&gt;</a><span class="lineNum">      75 </span>            :     constexpr _Tp&amp;&amp;<span class="lineNum">      76 </span><span class="lineCov">       6754 :     forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept</span><span class="lineNum">      77 </span><span class="lineCov">       6754 :     { return static_cast&lt;_Tp&amp;&amp;&gt;(__t); }</span><span class="lineNum">      78 </span>            : <span class="lineNum">      79 </span>            :   /**<span class="lineNum">      80 </span>            :    *  @brief  Forward an rvalue.<span class="lineNum">      81 </span>            :    *  @return The parameter cast to the specified type.<span class="lineNum">      82 </span>            :    *<span class="lineNum">      83 </span>            :    *  This function is used to implement &quot;perfect forwarding&quot;.<span class="lineNum">      84 </span>            :    */<span class="lineNum">      85 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      86 </span>            :     constexpr _Tp&amp;&amp;<span class="lineNum">      87 </span>            :     forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept<span class="lineNum">      88 </span>            :     {<span class="lineNum">      89 </span>            :       static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value, &quot;template argument&quot;<span class="lineNum">      90 </span>            :                     &quot; substituting _Tp is an lvalue reference type&quot;);<span class="lineNum">      91 </span>            :       return static_cast&lt;_Tp&amp;&amp;&gt;(__t);<span class="lineNum">      92 </span>            :     }<span class="lineNum">      93 </span>            : <span class="lineNum">      94 </span>            :   /**<span class="lineNum">      95 </span>            :    *  @brief  Convert a value to an rvalue.<span class="lineNum">      96 </span>            :    *  @param  __t  A thing of arbitrary type.<span class="lineNum">      97 </span>            :    *  @return The parameter cast to an rvalue-reference to allow moving it.<span class="lineNum">      98 </span>            :   */<a name="99"><span class="lineNum">      99 </span>            :   template&lt;typename _Tp&gt;</a><span class="lineNum">     100 </span>            :     constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;<span class="lineNum">     101 </span><span class="lineCov">        784 :     move(_Tp&amp;&amp; __t) noexcept</span><span class="lineNum">     102 </span><span class="lineCov">        784 :     { return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); }</span><span class="lineNum">     103 </span>            : <span class="lineNum">     104 </span>            : <span class="lineNum">     105 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     106 </span>            :     struct __move_if_noexcept_cond<span class="lineNum">     107 </span>            :     : public __and_&lt;__not_&lt;is_nothrow_move_constructible&lt;_Tp&gt;&gt;,<span class="lineNum">     108 </span>            :                     is_copy_constructible&lt;_Tp&gt;&gt;::type { };<span class="lineNum">     109 </span>            : <span class="lineNum">     110 </span>            :   /**<span class="lineNum">     111 </span>            :    *  @brief  Conditionally convert a value to an rvalue.<span class="lineNum">     112 </span>            :    *  @param  __x  A thing of arbitrary type.<span class="lineNum">     113 </span>            :    *  @return The parameter, possibly cast to an rvalue-reference.<span class="lineNum">     114 </span>            :    *<span class="lineNum">     115 </span>            :    *  Same as std::move unless the type's move constructor could throw and the<span class="lineNum">     116 </span>            :    *  type is copyable, in which case an lvalue-reference is returned instead.<span class="lineNum">     117 </span>            :    */<span class="lineNum">     118 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     119 </span>            :     inline constexpr typename<span class="lineNum">     120 </span>            :     conditional&lt;__move_if_noexcept_cond&lt;_Tp&gt;::value, const _Tp&amp;, _Tp&amp;&amp;&gt;::type<span class="lineNum">     121 </span>            :     move_if_noexcept(_Tp&amp; __x) noexcept<span class="lineNum">     122 </span>            :     { return std::move(__x); }<span class="lineNum">     123 </span>            : <span class="lineNum">     124 </span>            :   // declval, from type_traits.<span class="lineNum">     125 </span>            : <span class="lineNum">     126 </span>            :   /**<span class="lineNum">     127 </span>            :    *  @brief Returns the actual address of the object or function<span class="lineNum">     128 </span>            :    *         referenced by r, even in the presence of an overloaded<span class="lineNum">     129 </span>            :    *         operator&amp;.<span class="lineNum">     130 </span>            :    *  @param  __r  Reference to an object or function.<span class="lineNum">     131 </span>            :    *  @return   The actual address.<span class="lineNum">     132 </span>            :   */<span class="lineNum">     133 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     134 </span>            :     inline _Tp*<span class="lineNum">     135 </span>            :     addressof(_Tp&amp; __r) noexcept<span class="lineNum">     136 </span>            :     { return std::__addressof(__r); }<span class="lineNum">     137 </span>            : <span class="lineNum">     138 </span>            :   /// @} group utilities<span class="lineNum">     139 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     140 </span>            : } // namespace<span class="lineNum">     141 </span>            : <span class="lineNum">     142 </span>            : #define _GLIBCXX_MOVE(__val) std::move(__val)<span class="lineNum">     143 </span>            : #define _GLIBCXX_FORWARD(_Tp, __val) std::forward&lt;_Tp&gt;(__val)<span class="lineNum">     144 </span>            : #else<span class="lineNum">     145 </span>            : #define _GLIBCXX_MOVE(__val) (__val)<span class="lineNum">     146 </span>            : #define _GLIBCXX_FORWARD(_Tp, __val) (__val)<span class="lineNum">     147 </span>            : #endif<span class="lineNum">     148 </span>            : <span class="lineNum">     149 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">     150 </span>            : {<span class="lineNum">     151 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">     152 </span>            : <span class="lineNum">     153 </span>            :   /**<span class="lineNum">     154 </span>            :    *  @addtogroup utilities<span class="lineNum">     155 </span>            :    *  @{<span class="lineNum">     156 </span>            :    */<span class="lineNum">     157 </span>            : <span class="lineNum">     158 </span>            :   /**<span class="lineNum">     159 </span>            :    *  @brief Swaps two values.<span class="lineNum">     160 </span>            :    *  @param  __a  A thing of arbitrary type.<span class="lineNum">     161 </span>            :    *  @param  __b  Another thing of arbitrary type.<span class="lineNum">     162 </span>            :    *  @return   Nothing.<span class="lineNum">     163 </span>            :   */<a name="164"><span class="lineNum">     164 </span>            :   template&lt;typename _Tp&gt;</a><span class="lineNum">     165 </span>            :     inline void<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     swap(_Tp&amp; __a, _Tp&amp; __b)</span><span class="lineNum">     167 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     168 </span>            :     noexcept(__and_&lt;is_nothrow_move_constructible&lt;_Tp&gt;,<span class="lineNum">     169 </span>            :                     is_nothrow_move_assignable&lt;_Tp&gt;&gt;::value)<span class="lineNum">     170 </span>            : #endif<span class="lineNum">     171 </span>            :     {<span class="lineNum">     172 </span>            :       // concept requirements<span class="lineNum">     173 </span>            :       __glibcxx_function_requires(_SGIAssignableConcept&lt;_Tp&gt;)<span class="lineNum">     174 </span>            : <span class="lineNum">     175 </span><span class="lineNoCov">          0 :       _Tp __tmp = _GLIBCXX_MOVE(__a);</span><span class="lineNum">     176 </span><span class="lineNoCov">          0 :       __a = _GLIBCXX_MOVE(__b);</span><span class="lineNum">     177 </span><span class="lineNoCov">          0 :       __b = _GLIBCXX_MOVE(__tmp);</span><span class="lineNum">     178 </span><span class="lineNoCov">          0 :     }</span><span class="lineNum">     179 </span>            : <span class="lineNum">     180 </span>            :   // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     181 </span>            :   // DR 809. std::swap should be overloaded for array types.<span class="lineNum">     182 </span>            :   /// Swap the contents of two arrays.<span class="lineNum">     183 </span>            :   template&lt;typename _Tp, size_t _Nm&gt;<span class="lineNum">     184 </span>            :     inline void<span class="lineNum">     185 </span>            :     swap(_Tp (&amp;__a)[_Nm], _Tp (&amp;__b)[_Nm])<span class="lineNum">     186 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     187 </span>            :     noexcept(noexcept(swap(*__a, *__b)))<span class="lineNum">     188 </span>            : #endif<span class="lineNum">     189 </span>            :     {<span class="lineNum">     190 </span>            :       for (size_t __n = 0; __n &lt; _Nm; ++__n)<span class="lineNum">     191 </span>            :         swap(__a[__n], __b[__n]);<span class="lineNum">     192 </span>            :     }<span class="lineNum">     193 </span>            : <span class="lineNum">     194 </span>            :   /// @} group utilities<span class="lineNum">     195 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     196 </span>            : } // namespace<span class="lineNum">     197 </span>            : <span class="lineNum">     198 </span>            : #endif /* _MOVE_H */</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/move.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/move.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/move.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - move.h<span style="font-size: 80%;"> (<a href="move.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntryLo">44.4 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">3</td>            <td class="headerCovTableEntry">7</td>            <td class="headerCovTableEntryLo">42.9 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="move.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#99">_ZSt4moveIRPdEONSt16remove_referenceIT_E4typeEOS3_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#99">_ZSt4moveIRPiEONSt16remove_referenceIT_E4typeEOS3_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#99">_ZSt4moveIRdEONSt16remove_referenceIT_E4typeEOS2_</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#164">_ZSt4swapIPdEvRT_S2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#164">_ZSt4swapIPiEvRT_S2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#74">_ZSt7forwardIRKdEOT_RNSt16remove_referenceIS2_E4typeE</a></td>              <td class="coverFnHi">1791</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#74">_ZSt7forwardIdEOT_RNSt16remove_referenceIS0_E4typeE</a></td>              <td class="coverFnHi">1586</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/move.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/move.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/move.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - move.h<span style="font-size: 80%;"> (<a href="move.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntryLo">44.4 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">3</td>            <td class="headerCovTableEntry">7</td>            <td class="headerCovTableEntryLo">42.9 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="move.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#99">_ZSt4moveIRPdEONSt16remove_referenceIT_E4typeEOS3_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#99">_ZSt4moveIRPiEONSt16remove_referenceIT_E4typeEOS3_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#164">_ZSt4swapIPdEvRT_S2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#164">_ZSt4swapIPiEvRT_S2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#99">_ZSt4moveIRdEONSt16remove_referenceIT_E4typeEOS2_</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#74">_ZSt7forwardIdEOT_RNSt16remove_referenceIS0_E4typeE</a></td>              <td class="coverFnHi">1586</td>            </tr>    <tr>              <td class="coverFn"><a href="move.h.gcov.html#74">_ZSt7forwardIRKdEOT_RNSt16remove_referenceIS2_E4typeE</a></td>              <td class="coverFnHi">1791</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/move.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/locale_facets.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/locale_facets.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - locale_facets.h<span style="font-size: 80%;"> (source / <a href="locale_facets.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">5</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Locale support -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 1997-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /** @file bits/locale_facets.h<span class="lineNum">      26 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      27 </span>            :  *  Do not attempt to use it directly. @headername{locale}<span class="lineNum">      28 </span>            :  */<span class="lineNum">      29 </span>            : <span class="lineNum">      30 </span>            : //<span class="lineNum">      31 </span>            : // ISO C++ 14882: 22.1  Locales<span class="lineNum">      32 </span>            : //<span class="lineNum">      33 </span>            : <span class="lineNum">      34 </span>            : #ifndef _LOCALE_FACETS_H<span class="lineNum">      35 </span>            : #define _LOCALE_FACETS_H 1<span class="lineNum">      36 </span>            : <span class="lineNum">      37 </span>            : #pragma GCC system_header<span class="lineNum">      38 </span>            : <span class="lineNum">      39 </span>            : #include &lt;cwctype&gt;        // For wctype_t<span class="lineNum">      40 </span>            : #include &lt;cctype&gt;<span class="lineNum">      41 </span>            : #include &lt;bits/ctype_base.h&gt;<span class="lineNum">      42 </span>            : #include &lt;iosfwd&gt;<span class="lineNum">      43 </span>            : #include &lt;bits/ios_base.h&gt;  // For ios_base, ios_base::iostate<span class="lineNum">      44 </span>            : #include &lt;streambuf&gt;<span class="lineNum">      45 </span>            : #include &lt;bits/cpp_type_traits.h&gt;<span class="lineNum">      46 </span>            : #include &lt;ext/type_traits.h&gt;<span class="lineNum">      47 </span>            : #include &lt;ext/numeric_traits.h&gt;<span class="lineNum">      48 </span>            : #include &lt;bits/streambuf_iterator.h&gt;<span class="lineNum">      49 </span>            : <span class="lineNum">      50 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      51 </span>            : {<span class="lineNum">      52 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      53 </span>            : <span class="lineNum">      54 </span>            :   // NB: Don't instantiate required wchar_t facets if no wchar_t support.<span class="lineNum">      55 </span>            : #ifdef _GLIBCXX_USE_WCHAR_T<span class="lineNum">      56 </span>            : # define  _GLIBCXX_NUM_FACETS 28<span class="lineNum">      57 </span>            : #else<span class="lineNum">      58 </span>            : # define  _GLIBCXX_NUM_FACETS 14<span class="lineNum">      59 </span>            : #endif<span class="lineNum">      60 </span>            : <span class="lineNum">      61 </span>            :   // Convert string to numeric value of type _Tp and store results.<span class="lineNum">      62 </span>            :   // NB: This is specialized for all required types, there is no<span class="lineNum">      63 </span>            :   // generic definition.<span class="lineNum">      64 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      65 </span>            :     void<span class="lineNum">      66 </span>            :     __convert_to_v(const char*, _Tp&amp;, ios_base::iostate&amp;,<span class="lineNum">      67 </span>            :                    const __c_locale&amp;) throw();<span class="lineNum">      68 </span>            : <span class="lineNum">      69 </span>            :   // Explicit specializations for required types.<span class="lineNum">      70 </span>            :   template&lt;&gt;<span class="lineNum">      71 </span>            :     void<span class="lineNum">      72 </span>            :     __convert_to_v(const char*, float&amp;, ios_base::iostate&amp;,<span class="lineNum">      73 </span>            :                    const __c_locale&amp;) throw();<span class="lineNum">      74 </span>            : <span class="lineNum">      75 </span>            :   template&lt;&gt;<span class="lineNum">      76 </span>            :     void<span class="lineNum">      77 </span>            :     __convert_to_v(const char*, double&amp;, ios_base::iostate&amp;,<span class="lineNum">      78 </span>            :                    const __c_locale&amp;) throw();<span class="lineNum">      79 </span>            : <span class="lineNum">      80 </span>            :   template&lt;&gt;<span class="lineNum">      81 </span>            :     void<span class="lineNum">      82 </span>            :     __convert_to_v(const char*, long double&amp;, ios_base::iostate&amp;,<span class="lineNum">      83 </span>            :                    const __c_locale&amp;) throw();<span class="lineNum">      84 </span>            : <span class="lineNum">      85 </span>            :   // NB: __pad is a struct, rather than a function, so it can be<span class="lineNum">      86 </span>            :   // partially-specialized.<span class="lineNum">      87 </span>            :   template&lt;typename _CharT, typename _Traits&gt;<span class="lineNum">      88 </span>            :     struct __pad<span class="lineNum">      89 </span>            :     {<span class="lineNum">      90 </span>            :       static void<span class="lineNum">      91 </span>            :       _S_pad(ios_base&amp; __io, _CharT __fill, _CharT* __news,<span class="lineNum">      92 </span>            :              const _CharT* __olds, streamsize __newlen, streamsize __oldlen);<span class="lineNum">      93 </span>            :     };<span class="lineNum">      94 </span>            : <span class="lineNum">      95 </span>            :   // Used by both numeric and monetary facets.<span class="lineNum">      96 </span>            :   // Inserts &quot;group separator&quot; characters into an array of characters.<span class="lineNum">      97 </span>            :   // It's recursive, one iteration per group.  It moves the characters<span class="lineNum">      98 </span>            :   // in the buffer this way: &quot;xxxx12345&quot; -&gt; &quot;12,345xxx&quot;.  Call this<span class="lineNum">      99 </span>            :   // only with __gsize != 0.<span class="lineNum">     100 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     101 </span>            :     _CharT*<span class="lineNum">     102 </span>            :     __add_grouping(_CharT* __s, _CharT __sep,<span class="lineNum">     103 </span>            :                    const char* __gbeg, size_t __gsize,<span class="lineNum">     104 </span>            :                    const _CharT* __first, const _CharT* __last);<span class="lineNum">     105 </span>            : <span class="lineNum">     106 </span>            :   // This template permits specializing facet output code for<span class="lineNum">     107 </span>            :   // ostreambuf_iterator.  For ostreambuf_iterator, sputn is<span class="lineNum">     108 </span>            :   // significantly more efficient than incrementing iterators.<span class="lineNum">     109 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     110 </span>            :     inline<span class="lineNum">     111 </span>            :     ostreambuf_iterator&lt;_CharT&gt;<span class="lineNum">     112 </span>            :     __write(ostreambuf_iterator&lt;_CharT&gt; __s, const _CharT* __ws, int __len)<span class="lineNum">     113 </span>            :     {<span class="lineNum">     114 </span>            :       __s._M_put(__ws, __len);<span class="lineNum">     115 </span>            :       return __s;<span class="lineNum">     116 </span>            :     }<span class="lineNum">     117 </span>            : <span class="lineNum">     118 </span>            :   // This is the unspecialized form of the template.<span class="lineNum">     119 </span>            :   template&lt;typename _CharT, typename _OutIter&gt;<span class="lineNum">     120 </span>            :     inline<span class="lineNum">     121 </span>            :     _OutIter<span class="lineNum">     122 </span>            :     __write(_OutIter __s, const _CharT* __ws, int __len)<span class="lineNum">     123 </span>            :     {<span class="lineNum">     124 </span>            :       for (int __j = 0; __j &lt; __len; __j++, ++__s)<span class="lineNum">     125 </span>            :         *__s = __ws[__j];<span class="lineNum">     126 </span>            :       return __s;<span class="lineNum">     127 </span>            :     }<span class="lineNum">     128 </span>            : <span class="lineNum">     129 </span>            : <span class="lineNum">     130 </span>            :   // 22.2.1.1  Template class ctype<span class="lineNum">     131 </span>            :   // Include host and configuration specific ctype enums for ctype_base.<span class="lineNum">     132 </span>            : <span class="lineNum">     133 </span>            :   /**<span class="lineNum">     134 </span>            :    *  @brief  Common base for ctype facet<span class="lineNum">     135 </span>            :    *<span class="lineNum">     136 </span>            :    *  This template class provides implementations of the public functions<span class="lineNum">     137 </span>            :    *  that forward to the protected virtual functions.<span class="lineNum">     138 </span>            :    *<span class="lineNum">     139 </span>            :    *  This template also provides abstract stubs for the protected virtual<span class="lineNum">     140 </span>            :    *  functions.<span class="lineNum">     141 </span>            :   */<span class="lineNum">     142 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     143 </span>            :     class __ctype_abstract_base : public locale::facet, public ctype_base<span class="lineNum">     144 </span>            :     {<span class="lineNum">     145 </span>            :     public:<span class="lineNum">     146 </span>            :       // Types:<span class="lineNum">     147 </span>            :       /// Typedef for the template parameter<span class="lineNum">     148 </span>            :       typedef _CharT char_type;<span class="lineNum">     149 </span>            : <span class="lineNum">     150 </span>            :       /**<span class="lineNum">     151 </span>            :        *  @brief  Test char_type classification.<span class="lineNum">     152 </span>            :        *<span class="lineNum">     153 </span>            :        *  This function finds a mask M for @a __c and compares it to<span class="lineNum">     154 </span>            :        *  mask @a __m.  It does so by returning the value of<span class="lineNum">     155 </span>            :        *  ctype&lt;char_type&gt;::do_is().<span class="lineNum">     156 </span>            :        *<span class="lineNum">     157 </span>            :        *  @param __c  The char_type to compare the mask of.<span class="lineNum">     158 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">     159 </span>            :        *  @return  (M &amp; __m) != 0.<span class="lineNum">     160 </span>            :       */<span class="lineNum">     161 </span>            :       bool<span class="lineNum">     162 </span>            :       is(mask __m, char_type __c) const<span class="lineNum">     163 </span>            :       { return this-&gt;do_is(__m, __c); }<span class="lineNum">     164 </span>            : <span class="lineNum">     165 </span>            :       /**<span class="lineNum">     166 </span>            :        *  @brief  Return a mask array.<span class="lineNum">     167 </span>            :        *<span class="lineNum">     168 </span>            :        *  This function finds the mask for each char_type in the range [lo,hi)<span class="lineNum">     169 </span>            :        *  and successively writes it to vec.  vec must have as many elements<span class="lineNum">     170 </span>            :        *  as the char array.  It does so by returning the value of<span class="lineNum">     171 </span>            :        *  ctype&lt;char_type&gt;::do_is().<span class="lineNum">     172 </span>            :        *<span class="lineNum">     173 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     174 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     175 </span>            :        *  @param __vec  Pointer to an array of mask storage.<span class="lineNum">     176 </span>            :        *  @return  @a __hi.<span class="lineNum">     177 </span>            :       */<span class="lineNum">     178 </span>            :       const char_type*<span class="lineNum">     179 </span>            :       is(const char_type *__lo, const char_type *__hi, mask *__vec) const<span class="lineNum">     180 </span>            :       { return this-&gt;do_is(__lo, __hi, __vec); }<span class="lineNum">     181 </span>            : <span class="lineNum">     182 </span>            :       /**<span class="lineNum">     183 </span>            :        *  @brief  Find char_type matching a mask<span class="lineNum">     184 </span>            :        *<span class="lineNum">     185 </span>            :        *  This function searches for and returns the first char_type c in<span class="lineNum">     186 </span>            :        *  [lo,hi) for which is(m,c) is true.  It does so by returning<span class="lineNum">     187 </span>            :        *  ctype&lt;char_type&gt;::do_scan_is().<span class="lineNum">     188 </span>            :        *<span class="lineNum">     189 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">     190 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     191 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     192 </span>            :        *  @return  Pointer to matching char_type if found, else @a __hi.<span class="lineNum">     193 </span>            :       */<span class="lineNum">     194 </span>            :       const char_type*<span class="lineNum">     195 </span>            :       scan_is(mask __m, const char_type* __lo, const char_type* __hi) const<span class="lineNum">     196 </span>            :       { return this-&gt;do_scan_is(__m, __lo, __hi); }<span class="lineNum">     197 </span>            : <span class="lineNum">     198 </span>            :       /**<span class="lineNum">     199 </span>            :        *  @brief  Find char_type not matching a mask<span class="lineNum">     200 </span>            :        *<span class="lineNum">     201 </span>            :        *  This function searches for and returns the first char_type c in<span class="lineNum">     202 </span>            :        *  [lo,hi) for which is(m,c) is false.  It does so by returning<span class="lineNum">     203 </span>            :        *  ctype&lt;char_type&gt;::do_scan_not().<span class="lineNum">     204 </span>            :        *<span class="lineNum">     205 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">     206 </span>            :        *  @param __lo  Pointer to first char in range.<span class="lineNum">     207 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     208 </span>            :        *  @return  Pointer to non-matching char if found, else @a __hi.<span class="lineNum">     209 </span>            :       */<span class="lineNum">     210 </span>            :       const char_type*<span class="lineNum">     211 </span>            :       scan_not(mask __m, const char_type* __lo, const char_type* __hi) const<span class="lineNum">     212 </span>            :       { return this-&gt;do_scan_not(__m, __lo, __hi); }<span class="lineNum">     213 </span>            : <span class="lineNum">     214 </span>            :       /**<span class="lineNum">     215 </span>            :        *  @brief  Convert to uppercase.<span class="lineNum">     216 </span>            :        *<span class="lineNum">     217 </span>            :        *  This function converts the argument to uppercase if possible.<span class="lineNum">     218 </span>            :        *  If not possible (for example, '2'), returns the argument.  It does<span class="lineNum">     219 </span>            :        *  so by returning ctype&lt;char_type&gt;::do_toupper().<span class="lineNum">     220 </span>            :        *<span class="lineNum">     221 </span>            :        *  @param __c  The char_type to convert.<span class="lineNum">     222 </span>            :        *  @return  The uppercase char_type if convertible, else @a __c.<span class="lineNum">     223 </span>            :       */<span class="lineNum">     224 </span>            :       char_type<span class="lineNum">     225 </span>            :       toupper(char_type __c) const<span class="lineNum">     226 </span>            :       { return this-&gt;do_toupper(__c); }<span class="lineNum">     227 </span>            : <span class="lineNum">     228 </span>            :       /**<span class="lineNum">     229 </span>            :        *  @brief  Convert array to uppercase.<span class="lineNum">     230 </span>            :        *<span class="lineNum">     231 </span>            :        *  This function converts each char_type in the range [lo,hi) to<span class="lineNum">     232 </span>            :        *  uppercase if possible.  Other elements remain untouched.  It does so<span class="lineNum">     233 </span>            :        *  by returning ctype&lt;char_type&gt;:: do_toupper(lo, hi).<span class="lineNum">     234 </span>            :        *<span class="lineNum">     235 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     236 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     237 </span>            :        *  @return  @a __hi.<span class="lineNum">     238 </span>            :       */<span class="lineNum">     239 </span>            :       const char_type*<span class="lineNum">     240 </span>            :       toupper(char_type *__lo, const char_type* __hi) const<span class="lineNum">     241 </span>            :       { return this-&gt;do_toupper(__lo, __hi); }<span class="lineNum">     242 </span>            : <span class="lineNum">     243 </span>            :       /**<span class="lineNum">     244 </span>            :        *  @brief  Convert to lowercase.<span class="lineNum">     245 </span>            :        *<span class="lineNum">     246 </span>            :        *  This function converts the argument to lowercase if possible.  If<span class="lineNum">     247 </span>            :        *  not possible (for example, '2'), returns the argument.  It does so<span class="lineNum">     248 </span>            :        *  by returning ctype&lt;char_type&gt;::do_tolower(c).<span class="lineNum">     249 </span>            :        *<span class="lineNum">     250 </span>            :        *  @param __c  The char_type to convert.<span class="lineNum">     251 </span>            :        *  @return  The lowercase char_type if convertible, else @a __c.<span class="lineNum">     252 </span>            :       */<span class="lineNum">     253 </span>            :       char_type<span class="lineNum">     254 </span>            :       tolower(char_type __c) const<span class="lineNum">     255 </span>            :       { return this-&gt;do_tolower(__c); }<span class="lineNum">     256 </span>            : <span class="lineNum">     257 </span>            :       /**<span class="lineNum">     258 </span>            :        *  @brief  Convert array to lowercase.<span class="lineNum">     259 </span>            :        *<span class="lineNum">     260 </span>            :        *  This function converts each char_type in the range [__lo,__hi) to<span class="lineNum">     261 </span>            :        *  lowercase if possible.  Other elements remain untouched.  It does so<span class="lineNum">     262 </span>            :        *  by returning ctype&lt;char_type&gt;:: do_tolower(__lo, __hi).<span class="lineNum">     263 </span>            :        *<span class="lineNum">     264 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     265 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     266 </span>            :        *  @return  @a __hi.<span class="lineNum">     267 </span>            :       */<span class="lineNum">     268 </span>            :       const char_type*<span class="lineNum">     269 </span>            :       tolower(char_type* __lo, const char_type* __hi) const<span class="lineNum">     270 </span>            :       { return this-&gt;do_tolower(__lo, __hi); }<span class="lineNum">     271 </span>            : <span class="lineNum">     272 </span>            :       /**<span class="lineNum">     273 </span>            :        *  @brief  Widen char to char_type<span class="lineNum">     274 </span>            :        *<span class="lineNum">     275 </span>            :        *  This function converts the char argument to char_type using the<span class="lineNum">     276 </span>            :        *  simplest reasonable transformation.  It does so by returning<span class="lineNum">     277 </span>            :        *  ctype&lt;char_type&gt;::do_widen(c).<span class="lineNum">     278 </span>            :        *<span class="lineNum">     279 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     280 </span>            :        *  codecvt for that.<span class="lineNum">     281 </span>            :        *<span class="lineNum">     282 </span>            :        *  @param __c  The char to convert.<span class="lineNum">     283 </span>            :        *  @return  The converted char_type.<span class="lineNum">     284 </span>            :       */<span class="lineNum">     285 </span>            :       char_type<span class="lineNum">     286 </span>            :       widen(char __c) const<span class="lineNum">     287 </span>            :       { return this-&gt;do_widen(__c); }<span class="lineNum">     288 </span>            : <span class="lineNum">     289 </span>            :       /**<span class="lineNum">     290 </span>            :        *  @brief  Widen array to char_type<span class="lineNum">     291 </span>            :        *<span class="lineNum">     292 </span>            :        *  This function converts each char in the input to char_type using the<span class="lineNum">     293 </span>            :        *  simplest reasonable transformation.  It does so by returning<span class="lineNum">     294 </span>            :        *  ctype&lt;char_type&gt;::do_widen(c).<span class="lineNum">     295 </span>            :        *<span class="lineNum">     296 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     297 </span>            :        *  codecvt for that.<span class="lineNum">     298 </span>            :        *<span class="lineNum">     299 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     300 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     301 </span>            :        *  @param __to  Pointer to the destination array.<span class="lineNum">     302 </span>            :        *  @return  @a __hi.<span class="lineNum">     303 </span>            :       */<span class="lineNum">     304 </span>            :       const char*<span class="lineNum">     305 </span>            :       widen(const char* __lo, const char* __hi, char_type* __to) const<span class="lineNum">     306 </span>            :       { return this-&gt;do_widen(__lo, __hi, __to); }<span class="lineNum">     307 </span>            : <span class="lineNum">     308 </span>            :       /**<span class="lineNum">     309 </span>            :        *  @brief  Narrow char_type to char<span class="lineNum">     310 </span>            :        *<span class="lineNum">     311 </span>            :        *  This function converts the char_type to char using the simplest<span class="lineNum">     312 </span>            :        *  reasonable transformation.  If the conversion fails, dfault is<span class="lineNum">     313 </span>            :        *  returned instead.  It does so by returning<span class="lineNum">     314 </span>            :        *  ctype&lt;char_type&gt;::do_narrow(__c).<span class="lineNum">     315 </span>            :        *<span class="lineNum">     316 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     317 </span>            :        *  codecvt for that.<span class="lineNum">     318 </span>            :        *<span class="lineNum">     319 </span>            :        *  @param __c  The char_type to convert.<span class="lineNum">     320 </span>            :        *  @param __dfault  Char to return if conversion fails.<span class="lineNum">     321 </span>            :        *  @return  The converted char.<span class="lineNum">     322 </span>            :       */<span class="lineNum">     323 </span>            :       char<span class="lineNum">     324 </span>            :       narrow(char_type __c, char __dfault) const<span class="lineNum">     325 </span>            :       { return this-&gt;do_narrow(__c, __dfault); }<span class="lineNum">     326 </span>            : <span class="lineNum">     327 </span>            :       /**<span class="lineNum">     328 </span>            :        *  @brief  Narrow array to char array<span class="lineNum">     329 </span>            :        *<span class="lineNum">     330 </span>            :        *  This function converts each char_type in the input to char using the<span class="lineNum">     331 </span>            :        *  simplest reasonable transformation and writes the results to the<span class="lineNum">     332 </span>            :        *  destination array.  For any char_type in the input that cannot be<span class="lineNum">     333 </span>            :        *  converted, @a dfault is used instead.  It does so by returning<span class="lineNum">     334 </span>            :        *  ctype&lt;char_type&gt;::do_narrow(__lo, __hi, __dfault, __to).<span class="lineNum">     335 </span>            :        *<span class="lineNum">     336 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     337 </span>            :        *  codecvt for that.<span class="lineNum">     338 </span>            :        *<span class="lineNum">     339 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     340 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     341 </span>            :        *  @param __dfault  Char to use if conversion fails.<span class="lineNum">     342 </span>            :        *  @param __to  Pointer to the destination array.<span class="lineNum">     343 </span>            :        *  @return  @a __hi.<span class="lineNum">     344 </span>            :       */<span class="lineNum">     345 </span>            :       const char_type*<span class="lineNum">     346 </span>            :       narrow(const char_type* __lo, const char_type* __hi,<span class="lineNum">     347 </span>            :               char __dfault, char* __to) const<span class="lineNum">     348 </span>            :       { return this-&gt;do_narrow(__lo, __hi, __dfault, __to); }<span class="lineNum">     349 </span>            : <span class="lineNum">     350 </span>            :     protected:<span class="lineNum">     351 </span>            :       explicit<span class="lineNum">     352 </span>            :       __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }<span class="lineNum">     353 </span>            : <span class="lineNum">     354 </span>            :       virtual<span class="lineNum">     355 </span>            :       ~__ctype_abstract_base() { }<span class="lineNum">     356 </span>            : <span class="lineNum">     357 </span>            :       /**<span class="lineNum">     358 </span>            :        *  @brief  Test char_type classification.<span class="lineNum">     359 </span>            :        *<span class="lineNum">     360 </span>            :        *  This function finds a mask M for @a c and compares it to mask @a m.<span class="lineNum">     361 </span>            :        *<span class="lineNum">     362 </span>            :        *  do_is() is a hook for a derived facet to change the behavior of<span class="lineNum">     363 </span>            :        *  classifying.  do_is() must always return the same result for the<span class="lineNum">     364 </span>            :        *  same input.<span class="lineNum">     365 </span>            :        *<span class="lineNum">     366 </span>            :        *  @param __c  The char_type to find the mask of.<span class="lineNum">     367 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">     368 </span>            :        *  @return  (M &amp; __m) != 0.<span class="lineNum">     369 </span>            :       */<span class="lineNum">     370 </span>            :       virtual bool<span class="lineNum">     371 </span>            :       do_is(mask __m, char_type __c) const = 0;<span class="lineNum">     372 </span>            : <span class="lineNum">     373 </span>            :       /**<span class="lineNum">     374 </span>            :        *  @brief  Return a mask array.<span class="lineNum">     375 </span>            :        *<span class="lineNum">     376 </span>            :        *  This function finds the mask for each char_type in the range [lo,hi)<span class="lineNum">     377 </span>            :        *  and successively writes it to vec.  vec must have as many elements<span class="lineNum">     378 </span>            :        *  as the input.<span class="lineNum">     379 </span>            :        *<span class="lineNum">     380 </span>            :        *  do_is() is a hook for a derived facet to change the behavior of<span class="lineNum">     381 </span>            :        *  classifying.  do_is() must always return the same result for the<span class="lineNum">     382 </span>            :        *  same input.<span class="lineNum">     383 </span>            :        *<span class="lineNum">     384 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     385 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     386 </span>            :        *  @param __vec  Pointer to an array of mask storage.<span class="lineNum">     387 </span>            :        *  @return  @a __hi.<span class="lineNum">     388 </span>            :       */<span class="lineNum">     389 </span>            :       virtual const char_type*<span class="lineNum">     390 </span>            :       do_is(const char_type* __lo, const char_type* __hi,<span class="lineNum">     391 </span>            :             mask* __vec) const = 0;<span class="lineNum">     392 </span>            : <span class="lineNum">     393 </span>            :       /**<span class="lineNum">     394 </span>            :        *  @brief  Find char_type matching mask<span class="lineNum">     395 </span>            :        *<span class="lineNum">     396 </span>            :        *  This function searches for and returns the first char_type c in<span class="lineNum">     397 </span>            :        *  [__lo,__hi) for which is(__m,c) is true.<span class="lineNum">     398 </span>            :        *<span class="lineNum">     399 </span>            :        *  do_scan_is() is a hook for a derived facet to change the behavior of<span class="lineNum">     400 </span>            :        *  match searching.  do_is() must always return the same result for the<span class="lineNum">     401 </span>            :        *  same input.<span class="lineNum">     402 </span>            :        *<span class="lineNum">     403 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">     404 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     405 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     406 </span>            :        *  @return  Pointer to a matching char_type if found, else @a __hi.<span class="lineNum">     407 </span>            :       */<span class="lineNum">     408 </span>            :       virtual const char_type*<span class="lineNum">     409 </span>            :       do_scan_is(mask __m, const char_type* __lo,<span class="lineNum">     410 </span>            :                  const char_type* __hi) const = 0;<span class="lineNum">     411 </span>            : <span class="lineNum">     412 </span>            :       /**<span class="lineNum">     413 </span>            :        *  @brief  Find char_type not matching mask<span class="lineNum">     414 </span>            :        *<span class="lineNum">     415 </span>            :        *  This function searches for and returns a pointer to the first<span class="lineNum">     416 </span>            :        *  char_type c of [lo,hi) for which is(m,c) is false.<span class="lineNum">     417 </span>            :        *<span class="lineNum">     418 </span>            :        *  do_scan_is() is a hook for a derived facet to change the behavior of<span class="lineNum">     419 </span>            :        *  match searching.  do_is() must always return the same result for the<span class="lineNum">     420 </span>            :        *  same input.<span class="lineNum">     421 </span>            :        *<span class="lineNum">     422 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">     423 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     424 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     425 </span>            :        *  @return  Pointer to a non-matching char_type if found, else @a __hi.<span class="lineNum">     426 </span>            :       */<span class="lineNum">     427 </span>            :       virtual const char_type*<span class="lineNum">     428 </span>            :       do_scan_not(mask __m, const char_type* __lo,<span class="lineNum">     429 </span>            :                   const char_type* __hi) const = 0;<span class="lineNum">     430 </span>            : <span class="lineNum">     431 </span>            :       /**<span class="lineNum">     432 </span>            :        *  @brief  Convert to uppercase.<span class="lineNum">     433 </span>            :        *<span class="lineNum">     434 </span>            :        *  This virtual function converts the char_type argument to uppercase<span class="lineNum">     435 </span>            :        *  if possible.  If not possible (for example, '2'), returns the<span class="lineNum">     436 </span>            :        *  argument.<span class="lineNum">     437 </span>            :        *<span class="lineNum">     438 </span>            :        *  do_toupper() is a hook for a derived facet to change the behavior of<span class="lineNum">     439 </span>            :        *  uppercasing.  do_toupper() must always return the same result for<span class="lineNum">     440 </span>            :        *  the same input.<span class="lineNum">     441 </span>            :        *<span class="lineNum">     442 </span>            :        *  @param __c  The char_type to convert.<span class="lineNum">     443 </span>            :        *  @return  The uppercase char_type if convertible, else @a __c.<span class="lineNum">     444 </span>            :       */<span class="lineNum">     445 </span>            :       virtual char_type<span class="lineNum">     446 </span>            :       do_toupper(char_type __c) const = 0;<span class="lineNum">     447 </span>            : <span class="lineNum">     448 </span>            :       /**<span class="lineNum">     449 </span>            :        *  @brief  Convert array to uppercase.<span class="lineNum">     450 </span>            :        *<span class="lineNum">     451 </span>            :        *  This virtual function converts each char_type in the range [__lo,__hi)<span class="lineNum">     452 </span>            :        *  to uppercase if possible.  Other elements remain untouched.<span class="lineNum">     453 </span>            :        *<span class="lineNum">     454 </span>            :        *  do_toupper() is a hook for a derived facet to change the behavior of<span class="lineNum">     455 </span>            :        *  uppercasing.  do_toupper() must always return the same result for<span class="lineNum">     456 </span>            :        *  the same input.<span class="lineNum">     457 </span>            :        *<span class="lineNum">     458 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     459 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     460 </span>            :        *  @return  @a __hi.<span class="lineNum">     461 </span>            :       */<span class="lineNum">     462 </span>            :       virtual const char_type*<span class="lineNum">     463 </span>            :       do_toupper(char_type* __lo, const char_type* __hi) const = 0;<span class="lineNum">     464 </span>            : <span class="lineNum">     465 </span>            :       /**<span class="lineNum">     466 </span>            :        *  @brief  Convert to lowercase.<span class="lineNum">     467 </span>            :        *<span class="lineNum">     468 </span>            :        *  This virtual function converts the argument to lowercase if<span class="lineNum">     469 </span>            :        *  possible.  If not possible (for example, '2'), returns the argument.<span class="lineNum">     470 </span>            :        *<span class="lineNum">     471 </span>            :        *  do_tolower() is a hook for a derived facet to change the behavior of<span class="lineNum">     472 </span>            :        *  lowercasing.  do_tolower() must always return the same result for<span class="lineNum">     473 </span>            :        *  the same input.<span class="lineNum">     474 </span>            :        *<span class="lineNum">     475 </span>            :        *  @param __c  The char_type to convert.<span class="lineNum">     476 </span>            :        *  @return  The lowercase char_type if convertible, else @a __c.<span class="lineNum">     477 </span>            :       */<span class="lineNum">     478 </span>            :       virtual char_type<span class="lineNum">     479 </span>            :       do_tolower(char_type __c) const = 0;<span class="lineNum">     480 </span>            : <span class="lineNum">     481 </span>            :       /**<span class="lineNum">     482 </span>            :        *  @brief  Convert array to lowercase.<span class="lineNum">     483 </span>            :        *<span class="lineNum">     484 </span>            :        *  This virtual function converts each char_type in the range [__lo,__hi)<span class="lineNum">     485 </span>            :        *  to lowercase if possible.  Other elements remain untouched.<span class="lineNum">     486 </span>            :        *<span class="lineNum">     487 </span>            :        *  do_tolower() is a hook for a derived facet to change the behavior of<span class="lineNum">     488 </span>            :        *  lowercasing.  do_tolower() must always return the same result for<span class="lineNum">     489 </span>            :        *  the same input.<span class="lineNum">     490 </span>            :        *<span class="lineNum">     491 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     492 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     493 </span>            :        *  @return  @a __hi.<span class="lineNum">     494 </span>            :       */<span class="lineNum">     495 </span>            :       virtual const char_type*<span class="lineNum">     496 </span>            :       do_tolower(char_type* __lo, const char_type* __hi) const = 0;<span class="lineNum">     497 </span>            : <span class="lineNum">     498 </span>            :       /**<span class="lineNum">     499 </span>            :        *  @brief  Widen char<span class="lineNum">     500 </span>            :        *<span class="lineNum">     501 </span>            :        *  This virtual function converts the char to char_type using the<span class="lineNum">     502 </span>            :        *  simplest reasonable transformation.<span class="lineNum">     503 </span>            :        *<span class="lineNum">     504 </span>            :        *  do_widen() is a hook for a derived facet to change the behavior of<span class="lineNum">     505 </span>            :        *  widening.  do_widen() must always return the same result for the<span class="lineNum">     506 </span>            :        *  same input.<span class="lineNum">     507 </span>            :        *<span class="lineNum">     508 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     509 </span>            :        *  codecvt for that.<span class="lineNum">     510 </span>            :        *<span class="lineNum">     511 </span>            :        *  @param __c  The char to convert.<span class="lineNum">     512 </span>            :        *  @return  The converted char_type<span class="lineNum">     513 </span>            :       */<span class="lineNum">     514 </span>            :       virtual char_type<span class="lineNum">     515 </span>            :       do_widen(char __c) const = 0;<span class="lineNum">     516 </span>            : <span class="lineNum">     517 </span>            :       /**<span class="lineNum">     518 </span>            :        *  @brief  Widen char array<span class="lineNum">     519 </span>            :        *<span class="lineNum">     520 </span>            :        *  This function converts each char in the input to char_type using the<span class="lineNum">     521 </span>            :        *  simplest reasonable transformation.<span class="lineNum">     522 </span>            :        *<span class="lineNum">     523 </span>            :        *  do_widen() is a hook for a derived facet to change the behavior of<span class="lineNum">     524 </span>            :        *  widening.  do_widen() must always return the same result for the<span class="lineNum">     525 </span>            :        *  same input.<span class="lineNum">     526 </span>            :        *<span class="lineNum">     527 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     528 </span>            :        *  codecvt for that.<span class="lineNum">     529 </span>            :        *<span class="lineNum">     530 </span>            :        *  @param __lo  Pointer to start range.<span class="lineNum">     531 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     532 </span>            :        *  @param __to  Pointer to the destination array.<span class="lineNum">     533 </span>            :        *  @return  @a __hi.<span class="lineNum">     534 </span>            :       */<span class="lineNum">     535 </span>            :       virtual const char*<span class="lineNum">     536 </span>            :       do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;<span class="lineNum">     537 </span>            : <span class="lineNum">     538 </span>            :       /**<span class="lineNum">     539 </span>            :        *  @brief  Narrow char_type to char<span class="lineNum">     540 </span>            :        *<span class="lineNum">     541 </span>            :        *  This virtual function converts the argument to char using the<span class="lineNum">     542 </span>            :        *  simplest reasonable transformation.  If the conversion fails, dfault<span class="lineNum">     543 </span>            :        *  is returned instead.<span class="lineNum">     544 </span>            :        *<span class="lineNum">     545 </span>            :        *  do_narrow() is a hook for a derived facet to change the behavior of<span class="lineNum">     546 </span>            :        *  narrowing.  do_narrow() must always return the same result for the<span class="lineNum">     547 </span>            :        *  same input.<span class="lineNum">     548 </span>            :        *<span class="lineNum">     549 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     550 </span>            :        *  codecvt for that.<span class="lineNum">     551 </span>            :        *<span class="lineNum">     552 </span>            :        *  @param __c  The char_type to convert.<span class="lineNum">     553 </span>            :        *  @param __dfault  Char to return if conversion fails.<span class="lineNum">     554 </span>            :        *  @return  The converted char.<span class="lineNum">     555 </span>            :       */<span class="lineNum">     556 </span>            :       virtual char<span class="lineNum">     557 </span>            :       do_narrow(char_type __c, char __dfault) const = 0;<span class="lineNum">     558 </span>            : <span class="lineNum">     559 </span>            :       /**<span class="lineNum">     560 </span>            :        *  @brief  Narrow char_type array to char<span class="lineNum">     561 </span>            :        *<span class="lineNum">     562 </span>            :        *  This virtual function converts each char_type in the range<span class="lineNum">     563 </span>            :        *  [__lo,__hi) to char using the simplest reasonable<span class="lineNum">     564 </span>            :        *  transformation and writes the results to the destination<span class="lineNum">     565 </span>            :        *  array.  For any element in the input that cannot be<span class="lineNum">     566 </span>            :        *  converted, @a __dfault is used instead.<span class="lineNum">     567 </span>            :        *<span class="lineNum">     568 </span>            :        *  do_narrow() is a hook for a derived facet to change the behavior of<span class="lineNum">     569 </span>            :        *  narrowing.  do_narrow() must always return the same result for the<span class="lineNum">     570 </span>            :        *  same input.<span class="lineNum">     571 </span>            :        *<span class="lineNum">     572 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     573 </span>            :        *  codecvt for that.<span class="lineNum">     574 </span>            :        *<span class="lineNum">     575 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     576 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     577 </span>            :        *  @param __dfault  Char to use if conversion fails.<span class="lineNum">     578 </span>            :        *  @param __to  Pointer to the destination array.<span class="lineNum">     579 </span>            :        *  @return  @a __hi.<span class="lineNum">     580 </span>            :       */<span class="lineNum">     581 </span>            :       virtual const char_type*<span class="lineNum">     582 </span>            :       do_narrow(const char_type* __lo, const char_type* __hi,<span class="lineNum">     583 </span>            :                 char __dfault, char* __to) const = 0;<span class="lineNum">     584 </span>            :     };<span class="lineNum">     585 </span>            : <span class="lineNum">     586 </span>            :   /**<span class="lineNum">     587 </span>            :    *  @brief  Primary class template ctype facet.<span class="lineNum">     588 </span>            :    *  @ingroup locales<span class="lineNum">     589 </span>            :    *<span class="lineNum">     590 </span>            :    *  This template class defines classification and conversion functions for<span class="lineNum">     591 </span>            :    *  character sets.  It wraps cctype functionality.  Ctype gets used by<span class="lineNum">     592 </span>            :    *  streams for many I/O operations.<span class="lineNum">     593 </span>            :    *<span class="lineNum">     594 </span>            :    *  This template provides the protected virtual functions the developer<span class="lineNum">     595 </span>            :    *  will have to replace in a derived class or specialization to make a<span class="lineNum">     596 </span>            :    *  working facet.  The public functions that access them are defined in<span class="lineNum">     597 </span>            :    *  __ctype_abstract_base, to allow for implementation flexibility.  See<span class="lineNum">     598 </span>            :    *  ctype&lt;wchar_t&gt; for an example.  The functions are documented in<span class="lineNum">     599 </span>            :    *  __ctype_abstract_base.<span class="lineNum">     600 </span>            :    *<span class="lineNum">     601 </span>            :    *  Note: implementations are provided for all the protected virtual<span class="lineNum">     602 </span>            :    *  functions, but will likely not be useful.<span class="lineNum">     603 </span>            :   */<span class="lineNum">     604 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     605 </span>            :     class ctype : public __ctype_abstract_base&lt;_CharT&gt;<span class="lineNum">     606 </span>            :     {<span class="lineNum">     607 </span>            :     public:<span class="lineNum">     608 </span>            :       // Types:<span class="lineNum">     609 </span>            :       typedef _CharT                    char_type;<span class="lineNum">     610 </span>            :       typedef typename __ctype_abstract_base&lt;_CharT&gt;::mask mask;<span class="lineNum">     611 </span>            : <span class="lineNum">     612 </span>            :       /// The facet id for ctype&lt;char_type&gt;<span class="lineNum">     613 </span>            :       static locale::id                 id;<span class="lineNum">     614 </span>            : <span class="lineNum">     615 </span>            :       explicit<span class="lineNum">     616 </span>            :       ctype(size_t __refs = 0) : __ctype_abstract_base&lt;_CharT&gt;(__refs) { }<span class="lineNum">     617 </span>            : <span class="lineNum">     618 </span>            :    protected:<span class="lineNum">     619 </span>            :       virtual<span class="lineNum">     620 </span>            :       ~ctype();<span class="lineNum">     621 </span>            : <span class="lineNum">     622 </span>            :       virtual bool<span class="lineNum">     623 </span>            :       do_is(mask __m, char_type __c) const;<span class="lineNum">     624 </span>            : <span class="lineNum">     625 </span>            :       virtual const char_type*<span class="lineNum">     626 </span>            :       do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;<span class="lineNum">     627 </span>            : <span class="lineNum">     628 </span>            :       virtual const char_type*<span class="lineNum">     629 </span>            :       do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;<span class="lineNum">     630 </span>            : <span class="lineNum">     631 </span>            :       virtual const char_type*<span class="lineNum">     632 </span>            :       do_scan_not(mask __m, const char_type* __lo,<span class="lineNum">     633 </span>            :                   const char_type* __hi) const;<span class="lineNum">     634 </span>            : <span class="lineNum">     635 </span>            :       virtual char_type<span class="lineNum">     636 </span>            :       do_toupper(char_type __c) const;<span class="lineNum">     637 </span>            : <span class="lineNum">     638 </span>            :       virtual const char_type*<span class="lineNum">     639 </span>            :       do_toupper(char_type* __lo, const char_type* __hi) const;<span class="lineNum">     640 </span>            : <span class="lineNum">     641 </span>            :       virtual char_type<span class="lineNum">     642 </span>            :       do_tolower(char_type __c) const;<span class="lineNum">     643 </span>            : <span class="lineNum">     644 </span>            :       virtual const char_type*<span class="lineNum">     645 </span>            :       do_tolower(char_type* __lo, const char_type* __hi) const;<span class="lineNum">     646 </span>            : <span class="lineNum">     647 </span>            :       virtual char_type<span class="lineNum">     648 </span>            :       do_widen(char __c) const;<span class="lineNum">     649 </span>            : <span class="lineNum">     650 </span>            :       virtual const char*<span class="lineNum">     651 </span>            :       do_widen(const char* __lo, const char* __hi, char_type* __dest) const;<span class="lineNum">     652 </span>            : <span class="lineNum">     653 </span>            :       virtual char<span class="lineNum">     654 </span>            :       do_narrow(char_type, char __dfault) const;<span class="lineNum">     655 </span>            : <span class="lineNum">     656 </span>            :       virtual const char_type*<span class="lineNum">     657 </span>            :       do_narrow(const char_type* __lo, const char_type* __hi,<span class="lineNum">     658 </span>            :                 char __dfault, char* __to) const;<span class="lineNum">     659 </span>            :     };<span class="lineNum">     660 </span>            : <span class="lineNum">     661 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     662 </span>            :     locale::id ctype&lt;_CharT&gt;::id;<span class="lineNum">     663 </span>            : <span class="lineNum">     664 </span>            :   /**<span class="lineNum">     665 </span>            :    *  @brief  The ctype&lt;char&gt; specialization.<span class="lineNum">     666 </span>            :    *  @ingroup locales<span class="lineNum">     667 </span>            :    *<span class="lineNum">     668 </span>            :    *  This class defines classification and conversion functions for<span class="lineNum">     669 </span>            :    *  the char type.  It gets used by char streams for many I/O<span class="lineNum">     670 </span>            :    *  operations.  The char specialization provides a number of<span class="lineNum">     671 </span>            :    *  optimizations as well.<span class="lineNum">     672 </span>            :   */<span class="lineNum">     673 </span>            :   template&lt;&gt;<span class="lineNum">     674 </span>            :     class ctype&lt;char&gt; : public locale::facet, public ctype_base<span class="lineNum">     675 </span>            :     {<span class="lineNum">     676 </span>            :     public:<span class="lineNum">     677 </span>            :       // Types:<span class="lineNum">     678 </span>            :       /// Typedef for the template parameter char.<span class="lineNum">     679 </span>            :       typedef char              char_type;<span class="lineNum">     680 </span>            : <span class="lineNum">     681 </span>            :     protected:<span class="lineNum">     682 </span>            :       // Data Members:<span class="lineNum">     683 </span>            :       __c_locale                _M_c_locale_ctype;<span class="lineNum">     684 </span>            :       bool                      _M_del;<span class="lineNum">     685 </span>            :       __to_type                 _M_toupper;<span class="lineNum">     686 </span>            :       __to_type                 _M_tolower;<span class="lineNum">     687 </span>            :       const mask*               _M_table;<span class="lineNum">     688 </span>            :       mutable char              _M_widen_ok;<span class="lineNum">     689 </span>            :       mutable char              _M_widen[1 + static_cast&lt;unsigned char&gt;(-1)];<span class="lineNum">     690 </span>            :       mutable char              _M_narrow[1 + static_cast&lt;unsigned char&gt;(-1)];<span class="lineNum">     691 </span>            :       mutable char              _M_narrow_ok;   // 0 uninitialized, 1 init,<span class="lineNum">     692 </span>            :                                                 // 2 memcpy can't be used<span class="lineNum">     693 </span>            : <span class="lineNum">     694 </span>            :     public:<span class="lineNum">     695 </span>            :       /// The facet id for ctype&lt;char&gt;<span class="lineNum">     696 </span>            :       static locale::id        id;<span class="lineNum">     697 </span>            :       /// The size of the mask table.  It is SCHAR_MAX + 1.<span class="lineNum">     698 </span>            :       static const size_t      table_size = 1 + static_cast&lt;unsigned char&gt;(-1);<span class="lineNum">     699 </span>            : <span class="lineNum">     700 </span>            :       /**<span class="lineNum">     701 </span>            :        *  @brief  Constructor performs initialization.<span class="lineNum">     702 </span>            :        *<span class="lineNum">     703 </span>            :        *  This is the constructor provided by the standard.<span class="lineNum">     704 </span>            :        *<span class="lineNum">     705 </span>            :        *  @param __table If non-zero, table is used as the per-char mask.<span class="lineNum">     706 </span>            :        *               Else classic_table() is used.<span class="lineNum">     707 </span>            :        *  @param __del   If true, passes ownership of table to this facet.<span class="lineNum">     708 </span>            :        *  @param __refs  Passed to the base facet class.<span class="lineNum">     709 </span>            :       */<span class="lineNum">     710 </span>            :       explicit<span class="lineNum">     711 </span>            :       ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);<span class="lineNum">     712 </span>            : <span class="lineNum">     713 </span>            :       /**<span class="lineNum">     714 </span>            :        *  @brief  Constructor performs static initialization.<span class="lineNum">     715 </span>            :        *<span class="lineNum">     716 </span>            :        *  This constructor is used to construct the initial C locale facet.<span class="lineNum">     717 </span>            :        *<span class="lineNum">     718 </span>            :        *  @param __cloc  Handle to C locale data.<span class="lineNum">     719 </span>            :        *  @param __table If non-zero, table is used as the per-char mask.<span class="lineNum">     720 </span>            :        *  @param __del   If true, passes ownership of table to this facet.<span class="lineNum">     721 </span>            :        *  @param __refs  Passed to the base facet class.<span class="lineNum">     722 </span>            :       */<span class="lineNum">     723 </span>            :       explicit<span class="lineNum">     724 </span>            :       ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,<span class="lineNum">     725 </span>            :             size_t __refs = 0);<span class="lineNum">     726 </span>            : <span class="lineNum">     727 </span>            :       /**<span class="lineNum">     728 </span>            :        *  @brief  Test char classification.<span class="lineNum">     729 </span>            :        *<span class="lineNum">     730 </span>            :        *  This function compares the mask table[c] to @a __m.<span class="lineNum">     731 </span>            :        *<span class="lineNum">     732 </span>            :        *  @param __c  The char to compare the mask of.<span class="lineNum">     733 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">     734 </span>            :        *  @return  True if __m &amp; table[__c] is true, false otherwise.<span class="lineNum">     735 </span>            :       */<span class="lineNum">     736 </span>            :       inline bool<span class="lineNum">     737 </span>            :       is(mask __m, char __c) const;<span class="lineNum">     738 </span>            : <span class="lineNum">     739 </span>            :       /**<span class="lineNum">     740 </span>            :        *  @brief  Return a mask array.<span class="lineNum">     741 </span>            :        *<span class="lineNum">     742 </span>            :        *  This function finds the mask for each char in the range [lo, hi) and<span class="lineNum">     743 </span>            :        *  successively writes it to vec.  vec must have as many elements as<span class="lineNum">     744 </span>            :        *  the char array.<span class="lineNum">     745 </span>            :        *<span class="lineNum">     746 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     747 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     748 </span>            :        *  @param __vec  Pointer to an array of mask storage.<span class="lineNum">     749 </span>            :        *  @return  @a __hi.<span class="lineNum">     750 </span>            :       */<span class="lineNum">     751 </span>            :       inline const char*<span class="lineNum">     752 </span>            :       is(const char* __lo, const char* __hi, mask* __vec) const;<span class="lineNum">     753 </span>            : <span class="lineNum">     754 </span>            :       /**<span class="lineNum">     755 </span>            :        *  @brief  Find char matching a mask<span class="lineNum">     756 </span>            :        *<span class="lineNum">     757 </span>            :        *  This function searches for and returns the first char in [lo,hi) for<span class="lineNum">     758 </span>            :        *  which is(m,char) is true.<span class="lineNum">     759 </span>            :        *<span class="lineNum">     760 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">     761 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     762 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     763 </span>            :        *  @return  Pointer to a matching char if found, else @a __hi.<span class="lineNum">     764 </span>            :       */<span class="lineNum">     765 </span>            :       inline const char*<span class="lineNum">     766 </span>            :       scan_is(mask __m, const char* __lo, const char* __hi) const;<span class="lineNum">     767 </span>            : <span class="lineNum">     768 </span>            :       /**<span class="lineNum">     769 </span>            :        *  @brief  Find char not matching a mask<span class="lineNum">     770 </span>            :        *<span class="lineNum">     771 </span>            :        *  This function searches for and returns a pointer to the first char<span class="lineNum">     772 </span>            :        *  in [__lo,__hi) for which is(m,char) is false.<span class="lineNum">     773 </span>            :        *<span class="lineNum">     774 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">     775 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     776 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     777 </span>            :        *  @return  Pointer to a non-matching char if found, else @a __hi.<span class="lineNum">     778 </span>            :       */<span class="lineNum">     779 </span>            :       inline const char*<span class="lineNum">     780 </span>            :       scan_not(mask __m, const char* __lo, const char* __hi) const;<span class="lineNum">     781 </span>            : <span class="lineNum">     782 </span>            :       /**<span class="lineNum">     783 </span>            :        *  @brief  Convert to uppercase.<span class="lineNum">     784 </span>            :        *<span class="lineNum">     785 </span>            :        *  This function converts the char argument to uppercase if possible.<span class="lineNum">     786 </span>            :        *  If not possible (for example, '2'), returns the argument.<span class="lineNum">     787 </span>            :        *<span class="lineNum">     788 </span>            :        *  toupper() acts as if it returns ctype&lt;char&gt;::do_toupper(c).<span class="lineNum">     789 </span>            :        *  do_toupper() must always return the same result for the same input.<span class="lineNum">     790 </span>            :        *<span class="lineNum">     791 </span>            :        *  @param __c  The char to convert.<span class="lineNum">     792 </span>            :        *  @return  The uppercase char if convertible, else @a __c.<span class="lineNum">     793 </span>            :       */<span class="lineNum">     794 </span>            :       char_type<span class="lineNum">     795 </span>            :       toupper(char_type __c) const<span class="lineNum">     796 </span>            :       { return this-&gt;do_toupper(__c); }<span class="lineNum">     797 </span>            : <span class="lineNum">     798 </span>            :       /**<span class="lineNum">     799 </span>            :        *  @brief  Convert array to uppercase.<span class="lineNum">     800 </span>            :        *<span class="lineNum">     801 </span>            :        *  This function converts each char in the range [__lo,__hi) to uppercase<span class="lineNum">     802 </span>            :        *  if possible.  Other chars remain untouched.<span class="lineNum">     803 </span>            :        *<span class="lineNum">     804 </span>            :        *  toupper() acts as if it returns ctype&lt;char&gt;:: do_toupper(__lo, __hi).<span class="lineNum">     805 </span>            :        *  do_toupper() must always return the same result for the same input.<span class="lineNum">     806 </span>            :        *<span class="lineNum">     807 </span>            :        *  @param __lo  Pointer to first char in range.<span class="lineNum">     808 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     809 </span>            :        *  @return  @a __hi.<span class="lineNum">     810 </span>            :       */<span class="lineNum">     811 </span>            :       const char_type*<span class="lineNum">     812 </span>            :       toupper(char_type *__lo, const char_type* __hi) const<span class="lineNum">     813 </span>            :       { return this-&gt;do_toupper(__lo, __hi); }<span class="lineNum">     814 </span>            : <span class="lineNum">     815 </span>            :       /**<span class="lineNum">     816 </span>            :        *  @brief  Convert to lowercase.<span class="lineNum">     817 </span>            :        *<span class="lineNum">     818 </span>            :        *  This function converts the char argument to lowercase if possible.<span class="lineNum">     819 </span>            :        *  If not possible (for example, '2'), returns the argument.<span class="lineNum">     820 </span>            :        *<span class="lineNum">     821 </span>            :        *  tolower() acts as if it returns ctype&lt;char&gt;::do_tolower(__c).<span class="lineNum">     822 </span>            :        *  do_tolower() must always return the same result for the same input.<span class="lineNum">     823 </span>            :        *<span class="lineNum">     824 </span>            :        *  @param __c  The char to convert.<span class="lineNum">     825 </span>            :        *  @return  The lowercase char if convertible, else @a __c.<span class="lineNum">     826 </span>            :       */<span class="lineNum">     827 </span>            :       char_type<span class="lineNum">     828 </span>            :       tolower(char_type __c) const<span class="lineNum">     829 </span>            :       { return this-&gt;do_tolower(__c); }<span class="lineNum">     830 </span>            : <span class="lineNum">     831 </span>            :       /**<span class="lineNum">     832 </span>            :        *  @brief  Convert array to lowercase.<span class="lineNum">     833 </span>            :        *<span class="lineNum">     834 </span>            :        *  This function converts each char in the range [lo,hi) to lowercase<span class="lineNum">     835 </span>            :        *  if possible.  Other chars remain untouched.<span class="lineNum">     836 </span>            :        *<span class="lineNum">     837 </span>            :        *  tolower() acts as if it returns ctype&lt;char&gt;:: do_tolower(__lo, __hi).<span class="lineNum">     838 </span>            :        *  do_tolower() must always return the same result for the same input.<span class="lineNum">     839 </span>            :        *<span class="lineNum">     840 </span>            :        *  @param __lo  Pointer to first char in range.<span class="lineNum">     841 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     842 </span>            :        *  @return  @a __hi.<span class="lineNum">     843 </span>            :       */<span class="lineNum">     844 </span>            :       const char_type*<span class="lineNum">     845 </span>            :       tolower(char_type* __lo, const char_type* __hi) const<span class="lineNum">     846 </span>            :       { return this-&gt;do_tolower(__lo, __hi); }<span class="lineNum">     847 </span>            : <span class="lineNum">     848 </span>            :       /**<span class="lineNum">     849 </span>            :        *  @brief  Widen char<span class="lineNum">     850 </span>            :        *<span class="lineNum">     851 </span>            :        *  This function converts the char to char_type using the simplest<span class="lineNum">     852 </span>            :        *  reasonable transformation.  For an underived ctype&lt;char&gt; facet, the<span class="lineNum">     853 </span>            :        *  argument will be returned unchanged.<span class="lineNum">     854 </span>            :        *<span class="lineNum">     855 </span>            :        *  This function works as if it returns ctype&lt;char&gt;::do_widen(c).<span class="lineNum">     856 </span>            :        *  do_widen() must always return the same result for the same input.<span class="lineNum">     857 </span>            :        *<span class="lineNum">     858 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     859 </span>            :        *  codecvt for that.<span class="lineNum">     860 </span>            :        *<span class="lineNum">     861 </span>            :        *  @param __c  The char to convert.<span class="lineNum">     862 </span>            :        *  @return  The converted character.<a name="863"><span class="lineNum">     863 </span>            :       */</a><span class="lineNum">     864 </span>            :       char_type<span class="lineNum">     865 </span><span class="lineNoCov">          0 :       widen(char __c) const</span><span class="lineNum">     866 </span>            :       {<span class="lineNum">     867 </span><span class="lineNoCov">          0 :         if (_M_widen_ok)</span><span class="lineNum">     868 </span><span class="lineNoCov">          0 :           return _M_widen[static_cast&lt;unsigned char&gt;(__c)];</span><span class="lineNum">     869 </span><span class="lineNoCov">          0 :         this-&gt;_M_widen_init();</span><span class="lineNum">     870 </span><span class="lineNoCov">          0 :         return this-&gt;do_widen(__c);</span><span class="lineNum">     871 </span>            :       }<span class="lineNum">     872 </span>            : <span class="lineNum">     873 </span>            :       /**<span class="lineNum">     874 </span>            :        *  @brief  Widen char array<span class="lineNum">     875 </span>            :        *<span class="lineNum">     876 </span>            :        *  This function converts each char in the input to char using the<span class="lineNum">     877 </span>            :        *  simplest reasonable transformation.  For an underived ctype&lt;char&gt;<span class="lineNum">     878 </span>            :        *  facet, the argument will be copied unchanged.<span class="lineNum">     879 </span>            :        *<span class="lineNum">     880 </span>            :        *  This function works as if it returns ctype&lt;char&gt;::do_widen(c).<span class="lineNum">     881 </span>            :        *  do_widen() must always return the same result for the same input.<span class="lineNum">     882 </span>            :        *<span class="lineNum">     883 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     884 </span>            :        *  codecvt for that.<span class="lineNum">     885 </span>            :        *<span class="lineNum">     886 </span>            :        *  @param __lo  Pointer to first char in range.<span class="lineNum">     887 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     888 </span>            :        *  @param __to  Pointer to the destination array.<span class="lineNum">     889 </span>            :        *  @return  @a __hi.<span class="lineNum">     890 </span>            :       */<span class="lineNum">     891 </span>            :       const char*<span class="lineNum">     892 </span>            :       widen(const char* __lo, const char* __hi, char_type* __to) const<span class="lineNum">     893 </span>            :       {<span class="lineNum">     894 </span>            :         if (_M_widen_ok == 1)<span class="lineNum">     895 </span>            :           {<span class="lineNum">     896 </span>            :             __builtin_memcpy(__to, __lo, __hi - __lo);<span class="lineNum">     897 </span>            :             return __hi;<span class="lineNum">     898 </span>            :           }<span class="lineNum">     899 </span>            :         if (!_M_widen_ok)<span class="lineNum">     900 </span>            :           _M_widen_init();<span class="lineNum">     901 </span>            :         return this-&gt;do_widen(__lo, __hi, __to);<span class="lineNum">     902 </span>            :       }<span class="lineNum">     903 </span>            : <span class="lineNum">     904 </span>            :       /**<span class="lineNum">     905 </span>            :        *  @brief  Narrow char<span class="lineNum">     906 </span>            :        *<span class="lineNum">     907 </span>            :        *  This function converts the char to char using the simplest<span class="lineNum">     908 </span>            :        *  reasonable transformation.  If the conversion fails, dfault is<span class="lineNum">     909 </span>            :        *  returned instead.  For an underived ctype&lt;char&gt; facet, @a c<span class="lineNum">     910 </span>            :        *  will be returned unchanged.<span class="lineNum">     911 </span>            :        *<span class="lineNum">     912 </span>            :        *  This function works as if it returns ctype&lt;char&gt;::do_narrow(c).<span class="lineNum">     913 </span>            :        *  do_narrow() must always return the same result for the same input.<span class="lineNum">     914 </span>            :        *<span class="lineNum">     915 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     916 </span>            :        *  codecvt for that.<span class="lineNum">     917 </span>            :        *<span class="lineNum">     918 </span>            :        *  @param __c  The char to convert.<span class="lineNum">     919 </span>            :        *  @param __dfault  Char to return if conversion fails.<span class="lineNum">     920 </span>            :        *  @return  The converted character.<span class="lineNum">     921 </span>            :       */<span class="lineNum">     922 </span>            :       char<span class="lineNum">     923 </span>            :       narrow(char_type __c, char __dfault) const<span class="lineNum">     924 </span>            :       {<span class="lineNum">     925 </span>            :         if (_M_narrow[static_cast&lt;unsigned char&gt;(__c)])<span class="lineNum">     926 </span>            :           return _M_narrow[static_cast&lt;unsigned char&gt;(__c)];<span class="lineNum">     927 </span>            :         const char __t = do_narrow(__c, __dfault);<span class="lineNum">     928 </span>            :         if (__t != __dfault)<span class="lineNum">     929 </span>            :           _M_narrow[static_cast&lt;unsigned char&gt;(__c)] = __t;<span class="lineNum">     930 </span>            :         return __t;<span class="lineNum">     931 </span>            :       }<span class="lineNum">     932 </span>            : <span class="lineNum">     933 </span>            :       /**<span class="lineNum">     934 </span>            :        *  @brief  Narrow char array<span class="lineNum">     935 </span>            :        *<span class="lineNum">     936 </span>            :        *  This function converts each char in the input to char using the<span class="lineNum">     937 </span>            :        *  simplest reasonable transformation and writes the results to the<span class="lineNum">     938 </span>            :        *  destination array.  For any char in the input that cannot be<span class="lineNum">     939 </span>            :        *  converted, @a dfault is used instead.  For an underived ctype&lt;char&gt;<span class="lineNum">     940 </span>            :        *  facet, the argument will be copied unchanged.<span class="lineNum">     941 </span>            :        *<span class="lineNum">     942 </span>            :        *  This function works as if it returns ctype&lt;char&gt;::do_narrow(lo, hi,<span class="lineNum">     943 </span>            :        *  dfault, to).  do_narrow() must always return the same result for the<span class="lineNum">     944 </span>            :        *  same input.<span class="lineNum">     945 </span>            :        *<span class="lineNum">     946 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">     947 </span>            :        *  codecvt for that.<span class="lineNum">     948 </span>            :        *<span class="lineNum">     949 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">     950 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">     951 </span>            :        *  @param __dfault  Char to use if conversion fails.<span class="lineNum">     952 </span>            :        *  @param __to  Pointer to the destination array.<span class="lineNum">     953 </span>            :        *  @return  @a __hi.<span class="lineNum">     954 </span>            :       */<span class="lineNum">     955 </span>            :       const char_type*<span class="lineNum">     956 </span>            :       narrow(const char_type* __lo, const char_type* __hi,<span class="lineNum">     957 </span>            :              char __dfault, char* __to) const<span class="lineNum">     958 </span>            :       {<span class="lineNum">     959 </span>            :         if (__builtin_expect(_M_narrow_ok == 1, true))<span class="lineNum">     960 </span>            :           {<span class="lineNum">     961 </span>            :             __builtin_memcpy(__to, __lo, __hi - __lo);<span class="lineNum">     962 </span>            :             return __hi;<span class="lineNum">     963 </span>            :           }<span class="lineNum">     964 </span>            :         if (!_M_narrow_ok)<span class="lineNum">     965 </span>            :           _M_narrow_init();<span class="lineNum">     966 </span>            :         return this-&gt;do_narrow(__lo, __hi, __dfault, __to);<span class="lineNum">     967 </span>            :       }<span class="lineNum">     968 </span>            : <span class="lineNum">     969 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     970 </span>            :       // DR 695. ctype&lt;char&gt;::classic_table() not accessible.<span class="lineNum">     971 </span>            :       /// Returns a pointer to the mask table provided to the constructor, or<span class="lineNum">     972 </span>            :       /// the default from classic_table() if none was provided.<span class="lineNum">     973 </span>            :       const mask*<span class="lineNum">     974 </span>            :       table() const throw()<span class="lineNum">     975 </span>            :       { return _M_table; }<span class="lineNum">     976 </span>            : <span class="lineNum">     977 </span>            :       /// Returns a pointer to the C locale mask table.<span class="lineNum">     978 </span>            :       static const mask*<span class="lineNum">     979 </span>            :       classic_table() throw();<span class="lineNum">     980 </span>            :     protected:<span class="lineNum">     981 </span>            : <span class="lineNum">     982 </span>            :       /**<span class="lineNum">     983 </span>            :        *  @brief  Destructor.<span class="lineNum">     984 </span>            :        *<span class="lineNum">     985 </span>            :        *  This function deletes table() if @a del was true in the<span class="lineNum">     986 </span>            :        *  constructor.<span class="lineNum">     987 </span>            :       */<span class="lineNum">     988 </span>            :       virtual<span class="lineNum">     989 </span>            :       ~ctype();<span class="lineNum">     990 </span>            : <span class="lineNum">     991 </span>            :       /**<span class="lineNum">     992 </span>            :        *  @brief  Convert to uppercase.<span class="lineNum">     993 </span>            :        *<span class="lineNum">     994 </span>            :        *  This virtual function converts the char argument to uppercase if<span class="lineNum">     995 </span>            :        *  possible.  If not possible (for example, '2'), returns the argument.<span class="lineNum">     996 </span>            :        *<span class="lineNum">     997 </span>            :        *  do_toupper() is a hook for a derived facet to change the behavior of<span class="lineNum">     998 </span>            :        *  uppercasing.  do_toupper() must always return the same result for<span class="lineNum">     999 </span>            :        *  the same input.<span class="lineNum">    1000 </span>            :        *<span class="lineNum">    1001 </span>            :        *  @param __c  The char to convert.<span class="lineNum">    1002 </span>            :        *  @return  The uppercase char if convertible, else @a __c.<span class="lineNum">    1003 </span>            :       */<span class="lineNum">    1004 </span>            :       virtual char_type<span class="lineNum">    1005 </span>            :       do_toupper(char_type __c) const;<span class="lineNum">    1006 </span>            : <span class="lineNum">    1007 </span>            :       /**<span class="lineNum">    1008 </span>            :        *  @brief  Convert array to uppercase.<span class="lineNum">    1009 </span>            :        *<span class="lineNum">    1010 </span>            :        *  This virtual function converts each char in the range [lo,hi) to<span class="lineNum">    1011 </span>            :        *  uppercase if possible.  Other chars remain untouched.<span class="lineNum">    1012 </span>            :        *<span class="lineNum">    1013 </span>            :        *  do_toupper() is a hook for a derived facet to change the behavior of<span class="lineNum">    1014 </span>            :        *  uppercasing.  do_toupper() must always return the same result for<span class="lineNum">    1015 </span>            :        *  the same input.<span class="lineNum">    1016 </span>            :        *<span class="lineNum">    1017 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">    1018 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1019 </span>            :        *  @return  @a __hi.<span class="lineNum">    1020 </span>            :       */<span class="lineNum">    1021 </span>            :       virtual const char_type*<span class="lineNum">    1022 </span>            :       do_toupper(char_type* __lo, const char_type* __hi) const;<span class="lineNum">    1023 </span>            : <span class="lineNum">    1024 </span>            :       /**<span class="lineNum">    1025 </span>            :        *  @brief  Convert to lowercase.<span class="lineNum">    1026 </span>            :        *<span class="lineNum">    1027 </span>            :        *  This virtual function converts the char argument to lowercase if<span class="lineNum">    1028 </span>            :        *  possible.  If not possible (for example, '2'), returns the argument.<span class="lineNum">    1029 </span>            :        *<span class="lineNum">    1030 </span>            :        *  do_tolower() is a hook for a derived facet to change the behavior of<span class="lineNum">    1031 </span>            :        *  lowercasing.  do_tolower() must always return the same result for<span class="lineNum">    1032 </span>            :        *  the same input.<span class="lineNum">    1033 </span>            :        *<span class="lineNum">    1034 </span>            :        *  @param __c  The char to convert.<span class="lineNum">    1035 </span>            :        *  @return  The lowercase char if convertible, else @a __c.<span class="lineNum">    1036 </span>            :       */<span class="lineNum">    1037 </span>            :       virtual char_type<span class="lineNum">    1038 </span>            :       do_tolower(char_type __c) const;<span class="lineNum">    1039 </span>            : <span class="lineNum">    1040 </span>            :       /**<span class="lineNum">    1041 </span>            :        *  @brief  Convert array to lowercase.<span class="lineNum">    1042 </span>            :        *<span class="lineNum">    1043 </span>            :        *  This virtual function converts each char in the range [lo,hi) to<span class="lineNum">    1044 </span>            :        *  lowercase if possible.  Other chars remain untouched.<span class="lineNum">    1045 </span>            :        *<span class="lineNum">    1046 </span>            :        *  do_tolower() is a hook for a derived facet to change the behavior of<span class="lineNum">    1047 </span>            :        *  lowercasing.  do_tolower() must always return the same result for<span class="lineNum">    1048 </span>            :        *  the same input.<span class="lineNum">    1049 </span>            :        *<span class="lineNum">    1050 </span>            :        *  @param __lo  Pointer to first char in range.<span class="lineNum">    1051 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1052 </span>            :        *  @return  @a __hi.<span class="lineNum">    1053 </span>            :       */<span class="lineNum">    1054 </span>            :       virtual const char_type*<span class="lineNum">    1055 </span>            :       do_tolower(char_type* __lo, const char_type* __hi) const;<span class="lineNum">    1056 </span>            : <span class="lineNum">    1057 </span>            :       /**<span class="lineNum">    1058 </span>            :        *  @brief  Widen char<span class="lineNum">    1059 </span>            :        *<span class="lineNum">    1060 </span>            :        *  This virtual function converts the char to char using the simplest<span class="lineNum">    1061 </span>            :        *  reasonable transformation.  For an underived ctype&lt;char&gt; facet, the<span class="lineNum">    1062 </span>            :        *  argument will be returned unchanged.<span class="lineNum">    1063 </span>            :        *<span class="lineNum">    1064 </span>            :        *  do_widen() is a hook for a derived facet to change the behavior of<span class="lineNum">    1065 </span>            :        *  widening.  do_widen() must always return the same result for the<span class="lineNum">    1066 </span>            :        *  same input.<span class="lineNum">    1067 </span>            :        *<span class="lineNum">    1068 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">    1069 </span>            :        *  codecvt for that.<span class="lineNum">    1070 </span>            :        *<span class="lineNum">    1071 </span>            :        *  @param __c  The char to convert.<span class="lineNum">    1072 </span>            :        *  @return  The converted character.<span class="lineNum">    1073 </span>            :       */<span class="lineNum">    1074 </span>            :       virtual char_type<span class="lineNum">    1075 </span>            :       do_widen(char __c) const<span class="lineNum">    1076 </span>            :       { return __c; }<span class="lineNum">    1077 </span>            : <span class="lineNum">    1078 </span>            :       /**<span class="lineNum">    1079 </span>            :        *  @brief  Widen char array<span class="lineNum">    1080 </span>            :        *<span class="lineNum">    1081 </span>            :        *  This function converts each char in the range [lo,hi) to char using<span class="lineNum">    1082 </span>            :        *  the simplest reasonable transformation.  For an underived<span class="lineNum">    1083 </span>            :        *  ctype&lt;char&gt; facet, the argument will be copied unchanged.<span class="lineNum">    1084 </span>            :        *<span class="lineNum">    1085 </span>            :        *  do_widen() is a hook for a derived facet to change the behavior of<span class="lineNum">    1086 </span>            :        *  widening.  do_widen() must always return the same result for the<span class="lineNum">    1087 </span>            :        *  same input.<span class="lineNum">    1088 </span>            :        *<span class="lineNum">    1089 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">    1090 </span>            :        *  codecvt for that.<span class="lineNum">    1091 </span>            :        *<span class="lineNum">    1092 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">    1093 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1094 </span>            :        *  @param __to  Pointer to the destination array.<span class="lineNum">    1095 </span>            :        *  @return  @a __hi.<span class="lineNum">    1096 </span>            :       */<span class="lineNum">    1097 </span>            :       virtual const char*<span class="lineNum">    1098 </span>            :       do_widen(const char* __lo, const char* __hi, char_type* __to) const<span class="lineNum">    1099 </span>            :       {<span class="lineNum">    1100 </span>            :         __builtin_memcpy(__to, __lo, __hi - __lo);<span class="lineNum">    1101 </span>            :         return __hi;<span class="lineNum">    1102 </span>            :       }<span class="lineNum">    1103 </span>            : <span class="lineNum">    1104 </span>            :       /**<span class="lineNum">    1105 </span>            :        *  @brief  Narrow char<span class="lineNum">    1106 </span>            :        *<span class="lineNum">    1107 </span>            :        *  This virtual function converts the char to char using the simplest<span class="lineNum">    1108 </span>            :        *  reasonable transformation.  If the conversion fails, dfault is<span class="lineNum">    1109 </span>            :        *  returned instead.  For an underived ctype&lt;char&gt; facet, @a c will be<span class="lineNum">    1110 </span>            :        *  returned unchanged.<span class="lineNum">    1111 </span>            :        *<span class="lineNum">    1112 </span>            :        *  do_narrow() is a hook for a derived facet to change the behavior of<span class="lineNum">    1113 </span>            :        *  narrowing.  do_narrow() must always return the same result for the<span class="lineNum">    1114 </span>            :        *  same input.<span class="lineNum">    1115 </span>            :        *<span class="lineNum">    1116 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">    1117 </span>            :        *  codecvt for that.<span class="lineNum">    1118 </span>            :        *<span class="lineNum">    1119 </span>            :        *  @param __c  The char to convert.<span class="lineNum">    1120 </span>            :        *  @param __dfault  Char to return if conversion fails.<span class="lineNum">    1121 </span>            :        *  @return  The converted char.<span class="lineNum">    1122 </span>            :       */<span class="lineNum">    1123 </span>            :       virtual char<span class="lineNum">    1124 </span>            :       do_narrow(char_type __c, char __dfault) const<span class="lineNum">    1125 </span>            :       { return __c; }<span class="lineNum">    1126 </span>            : <span class="lineNum">    1127 </span>            :       /**<span class="lineNum">    1128 </span>            :        *  @brief  Narrow char array to char array<span class="lineNum">    1129 </span>            :        *<span class="lineNum">    1130 </span>            :        *  This virtual function converts each char in the range [lo,hi) to<span class="lineNum">    1131 </span>            :        *  char using the simplest reasonable transformation and writes the<span class="lineNum">    1132 </span>            :        *  results to the destination array.  For any char in the input that<span class="lineNum">    1133 </span>            :        *  cannot be converted, @a dfault is used instead.  For an underived<span class="lineNum">    1134 </span>            :        *  ctype&lt;char&gt; facet, the argument will be copied unchanged.<span class="lineNum">    1135 </span>            :        *<span class="lineNum">    1136 </span>            :        *  do_narrow() is a hook for a derived facet to change the behavior of<span class="lineNum">    1137 </span>            :        *  narrowing.  do_narrow() must always return the same result for the<span class="lineNum">    1138 </span>            :        *  same input.<span class="lineNum">    1139 </span>            :        *<span class="lineNum">    1140 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">    1141 </span>            :        *  codecvt for that.<span class="lineNum">    1142 </span>            :        *<span class="lineNum">    1143 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">    1144 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1145 </span>            :        *  @param __dfault  Char to use if conversion fails.<span class="lineNum">    1146 </span>            :        *  @param __to  Pointer to the destination array.<span class="lineNum">    1147 </span>            :        *  @return  @a __hi.<span class="lineNum">    1148 </span>            :       */<span class="lineNum">    1149 </span>            :       virtual const char_type*<span class="lineNum">    1150 </span>            :       do_narrow(const char_type* __lo, const char_type* __hi,<span class="lineNum">    1151 </span>            :                 char __dfault, char* __to) const<span class="lineNum">    1152 </span>            :       {<span class="lineNum">    1153 </span>            :         __builtin_memcpy(__to, __lo, __hi - __lo);<span class="lineNum">    1154 </span>            :         return __hi;<span class="lineNum">    1155 </span>            :       }<span class="lineNum">    1156 </span>            : <span class="lineNum">    1157 </span>            :     private:<span class="lineNum">    1158 </span>            :       void _M_narrow_init() const;<span class="lineNum">    1159 </span>            :       void _M_widen_init() const;<span class="lineNum">    1160 </span>            :     };<span class="lineNum">    1161 </span>            : <span class="lineNum">    1162 </span>            : #ifdef _GLIBCXX_USE_WCHAR_T<span class="lineNum">    1163 </span>            :   /**<span class="lineNum">    1164 </span>            :    *  @brief  The ctype&lt;wchar_t&gt; specialization.<span class="lineNum">    1165 </span>            :    *  @ingroup locales<span class="lineNum">    1166 </span>            :    *<span class="lineNum">    1167 </span>            :    *  This class defines classification and conversion functions for the<span class="lineNum">    1168 </span>            :    *  wchar_t type.  It gets used by wchar_t streams for many I/O operations.<span class="lineNum">    1169 </span>            :    *  The wchar_t specialization provides a number of optimizations as well.<span class="lineNum">    1170 </span>            :    *<span class="lineNum">    1171 </span>            :    *  ctype&lt;wchar_t&gt; inherits its public methods from<span class="lineNum">    1172 </span>            :    *  __ctype_abstract_base&lt;wchar_t&gt;.<span class="lineNum">    1173 </span>            :   */<span class="lineNum">    1174 </span>            :   template&lt;&gt;<span class="lineNum">    1175 </span>            :     class ctype&lt;wchar_t&gt; : public __ctype_abstract_base&lt;wchar_t&gt;<span class="lineNum">    1176 </span>            :     {<span class="lineNum">    1177 </span>            :     public:<span class="lineNum">    1178 </span>            :       // Types:<span class="lineNum">    1179 </span>            :       /// Typedef for the template parameter wchar_t.<span class="lineNum">    1180 </span>            :       typedef wchar_t           char_type;<span class="lineNum">    1181 </span>            :       typedef wctype_t          __wmask_type;<span class="lineNum">    1182 </span>            : <span class="lineNum">    1183 </span>            :     protected:<span class="lineNum">    1184 </span>            :       __c_locale                _M_c_locale_ctype;<span class="lineNum">    1185 </span>            : <span class="lineNum">    1186 </span>            :       // Pre-computed narrowed and widened chars.<span class="lineNum">    1187 </span>            :       bool                      _M_narrow_ok;<span class="lineNum">    1188 </span>            :       char                      _M_narrow[128];<span class="lineNum">    1189 </span>            :       wint_t                    _M_widen[1 + static_cast&lt;unsigned char&gt;(-1)];<span class="lineNum">    1190 </span>            : <span class="lineNum">    1191 </span>            :       // Pre-computed elements for do_is.<span class="lineNum">    1192 </span>            :       mask                      _M_bit[16];<span class="lineNum">    1193 </span>            :       __wmask_type              _M_wmask[16];<span class="lineNum">    1194 </span>            : <span class="lineNum">    1195 </span>            :     public:<span class="lineNum">    1196 </span>            :       // Data Members:<span class="lineNum">    1197 </span>            :       /// The facet id for ctype&lt;wchar_t&gt;<span class="lineNum">    1198 </span>            :       static locale::id         id;<span class="lineNum">    1199 </span>            : <span class="lineNum">    1200 </span>            :       /**<span class="lineNum">    1201 </span>            :        *  @brief  Constructor performs initialization.<span class="lineNum">    1202 </span>            :        *<span class="lineNum">    1203 </span>            :        *  This is the constructor provided by the standard.<span class="lineNum">    1204 </span>            :        *<span class="lineNum">    1205 </span>            :        *  @param __refs  Passed to the base facet class.<span class="lineNum">    1206 </span>            :       */<span class="lineNum">    1207 </span>            :       explicit<span class="lineNum">    1208 </span>            :       ctype(size_t __refs = 0);<span class="lineNum">    1209 </span>            : <span class="lineNum">    1210 </span>            :       /**<span class="lineNum">    1211 </span>            :        *  @brief  Constructor performs static initialization.<span class="lineNum">    1212 </span>            :        *<span class="lineNum">    1213 </span>            :        *  This constructor is used to construct the initial C locale facet.<span class="lineNum">    1214 </span>            :        *<span class="lineNum">    1215 </span>            :        *  @param __cloc  Handle to C locale data.<span class="lineNum">    1216 </span>            :        *  @param __refs  Passed to the base facet class.<span class="lineNum">    1217 </span>            :       */<span class="lineNum">    1218 </span>            :       explicit<span class="lineNum">    1219 </span>            :       ctype(__c_locale __cloc, size_t __refs = 0);<span class="lineNum">    1220 </span>            : <span class="lineNum">    1221 </span>            :     protected:<span class="lineNum">    1222 </span>            :       __wmask_type<span class="lineNum">    1223 </span>            :       _M_convert_to_wmask(const mask __m) const throw();<span class="lineNum">    1224 </span>            : <span class="lineNum">    1225 </span>            :       /// Destructor<span class="lineNum">    1226 </span>            :       virtual<span class="lineNum">    1227 </span>            :       ~ctype();<span class="lineNum">    1228 </span>            : <span class="lineNum">    1229 </span>            :       /**<span class="lineNum">    1230 </span>            :        *  @brief  Test wchar_t classification.<span class="lineNum">    1231 </span>            :        *<span class="lineNum">    1232 </span>            :        *  This function finds a mask M for @a c and compares it to mask @a m.<span class="lineNum">    1233 </span>            :        *<span class="lineNum">    1234 </span>            :        *  do_is() is a hook for a derived facet to change the behavior of<span class="lineNum">    1235 </span>            :        *  classifying.  do_is() must always return the same result for the<span class="lineNum">    1236 </span>            :        *  same input.<span class="lineNum">    1237 </span>            :        *<span class="lineNum">    1238 </span>            :        *  @param __c  The wchar_t to find the mask of.<span class="lineNum">    1239 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">    1240 </span>            :        *  @return  (M &amp; __m) != 0.<span class="lineNum">    1241 </span>            :       */<span class="lineNum">    1242 </span>            :       virtual bool<span class="lineNum">    1243 </span>            :       do_is(mask __m, char_type __c) const;<span class="lineNum">    1244 </span>            : <span class="lineNum">    1245 </span>            :       /**<span class="lineNum">    1246 </span>            :        *  @brief  Return a mask array.<span class="lineNum">    1247 </span>            :        *<span class="lineNum">    1248 </span>            :        *  This function finds the mask for each wchar_t in the range [lo,hi)<span class="lineNum">    1249 </span>            :        *  and successively writes it to vec.  vec must have as many elements<span class="lineNum">    1250 </span>            :        *  as the input.<span class="lineNum">    1251 </span>            :        *<span class="lineNum">    1252 </span>            :        *  do_is() is a hook for a derived facet to change the behavior of<span class="lineNum">    1253 </span>            :        *  classifying.  do_is() must always return the same result for the<span class="lineNum">    1254 </span>            :        *  same input.<span class="lineNum">    1255 </span>            :        *<span class="lineNum">    1256 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">    1257 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1258 </span>            :        *  @param __vec  Pointer to an array of mask storage.<span class="lineNum">    1259 </span>            :        *  @return  @a __hi.<span class="lineNum">    1260 </span>            :       */<span class="lineNum">    1261 </span>            :       virtual const char_type*<span class="lineNum">    1262 </span>            :       do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;<span class="lineNum">    1263 </span>            : <span class="lineNum">    1264 </span>            :       /**<span class="lineNum">    1265 </span>            :        *  @brief  Find wchar_t matching mask<span class="lineNum">    1266 </span>            :        *<span class="lineNum">    1267 </span>            :        *  This function searches for and returns the first wchar_t c in<span class="lineNum">    1268 </span>            :        *  [__lo,__hi) for which is(__m,c) is true.<span class="lineNum">    1269 </span>            :        *<span class="lineNum">    1270 </span>            :        *  do_scan_is() is a hook for a derived facet to change the behavior of<span class="lineNum">    1271 </span>            :        *  match searching.  do_is() must always return the same result for the<span class="lineNum">    1272 </span>            :        *  same input.<span class="lineNum">    1273 </span>            :        *<span class="lineNum">    1274 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">    1275 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">    1276 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1277 </span>            :        *  @return  Pointer to a matching wchar_t if found, else @a __hi.<span class="lineNum">    1278 </span>            :       */<span class="lineNum">    1279 </span>            :       virtual const char_type*<span class="lineNum">    1280 </span>            :       do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;<span class="lineNum">    1281 </span>            : <span class="lineNum">    1282 </span>            :       /**<span class="lineNum">    1283 </span>            :        *  @brief  Find wchar_t not matching mask<span class="lineNum">    1284 </span>            :        *<span class="lineNum">    1285 </span>            :        *  This function searches for and returns a pointer to the first<span class="lineNum">    1286 </span>            :        *  wchar_t c of [__lo,__hi) for which is(__m,c) is false.<span class="lineNum">    1287 </span>            :        *<span class="lineNum">    1288 </span>            :        *  do_scan_is() is a hook for a derived facet to change the behavior of<span class="lineNum">    1289 </span>            :        *  match searching.  do_is() must always return the same result for the<span class="lineNum">    1290 </span>            :        *  same input.<span class="lineNum">    1291 </span>            :        *<span class="lineNum">    1292 </span>            :        *  @param __m  The mask to compare against.<span class="lineNum">    1293 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">    1294 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1295 </span>            :        *  @return  Pointer to a non-matching wchar_t if found, else @a __hi.<span class="lineNum">    1296 </span>            :       */<span class="lineNum">    1297 </span>            :       virtual const char_type*<span class="lineNum">    1298 </span>            :       do_scan_not(mask __m, const char_type* __lo,<span class="lineNum">    1299 </span>            :                   const char_type* __hi) const;<span class="lineNum">    1300 </span>            : <span class="lineNum">    1301 </span>            :       /**<span class="lineNum">    1302 </span>            :        *  @brief  Convert to uppercase.<span class="lineNum">    1303 </span>            :        *<span class="lineNum">    1304 </span>            :        *  This virtual function converts the wchar_t argument to uppercase if<span class="lineNum">    1305 </span>            :        *  possible.  If not possible (for example, '2'), returns the argument.<span class="lineNum">    1306 </span>            :        *<span class="lineNum">    1307 </span>            :        *  do_toupper() is a hook for a derived facet to change the behavior of<span class="lineNum">    1308 </span>            :        *  uppercasing.  do_toupper() must always return the same result for<span class="lineNum">    1309 </span>            :        *  the same input.<span class="lineNum">    1310 </span>            :        *<span class="lineNum">    1311 </span>            :        *  @param __c  The wchar_t to convert.<span class="lineNum">    1312 </span>            :        *  @return  The uppercase wchar_t if convertible, else @a __c.<span class="lineNum">    1313 </span>            :       */<span class="lineNum">    1314 </span>            :       virtual char_type<span class="lineNum">    1315 </span>            :       do_toupper(char_type __c) const;<span class="lineNum">    1316 </span>            : <span class="lineNum">    1317 </span>            :       /**<span class="lineNum">    1318 </span>            :        *  @brief  Convert array to uppercase.<span class="lineNum">    1319 </span>            :        *<span class="lineNum">    1320 </span>            :        *  This virtual function converts each wchar_t in the range [lo,hi) to<span class="lineNum">    1321 </span>            :        *  uppercase if possible.  Other elements remain untouched.<span class="lineNum">    1322 </span>            :        *<span class="lineNum">    1323 </span>            :        *  do_toupper() is a hook for a derived facet to change the behavior of<span class="lineNum">    1324 </span>            :        *  uppercasing.  do_toupper() must always return the same result for<span class="lineNum">    1325 </span>            :        *  the same input.<span class="lineNum">    1326 </span>            :        *<span class="lineNum">    1327 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">    1328 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1329 </span>            :        *  @return  @a __hi.<span class="lineNum">    1330 </span>            :       */<span class="lineNum">    1331 </span>            :       virtual const char_type*<span class="lineNum">    1332 </span>            :       do_toupper(char_type* __lo, const char_type* __hi) const;<span class="lineNum">    1333 </span>            : <span class="lineNum">    1334 </span>            :       /**<span class="lineNum">    1335 </span>            :        *  @brief  Convert to lowercase.<span class="lineNum">    1336 </span>            :        *<span class="lineNum">    1337 </span>            :        *  This virtual function converts the argument to lowercase if<span class="lineNum">    1338 </span>            :        *  possible.  If not possible (for example, '2'), returns the argument.<span class="lineNum">    1339 </span>            :        *<span class="lineNum">    1340 </span>            :        *  do_tolower() is a hook for a derived facet to change the behavior of<span class="lineNum">    1341 </span>            :        *  lowercasing.  do_tolower() must always return the same result for<span class="lineNum">    1342 </span>            :        *  the same input.<span class="lineNum">    1343 </span>            :        *<span class="lineNum">    1344 </span>            :        *  @param __c  The wchar_t to convert.<span class="lineNum">    1345 </span>            :        *  @return  The lowercase wchar_t if convertible, else @a __c.<span class="lineNum">    1346 </span>            :       */<span class="lineNum">    1347 </span>            :       virtual char_type<span class="lineNum">    1348 </span>            :       do_tolower(char_type __c) const;<span class="lineNum">    1349 </span>            : <span class="lineNum">    1350 </span>            :       /**<span class="lineNum">    1351 </span>            :        *  @brief  Convert array to lowercase.<span class="lineNum">    1352 </span>            :        *<span class="lineNum">    1353 </span>            :        *  This virtual function converts each wchar_t in the range [lo,hi) to<span class="lineNum">    1354 </span>            :        *  lowercase if possible.  Other elements remain untouched.<span class="lineNum">    1355 </span>            :        *<span class="lineNum">    1356 </span>            :        *  do_tolower() is a hook for a derived facet to change the behavior of<span class="lineNum">    1357 </span>            :        *  lowercasing.  do_tolower() must always return the same result for<span class="lineNum">    1358 </span>            :        *  the same input.<span class="lineNum">    1359 </span>            :        *<span class="lineNum">    1360 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">    1361 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1362 </span>            :        *  @return  @a __hi.<span class="lineNum">    1363 </span>            :       */<span class="lineNum">    1364 </span>            :       virtual const char_type*<span class="lineNum">    1365 </span>            :       do_tolower(char_type* __lo, const char_type* __hi) const;<span class="lineNum">    1366 </span>            : <span class="lineNum">    1367 </span>            :       /**<span class="lineNum">    1368 </span>            :        *  @brief  Widen char to wchar_t<span class="lineNum">    1369 </span>            :        *<span class="lineNum">    1370 </span>            :        *  This virtual function converts the char to wchar_t using the<span class="lineNum">    1371 </span>            :        *  simplest reasonable transformation.  For an underived ctype&lt;wchar_t&gt;<span class="lineNum">    1372 </span>            :        *  facet, the argument will be cast to wchar_t.<span class="lineNum">    1373 </span>            :        *<span class="lineNum">    1374 </span>            :        *  do_widen() is a hook for a derived facet to change the behavior of<span class="lineNum">    1375 </span>            :        *  widening.  do_widen() must always return the same result for the<span class="lineNum">    1376 </span>            :        *  same input.<span class="lineNum">    1377 </span>            :        *<span class="lineNum">    1378 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">    1379 </span>            :        *  codecvt for that.<span class="lineNum">    1380 </span>            :        *<span class="lineNum">    1381 </span>            :        *  @param __c  The char to convert.<span class="lineNum">    1382 </span>            :        *  @return  The converted wchar_t.<span class="lineNum">    1383 </span>            :       */<span class="lineNum">    1384 </span>            :       virtual char_type<span class="lineNum">    1385 </span>            :       do_widen(char __c) const;<span class="lineNum">    1386 </span>            : <span class="lineNum">    1387 </span>            :       /**<span class="lineNum">    1388 </span>            :        *  @brief  Widen char array to wchar_t array<span class="lineNum">    1389 </span>            :        *<span class="lineNum">    1390 </span>            :        *  This function converts each char in the input to wchar_t using the<span class="lineNum">    1391 </span>            :        *  simplest reasonable transformation.  For an underived ctype&lt;wchar_t&gt;<span class="lineNum">    1392 </span>            :        *  facet, the argument will be copied, casting each element to wchar_t.<span class="lineNum">    1393 </span>            :        *<span class="lineNum">    1394 </span>            :        *  do_widen() is a hook for a derived facet to change the behavior of<span class="lineNum">    1395 </span>            :        *  widening.  do_widen() must always return the same result for the<span class="lineNum">    1396 </span>            :        *  same input.<span class="lineNum">    1397 </span>            :        *<span class="lineNum">    1398 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">    1399 </span>            :        *  codecvt for that.<span class="lineNum">    1400 </span>            :        *<span class="lineNum">    1401 </span>            :        *  @param __lo  Pointer to start range.<span class="lineNum">    1402 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1403 </span>            :        *  @param __to  Pointer to the destination array.<span class="lineNum">    1404 </span>            :        *  @return  @a __hi.<span class="lineNum">    1405 </span>            :       */<span class="lineNum">    1406 </span>            :       virtual const char*<span class="lineNum">    1407 </span>            :       do_widen(const char* __lo, const char* __hi, char_type* __to) const;<span class="lineNum">    1408 </span>            : <span class="lineNum">    1409 </span>            :       /**<span class="lineNum">    1410 </span>            :        *  @brief  Narrow wchar_t to char<span class="lineNum">    1411 </span>            :        *<span class="lineNum">    1412 </span>            :        *  This virtual function converts the argument to char using<span class="lineNum">    1413 </span>            :        *  the simplest reasonable transformation.  If the conversion<span class="lineNum">    1414 </span>            :        *  fails, dfault is returned instead.  For an underived<span class="lineNum">    1415 </span>            :        *  ctype&lt;wchar_t&gt; facet, @a c will be cast to char and<span class="lineNum">    1416 </span>            :        *  returned.<span class="lineNum">    1417 </span>            :        *<span class="lineNum">    1418 </span>            :        *  do_narrow() is a hook for a derived facet to change the<span class="lineNum">    1419 </span>            :        *  behavior of narrowing.  do_narrow() must always return the<span class="lineNum">    1420 </span>            :        *  same result for the same input.<span class="lineNum">    1421 </span>            :        *<span class="lineNum">    1422 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">    1423 </span>            :        *  codecvt for that.<span class="lineNum">    1424 </span>            :        *<span class="lineNum">    1425 </span>            :        *  @param __c  The wchar_t to convert.<span class="lineNum">    1426 </span>            :        *  @param __dfault  Char to return if conversion fails.<span class="lineNum">    1427 </span>            :        *  @return  The converted char.<span class="lineNum">    1428 </span>            :       */<span class="lineNum">    1429 </span>            :       virtual char<span class="lineNum">    1430 </span>            :       do_narrow(char_type __c, char __dfault) const;<span class="lineNum">    1431 </span>            : <span class="lineNum">    1432 </span>            :       /**<span class="lineNum">    1433 </span>            :        *  @brief  Narrow wchar_t array to char array<span class="lineNum">    1434 </span>            :        *<span class="lineNum">    1435 </span>            :        *  This virtual function converts each wchar_t in the range [lo,hi) to<span class="lineNum">    1436 </span>            :        *  char using the simplest reasonable transformation and writes the<span class="lineNum">    1437 </span>            :        *  results to the destination array.  For any wchar_t in the input that<span class="lineNum">    1438 </span>            :        *  cannot be converted, @a dfault is used instead.  For an underived<span class="lineNum">    1439 </span>            :        *  ctype&lt;wchar_t&gt; facet, the argument will be copied, casting each<span class="lineNum">    1440 </span>            :        *  element to char.<span class="lineNum">    1441 </span>            :        *<span class="lineNum">    1442 </span>            :        *  do_narrow() is a hook for a derived facet to change the behavior of<span class="lineNum">    1443 </span>            :        *  narrowing.  do_narrow() must always return the same result for the<span class="lineNum">    1444 </span>            :        *  same input.<span class="lineNum">    1445 </span>            :        *<span class="lineNum">    1446 </span>            :        *  Note: this is not what you want for codepage conversions.  See<span class="lineNum">    1447 </span>            :        *  codecvt for that.<span class="lineNum">    1448 </span>            :        *<span class="lineNum">    1449 </span>            :        *  @param __lo  Pointer to start of range.<span class="lineNum">    1450 </span>            :        *  @param __hi  Pointer to end of range.<span class="lineNum">    1451 </span>            :        *  @param __dfault  Char to use if conversion fails.<span class="lineNum">    1452 </span>            :        *  @param __to  Pointer to the destination array.<span class="lineNum">    1453 </span>            :        *  @return  @a __hi.<span class="lineNum">    1454 </span>            :       */<span class="lineNum">    1455 </span>            :       virtual const char_type*<span class="lineNum">    1456 </span>            :       do_narrow(const char_type* __lo, const char_type* __hi,<span class="lineNum">    1457 </span>            :                 char __dfault, char* __to) const;<span class="lineNum">    1458 </span>            : <span class="lineNum">    1459 </span>            :       // For use at construction time only.<span class="lineNum">    1460 </span>            :       void<span class="lineNum">    1461 </span>            :       _M_initialize_ctype() throw();<span class="lineNum">    1462 </span>            :     };<span class="lineNum">    1463 </span>            : #endif //_GLIBCXX_USE_WCHAR_T<span class="lineNum">    1464 </span>            : <span class="lineNum">    1465 </span>            :   /// class ctype_byname [22.2.1.2].<span class="lineNum">    1466 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    1467 </span>            :     class ctype_byname : public ctype&lt;_CharT&gt;<span class="lineNum">    1468 </span>            :     {<span class="lineNum">    1469 </span>            :     public:<span class="lineNum">    1470 </span>            :       typedef typename ctype&lt;_CharT&gt;::mask  mask;<span class="lineNum">    1471 </span>            : <span class="lineNum">    1472 </span>            :       explicit<span class="lineNum">    1473 </span>            :       ctype_byname(const char* __s, size_t __refs = 0);<span class="lineNum">    1474 </span>            : <span class="lineNum">    1475 </span>            :     protected:<span class="lineNum">    1476 </span>            :       virtual<span class="lineNum">    1477 </span>            :       ~ctype_byname() { };<span class="lineNum">    1478 </span>            :     };<span class="lineNum">    1479 </span>            : <span class="lineNum">    1480 </span>            :   /// 22.2.1.4  Class ctype_byname specializations.<span class="lineNum">    1481 </span>            :   template&lt;&gt;<span class="lineNum">    1482 </span>            :     class ctype_byname&lt;char&gt; : public ctype&lt;char&gt;<span class="lineNum">    1483 </span>            :     {<span class="lineNum">    1484 </span>            :     public:<span class="lineNum">    1485 </span>            :       explicit<span class="lineNum">    1486 </span>            :       ctype_byname(const char* __s, size_t __refs = 0);<span class="lineNum">    1487 </span>            : <span class="lineNum">    1488 </span>            :     protected:<span class="lineNum">    1489 </span>            :       virtual<span class="lineNum">    1490 </span>            :       ~ctype_byname();<span class="lineNum">    1491 </span>            :     };<span class="lineNum">    1492 </span>            : <span class="lineNum">    1493 </span>            : #ifdef _GLIBCXX_USE_WCHAR_T<span class="lineNum">    1494 </span>            :   template&lt;&gt;<span class="lineNum">    1495 </span>            :     class ctype_byname&lt;wchar_t&gt; : public ctype&lt;wchar_t&gt;<span class="lineNum">    1496 </span>            :     {<span class="lineNum">    1497 </span>            :     public:<span class="lineNum">    1498 </span>            :       explicit<span class="lineNum">    1499 </span>            :       ctype_byname(const char* __s, size_t __refs = 0);<span class="lineNum">    1500 </span>            : <span class="lineNum">    1501 </span>            :     protected:<span class="lineNum">    1502 </span>            :       virtual<span class="lineNum">    1503 </span>            :       ~ctype_byname();<span class="lineNum">    1504 </span>            :     };<span class="lineNum">    1505 </span>            : #endif<span class="lineNum">    1506 </span>            : <span class="lineNum">    1507 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">    1508 </span>            : } // namespace<span class="lineNum">    1509 </span>            : <span class="lineNum">    1510 </span>            : // Include host and configuration specific ctype inlines.<span class="lineNum">    1511 </span>            : #include &lt;bits/ctype_inline.h&gt;<span class="lineNum">    1512 </span>            : <span class="lineNum">    1513 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">    1514 </span>            : {<span class="lineNum">    1515 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">    1516 </span>            : <span class="lineNum">    1517 </span>            :   // 22.2.2  The numeric category.<span class="lineNum">    1518 </span>            :   class __num_base<span class="lineNum">    1519 </span>            :   {<span class="lineNum">    1520 </span>            :   public:<span class="lineNum">    1521 </span>            :     // NB: Code depends on the order of _S_atoms_out elements.<span class="lineNum">    1522 </span>            :     // Below are the indices into _S_atoms_out.<span class="lineNum">    1523 </span>            :     enum<span class="lineNum">    1524 </span>            :       {<span class="lineNum">    1525 </span>            :         _S_ominus,<span class="lineNum">    1526 </span>            :         _S_oplus,<span class="lineNum">    1527 </span>            :         _S_ox,<span class="lineNum">    1528 </span>            :         _S_oX,<span class="lineNum">    1529 </span>            :         _S_odigits,<span class="lineNum">    1530 </span>            :         _S_odigits_end = _S_odigits + 16,<span class="lineNum">    1531 </span>            :         _S_oudigits = _S_odigits_end,<span class="lineNum">    1532 </span>            :         _S_oudigits_end = _S_oudigits + 16,<span class="lineNum">    1533 </span>            :         _S_oe = _S_odigits + 14,  // For scientific notation, 'e'<span class="lineNum">    1534 </span>            :         _S_oE = _S_oudigits + 14, // For scientific notation, 'E'<span class="lineNum">    1535 </span>            :         _S_oend = _S_oudigits_end<span class="lineNum">    1536 </span>            :       };<span class="lineNum">    1537 </span>            : <span class="lineNum">    1538 </span>            :     // A list of valid numeric literals for output.  This array<span class="lineNum">    1539 </span>            :     // contains chars that will be passed through the current locale's<span class="lineNum">    1540 </span>            :     // ctype&lt;_CharT&gt;.widen() and then used to render numbers.<span class="lineNum">    1541 </span>            :     // For the standard &quot;C&quot; locale, this is<span class="lineNum">    1542 </span>            :     // &quot;-+xX0123456789abcdef0123456789ABCDEF&quot;.<span class="lineNum">    1543 </span>            :     static const char* _S_atoms_out;<span class="lineNum">    1544 </span>            : <span class="lineNum">    1545 </span>            :     // String literal of acceptable (narrow) input, for num_get.<span class="lineNum">    1546 </span>            :     // &quot;-+xX0123456789abcdefABCDEF&quot;<span class="lineNum">    1547 </span>            :     static const char* _S_atoms_in;<span class="lineNum">    1548 </span>            : <span class="lineNum">    1549 </span>            :     enum<span class="lineNum">    1550 </span>            :     {<span class="lineNum">    1551 </span>            :       _S_iminus,<span class="lineNum">    1552 </span>            :       _S_iplus,<span class="lineNum">    1553 </span>            :       _S_ix,<span class="lineNum">    1554 </span>            :       _S_iX,<span class="lineNum">    1555 </span>            :       _S_izero,<span class="lineNum">    1556 </span>            :       _S_ie = _S_izero + 14,<span class="lineNum">    1557 </span>            :       _S_iE = _S_izero + 20,<span class="lineNum">    1558 </span>            :       _S_iend = 26<span class="lineNum">    1559 </span>            :     };<span class="lineNum">    1560 </span>            : <span class="lineNum">    1561 </span>            :     // num_put<span class="lineNum">    1562 </span>            :     // Construct and return valid scanf format for floating point types.<span class="lineNum">    1563 </span>            :     static void<span class="lineNum">    1564 </span>            :     _S_format_float(const ios_base&amp; __io, char* __fptr, char __mod) throw();<span class="lineNum">    1565 </span>            :   };<span class="lineNum">    1566 </span>            : <span class="lineNum">    1567 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    1568 </span>            :     struct __numpunct_cache : public locale::facet<span class="lineNum">    1569 </span>            :     {<span class="lineNum">    1570 </span>            :       const char*                       _M_grouping;<span class="lineNum">    1571 </span>            :       size_t                            _M_grouping_size;<span class="lineNum">    1572 </span>            :       bool                              _M_use_grouping;<span class="lineNum">    1573 </span>            :       const _CharT*                     _M_truename;<span class="lineNum">    1574 </span>            :       size_t                            _M_truename_size;<span class="lineNum">    1575 </span>            :       const _CharT*                     _M_falsename;<span class="lineNum">    1576 </span>            :       size_t                            _M_falsename_size;<span class="lineNum">    1577 </span>            :       _CharT                            _M_decimal_point;<span class="lineNum">    1578 </span>            :       _CharT                            _M_thousands_sep;<span class="lineNum">    1579 </span>            : <span class="lineNum">    1580 </span>            :       // A list of valid numeric literals for output: in the standard<span class="lineNum">    1581 </span>            :       // &quot;C&quot; locale, this is &quot;-+xX0123456789abcdef0123456789ABCDEF&quot;.<span class="lineNum">    1582 </span>            :       // This array contains the chars after having been passed<span class="lineNum">    1583 </span>            :       // through the current locale's ctype&lt;_CharT&gt;.widen().<span class="lineNum">    1584 </span>            :       _CharT                            _M_atoms_out[__num_base::_S_oend];<span class="lineNum">    1585 </span>            : <span class="lineNum">    1586 </span>            :       // A list of valid numeric literals for input: in the standard<span class="lineNum">    1587 </span>            :       // &quot;C&quot; locale, this is &quot;-+xX0123456789abcdefABCDEF&quot;<span class="lineNum">    1588 </span>            :       // This array contains the chars after having been passed<span class="lineNum">    1589 </span>            :       // through the current locale's ctype&lt;_CharT&gt;.widen().<span class="lineNum">    1590 </span>            :       _CharT                            _M_atoms_in[__num_base::_S_iend];<span class="lineNum">    1591 </span>            : <span class="lineNum">    1592 </span>            :       bool                              _M_allocated;<span class="lineNum">    1593 </span>            : <span class="lineNum">    1594 </span>            :       __numpunct_cache(size_t __refs = 0)<span class="lineNum">    1595 </span>            :       : facet(__refs), _M_grouping(0), _M_grouping_size(0),<span class="lineNum">    1596 </span>            :         _M_use_grouping(false),<span class="lineNum">    1597 </span>            :         _M_truename(0), _M_truename_size(0), _M_falsename(0),<span class="lineNum">    1598 </span>            :         _M_falsename_size(0), _M_decimal_point(_CharT()),<span class="lineNum">    1599 </span>            :         _M_thousands_sep(_CharT()), _M_allocated(false)<span class="lineNum">    1600 </span>            :         { }<span class="lineNum">    1601 </span>            : <span class="lineNum">    1602 </span>            :       ~__numpunct_cache();<span class="lineNum">    1603 </span>            : <span class="lineNum">    1604 </span>            :       void<span class="lineNum">    1605 </span>            :       _M_cache(const locale&amp; __loc);<span class="lineNum">    1606 </span>            : <span class="lineNum">    1607 </span>            :     private:<span class="lineNum">    1608 </span>            :       __numpunct_cache&amp;<span class="lineNum">    1609 </span>            :       operator=(const __numpunct_cache&amp;);<span class="lineNum">    1610 </span>            : <span class="lineNum">    1611 </span>            :       explicit<span class="lineNum">    1612 </span>            :       __numpunct_cache(const __numpunct_cache&amp;);<span class="lineNum">    1613 </span>            :     };<span class="lineNum">    1614 </span>            : <span class="lineNum">    1615 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    1616 </span>            :     __numpunct_cache&lt;_CharT&gt;::~__numpunct_cache()<span class="lineNum">    1617 </span>            :     {<span class="lineNum">    1618 </span>            :       if (_M_allocated)<span class="lineNum">    1619 </span>            :         {<span class="lineNum">    1620 </span>            :           delete [] _M_grouping;<span class="lineNum">    1621 </span>            :           delete [] _M_truename;<span class="lineNum">    1622 </span>            :           delete [] _M_falsename;<span class="lineNum">    1623 </span>            :         }<span class="lineNum">    1624 </span>            :     }<span class="lineNum">    1625 </span>            : <span class="lineNum">    1626 </span>            :   /**<span class="lineNum">    1627 </span>            :    *  @brief  Primary class template numpunct.<span class="lineNum">    1628 </span>            :    *  @ingroup locales<span class="lineNum">    1629 </span>            :    *<span class="lineNum">    1630 </span>            :    *  This facet stores several pieces of information related to printing and<span class="lineNum">    1631 </span>            :    *  scanning numbers, such as the decimal point character.  It takes a<span class="lineNum">    1632 </span>            :    *  template parameter specifying the char type.  The numpunct facet is<span class="lineNum">    1633 </span>            :    *  used by streams for many I/O operations involving numbers.<span class="lineNum">    1634 </span>            :    *<span class="lineNum">    1635 </span>            :    *  The numpunct template uses protected virtual functions to provide the<span class="lineNum">    1636 </span>            :    *  actual results.  The public accessors forward the call to the virtual<span class="lineNum">    1637 </span>            :    *  functions.  These virtual functions are hooks for developers to<span class="lineNum">    1638 </span>            :    *  implement the behavior they require from a numpunct facet.<span class="lineNum">    1639 </span>            :   */<span class="lineNum">    1640 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    1641 </span>            :     class numpunct : public locale::facet<span class="lineNum">    1642 </span>            :     {<span class="lineNum">    1643 </span>            :     public:<span class="lineNum">    1644 </span>            :       // Types:<span class="lineNum">    1645 </span>            :       //@{<span class="lineNum">    1646 </span>            :       /// Public typedefs<span class="lineNum">    1647 </span>            :       typedef _CharT                    char_type;<span class="lineNum">    1648 </span>            :       typedef basic_string&lt;_CharT&gt;        string_type;<span class="lineNum">    1649 </span>            :       //@}<span class="lineNum">    1650 </span>            :       typedef __numpunct_cache&lt;_CharT&gt;  __cache_type;<span class="lineNum">    1651 </span>            : <span class="lineNum">    1652 </span>            :     protected:<span class="lineNum">    1653 </span>            :       __cache_type*                     _M_data;<span class="lineNum">    1654 </span>            : <span class="lineNum">    1655 </span>            :     public:<span class="lineNum">    1656 </span>            :       /// Numpunct facet id.<span class="lineNum">    1657 </span>            :       static locale::id                 id;<span class="lineNum">    1658 </span>            : <span class="lineNum">    1659 </span>            :       /**<span class="lineNum">    1660 </span>            :        *  @brief  Numpunct constructor.<span class="lineNum">    1661 </span>            :        *<span class="lineNum">    1662 </span>            :        *  @param  __refs  Refcount to pass to the base class.<span class="lineNum">    1663 </span>            :        */<span class="lineNum">    1664 </span>            :       explicit<span class="lineNum">    1665 </span>            :       numpunct(size_t __refs = 0)<span class="lineNum">    1666 </span>            :       : facet(__refs), _M_data(0)<span class="lineNum">    1667 </span>            :       { _M_initialize_numpunct(); }<span class="lineNum">    1668 </span>            : <span class="lineNum">    1669 </span>            :       /**<span class="lineNum">    1670 </span>            :        *  @brief  Internal constructor.  Not for general use.<span class="lineNum">    1671 </span>            :        *<span class="lineNum">    1672 </span>            :        *  This is a constructor for use by the library itself to set up the<span class="lineNum">    1673 </span>            :        *  predefined locale facets.<span class="lineNum">    1674 </span>            :        *<span class="lineNum">    1675 </span>            :        *  @param  __cache  __numpunct_cache object.<span class="lineNum">    1676 </span>            :        *  @param  __refs  Refcount to pass to the base class.<span class="lineNum">    1677 </span>            :        */<span class="lineNum">    1678 </span>            :       explicit<span class="lineNum">    1679 </span>            :       numpunct(__cache_type* __cache, size_t __refs = 0)<span class="lineNum">    1680 </span>            :       : facet(__refs), _M_data(__cache)<span class="lineNum">    1681 </span>            :       { _M_initialize_numpunct(); }<span class="lineNum">    1682 </span>            : <span class="lineNum">    1683 </span>            :       /**<span class="lineNum">    1684 </span>            :        *  @brief  Internal constructor.  Not for general use.<span class="lineNum">    1685 </span>            :        *<span class="lineNum">    1686 </span>            :        *  This is a constructor for use by the library itself to set up new<span class="lineNum">    1687 </span>            :        *  locales.<span class="lineNum">    1688 </span>            :        *<span class="lineNum">    1689 </span>            :        *  @param  __cloc  The C locale.<span class="lineNum">    1690 </span>            :        *  @param  __refs  Refcount to pass to the base class.<span class="lineNum">    1691 </span>            :        */<span class="lineNum">    1692 </span>            :       explicit<span class="lineNum">    1693 </span>            :       numpunct(__c_locale __cloc, size_t __refs = 0)<span class="lineNum">    1694 </span>            :       : facet(__refs), _M_data(0)<span class="lineNum">    1695 </span>            :       { _M_initialize_numpunct(__cloc); }<span class="lineNum">    1696 </span>            : <span class="lineNum">    1697 </span>            :       /**<span class="lineNum">    1698 </span>            :        *  @brief  Return decimal point character.<span class="lineNum">    1699 </span>            :        *<span class="lineNum">    1700 </span>            :        *  This function returns a char_type to use as a decimal point.  It<span class="lineNum">    1701 </span>            :        *  does so by returning returning<span class="lineNum">    1702 </span>            :        *  numpunct&lt;char_type&gt;::do_decimal_point().<span class="lineNum">    1703 </span>            :        *<span class="lineNum">    1704 </span>            :        *  @return  @a char_type representing a decimal point.<span class="lineNum">    1705 </span>            :       */<span class="lineNum">    1706 </span>            :       char_type<span class="lineNum">    1707 </span>            :       decimal_point() const<span class="lineNum">    1708 </span>            :       { return this-&gt;do_decimal_point(); }<span class="lineNum">    1709 </span>            : <span class="lineNum">    1710 </span>            :       /**<span class="lineNum">    1711 </span>            :        *  @brief  Return thousands separator character.<span class="lineNum">    1712 </span>            :        *<span class="lineNum">    1713 </span>            :        *  This function returns a char_type to use as a thousands<span class="lineNum">    1714 </span>            :        *  separator.  It does so by returning returning<span class="lineNum">    1715 </span>            :        *  numpunct&lt;char_type&gt;::do_thousands_sep().<span class="lineNum">    1716 </span>            :        *<span class="lineNum">    1717 </span>            :        *  @return  char_type representing a thousands separator.<span class="lineNum">    1718 </span>            :       */<span class="lineNum">    1719 </span>            :       char_type<span class="lineNum">    1720 </span>            :       thousands_sep() const<span class="lineNum">    1721 </span>            :       { return this-&gt;do_thousands_sep(); }<span class="lineNum">    1722 </span>            : <span class="lineNum">    1723 </span>            :       /**<span class="lineNum">    1724 </span>            :        *  @brief  Return grouping specification.<span class="lineNum">    1725 </span>            :        *<span class="lineNum">    1726 </span>            :        *  This function returns a string representing groupings for the<span class="lineNum">    1727 </span>            :        *  integer part of a number.  Groupings indicate where thousands<span class="lineNum">    1728 </span>            :        *  separators should be inserted in the integer part of a number.<span class="lineNum">    1729 </span>            :        *<span class="lineNum">    1730 </span>            :        *  Each char in the return string is interpret as an integer<span class="lineNum">    1731 </span>            :        *  rather than a character.  These numbers represent the number<span class="lineNum">    1732 </span>            :        *  of digits in a group.  The first char in the string<span class="lineNum">    1733 </span>            :        *  represents the number of digits in the least significant<span class="lineNum">    1734 </span>            :        *  group.  If a char is negative, it indicates an unlimited<span class="lineNum">    1735 </span>            :        *  number of digits for the group.  If more chars from the<span class="lineNum">    1736 </span>            :        *  string are required to group a number, the last char is used<span class="lineNum">    1737 </span>            :        *  repeatedly.<span class="lineNum">    1738 </span>            :        *<span class="lineNum">    1739 </span>            :        *  For example, if the grouping() returns &quot;\003\002&quot; and is<span class="lineNum">    1740 </span>            :        *  applied to the number 123456789, this corresponds to<span class="lineNum">    1741 </span>            :        *  12,34,56,789.  Note that if the string was &quot;32&quot;, this would<span class="lineNum">    1742 </span>            :        *  put more than 50 digits into the least significant group if<span class="lineNum">    1743 </span>            :        *  the character set is ASCII.<span class="lineNum">    1744 </span>            :        *<span class="lineNum">    1745 </span>            :        *  The string is returned by calling<span class="lineNum">    1746 </span>            :        *  numpunct&lt;char_type&gt;::do_grouping().<span class="lineNum">    1747 </span>            :        *<span class="lineNum">    1748 </span>            :        *  @return  string representing grouping specification.<span class="lineNum">    1749 </span>            :       */<span class="lineNum">    1750 </span>            :       string<span class="lineNum">    1751 </span>            :       grouping() const<span class="lineNum">    1752 </span>            :       { return this-&gt;do_grouping(); }<span class="lineNum">    1753 </span>            : <span class="lineNum">    1754 </span>            :       /**<span class="lineNum">    1755 </span>            :        *  @brief  Return string representation of bool true.<span class="lineNum">    1756 </span>            :        *<span class="lineNum">    1757 </span>            :        *  This function returns a string_type containing the text<span class="lineNum">    1758 </span>            :        *  representation for true bool variables.  It does so by calling<span class="lineNum">    1759 </span>            :        *  numpunct&lt;char_type&gt;::do_truename().<span class="lineNum">    1760 </span>            :        *<span class="lineNum">    1761 </span>            :        *  @return  string_type representing printed form of true.<span class="lineNum">    1762 </span>            :       */<span class="lineNum">    1763 </span>            :       string_type<span class="lineNum">    1764 </span>            :       truename() const<span class="lineNum">    1765 </span>            :       { return this-&gt;do_truename(); }<span class="lineNum">    1766 </span>            : <span class="lineNum">    1767 </span>            :       /**<span class="lineNum">    1768 </span>            :        *  @brief  Return string representation of bool false.<span class="lineNum">    1769 </span>            :        *<span class="lineNum">    1770 </span>            :        *  This function returns a string_type containing the text<span class="lineNum">    1771 </span>            :        *  representation for false bool variables.  It does so by calling<span class="lineNum">    1772 </span>            :        *  numpunct&lt;char_type&gt;::do_falsename().<span class="lineNum">    1773 </span>            :        *<span class="lineNum">    1774 </span>            :        *  @return  string_type representing printed form of false.<span class="lineNum">    1775 </span>            :       */<span class="lineNum">    1776 </span>            :       string_type<span class="lineNum">    1777 </span>            :       falsename() const<span class="lineNum">    1778 </span>            :       { return this-&gt;do_falsename(); }<span class="lineNum">    1779 </span>            : <span class="lineNum">    1780 </span>            :     protected:<span class="lineNum">    1781 </span>            :       /// Destructor.<span class="lineNum">    1782 </span>            :       virtual<span class="lineNum">    1783 </span>            :       ~numpunct();<span class="lineNum">    1784 </span>            : <span class="lineNum">    1785 </span>            :       /**<span class="lineNum">    1786 </span>            :        *  @brief  Return decimal point character.<span class="lineNum">    1787 </span>            :        *<span class="lineNum">    1788 </span>            :        *  Returns a char_type to use as a decimal point.  This function is a<span class="lineNum">    1789 </span>            :        *  hook for derived classes to change the value returned.<span class="lineNum">    1790 </span>            :        *<span class="lineNum">    1791 </span>            :        *  @return  @a char_type representing a decimal point.<span class="lineNum">    1792 </span>            :       */<span class="lineNum">    1793 </span>            :       virtual char_type<span class="lineNum">    1794 </span>            :       do_decimal_point() const<span class="lineNum">    1795 </span>            :       { return _M_data-&gt;_M_decimal_point; }<span class="lineNum">    1796 </span>            : <span class="lineNum">    1797 </span>            :       /**<span class="lineNum">    1798 </span>            :        *  @brief  Return thousands separator character.<span class="lineNum">    1799 </span>            :        *<span class="lineNum">    1800 </span>            :        *  Returns a char_type to use as a thousands separator.  This function<span class="lineNum">    1801 </span>            :        *  is a hook for derived classes to change the value returned.<span class="lineNum">    1802 </span>            :        *<span class="lineNum">    1803 </span>            :        *  @return  @a char_type representing a thousands separator.<span class="lineNum">    1804 </span>            :       */<span class="lineNum">    1805 </span>            :       virtual char_type<span class="lineNum">    1806 </span>            :       do_thousands_sep() const<span class="lineNum">    1807 </span>            :       { return _M_data-&gt;_M_thousands_sep; }<span class="lineNum">    1808 </span>            : <span class="lineNum">    1809 </span>            :       /**<span class="lineNum">    1810 </span>            :        *  @brief  Return grouping specification.<span class="lineNum">    1811 </span>            :        *<span class="lineNum">    1812 </span>            :        *  Returns a string representing groupings for the integer part of a<span class="lineNum">    1813 </span>            :        *  number.  This function is a hook for derived classes to change the<span class="lineNum">    1814 </span>            :        *  value returned.  @see grouping() for details.<span class="lineNum">    1815 </span>            :        *<span class="lineNum">    1816 </span>            :        *  @return  String representing grouping specification.<span class="lineNum">    1817 </span>            :       */<span class="lineNum">    1818 </span>            :       virtual string<span class="lineNum">    1819 </span>            :       do_grouping() const<span class="lineNum">    1820 </span>            :       { return _M_data-&gt;_M_grouping; }<span class="lineNum">    1821 </span>            : <span class="lineNum">    1822 </span>            :       /**<span class="lineNum">    1823 </span>            :        *  @brief  Return string representation of bool true.<span class="lineNum">    1824 </span>            :        *<span class="lineNum">    1825 </span>            :        *  Returns a string_type containing the text representation for true<span class="lineNum">    1826 </span>            :        *  bool variables.  This function is a hook for derived classes to<span class="lineNum">    1827 </span>            :        *  change the value returned.<span class="lineNum">    1828 </span>            :        *<span class="lineNum">    1829 </span>            :        *  @return  string_type representing printed form of true.<span class="lineNum">    1830 </span>            :       */<span class="lineNum">    1831 </span>            :       virtual string_type<span class="lineNum">    1832 </span>            :       do_truename() const<span class="lineNum">    1833 </span>            :       { return _M_data-&gt;_M_truename; }<span class="lineNum">    1834 </span>            : <span class="lineNum">    1835 </span>            :       /**<span class="lineNum">    1836 </span>            :        *  @brief  Return string representation of bool false.<span class="lineNum">    1837 </span>            :        *<span class="lineNum">    1838 </span>            :        *  Returns a string_type containing the text representation for false<span class="lineNum">    1839 </span>            :        *  bool variables.  This function is a hook for derived classes to<span class="lineNum">    1840 </span>            :        *  change the value returned.<span class="lineNum">    1841 </span>            :        *<span class="lineNum">    1842 </span>            :        *  @return  string_type representing printed form of false.<span class="lineNum">    1843 </span>            :       */<span class="lineNum">    1844 </span>            :       virtual string_type<span class="lineNum">    1845 </span>            :       do_falsename() const<span class="lineNum">    1846 </span>            :       { return _M_data-&gt;_M_falsename; }<span class="lineNum">    1847 </span>            : <span class="lineNum">    1848 </span>            :       // For use at construction time only.<span class="lineNum">    1849 </span>            :       void<span class="lineNum">    1850 </span>            :       _M_initialize_numpunct(__c_locale __cloc = 0);<span class="lineNum">    1851 </span>            :     };<span class="lineNum">    1852 </span>            : <span class="lineNum">    1853 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    1854 </span>            :     locale::id numpunct&lt;_CharT&gt;::id;<span class="lineNum">    1855 </span>            : <span class="lineNum">    1856 </span>            :   template&lt;&gt;<span class="lineNum">    1857 </span>            :     numpunct&lt;char&gt;::~numpunct();<span class="lineNum">    1858 </span>            : <span class="lineNum">    1859 </span>            :   template&lt;&gt;<span class="lineNum">    1860 </span>            :     void<span class="lineNum">    1861 </span>            :     numpunct&lt;char&gt;::_M_initialize_numpunct(__c_locale __cloc);<span class="lineNum">    1862 </span>            : <span class="lineNum">    1863 </span>            : #ifdef _GLIBCXX_USE_WCHAR_T<span class="lineNum">    1864 </span>            :   template&lt;&gt;<span class="lineNum">    1865 </span>            :     numpunct&lt;wchar_t&gt;::~numpunct();<span class="lineNum">    1866 </span>            : <span class="lineNum">    1867 </span>            :   template&lt;&gt;<span class="lineNum">    1868 </span>            :     void<span class="lineNum">    1869 </span>            :     numpunct&lt;wchar_t&gt;::_M_initialize_numpunct(__c_locale __cloc);<span class="lineNum">    1870 </span>            : #endif<span class="lineNum">    1871 </span>            : <span class="lineNum">    1872 </span>            :   /// class numpunct_byname [22.2.3.2].<span class="lineNum">    1873 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    1874 </span>            :     class numpunct_byname : public numpunct&lt;_CharT&gt;<span class="lineNum">    1875 </span>            :     {<span class="lineNum">    1876 </span>            :     public:<span class="lineNum">    1877 </span>            :       typedef _CharT                    char_type;<span class="lineNum">    1878 </span>            :       typedef basic_string&lt;_CharT&gt;        string_type;<span class="lineNum">    1879 </span>            : <span class="lineNum">    1880 </span>            :       explicit<span class="lineNum">    1881 </span>            :       numpunct_byname(const char* __s, size_t __refs = 0)<span class="lineNum">    1882 </span>            :       : numpunct&lt;_CharT&gt;(__refs)<span class="lineNum">    1883 </span>            :       {<span class="lineNum">    1884 </span>            :         if (__builtin_strcmp(__s, &quot;C&quot;) != 0<span class="lineNum">    1885 </span>            :             &amp;&amp; __builtin_strcmp(__s, &quot;POSIX&quot;) != 0)<span class="lineNum">    1886 </span>            :           {<span class="lineNum">    1887 </span>            :             __c_locale __tmp;<span class="lineNum">    1888 </span>            :             this-&gt;_S_create_c_locale(__tmp, __s);<span class="lineNum">    1889 </span>            :             this-&gt;_M_initialize_numpunct(__tmp);<span class="lineNum">    1890 </span>            :             this-&gt;_S_destroy_c_locale(__tmp);<span class="lineNum">    1891 </span>            :           }<span class="lineNum">    1892 </span>            :       }<span class="lineNum">    1893 </span>            : <span class="lineNum">    1894 </span>            :     protected:<span class="lineNum">    1895 </span>            :       virtual<span class="lineNum">    1896 </span>            :       ~numpunct_byname() { }<span class="lineNum">    1897 </span>            :     };<span class="lineNum">    1898 </span>            : <span class="lineNum">    1899 </span>            : _GLIBCXX_BEGIN_NAMESPACE_LDBL<span class="lineNum">    1900 </span>            : <span class="lineNum">    1901 </span>            :   /**<span class="lineNum">    1902 </span>            :    *  @brief  Primary class template num_get.<span class="lineNum">    1903 </span>            :    *  @ingroup locales<span class="lineNum">    1904 </span>            :    *<span class="lineNum">    1905 </span>            :    *  This facet encapsulates the code to parse and return a number<span class="lineNum">    1906 </span>            :    *  from a string.  It is used by the istream numeric extraction<span class="lineNum">    1907 </span>            :    *  operators.<span class="lineNum">    1908 </span>            :    *<span class="lineNum">    1909 </span>            :    *  The num_get template uses protected virtual functions to provide the<span class="lineNum">    1910 </span>            :    *  actual results.  The public accessors forward the call to the virtual<span class="lineNum">    1911 </span>            :    *  functions.  These virtual functions are hooks for developers to<span class="lineNum">    1912 </span>            :    *  implement the behavior they require from the num_get facet.<span class="lineNum">    1913 </span>            :   */<span class="lineNum">    1914 </span>            :   template&lt;typename _CharT, typename _InIter&gt;<span class="lineNum">    1915 </span>            :     class num_get : public locale::facet<span class="lineNum">    1916 </span>            :     {<span class="lineNum">    1917 </span>            :     public:<span class="lineNum">    1918 </span>            :       // Types:<span class="lineNum">    1919 </span>            :       //@{<span class="lineNum">    1920 </span>            :       /// Public typedefs<span class="lineNum">    1921 </span>            :       typedef _CharT                    char_type;<span class="lineNum">    1922 </span>            :       typedef _InIter                   iter_type;<span class="lineNum">    1923 </span>            :       //@}<span class="lineNum">    1924 </span>            : <span class="lineNum">    1925 </span>            :       /// Numpunct facet id.<span class="lineNum">    1926 </span>            :       static locale::id                 id;<span class="lineNum">    1927 </span>            : <span class="lineNum">    1928 </span>            :       /**<span class="lineNum">    1929 </span>            :        *  @brief  Constructor performs initialization.<span class="lineNum">    1930 </span>            :        *<span class="lineNum">    1931 </span>            :        *  This is the constructor provided by the standard.<span class="lineNum">    1932 </span>            :        *<span class="lineNum">    1933 </span>            :        *  @param __refs  Passed to the base facet class.<span class="lineNum">    1934 </span>            :       */<span class="lineNum">    1935 </span>            :       explicit<span class="lineNum">    1936 </span>            :       num_get(size_t __refs = 0) : facet(__refs) { }<span class="lineNum">    1937 </span>            : <span class="lineNum">    1938 </span>            :       /**<span class="lineNum">    1939 </span>            :        *  @brief  Numeric parsing.<span class="lineNum">    1940 </span>            :        *<span class="lineNum">    1941 </span>            :        *  Parses the input stream into the bool @a v.  It does so by calling<span class="lineNum">    1942 </span>            :        *  num_get::do_get().<span class="lineNum">    1943 </span>            :        *<span class="lineNum">    1944 </span>            :        *  If ios_base::boolalpha is set, attempts to read<span class="lineNum">    1945 </span>            :        *  ctype&lt;CharT&gt;::truename() or ctype&lt;CharT&gt;::falsename().  Sets<span class="lineNum">    1946 </span>            :        *  @a v to true or false if successful.  Sets err to<span class="lineNum">    1947 </span>            :        *  ios_base::failbit if reading the string fails.  Sets err to<span class="lineNum">    1948 </span>            :        *  ios_base::eofbit if the stream is emptied.<span class="lineNum">    1949 </span>            :        *<span class="lineNum">    1950 </span>            :        *  If ios_base::boolalpha is not set, proceeds as with reading a long,<span class="lineNum">    1951 </span>            :        *  except if the value is 1, sets @a v to true, if the value is 0, sets<span class="lineNum">    1952 </span>            :        *  @a v to false, and otherwise set err to ios_base::failbit.<span class="lineNum">    1953 </span>            :        *<span class="lineNum">    1954 </span>            :        *  @param  __in  Start of input stream.<span class="lineNum">    1955 </span>            :        *  @param  __end  End of input stream.<span class="lineNum">    1956 </span>            :        *  @param  __io  Source of locale and flags.<span class="lineNum">    1957 </span>            :        *  @param  __err  Error flags to set.<span class="lineNum">    1958 </span>            :        *  @param  __v  Value to format and insert.<span class="lineNum">    1959 </span>            :        *  @return  Iterator after reading.<span class="lineNum">    1960 </span>            :       */<span class="lineNum">    1961 </span>            :       iter_type<span class="lineNum">    1962 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    1963 </span>            :           ios_base::iostate&amp; __err, bool&amp; __v) const<span class="lineNum">    1964 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    1965 </span>            : <span class="lineNum">    1966 </span>            :       //@{<span class="lineNum">    1967 </span>            :       /**<span class="lineNum">    1968 </span>            :        *  @brief  Numeric parsing.<span class="lineNum">    1969 </span>            :        *<span class="lineNum">    1970 </span>            :        *  Parses the input stream into the integral variable @a v.  It does so<span class="lineNum">    1971 </span>            :        *  by calling num_get::do_get().<span class="lineNum">    1972 </span>            :        *<span class="lineNum">    1973 </span>            :        *  Parsing is affected by the flag settings in @a io.<span class="lineNum">    1974 </span>            :        *<span class="lineNum">    1975 </span>            :        *  The basic parse is affected by the value of io.flags() &amp;<span class="lineNum">    1976 </span>            :        *  ios_base::basefield.  If equal to ios_base::oct, parses like the<span class="lineNum">    1977 </span>            :        *  scanf %o specifier.  Else if equal to ios_base::hex, parses like %X<span class="lineNum">    1978 </span>            :        *  specifier.  Else if basefield equal to 0, parses like the %i<span class="lineNum">    1979 </span>            :        *  specifier.  Otherwise, parses like %d for signed and %u for unsigned<span class="lineNum">    1980 </span>            :        *  types.  The matching type length modifier is also used.<span class="lineNum">    1981 </span>            :        *<span class="lineNum">    1982 </span>            :        *  Digit grouping is interpreted according to<span class="lineNum">    1983 </span>            :        *  numpunct::grouping() and numpunct::thousands_sep().  If the<span class="lineNum">    1984 </span>            :        *  pattern of digit groups isn't consistent, sets err to<span class="lineNum">    1985 </span>            :        *  ios_base::failbit.<span class="lineNum">    1986 </span>            :        *<span class="lineNum">    1987 </span>            :        *  If parsing the string yields a valid value for @a v, @a v is set.<span class="lineNum">    1988 </span>            :        *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.<span class="lineNum">    1989 </span>            :        *  Sets err to ios_base::eofbit if the stream is emptied.<span class="lineNum">    1990 </span>            :        *<span class="lineNum">    1991 </span>            :        *  @param  __in  Start of input stream.<span class="lineNum">    1992 </span>            :        *  @param  __end  End of input stream.<span class="lineNum">    1993 </span>            :        *  @param  __io  Source of locale and flags.<span class="lineNum">    1994 </span>            :        *  @param  __err  Error flags to set.<span class="lineNum">    1995 </span>            :        *  @param  __v  Value to format and insert.<span class="lineNum">    1996 </span>            :        *  @return  Iterator after reading.<span class="lineNum">    1997 </span>            :       */<span class="lineNum">    1998 </span>            :       iter_type<span class="lineNum">    1999 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2000 </span>            :           ios_base::iostate&amp; __err, long&amp; __v) const<span class="lineNum">    2001 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    2002 </span>            : <span class="lineNum">    2003 </span>            :       iter_type<span class="lineNum">    2004 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2005 </span>            :           ios_base::iostate&amp; __err, unsigned short&amp; __v) const<span class="lineNum">    2006 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    2007 </span>            : <span class="lineNum">    2008 </span>            :       iter_type<span class="lineNum">    2009 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2010 </span>            :           ios_base::iostate&amp; __err, unsigned int&amp; __v)   const<span class="lineNum">    2011 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    2012 </span>            : <span class="lineNum">    2013 </span>            :       iter_type<span class="lineNum">    2014 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2015 </span>            :           ios_base::iostate&amp; __err, unsigned long&amp; __v)  const<span class="lineNum">    2016 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    2017 </span>            : <span class="lineNum">    2018 </span>            : #ifdef _GLIBCXX_USE_LONG_LONG<span class="lineNum">    2019 </span>            :       iter_type<span class="lineNum">    2020 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2021 </span>            :           ios_base::iostate&amp; __err, long long&amp; __v) const<span class="lineNum">    2022 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    2023 </span>            : <span class="lineNum">    2024 </span>            :       iter_type<span class="lineNum">    2025 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2026 </span>            :           ios_base::iostate&amp; __err, unsigned long long&amp; __v)  const<span class="lineNum">    2027 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    2028 </span>            : #endif<span class="lineNum">    2029 </span>            :       //@}<span class="lineNum">    2030 </span>            : <span class="lineNum">    2031 </span>            :       //@{<span class="lineNum">    2032 </span>            :       /**<span class="lineNum">    2033 </span>            :        *  @brief  Numeric parsing.<span class="lineNum">    2034 </span>            :        *<span class="lineNum">    2035 </span>            :        *  Parses the input stream into the integral variable @a v.  It does so<span class="lineNum">    2036 </span>            :        *  by calling num_get::do_get().<span class="lineNum">    2037 </span>            :        *<span class="lineNum">    2038 </span>            :        *  The input characters are parsed like the scanf %g specifier.  The<span class="lineNum">    2039 </span>            :        *  matching type length modifier is also used.<span class="lineNum">    2040 </span>            :        *<span class="lineNum">    2041 </span>            :        *  The decimal point character used is numpunct::decimal_point().<span class="lineNum">    2042 </span>            :        *  Digit grouping is interpreted according to<span class="lineNum">    2043 </span>            :        *  numpunct::grouping() and numpunct::thousands_sep().  If the<span class="lineNum">    2044 </span>            :        *  pattern of digit groups isn't consistent, sets err to<span class="lineNum">    2045 </span>            :        *  ios_base::failbit.<span class="lineNum">    2046 </span>            :        *<span class="lineNum">    2047 </span>            :        *  If parsing the string yields a valid value for @a v, @a v is set.<span class="lineNum">    2048 </span>            :        *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.<span class="lineNum">    2049 </span>            :        *  Sets err to ios_base::eofbit if the stream is emptied.<span class="lineNum">    2050 </span>            :        *<span class="lineNum">    2051 </span>            :        *  @param  __in  Start of input stream.<span class="lineNum">    2052 </span>            :        *  @param  __end  End of input stream.<span class="lineNum">    2053 </span>            :        *  @param  __io  Source of locale and flags.<span class="lineNum">    2054 </span>            :        *  @param  __err  Error flags to set.<span class="lineNum">    2055 </span>            :        *  @param  __v  Value to format and insert.<span class="lineNum">    2056 </span>            :        *  @return  Iterator after reading.<span class="lineNum">    2057 </span>            :       */<span class="lineNum">    2058 </span>            :       iter_type<span class="lineNum">    2059 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2060 </span>            :           ios_base::iostate&amp; __err, float&amp; __v) const<span class="lineNum">    2061 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    2062 </span>            : <span class="lineNum">    2063 </span>            :       iter_type<span class="lineNum">    2064 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2065 </span>            :           ios_base::iostate&amp; __err, double&amp; __v) const<span class="lineNum">    2066 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    2067 </span>            : <span class="lineNum">    2068 </span>            :       iter_type<span class="lineNum">    2069 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2070 </span>            :           ios_base::iostate&amp; __err, long double&amp; __v) const<span class="lineNum">    2071 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    2072 </span>            :       //@}<span class="lineNum">    2073 </span>            : <span class="lineNum">    2074 </span>            :       /**<span class="lineNum">    2075 </span>            :        *  @brief  Numeric parsing.<span class="lineNum">    2076 </span>            :        *<span class="lineNum">    2077 </span>            :        *  Parses the input stream into the pointer variable @a v.  It does so<span class="lineNum">    2078 </span>            :        *  by calling num_get::do_get().<span class="lineNum">    2079 </span>            :        *<span class="lineNum">    2080 </span>            :        *  The input characters are parsed like the scanf %p specifier.<span class="lineNum">    2081 </span>            :        *<span class="lineNum">    2082 </span>            :        *  Digit grouping is interpreted according to<span class="lineNum">    2083 </span>            :        *  numpunct::grouping() and numpunct::thousands_sep().  If the<span class="lineNum">    2084 </span>            :        *  pattern of digit groups isn't consistent, sets err to<span class="lineNum">    2085 </span>            :        *  ios_base::failbit.<span class="lineNum">    2086 </span>            :        *<span class="lineNum">    2087 </span>            :        *  Note that the digit grouping effect for pointers is a bit ambiguous<span class="lineNum">    2088 </span>            :        *  in the standard and shouldn't be relied on.  See DR 344.<span class="lineNum">    2089 </span>            :        *<span class="lineNum">    2090 </span>            :        *  If parsing the string yields a valid value for @a v, @a v is set.<span class="lineNum">    2091 </span>            :        *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.<span class="lineNum">    2092 </span>            :        *  Sets err to ios_base::eofbit if the stream is emptied.<span class="lineNum">    2093 </span>            :        *<span class="lineNum">    2094 </span>            :        *  @param  __in  Start of input stream.<span class="lineNum">    2095 </span>            :        *  @param  __end  End of input stream.<span class="lineNum">    2096 </span>            :        *  @param  __io  Source of locale and flags.<span class="lineNum">    2097 </span>            :        *  @param  __err  Error flags to set.<span class="lineNum">    2098 </span>            :        *  @param  __v  Value to format and insert.<span class="lineNum">    2099 </span>            :        *  @return  Iterator after reading.<span class="lineNum">    2100 </span>            :       */<span class="lineNum">    2101 </span>            :       iter_type<span class="lineNum">    2102 </span>            :       get(iter_type __in, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2103 </span>            :           ios_base::iostate&amp; __err, void*&amp; __v) const<span class="lineNum">    2104 </span>            :       { return this-&gt;do_get(__in, __end, __io, __err, __v); }<span class="lineNum">    2105 </span>            : <span class="lineNum">    2106 </span>            :     protected:<span class="lineNum">    2107 </span>            :       /// Destructor.<span class="lineNum">    2108 </span>            :       virtual ~num_get() { }<span class="lineNum">    2109 </span>            : <span class="lineNum">    2110 </span>            :       iter_type<span class="lineNum">    2111 </span>            :       _M_extract_float(iter_type, iter_type, ios_base&amp;, ios_base::iostate&amp;,<span class="lineNum">    2112 </span>            :                        string&amp;) const;<span class="lineNum">    2113 </span>            : <span class="lineNum">    2114 </span>            :       template&lt;typename _ValueT&gt;<span class="lineNum">    2115 </span>            :         iter_type<span class="lineNum">    2116 </span>            :         _M_extract_int(iter_type, iter_type, ios_base&amp;, ios_base::iostate&amp;,<span class="lineNum">    2117 </span>            :                        _ValueT&amp;) const;<span class="lineNum">    2118 </span>            : <span class="lineNum">    2119 </span>            :       template&lt;typename _CharT2&gt;<span class="lineNum">    2120 </span>            :       typename __gnu_cxx::__enable_if&lt;__is_char&lt;_CharT2&gt;::__value, int&gt;::__type<span class="lineNum">    2121 </span>            :         _M_find(const _CharT2*, size_t __len, _CharT2 __c) const<span class="lineNum">    2122 </span>            :         {<span class="lineNum">    2123 </span>            :           int __ret = -1;<span class="lineNum">    2124 </span>            :           if (__len &lt;= 10)<span class="lineNum">    2125 </span>            :             {<span class="lineNum">    2126 </span>            :               if (__c &gt;= _CharT2('0') &amp;&amp; __c &lt; _CharT2(_CharT2('0') + __len))<span class="lineNum">    2127 </span>            :                 __ret = __c - _CharT2('0');<span class="lineNum">    2128 </span>            :             }<span class="lineNum">    2129 </span>            :           else<span class="lineNum">    2130 </span>            :             {<span class="lineNum">    2131 </span>            :               if (__c &gt;= _CharT2('0') &amp;&amp; __c &lt;= _CharT2('9'))<span class="lineNum">    2132 </span>            :                 __ret = __c - _CharT2('0');<span class="lineNum">    2133 </span>            :               else if (__c &gt;= _CharT2('a') &amp;&amp; __c &lt;= _CharT2('f'))<span class="lineNum">    2134 </span>            :                 __ret = 10 + (__c - _CharT2('a'));<span class="lineNum">    2135 </span>            :               else if (__c &gt;= _CharT2('A') &amp;&amp; __c &lt;= _CharT2('F'))<span class="lineNum">    2136 </span>            :                 __ret = 10 + (__c - _CharT2('A'));<span class="lineNum">    2137 </span>            :             }<span class="lineNum">    2138 </span>            :           return __ret;<span class="lineNum">    2139 </span>            :         }<span class="lineNum">    2140 </span>            : <span class="lineNum">    2141 </span>            :       template&lt;typename _CharT2&gt;<span class="lineNum">    2142 </span>            :       typename __gnu_cxx::__enable_if&lt;!__is_char&lt;_CharT2&gt;::__value,<span class="lineNum">    2143 </span>            :                                       int&gt;::__type<span class="lineNum">    2144 </span>            :         _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const<span class="lineNum">    2145 </span>            :         {<span class="lineNum">    2146 </span>            :           int __ret = -1;<span class="lineNum">    2147 </span>            :           const char_type* __q = char_traits&lt;_CharT2&gt;::find(__zero, __len, __c);<span class="lineNum">    2148 </span>            :           if (__q)<span class="lineNum">    2149 </span>            :             {<span class="lineNum">    2150 </span>            :               __ret = __q - __zero;<span class="lineNum">    2151 </span>            :               if (__ret &gt; 15)<span class="lineNum">    2152 </span>            :                 __ret -= 6;<span class="lineNum">    2153 </span>            :             }<span class="lineNum">    2154 </span>            :           return __ret;<span class="lineNum">    2155 </span>            :         }<span class="lineNum">    2156 </span>            : <span class="lineNum">    2157 </span>            :       //@{<span class="lineNum">    2158 </span>            :       /**<span class="lineNum">    2159 </span>            :        *  @brief  Numeric parsing.<span class="lineNum">    2160 </span>            :        *<span class="lineNum">    2161 </span>            :        *  Parses the input stream into the variable @a v.  This function is a<span class="lineNum">    2162 </span>            :        *  hook for derived classes to change the value returned.  @see get()<span class="lineNum">    2163 </span>            :        *  for more details.<span class="lineNum">    2164 </span>            :        *<span class="lineNum">    2165 </span>            :        *  @param  __beg  Start of input stream.<span class="lineNum">    2166 </span>            :        *  @param  __end  End of input stream.<span class="lineNum">    2167 </span>            :        *  @param  __io  Source of locale and flags.<span class="lineNum">    2168 </span>            :        *  @param  __err  Error flags to set.<span class="lineNum">    2169 </span>            :        *  @param  __v  Value to format and insert.<span class="lineNum">    2170 </span>            :        *  @return  Iterator after reading.<span class="lineNum">    2171 </span>            :       */<span class="lineNum">    2172 </span>            :       virtual iter_type<span class="lineNum">    2173 </span>            :       do_get(iter_type, iter_type, ios_base&amp;, ios_base::iostate&amp;, bool&amp;) const;<span class="lineNum">    2174 </span>            : <span class="lineNum">    2175 </span>            :       virtual iter_type<span class="lineNum">    2176 </span>            :       do_get(iter_type __beg, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2177 </span>            :              ios_base::iostate&amp; __err, long&amp; __v) const<span class="lineNum">    2178 </span>            :       { return _M_extract_int(__beg, __end, __io, __err, __v); }<span class="lineNum">    2179 </span>            : <span class="lineNum">    2180 </span>            :       virtual iter_type<span class="lineNum">    2181 </span>            :       do_get(iter_type __beg, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2182 </span>            :              ios_base::iostate&amp; __err, unsigned short&amp; __v) const<span class="lineNum">    2183 </span>            :       { return _M_extract_int(__beg, __end, __io, __err, __v); }<span class="lineNum">    2184 </span>            : <span class="lineNum">    2185 </span>            :       virtual iter_type<span class="lineNum">    2186 </span>            :       do_get(iter_type __beg, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2187 </span>            :              ios_base::iostate&amp; __err, unsigned int&amp; __v) const<span class="lineNum">    2188 </span>            :       { return _M_extract_int(__beg, __end, __io, __err, __v); }<span class="lineNum">    2189 </span>            : <span class="lineNum">    2190 </span>            :       virtual iter_type<span class="lineNum">    2191 </span>            :       do_get(iter_type __beg, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2192 </span>            :              ios_base::iostate&amp; __err, unsigned long&amp; __v) const<span class="lineNum">    2193 </span>            :       { return _M_extract_int(__beg, __end, __io, __err, __v); }<span class="lineNum">    2194 </span>            : <span class="lineNum">    2195 </span>            : #ifdef _GLIBCXX_USE_LONG_LONG<span class="lineNum">    2196 </span>            :       virtual iter_type<span class="lineNum">    2197 </span>            :       do_get(iter_type __beg, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2198 </span>            :              ios_base::iostate&amp; __err, long long&amp; __v) const<span class="lineNum">    2199 </span>            :       { return _M_extract_int(__beg, __end, __io, __err, __v); }<span class="lineNum">    2200 </span>            : <span class="lineNum">    2201 </span>            :       virtual iter_type<span class="lineNum">    2202 </span>            :       do_get(iter_type __beg, iter_type __end, ios_base&amp; __io,<span class="lineNum">    2203 </span>            :              ios_base::iostate&amp; __err, unsigned long long&amp; __v) const<span class="lineNum">    2204 </span>            :       { return _M_extract_int(__beg, __end, __io, __err, __v); }<span class="lineNum">    2205 </span>            : #endif<span class="lineNum">    2206 </span>            : <span class="lineNum">    2207 </span>            :       virtual iter_type<span class="lineNum">    2208 </span>            :       do_get(iter_type, iter_type, ios_base&amp;, ios_base::iostate&amp;, float&amp;) const;<span class="lineNum">    2209 </span>            : <span class="lineNum">    2210 </span>            :       virtual iter_type<span class="lineNum">    2211 </span>            :       do_get(iter_type, iter_type, ios_base&amp;, ios_base::iostate&amp;,<span class="lineNum">    2212 </span>            :              double&amp;) const;<span class="lineNum">    2213 </span>            : <span class="lineNum">    2214 </span>            :       // XXX GLIBCXX_ABI Deprecated<span class="lineNum">    2215 </span>            : #if defined _GLIBCXX_LONG_DOUBLE_COMPAT &amp;&amp; defined __LONG_DOUBLE_128__<span class="lineNum">    2216 </span>            :       virtual iter_type<span class="lineNum">    2217 </span>            :       __do_get(iter_type, iter_type, ios_base&amp;, ios_base::iostate&amp;,<span class="lineNum">    2218 </span>            :                double&amp;) const;<span class="lineNum">    2219 </span>            : #else<span class="lineNum">    2220 </span>            :       virtual iter_type<span class="lineNum">    2221 </span>            :       do_get(iter_type, iter_type, ios_base&amp;, ios_base::iostate&amp;,<span class="lineNum">    2222 </span>            :              long double&amp;) const;<span class="lineNum">    2223 </span>            : #endif<span class="lineNum">    2224 </span>            : <span class="lineNum">    2225 </span>            :       virtual iter_type<span class="lineNum">    2226 </span>            :       do_get(iter_type, iter_type, ios_base&amp;, ios_base::iostate&amp;, void*&amp;) const;<span class="lineNum">    2227 </span>            : <span class="lineNum">    2228 </span>            :       // XXX GLIBCXX_ABI Deprecated<span class="lineNum">    2229 </span>            : #if defined _GLIBCXX_LONG_DOUBLE_COMPAT &amp;&amp; defined __LONG_DOUBLE_128__<span class="lineNum">    2230 </span>            :       virtual iter_type<span class="lineNum">    2231 </span>            :       do_get(iter_type, iter_type, ios_base&amp;, ios_base::iostate&amp;,<span class="lineNum">    2232 </span>            :              long double&amp;) const;<span class="lineNum">    2233 </span>            : #endif<span class="lineNum">    2234 </span>            :       //@}<span class="lineNum">    2235 </span>            :     };<span class="lineNum">    2236 </span>            : <span class="lineNum">    2237 </span>            :   template&lt;typename _CharT, typename _InIter&gt;<span class="lineNum">    2238 </span>            :     locale::id num_get&lt;_CharT, _InIter&gt;::id;<span class="lineNum">    2239 </span>            : <span class="lineNum">    2240 </span>            : <span class="lineNum">    2241 </span>            :   /**<span class="lineNum">    2242 </span>            :    *  @brief  Primary class template num_put.<span class="lineNum">    2243 </span>            :    *  @ingroup locales<span class="lineNum">    2244 </span>            :    *<span class="lineNum">    2245 </span>            :    *  This facet encapsulates the code to convert a number to a string.  It is<span class="lineNum">    2246 </span>            :    *  used by the ostream numeric insertion operators.<span class="lineNum">    2247 </span>            :    *<span class="lineNum">    2248 </span>            :    *  The num_put template uses protected virtual functions to provide the<span class="lineNum">    2249 </span>            :    *  actual results.  The public accessors forward the call to the virtual<span class="lineNum">    2250 </span>            :    *  functions.  These virtual functions are hooks for developers to<span class="lineNum">    2251 </span>            :    *  implement the behavior they require from the num_put facet.<span class="lineNum">    2252 </span>            :   */<span class="lineNum">    2253 </span>            :   template&lt;typename _CharT, typename _OutIter&gt;<span class="lineNum">    2254 </span>            :     class num_put : public locale::facet<span class="lineNum">    2255 </span>            :     {<span class="lineNum">    2256 </span>            :     public:<span class="lineNum">    2257 </span>            :       // Types:<span class="lineNum">    2258 </span>            :       //@{<span class="lineNum">    2259 </span>            :       /// Public typedefs<span class="lineNum">    2260 </span>            :       typedef _CharT            char_type;<span class="lineNum">    2261 </span>            :       typedef _OutIter          iter_type;<span class="lineNum">    2262 </span>            :       //@}<span class="lineNum">    2263 </span>            : <span class="lineNum">    2264 </span>            :       /// Numpunct facet id.<span class="lineNum">    2265 </span>            :       static locale::id         id;<span class="lineNum">    2266 </span>            : <span class="lineNum">    2267 </span>            :       /**<span class="lineNum">    2268 </span>            :        *  @brief  Constructor performs initialization.<span class="lineNum">    2269 </span>            :        *<span class="lineNum">    2270 </span>            :        *  This is the constructor provided by the standard.<span class="lineNum">    2271 </span>            :        *<span class="lineNum">    2272 </span>            :        *  @param __refs  Passed to the base facet class.<span class="lineNum">    2273 </span>            :       */<span class="lineNum">    2274 </span>            :       explicit<span class="lineNum">    2275 </span>            :       num_put(size_t __refs = 0) : facet(__refs) { }<span class="lineNum">    2276 </span>            : <span class="lineNum">    2277 </span>            :       /**<span class="lineNum">    2278 </span>            :        *  @brief  Numeric formatting.<span class="lineNum">    2279 </span>            :        *<span class="lineNum">    2280 </span>            :        *  Formats the boolean @a v and inserts it into a stream.  It does so<span class="lineNum">    2281 </span>            :        *  by calling num_put::do_put().<span class="lineNum">    2282 </span>            :        *<span class="lineNum">    2283 </span>            :        *  If ios_base::boolalpha is set, writes ctype&lt;CharT&gt;::truename() or<span class="lineNum">    2284 </span>            :        *  ctype&lt;CharT&gt;::falsename().  Otherwise formats @a v as an int.<span class="lineNum">    2285 </span>            :        *<span class="lineNum">    2286 </span>            :        *  @param  __s  Stream to write to.<span class="lineNum">    2287 </span>            :        *  @param  __io  Source of locale and flags.<span class="lineNum">    2288 </span>            :        *  @param  __fill  Char_type to use for filling.<span class="lineNum">    2289 </span>            :        *  @param  __v  Value to format and insert.<span class="lineNum">    2290 </span>            :        *  @return  Iterator after writing.<span class="lineNum">    2291 </span>            :       */<span class="lineNum">    2292 </span>            :       iter_type<span class="lineNum">    2293 </span>            :       put(iter_type __s, ios_base&amp; __io, char_type __fill, bool __v) const<span class="lineNum">    2294 </span>            :       { return this-&gt;do_put(__s, __io, __fill, __v); }<span class="lineNum">    2295 </span>            : <span class="lineNum">    2296 </span>            :       //@{<span class="lineNum">    2297 </span>            :       /**<span class="lineNum">    2298 </span>            :        *  @brief  Numeric formatting.<span class="lineNum">    2299 </span>            :        *<span class="lineNum">    2300 </span>            :        *  Formats the integral value @a v and inserts it into a<span class="lineNum">    2301 </span>            :        *  stream.  It does so by calling num_put::do_put().<span class="lineNum">    2302 </span>            :        *<span class="lineNum">    2303 </span>            :        *  Formatting is affected by the flag settings in @a io.<span class="lineNum">    2304 </span>            :        *<span class="lineNum">    2305 </span>            :        *  The basic format is affected by the value of io.flags() &amp;<span class="lineNum">    2306 </span>            :        *  ios_base::basefield.  If equal to ios_base::oct, formats like the<span class="lineNum">    2307 </span>            :        *  printf %o specifier.  Else if equal to ios_base::hex, formats like<span class="lineNum">    2308 </span>            :        *  %x or %X with ios_base::uppercase unset or set respectively.<span class="lineNum">    2309 </span>            :        *  Otherwise, formats like %d, %ld, %lld for signed and %u, %lu, %llu<span class="lineNum">    2310 </span>            :        *  for unsigned values.  Note that if both oct and hex are set, neither<span class="lineNum">    2311 </span>            :        *  will take effect.<span class="lineNum">    2312 </span>            :        *<span class="lineNum">    2313 </span>            :        *  If ios_base::showpos is set, '+' is output before positive values.<span class="lineNum">    2314 </span>            :        *  If ios_base::showbase is set, '0' precedes octal values (except 0)<span class="lineNum">    2315 </span>            :        *  and '0[xX]' precedes hex values.<span class="lineNum">    2316 </span>            :        *<span class="lineNum">    2317 </span>            :        *  The decimal point character used is numpunct::decimal_point().<span class="lineNum">    2318 </span>            :        *  Thousands separators are inserted according to<span class="lineNum">    2319 </span>            :        *  numpunct::grouping() and numpunct::thousands_sep().<span class="lineNum">    2320 </span>            :        *<span class="lineNum">    2321 </span>            :        *  If io.width() is non-zero, enough @a fill characters are inserted to<span class="lineNum">    2322 </span>            :        *  make the result at least that wide.  If<span class="lineNum">    2323 </span>            :        *  (io.flags() &amp; ios_base::adjustfield) == ios_base::left, result is<span class="lineNum">    2324 </span>            :        *  padded at the end.  If ios_base::internal, then padding occurs<span class="lineNum">    2325 </span>            :        *  immediately after either a '+' or '-' or after '0x' or '0X'.<span class="lineNum">    2326 </span>            :        *  Otherwise, padding occurs at the beginning.<span class="lineNum">    2327 </span>            :        *<span class="lineNum">    2328 </span>            :        *  @param  __s  Stream to write to.<span class="lineNum">    2329 </span>            :        *  @param  __io  Source of locale and flags.<span class="lineNum">    2330 </span>            :        *  @param  __fill  Char_type to use for filling.<span class="lineNum">    2331 </span>            :        *  @param  __v  Value to format and insert.<span class="lineNum">    2332 </span>            :        *  @return  Iterator after writing.<span class="lineNum">    2333 </span>            :       */<span class="lineNum">    2334 </span>            :       iter_type<span class="lineNum">    2335 </span>            :       put(iter_type __s, ios_base&amp; __io, char_type __fill, long __v) const<span class="lineNum">    2336 </span>            :       { return this-&gt;do_put(__s, __io, __fill, __v); }<span class="lineNum">    2337 </span>            : <span class="lineNum">    2338 </span>            :       iter_type<span class="lineNum">    2339 </span>            :       put(iter_type __s, ios_base&amp; __io, char_type __fill,<span class="lineNum">    2340 </span>            :           unsigned long __v) const<span class="lineNum">    2341 </span>            :       { return this-&gt;do_put(__s, __io, __fill, __v); }<span class="lineNum">    2342 </span>            : <span class="lineNum">    2343 </span>            : #ifdef _GLIBCXX_USE_LONG_LONG<span class="lineNum">    2344 </span>            :       iter_type<span class="lineNum">    2345 </span>            :       put(iter_type __s, ios_base&amp; __io, char_type __fill, long long __v) const<span class="lineNum">    2346 </span>            :       { return this-&gt;do_put(__s, __io, __fill, __v); }<span class="lineNum">    2347 </span>            : <span class="lineNum">    2348 </span>            :       iter_type<span class="lineNum">    2349 </span>            :       put(iter_type __s, ios_base&amp; __io, char_type __fill,<span class="lineNum">    2350 </span>            :           unsigned long long __v) const<span class="lineNum">    2351 </span>            :       { return this-&gt;do_put(__s, __io, __fill, __v); }<span class="lineNum">    2352 </span>            : #endif<span class="lineNum">    2353 </span>            :       //@}<span class="lineNum">    2354 </span>            : <span class="lineNum">    2355 </span>            :       //@{<span class="lineNum">    2356 </span>            :       /**<span class="lineNum">    2357 </span>            :        *  @brief  Numeric formatting.<span class="lineNum">    2358 </span>            :        *<span class="lineNum">    2359 </span>            :        *  Formats the floating point value @a v and inserts it into a stream.<span class="lineNum">    2360 </span>            :        *  It does so by calling num_put::do_put().<span class="lineNum">    2361 </span>            :        *<span class="lineNum">    2362 </span>            :        *  Formatting is affected by the flag settings in @a io.<span class="lineNum">    2363 </span>            :        *<span class="lineNum">    2364 </span>            :        *  The basic format is affected by the value of io.flags() &amp;<span class="lineNum">    2365 </span>            :        *  ios_base::floatfield.  If equal to ios_base::fixed, formats like the<span class="lineNum">    2366 </span>            :        *  printf %f specifier.  Else if equal to ios_base::scientific, formats<span class="lineNum">    2367 </span>            :        *  like %e or %E with ios_base::uppercase unset or set respectively.<span class="lineNum">    2368 </span>            :        *  Otherwise, formats like %g or %G depending on uppercase.  Note that<span class="lineNum">    2369 </span>            :        *  if both fixed and scientific are set, the effect will also be like<span class="lineNum">    2370 </span>            :        *  %g or %G.<span class="lineNum">    2371 </span>            :        *<span class="lineNum">    2372 </span>            :        *  The output precision is given by io.precision().  This precision is<span class="lineNum">    2373 </span>            :        *  capped at numeric_limits::digits10 + 2 (different for double and<span class="lineNum">    2374 </span>            :        *  long double).  The default precision is 6.<span class="lineNum">    2375 </span>            :        *<span class="lineNum">    2376 </span>            :        *  If ios_base::showpos is set, '+' is output before positive values.<span class="lineNum">    2377 </span>            :        *  If ios_base::showpoint is set, a decimal point will always be<span class="lineNum">    2378 </span>            :        *  output.<span class="lineNum">    2379 </span>            :        *<span class="lineNum">    2380 </span>            :        *  The decimal point character used is numpunct::decimal_point().<span class="lineNum">    2381 </span>            :        *  Thousands separators are inserted according to<span class="lineNum">    2382 </span>            :        *  numpunct::grouping() and numpunct::thousands_sep().<span class="lineNum">    2383 </span>            :        *<span class="lineNum">    2384 </span>            :        *  If io.width() is non-zero, enough @a fill characters are inserted to<span class="lineNum">    2385 </span>            :        *  make the result at least that wide.  If<span class="lineNum">    2386 </span>            :        *  (io.flags() &amp; ios_base::adjustfield) == ios_base::left, result is<span class="lineNum">    2387 </span>            :        *  padded at the end.  If ios_base::internal, then padding occurs<span class="lineNum">    2388 </span>            :        *  immediately after either a '+' or '-' or after '0x' or '0X'.<span class="lineNum">    2389 </span>            :        *  Otherwise, padding occurs at the beginning.<span class="lineNum">    2390 </span>            :        *<span class="lineNum">    2391 </span>            :        *  @param  __s  Stream to write to.<span class="lineNum">    2392 </span>            :        *  @param  __io  Source of locale and flags.<span class="lineNum">    2393 </span>            :        *  @param  __fill  Char_type to use for filling.<span class="lineNum">    2394 </span>            :        *  @param  __v  Value to format and insert.<span class="lineNum">    2395 </span>            :        *  @return  Iterator after writing.<span class="lineNum">    2396 </span>            :       */<span class="lineNum">    2397 </span>            :       iter_type<span class="lineNum">    2398 </span>            :       put(iter_type __s, ios_base&amp; __io, char_type __fill, double __v) const<span class="lineNum">    2399 </span>            :       { return this-&gt;do_put(__s, __io, __fill, __v); }<span class="lineNum">    2400 </span>            : <span class="lineNum">    2401 </span>            :       iter_type<span class="lineNum">    2402 </span>            :       put(iter_type __s, ios_base&amp; __io, char_type __fill,<span class="lineNum">    2403 </span>            :           long double __v) const<span class="lineNum">    2404 </span>            :       { return this-&gt;do_put(__s, __io, __fill, __v); }<span class="lineNum">    2405 </span>            :       //@}<span class="lineNum">    2406 </span>            : <span class="lineNum">    2407 </span>            :       /**<span class="lineNum">    2408 </span>            :        *  @brief  Numeric formatting.<span class="lineNum">    2409 </span>            :        *<span class="lineNum">    2410 </span>            :        *  Formats the pointer value @a v and inserts it into a stream.  It<span class="lineNum">    2411 </span>            :        *  does so by calling num_put::do_put().<span class="lineNum">    2412 </span>            :        *<span class="lineNum">    2413 </span>            :        *  This function formats @a v as an unsigned long with ios_base::hex<span class="lineNum">    2414 </span>            :        *  and ios_base::showbase set.<span class="lineNum">    2415 </span>            :        *<span class="lineNum">    2416 </span>            :        *  @param  __s  Stream to write to.<span class="lineNum">    2417 </span>            :        *  @param  __io  Source of locale and flags.<span class="lineNum">    2418 </span>            :        *  @param  __fill  Char_type to use for filling.<span class="lineNum">    2419 </span>            :        *  @param  __v  Value to format and insert.<span class="lineNum">    2420 </span>            :        *  @return  Iterator after writing.<span class="lineNum">    2421 </span>            :       */<span class="lineNum">    2422 </span>            :       iter_type<span class="lineNum">    2423 </span>            :       put(iter_type __s, ios_base&amp; __io, char_type __fill,<span class="lineNum">    2424 </span>            :           const void* __v) const<span class="lineNum">    2425 </span>            :       { return this-&gt;do_put(__s, __io, __fill, __v); }<span class="lineNum">    2426 </span>            : <span class="lineNum">    2427 </span>            :     protected:<span class="lineNum">    2428 </span>            :       template&lt;typename _ValueT&gt;<span class="lineNum">    2429 </span>            :         iter_type<span class="lineNum">    2430 </span>            :         _M_insert_float(iter_type, ios_base&amp; __io, char_type __fill,<span class="lineNum">    2431 </span>            :                         char __mod, _ValueT __v) const;<span class="lineNum">    2432 </span>            : <span class="lineNum">    2433 </span>            :       void<span class="lineNum">    2434 </span>            :       _M_group_float(const char* __grouping, size_t __grouping_size,<span class="lineNum">    2435 </span>            :                      char_type __sep, const char_type* __p, char_type* __new,<span class="lineNum">    2436 </span>            :                      char_type* __cs, int&amp; __len) const;<span class="lineNum">    2437 </span>            : <span class="lineNum">    2438 </span>            :       template&lt;typename _ValueT&gt;<span class="lineNum">    2439 </span>            :         iter_type<span class="lineNum">    2440 </span>            :         _M_insert_int(iter_type, ios_base&amp; __io, char_type __fill,<span class="lineNum">    2441 </span>            :                       _ValueT __v) const;<span class="lineNum">    2442 </span>            : <span class="lineNum">    2443 </span>            :       void<span class="lineNum">    2444 </span>            :       _M_group_int(const char* __grouping, size_t __grouping_size,<span class="lineNum">    2445 </span>            :                    char_type __sep, ios_base&amp; __io, char_type* __new,<span class="lineNum">    2446 </span>            :                    char_type* __cs, int&amp; __len) const;<span class="lineNum">    2447 </span>            : <span class="lineNum">    2448 </span>            :       void<span class="lineNum">    2449 </span>            :       _M_pad(char_type __fill, streamsize __w, ios_base&amp; __io,<span class="lineNum">    2450 </span>            :              char_type* __new, const char_type* __cs, int&amp; __len) const;<span class="lineNum">    2451 </span>            : <span class="lineNum">    2452 </span>            :       /// Destructor.<span class="lineNum">    2453 </span>            :       virtual<span class="lineNum">    2454 </span>            :       ~num_put() { };<span class="lineNum">    2455 </span>            : <span class="lineNum">    2456 </span>            :       //@{<span class="lineNum">    2457 </span>            :       /**<span class="lineNum">    2458 </span>            :        *  @brief  Numeric formatting.<span class="lineNum">    2459 </span>            :        *<span class="lineNum">    2460 </span>            :        *  These functions do the work of formatting numeric values and<span class="lineNum">    2461 </span>            :        *  inserting them into a stream. This function is a hook for derived<span class="lineNum">    2462 </span>            :        *  classes to change the value returned.<span class="lineNum">    2463 </span>            :        *<span class="lineNum">    2464 </span>            :        *  @param  __s  Stream to write to.<span class="lineNum">    2465 </span>            :        *  @param  __io  Source of locale and flags.<span class="lineNum">    2466 </span>            :        *  @param  __fill  Char_type to use for filling.<span class="lineNum">    2467 </span>            :        *  @param  __v  Value to format and insert.<span class="lineNum">    2468 </span>            :        *  @return  Iterator after writing.<span class="lineNum">    2469 </span>            :       */<span class="lineNum">    2470 </span>            :       virtual iter_type<span class="lineNum">    2471 </span>            :       do_put(iter_type __s, ios_base&amp; __io, char_type __fill, bool __v) const;<span class="lineNum">    2472 </span>            : <span class="lineNum">    2473 </span>            :       virtual iter_type<span class="lineNum">    2474 </span>            :       do_put(iter_type __s, ios_base&amp; __io, char_type __fill, long __v) const<span class="lineNum">    2475 </span>            :       { return _M_insert_int(__s, __io, __fill, __v); }<span class="lineNum">    2476 </span>            : <span class="lineNum">    2477 </span>            :       virtual iter_type<span class="lineNum">    2478 </span>            :       do_put(iter_type __s, ios_base&amp; __io, char_type __fill,<span class="lineNum">    2479 </span>            :              unsigned long __v) const<span class="lineNum">    2480 </span>            :       { return _M_insert_int(__s, __io, __fill, __v); }<span class="lineNum">    2481 </span>            : <span class="lineNum">    2482 </span>            : #ifdef _GLIBCXX_USE_LONG_LONG<span class="lineNum">    2483 </span>            :       virtual iter_type<span class="lineNum">    2484 </span>            :       do_put(iter_type __s, ios_base&amp; __io, char_type __fill,<span class="lineNum">    2485 </span>            :              long long __v) const<span class="lineNum">    2486 </span>            :       { return _M_insert_int(__s, __io, __fill, __v); }<span class="lineNum">    2487 </span>            : <span class="lineNum">    2488 </span>            :       virtual iter_type<span class="lineNum">    2489 </span>            :       do_put(iter_type __s, ios_base&amp; __io, char_type __fill,<span class="lineNum">    2490 </span>            :              unsigned long long __v) const<span class="lineNum">    2491 </span>            :       { return _M_insert_int(__s, __io, __fill, __v); }<span class="lineNum">    2492 </span>            : #endif<span class="lineNum">    2493 </span>            : <span class="lineNum">    2494 </span>            :       virtual iter_type<span class="lineNum">    2495 </span>            :       do_put(iter_type, ios_base&amp;, char_type, double) const;<span class="lineNum">    2496 </span>            : <span class="lineNum">    2497 </span>            :       // XXX GLIBCXX_ABI Deprecated<span class="lineNum">    2498 </span>            : #if defined _GLIBCXX_LONG_DOUBLE_COMPAT &amp;&amp; defined __LONG_DOUBLE_128__<span class="lineNum">    2499 </span>            :       virtual iter_type<span class="lineNum">    2500 </span>            :       __do_put(iter_type, ios_base&amp;, char_type, double) const;<span class="lineNum">    2501 </span>            : #else<span class="lineNum">    2502 </span>            :       virtual iter_type<span class="lineNum">    2503 </span>            :       do_put(iter_type, ios_base&amp;, char_type, long double) const;<span class="lineNum">    2504 </span>            : #endif<span class="lineNum">    2505 </span>            : <span class="lineNum">    2506 </span>            :       virtual iter_type<span class="lineNum">    2507 </span>            :       do_put(iter_type, ios_base&amp;, char_type, const void*) const;<span class="lineNum">    2508 </span>            : <span class="lineNum">    2509 </span>            :       // XXX GLIBCXX_ABI Deprecated<span class="lineNum">    2510 </span>            : #if defined _GLIBCXX_LONG_DOUBLE_COMPAT &amp;&amp; defined __LONG_DOUBLE_128__<span class="lineNum">    2511 </span>            :       virtual iter_type<span class="lineNum">    2512 </span>            :       do_put(iter_type, ios_base&amp;, char_type, long double) const;<span class="lineNum">    2513 </span>            : #endif<span class="lineNum">    2514 </span>            :       //@}<span class="lineNum">    2515 </span>            :     };<span class="lineNum">    2516 </span>            : <span class="lineNum">    2517 </span>            :   template &lt;typename _CharT, typename _OutIter&gt;<span class="lineNum">    2518 </span>            :     locale::id num_put&lt;_CharT, _OutIter&gt;::id;<span class="lineNum">    2519 </span>            : <span class="lineNum">    2520 </span>            : _GLIBCXX_END_NAMESPACE_LDBL<span class="lineNum">    2521 </span>            : <span class="lineNum">    2522 </span>            :   // Subclause convenience interfaces, inlines.<span class="lineNum">    2523 </span>            :   // NB: These are inline because, when used in a loop, some compilers<span class="lineNum">    2524 </span>            :   // can hoist the body out of the loop; then it's just as fast as the<span class="lineNum">    2525 </span>            :   // C is*() function.<span class="lineNum">    2526 </span>            : <span class="lineNum">    2527 </span>            :   /// Convenience interface to ctype.is(ctype_base::space, __c).<span class="lineNum">    2528 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2529 </span>            :     inline bool<span class="lineNum">    2530 </span>            :     isspace(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2531 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::space, __c); }<span class="lineNum">    2532 </span>            : <span class="lineNum">    2533 </span>            :   /// Convenience interface to ctype.is(ctype_base::print, __c).<span class="lineNum">    2534 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2535 </span>            :     inline bool<span class="lineNum">    2536 </span>            :     isprint(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2537 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::print, __c); }<span class="lineNum">    2538 </span>            : <span class="lineNum">    2539 </span>            :   /// Convenience interface to ctype.is(ctype_base::cntrl, __c).<span class="lineNum">    2540 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2541 </span>            :     inline bool<span class="lineNum">    2542 </span>            :     iscntrl(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2543 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::cntrl, __c); }<span class="lineNum">    2544 </span>            : <span class="lineNum">    2545 </span>            :   /// Convenience interface to ctype.is(ctype_base::upper, __c).<span class="lineNum">    2546 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2547 </span>            :     inline bool<span class="lineNum">    2548 </span>            :     isupper(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2549 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::upper, __c); }<span class="lineNum">    2550 </span>            : <span class="lineNum">    2551 </span>            :   /// Convenience interface to ctype.is(ctype_base::lower, __c).<span class="lineNum">    2552 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2553 </span>            :     inline bool<span class="lineNum">    2554 </span>            :     islower(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2555 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::lower, __c); }<span class="lineNum">    2556 </span>            : <span class="lineNum">    2557 </span>            :   /// Convenience interface to ctype.is(ctype_base::alpha, __c).<span class="lineNum">    2558 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2559 </span>            :     inline bool<span class="lineNum">    2560 </span>            :     isalpha(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2561 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::alpha, __c); }<span class="lineNum">    2562 </span>            : <span class="lineNum">    2563 </span>            :   /// Convenience interface to ctype.is(ctype_base::digit, __c).<span class="lineNum">    2564 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2565 </span>            :     inline bool<span class="lineNum">    2566 </span>            :     isdigit(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2567 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::digit, __c); }<span class="lineNum">    2568 </span>            : <span class="lineNum">    2569 </span>            :   /// Convenience interface to ctype.is(ctype_base::punct, __c).<span class="lineNum">    2570 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2571 </span>            :     inline bool<span class="lineNum">    2572 </span>            :     ispunct(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2573 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::punct, __c); }<span class="lineNum">    2574 </span>            : <span class="lineNum">    2575 </span>            :   /// Convenience interface to ctype.is(ctype_base::xdigit, __c).<span class="lineNum">    2576 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2577 </span>            :     inline bool<span class="lineNum">    2578 </span>            :     isxdigit(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2579 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::xdigit, __c); }<span class="lineNum">    2580 </span>            : <span class="lineNum">    2581 </span>            :   /// Convenience interface to ctype.is(ctype_base::alnum, __c).<span class="lineNum">    2582 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2583 </span>            :     inline bool<span class="lineNum">    2584 </span>            :     isalnum(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2585 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::alnum, __c); }<span class="lineNum">    2586 </span>            : <span class="lineNum">    2587 </span>            :   /// Convenience interface to ctype.is(ctype_base::graph, __c).<span class="lineNum">    2588 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2589 </span>            :     inline bool<span class="lineNum">    2590 </span>            :     isgraph(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2591 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).is(ctype_base::graph, __c); }<span class="lineNum">    2592 </span>            : <span class="lineNum">    2593 </span>            :   /// Convenience interface to ctype.toupper(__c).<span class="lineNum">    2594 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2595 </span>            :     inline _CharT<span class="lineNum">    2596 </span>            :     toupper(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2597 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).toupper(__c); }<span class="lineNum">    2598 </span>            : <span class="lineNum">    2599 </span>            :   /// Convenience interface to ctype.tolower(__c).<span class="lineNum">    2600 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">    2601 </span>            :     inline _CharT<span class="lineNum">    2602 </span>            :     tolower(_CharT __c, const locale&amp; __loc)<span class="lineNum">    2603 </span>            :     { return use_facet&lt;ctype&lt;_CharT&gt; &gt;(__loc).tolower(__c); }<span class="lineNum">    2604 </span>            : <span class="lineNum">    2605 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">    2606 </span>            : } // namespace std<span class="lineNum">    2607 </span>            : <span class="lineNum">    2608 </span>            : # include &lt;bits/locale_facets.tcc&gt;<span class="lineNum">    2609 </span>            : <span class="lineNum">    2610 </span>            : #endif</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/locale_facets.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - locale_facets.h<span style="font-size: 80%;"> (<a href="locale_facets.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">5</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="locale_facets.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="locale_facets.h.gcov.html#863">_ZNKSt5ctypeIcE5widenEc</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/locale_facets.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - locale_facets.h<span style="font-size: 80%;"> (<a href="locale_facets.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">5</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="locale_facets.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="locale_facets.h.gcov.html#863">_ZNKSt5ctypeIcE5widenEc</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/locale_facets.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/ios_base.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/ios_base.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/ios_base.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - ios_base.h<span style="font-size: 80%;"> (source / <a href="ios_base.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Iostreams base classes -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 1997-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /** @file bits/ios_base.h<span class="lineNum">      26 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      27 </span>            :  *  Do not attempt to use it directly. @headername{ios}<span class="lineNum">      28 </span>            :  */<span class="lineNum">      29 </span>            : <span class="lineNum">      30 </span>            : //<span class="lineNum">      31 </span>            : // ISO C++ 14882: 27.4  Iostreams base classes<span class="lineNum">      32 </span>            : //<span class="lineNum">      33 </span>            : <span class="lineNum">      34 </span>            : #ifndef _IOS_BASE_H<span class="lineNum">      35 </span>            : #define _IOS_BASE_H 1<span class="lineNum">      36 </span>            : <span class="lineNum">      37 </span>            : #pragma GCC system_header<span class="lineNum">      38 </span>            : <span class="lineNum">      39 </span>            : #include &lt;ext/atomicity.h&gt;<span class="lineNum">      40 </span>            : #include &lt;bits/localefwd.h&gt;<span class="lineNum">      41 </span>            : #include &lt;bits/locale_classes.h&gt;<span class="lineNum">      42 </span>            : <span class="lineNum">      43 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      44 </span>            : {<span class="lineNum">      45 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      46 </span>            : <span class="lineNum">      47 </span>            :   // The following definitions of bitmask types are enums, not ints,<span class="lineNum">      48 </span>            :   // as permitted (but not required) in the standard, in order to provide<span class="lineNum">      49 </span>            :   // better type safety in iostream calls.  A side effect is that<span class="lineNum">      50 </span>            :   // expressions involving them are no longer compile-time constants.<span class="lineNum">      51 </span>            :   enum _Ios_Fmtflags <span class="lineNum">      52 </span>            :     { <span class="lineNum">      53 </span>            :       _S_boolalpha      = 1L &lt;&lt; 0,<span class="lineNum">      54 </span>            :       _S_dec            = 1L &lt;&lt; 1,<span class="lineNum">      55 </span>            :       _S_fixed          = 1L &lt;&lt; 2,<span class="lineNum">      56 </span>            :       _S_hex            = 1L &lt;&lt; 3,<span class="lineNum">      57 </span>            :       _S_internal       = 1L &lt;&lt; 4,<span class="lineNum">      58 </span>            :       _S_left           = 1L &lt;&lt; 5,<span class="lineNum">      59 </span>            :       _S_oct            = 1L &lt;&lt; 6,<span class="lineNum">      60 </span>            :       _S_right          = 1L &lt;&lt; 7,<span class="lineNum">      61 </span>            :       _S_scientific     = 1L &lt;&lt; 8,<span class="lineNum">      62 </span>            :       _S_showbase       = 1L &lt;&lt; 9,<span class="lineNum">      63 </span>            :       _S_showpoint      = 1L &lt;&lt; 10,<span class="lineNum">      64 </span>            :       _S_showpos        = 1L &lt;&lt; 11,<span class="lineNum">      65 </span>            :       _S_skipws         = 1L &lt;&lt; 12,<span class="lineNum">      66 </span>            :       _S_unitbuf        = 1L &lt;&lt; 13,<span class="lineNum">      67 </span>            :       _S_uppercase      = 1L &lt;&lt; 14,<span class="lineNum">      68 </span>            :       _S_adjustfield    = _S_left | _S_right | _S_internal,<span class="lineNum">      69 </span>            :       _S_basefield      = _S_dec | _S_oct | _S_hex,<span class="lineNum">      70 </span>            :       _S_floatfield     = _S_scientific | _S_fixed,<span class="lineNum">      71 </span>            :       _S_ios_fmtflags_end = 1L &lt;&lt; 16 <span class="lineNum">      72 </span>            :     };<span class="lineNum">      73 </span>            : <span class="lineNum">      74 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags<span class="lineNum">      75 </span>            :   operator&amp;(_Ios_Fmtflags __a, _Ios_Fmtflags __b)<span class="lineNum">      76 </span>            :   { return _Ios_Fmtflags(static_cast&lt;int&gt;(__a) &amp; static_cast&lt;int&gt;(__b)); }<span class="lineNum">      77 </span>            : <span class="lineNum">      78 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags<span class="lineNum">      79 </span>            :   operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)<span class="lineNum">      80 </span>            :   { return _Ios_Fmtflags(static_cast&lt;int&gt;(__a) | static_cast&lt;int&gt;(__b)); }<span class="lineNum">      81 </span>            : <span class="lineNum">      82 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags<span class="lineNum">      83 </span>            :   operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)<span class="lineNum">      84 </span>            :   { return _Ios_Fmtflags(static_cast&lt;int&gt;(__a) ^ static_cast&lt;int&gt;(__b)); }<span class="lineNum">      85 </span>            : <span class="lineNum">      86 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags<span class="lineNum">      87 </span>            :   operator~(_Ios_Fmtflags __a)<span class="lineNum">      88 </span>            :   { return _Ios_Fmtflags(~static_cast&lt;int&gt;(__a)); }<span class="lineNum">      89 </span>            : <span class="lineNum">      90 </span>            :   inline const _Ios_Fmtflags&amp;<span class="lineNum">      91 </span>            :   operator|=(_Ios_Fmtflags&amp; __a, _Ios_Fmtflags __b)<span class="lineNum">      92 </span>            :   { return __a = __a | __b; }<span class="lineNum">      93 </span>            : <span class="lineNum">      94 </span>            :   inline const _Ios_Fmtflags&amp;<span class="lineNum">      95 </span>            :   operator&amp;=(_Ios_Fmtflags&amp; __a, _Ios_Fmtflags __b)<span class="lineNum">      96 </span>            :   { return __a = __a &amp; __b; }<span class="lineNum">      97 </span>            : <span class="lineNum">      98 </span>            :   inline const _Ios_Fmtflags&amp;<span class="lineNum">      99 </span>            :   operator^=(_Ios_Fmtflags&amp; __a, _Ios_Fmtflags __b)<span class="lineNum">     100 </span>            :   { return __a = __a ^ __b; }<span class="lineNum">     101 </span>            : <span class="lineNum">     102 </span>            : <span class="lineNum">     103 </span>            :   enum _Ios_Openmode <span class="lineNum">     104 </span>            :     { <span class="lineNum">     105 </span>            :       _S_app            = 1L &lt;&lt; 0,<span class="lineNum">     106 </span>            :       _S_ate            = 1L &lt;&lt; 1,<span class="lineNum">     107 </span>            :       _S_bin            = 1L &lt;&lt; 2,<span class="lineNum">     108 </span>            :       _S_in             = 1L &lt;&lt; 3,<span class="lineNum">     109 </span>            :       _S_out            = 1L &lt;&lt; 4,<span class="lineNum">     110 </span>            :       _S_trunc          = 1L &lt;&lt; 5,<span class="lineNum">     111 </span>            :       _S_ios_openmode_end = 1L &lt;&lt; 16 <span class="lineNum">     112 </span>            :     };<span class="lineNum">     113 </span>            : <span class="lineNum">     114 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Openmode<span class="lineNum">     115 </span>            :   operator&amp;(_Ios_Openmode __a, _Ios_Openmode __b)<span class="lineNum">     116 </span>            :   { return _Ios_Openmode(static_cast&lt;int&gt;(__a) &amp; static_cast&lt;int&gt;(__b)); }<span class="lineNum">     117 </span>            : <span class="lineNum">     118 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Openmode<span class="lineNum">     119 </span>            :   operator|(_Ios_Openmode __a, _Ios_Openmode __b)<span class="lineNum">     120 </span>            :   { return _Ios_Openmode(static_cast&lt;int&gt;(__a) | static_cast&lt;int&gt;(__b)); }<span class="lineNum">     121 </span>            : <span class="lineNum">     122 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Openmode<span class="lineNum">     123 </span>            :   operator^(_Ios_Openmode __a, _Ios_Openmode __b)<span class="lineNum">     124 </span>            :   { return _Ios_Openmode(static_cast&lt;int&gt;(__a) ^ static_cast&lt;int&gt;(__b)); }<span class="lineNum">     125 </span>            : <span class="lineNum">     126 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Openmode<span class="lineNum">     127 </span>            :   operator~(_Ios_Openmode __a)<span class="lineNum">     128 </span>            :   { return _Ios_Openmode(~static_cast&lt;int&gt;(__a)); }<span class="lineNum">     129 </span>            : <span class="lineNum">     130 </span>            :   inline const _Ios_Openmode&amp;<span class="lineNum">     131 </span>            :   operator|=(_Ios_Openmode&amp; __a, _Ios_Openmode __b)<span class="lineNum">     132 </span>            :   { return __a = __a | __b; }<span class="lineNum">     133 </span>            : <span class="lineNum">     134 </span>            :   inline const _Ios_Openmode&amp;<span class="lineNum">     135 </span>            :   operator&amp;=(_Ios_Openmode&amp; __a, _Ios_Openmode __b)<span class="lineNum">     136 </span>            :   { return __a = __a &amp; __b; }<span class="lineNum">     137 </span>            : <span class="lineNum">     138 </span>            :   inline const _Ios_Openmode&amp;<span class="lineNum">     139 </span>            :   operator^=(_Ios_Openmode&amp; __a, _Ios_Openmode __b)<span class="lineNum">     140 </span>            :   { return __a = __a ^ __b; }<span class="lineNum">     141 </span>            : <span class="lineNum">     142 </span>            : <span class="lineNum">     143 </span>            :   enum _Ios_Iostate<span class="lineNum">     144 </span>            :     { <span class="lineNum">     145 </span>            :       _S_goodbit                = 0,<span class="lineNum">     146 </span>            :       _S_badbit                 = 1L &lt;&lt; 0,<span class="lineNum">     147 </span>            :       _S_eofbit                 = 1L &lt;&lt; 1,<span class="lineNum">     148 </span>            :       _S_failbit                = 1L &lt;&lt; 2,<span class="lineNum">     149 </span>            :       _S_ios_iostate_end = 1L &lt;&lt; 16 <span class="lineNum">     150 </span>            :     };<span class="lineNum">     151 </span>            : <span class="lineNum">     152 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Iostate<span class="lineNum">     153 </span>            :   operator&amp;(_Ios_Iostate __a, _Ios_Iostate __b)<span class="lineNum">     154 </span>            :   { return _Ios_Iostate(static_cast&lt;int&gt;(__a) &amp; static_cast&lt;int&gt;(__b)); }<a name="155"><span class="lineNum">     155 </span>            : </a><span class="lineNum">     156 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Iostate<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   operator|(_Ios_Iostate __a, _Ios_Iostate __b)</span><span class="lineNum">     158 </span><span class="lineNoCov">          0 :   { return _Ios_Iostate(static_cast&lt;int&gt;(__a) | static_cast&lt;int&gt;(__b)); }</span><span class="lineNum">     159 </span>            : <span class="lineNum">     160 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Iostate<span class="lineNum">     161 </span>            :   operator^(_Ios_Iostate __a, _Ios_Iostate __b)<span class="lineNum">     162 </span>            :   { return _Ios_Iostate(static_cast&lt;int&gt;(__a) ^ static_cast&lt;int&gt;(__b)); }<span class="lineNum">     163 </span>            : <span class="lineNum">     164 </span>            :   inline _GLIBCXX_CONSTEXPR _Ios_Iostate<span class="lineNum">     165 </span>            :   operator~(_Ios_Iostate __a)<span class="lineNum">     166 </span>            :   { return _Ios_Iostate(~static_cast&lt;int&gt;(__a)); }<span class="lineNum">     167 </span>            : <span class="lineNum">     168 </span>            :   inline const _Ios_Iostate&amp;<span class="lineNum">     169 </span>            :   operator|=(_Ios_Iostate&amp; __a, _Ios_Iostate __b)<span class="lineNum">     170 </span>            :   { return __a = __a | __b; }<span class="lineNum">     171 </span>            : <span class="lineNum">     172 </span>            :   inline const _Ios_Iostate&amp;<span class="lineNum">     173 </span>            :   operator&amp;=(_Ios_Iostate&amp; __a, _Ios_Iostate __b)<span class="lineNum">     174 </span>            :   { return __a = __a &amp; __b; }<span class="lineNum">     175 </span>            : <span class="lineNum">     176 </span>            :   inline const  _Ios_Iostate&amp;<span class="lineNum">     177 </span>            :   operator^=(_Ios_Iostate&amp; __a, _Ios_Iostate __b)<span class="lineNum">     178 </span>            :   { return __a = __a ^ __b; }<span class="lineNum">     179 </span>            : <span class="lineNum">     180 </span>            : <span class="lineNum">     181 </span>            :   enum _Ios_Seekdir <span class="lineNum">     182 </span>            :     { <span class="lineNum">     183 </span>            :       _S_beg = 0,<span class="lineNum">     184 </span>            :       _S_cur = _GLIBCXX_STDIO_SEEK_CUR,<span class="lineNum">     185 </span>            :       _S_end = _GLIBCXX_STDIO_SEEK_END,<span class="lineNum">     186 </span>            :       _S_ios_seekdir_end = 1L &lt;&lt; 16 <span class="lineNum">     187 </span>            :     };<span class="lineNum">     188 </span>            : <span class="lineNum">     189 </span>            :   // 27.4.2  Class ios_base<span class="lineNum">     190 </span>            :   /**<span class="lineNum">     191 </span>            :    *  @brief  The base of the I/O class hierarchy.<span class="lineNum">     192 </span>            :    *  @ingroup io<span class="lineNum">     193 </span>            :    *<span class="lineNum">     194 </span>            :    *  This class defines everything that can be defined about I/O that does<span class="lineNum">     195 </span>            :    *  not depend on the type of characters being input or output.  Most<span class="lineNum">     196 </span>            :    *  people will only see @c ios_base when they need to specify the full<span class="lineNum">     197 </span>            :    *  name of the various I/O flags (e.g., the openmodes).<span class="lineNum">     198 </span>            :   */<span class="lineNum">     199 </span>            :   class ios_base<span class="lineNum">     200 </span>            :   {<span class="lineNum">     201 </span>            :   public:<span class="lineNum">     202 </span>            : <span class="lineNum">     203 </span>            :     /** <span class="lineNum">     204 </span>            :      *  @brief These are thrown to indicate problems with io.<span class="lineNum">     205 </span>            :      *  @ingroup exceptions<span class="lineNum">     206 </span>            :      *<span class="lineNum">     207 </span>            :      *  27.4.2.1.1  Class ios_base::failure<span class="lineNum">     208 </span>            :      */<span class="lineNum">     209 </span>            :     class failure : public exception<span class="lineNum">     210 </span>            :     {<span class="lineNum">     211 </span>            :     public:<span class="lineNum">     212 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     213 </span>            :       // 48.  Use of non-existent exception constructor<span class="lineNum">     214 </span>            :       explicit<span class="lineNum">     215 </span>            :       failure(const string&amp; __str) throw();<span class="lineNum">     216 </span>            : <span class="lineNum">     217 </span>            :       // This declaration is not useless:<span class="lineNum">     218 </span>            :       // http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Vague-Linkage.html<span class="lineNum">     219 </span>            :       virtual<span class="lineNum">     220 </span>            :       ~failure() throw();<span class="lineNum">     221 </span>            : <span class="lineNum">     222 </span>            :       virtual const char*<span class="lineNum">     223 </span>            :       what() const throw();<span class="lineNum">     224 </span>            : <span class="lineNum">     225 </span>            :     private:<span class="lineNum">     226 </span>            :       string _M_msg;<span class="lineNum">     227 </span>            :     };<span class="lineNum">     228 </span>            : <span class="lineNum">     229 </span>            :     // 27.4.2.1.2  Type ios_base::fmtflags<span class="lineNum">     230 </span>            :     /**<span class="lineNum">     231 </span>            :      *  @brief This is a bitmask type.<span class="lineNum">     232 </span>            :      *<span class="lineNum">     233 </span>            :      *  @c @a _Ios_Fmtflags is implementation-defined, but it is valid to<span class="lineNum">     234 </span>            :      *  perform bitwise operations on these values and expect the Right<span class="lineNum">     235 </span>            :      *  Thing to happen.  Defined objects of type fmtflags are:<span class="lineNum">     236 </span>            :      *  - boolalpha<span class="lineNum">     237 </span>            :      *  - dec<span class="lineNum">     238 </span>            :      *  - fixed<span class="lineNum">     239 </span>            :      *  - hex<span class="lineNum">     240 </span>            :      *  - internal<span class="lineNum">     241 </span>            :      *  - left<span class="lineNum">     242 </span>            :      *  - oct<span class="lineNum">     243 </span>            :      *  - right<span class="lineNum">     244 </span>            :      *  - scientific<span class="lineNum">     245 </span>            :      *  - showbase<span class="lineNum">     246 </span>            :      *  - showpoint<span class="lineNum">     247 </span>            :      *  - showpos<span class="lineNum">     248 </span>            :      *  - skipws<span class="lineNum">     249 </span>            :      *  - unitbuf<span class="lineNum">     250 </span>            :      *  - uppercase<span class="lineNum">     251 </span>            :      *  - adjustfield<span class="lineNum">     252 </span>            :      *  - basefield<span class="lineNum">     253 </span>            :      *  - floatfield<span class="lineNum">     254 </span>            :     */<span class="lineNum">     255 </span>            :     typedef _Ios_Fmtflags fmtflags;<span class="lineNum">     256 </span>            : <span class="lineNum">     257 </span>            :     /// Insert/extract @c bool in alphabetic rather than numeric format.<span class="lineNum">     258 </span>            :     static const fmtflags boolalpha =   _S_boolalpha;<span class="lineNum">     259 </span>            : <span class="lineNum">     260 </span>            :     /// Converts integer input or generates integer output in decimal base.<span class="lineNum">     261 </span>            :     static const fmtflags dec =         _S_dec;<span class="lineNum">     262 </span>            : <span class="lineNum">     263 </span>            :     /// Generate floating-point output in fixed-point notation.<span class="lineNum">     264 </span>            :     static const fmtflags fixed =       _S_fixed;<span class="lineNum">     265 </span>            : <span class="lineNum">     266 </span>            :     /// Converts integer input or generates integer output in hexadecimal base.<span class="lineNum">     267 </span>            :     static const fmtflags hex =         _S_hex;<span class="lineNum">     268 </span>            : <span class="lineNum">     269 </span>            :     /// Adds fill characters at a designated internal point in certain<span class="lineNum">     270 </span>            :     /// generated output, or identical to @c right if no such point is<span class="lineNum">     271 </span>            :     /// designated.<span class="lineNum">     272 </span>            :     static const fmtflags internal =    _S_internal;<span class="lineNum">     273 </span>            : <span class="lineNum">     274 </span>            :     /// Adds fill characters on the right (final positions) of certain<span class="lineNum">     275 </span>            :     /// generated output.  (I.e., the thing you print is flush left.)<span class="lineNum">     276 </span>            :     static const fmtflags left =        _S_left;<span class="lineNum">     277 </span>            : <span class="lineNum">     278 </span>            :     /// Converts integer input or generates integer output in octal base.<span class="lineNum">     279 </span>            :     static const fmtflags oct =         _S_oct;<span class="lineNum">     280 </span>            : <span class="lineNum">     281 </span>            :     /// Adds fill characters on the left (initial positions) of certain<span class="lineNum">     282 </span>            :     /// generated output.  (I.e., the thing you print is flush right.)<span class="lineNum">     283 </span>            :     static const fmtflags right =       _S_right;<span class="lineNum">     284 </span>            : <span class="lineNum">     285 </span>            :     /// Generates floating-point output in scientific notation.<span class="lineNum">     286 </span>            :     static const fmtflags scientific =  _S_scientific;<span class="lineNum">     287 </span>            : <span class="lineNum">     288 </span>            :     /// Generates a prefix indicating the numeric base of generated integer<span class="lineNum">     289 </span>            :     /// output.<span class="lineNum">     290 </span>            :     static const fmtflags showbase =    _S_showbase;<span class="lineNum">     291 </span>            : <span class="lineNum">     292 </span>            :     /// Generates a decimal-point character unconditionally in generated<span class="lineNum">     293 </span>            :     /// floating-point output.<span class="lineNum">     294 </span>            :     static const fmtflags showpoint =   _S_showpoint;<span class="lineNum">     295 </span>            : <span class="lineNum">     296 </span>            :     /// Generates a + sign in non-negative generated numeric output.<span class="lineNum">     297 </span>            :     static const fmtflags showpos =     _S_showpos;<span class="lineNum">     298 </span>            : <span class="lineNum">     299 </span>            :     /// Skips leading white space before certain input operations.<span class="lineNum">     300 </span>            :     static const fmtflags skipws =      _S_skipws;<span class="lineNum">     301 </span>            : <span class="lineNum">     302 </span>            :     /// Flushes output after each output operation.<span class="lineNum">     303 </span>            :     static const fmtflags unitbuf =     _S_unitbuf;<span class="lineNum">     304 </span>            : <span class="lineNum">     305 </span>            :     /// Replaces certain lowercase letters with their uppercase equivalents<span class="lineNum">     306 </span>            :     /// in generated output.<span class="lineNum">     307 </span>            :     static const fmtflags uppercase =   _S_uppercase;<span class="lineNum">     308 </span>            : <span class="lineNum">     309 </span>            :     /// A mask of left|right|internal.  Useful for the 2-arg form of @c setf.<span class="lineNum">     310 </span>            :     static const fmtflags adjustfield = _S_adjustfield;<span class="lineNum">     311 </span>            : <span class="lineNum">     312 </span>            :     /// A mask of dec|oct|hex.  Useful for the 2-arg form of @c setf.<span class="lineNum">     313 </span>            :     static const fmtflags basefield =   _S_basefield;<span class="lineNum">     314 </span>            : <span class="lineNum">     315 </span>            :     /// A mask of scientific|fixed.  Useful for the 2-arg form of @c setf.<span class="lineNum">     316 </span>            :     static const fmtflags floatfield =  _S_floatfield;<span class="lineNum">     317 </span>            : <span class="lineNum">     318 </span>            :     // 27.4.2.1.3  Type ios_base::iostate<span class="lineNum">     319 </span>            :     /**<span class="lineNum">     320 </span>            :      *  @brief This is a bitmask type.<span class="lineNum">     321 </span>            :      *<span class="lineNum">     322 </span>            :      *  @c @a _Ios_Iostate is implementation-defined, but it is valid to<span class="lineNum">     323 </span>            :      *  perform bitwise operations on these values and expect the Right<span class="lineNum">     324 </span>            :      *  Thing to happen.  Defined objects of type iostate are:<span class="lineNum">     325 </span>            :      *  - badbit<span class="lineNum">     326 </span>            :      *  - eofbit<span class="lineNum">     327 </span>            :      *  - failbit<span class="lineNum">     328 </span>            :      *  - goodbit<span class="lineNum">     329 </span>            :     */<span class="lineNum">     330 </span>            :     typedef _Ios_Iostate iostate;<span class="lineNum">     331 </span>            : <span class="lineNum">     332 </span>            :     /// Indicates a loss of integrity in an input or output sequence (such<span class="lineNum">     333 </span>            :     /// as an irrecoverable read error from a file).<span class="lineNum">     334 </span>            :     static const iostate badbit =       _S_badbit;<span class="lineNum">     335 </span>            : <span class="lineNum">     336 </span>            :     /// Indicates that an input operation reached the end of an input sequence.<span class="lineNum">     337 </span>            :     static const iostate eofbit =       _S_eofbit;<span class="lineNum">     338 </span>            : <span class="lineNum">     339 </span>            :     /// Indicates that an input operation failed to read the expected<span class="lineNum">     340 </span>            :     /// characters, or that an output operation failed to generate the<span class="lineNum">     341 </span>            :     /// desired characters.<span class="lineNum">     342 </span>            :     static const iostate failbit =      _S_failbit;<span class="lineNum">     343 </span>            : <span class="lineNum">     344 </span>            :     /// Indicates all is well.<span class="lineNum">     345 </span>            :     static const iostate goodbit =      _S_goodbit;<span class="lineNum">     346 </span>            : <span class="lineNum">     347 </span>            :     // 27.4.2.1.4  Type ios_base::openmode<span class="lineNum">     348 </span>            :     /**<span class="lineNum">     349 </span>            :      *  @brief This is a bitmask type.<span class="lineNum">     350 </span>            :      *<span class="lineNum">     351 </span>            :      *  @c @a _Ios_Openmode is implementation-defined, but it is valid to<span class="lineNum">     352 </span>            :      *  perform bitwise operations on these values and expect the Right<span class="lineNum">     353 </span>            :      *  Thing to happen.  Defined objects of type openmode are:<span class="lineNum">     354 </span>            :      *  - app<span class="lineNum">     355 </span>            :      *  - ate<span class="lineNum">     356 </span>            :      *  - binary<span class="lineNum">     357 </span>            :      *  - in<span class="lineNum">     358 </span>            :      *  - out<span class="lineNum">     359 </span>            :      *  - trunc<span class="lineNum">     360 </span>            :     */<span class="lineNum">     361 </span>            :     typedef _Ios_Openmode openmode;<span class="lineNum">     362 </span>            : <span class="lineNum">     363 </span>            :     /// Seek to end before each write.<span class="lineNum">     364 </span>            :     static const openmode app =         _S_app;<span class="lineNum">     365 </span>            : <span class="lineNum">     366 </span>            :     /// Open and seek to end immediately after opening.<span class="lineNum">     367 </span>            :     static const openmode ate =         _S_ate;<span class="lineNum">     368 </span>            : <span class="lineNum">     369 </span>            :     /// Perform input and output in binary mode (as opposed to text mode).<span class="lineNum">     370 </span>            :     /// This is probably not what you think it is; see<span class="lineNum">     371 </span>            :     /// http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch27s02.html<span class="lineNum">     372 </span>            :     static const openmode binary =      _S_bin;<span class="lineNum">     373 </span>            : <span class="lineNum">     374 </span>            :     /// Open for input.  Default for @c ifstream and fstream.<span class="lineNum">     375 </span>            :     static const openmode in =          _S_in;<span class="lineNum">     376 </span>            : <span class="lineNum">     377 </span>            :     /// Open for output.  Default for @c ofstream and fstream.<span class="lineNum">     378 </span>            :     static const openmode out =         _S_out;<span class="lineNum">     379 </span>            : <span class="lineNum">     380 </span>            :     /// Open for input.  Default for @c ofstream.<span class="lineNum">     381 </span>            :     static const openmode trunc =       _S_trunc;<span class="lineNum">     382 </span>            : <span class="lineNum">     383 </span>            :     // 27.4.2.1.5  Type ios_base::seekdir<span class="lineNum">     384 </span>            :     /**<span class="lineNum">     385 </span>            :      *  @brief This is an enumerated type.<span class="lineNum">     386 </span>            :      *<span class="lineNum">     387 </span>            :      *  @c @a _Ios_Seekdir is implementation-defined.  Defined values<span class="lineNum">     388 </span>            :      *  of type seekdir are:<span class="lineNum">     389 </span>            :      *  - beg<span class="lineNum">     390 </span>            :      *  - cur, equivalent to @c SEEK_CUR in the C standard library.<span class="lineNum">     391 </span>            :      *  - end, equivalent to @c SEEK_END in the C standard library.<span class="lineNum">     392 </span>            :     */<span class="lineNum">     393 </span>            :     typedef _Ios_Seekdir seekdir;<span class="lineNum">     394 </span>            : <span class="lineNum">     395 </span>            :     /// Request a seek relative to the beginning of the stream.<span class="lineNum">     396 </span>            :     static const seekdir beg =          _S_beg;<span class="lineNum">     397 </span>            : <span class="lineNum">     398 </span>            :     /// Request a seek relative to the current position within the sequence.<span class="lineNum">     399 </span>            :     static const seekdir cur =          _S_cur;<span class="lineNum">     400 </span>            : <span class="lineNum">     401 </span>            :     /// Request a seek relative to the current end of the sequence.<span class="lineNum">     402 </span>            :     static const seekdir end =          _S_end;<span class="lineNum">     403 </span>            : <span class="lineNum">     404 </span>            :     // Annex D.6<span class="lineNum">     405 </span>            :     typedef int io_state;<span class="lineNum">     406 </span>            :     typedef int open_mode;<span class="lineNum">     407 </span>            :     typedef int seek_dir;<span class="lineNum">     408 </span>            : <span class="lineNum">     409 </span>            :     typedef std::streampos streampos;<span class="lineNum">     410 </span>            :     typedef std::streamoff streamoff;<span class="lineNum">     411 </span>            : <span class="lineNum">     412 </span>            :     // Callbacks;<span class="lineNum">     413 </span>            :     /**<span class="lineNum">     414 </span>            :      *  @brief  The set of events that may be passed to an event callback.<span class="lineNum">     415 </span>            :      *<span class="lineNum">     416 </span>            :      *  erase_event is used during ~ios() and copyfmt().  imbue_event is used<span class="lineNum">     417 </span>            :      *  during imbue().  copyfmt_event is used during copyfmt().<span class="lineNum">     418 </span>            :     */<span class="lineNum">     419 </span>            :     enum event<span class="lineNum">     420 </span>            :     {<span class="lineNum">     421 </span>            :       erase_event,<span class="lineNum">     422 </span>            :       imbue_event,<span class="lineNum">     423 </span>            :       copyfmt_event<span class="lineNum">     424 </span>            :     };<span class="lineNum">     425 </span>            : <span class="lineNum">     426 </span>            :     /**<span class="lineNum">     427 </span>            :      *  @brief  The type of an event callback function.<span class="lineNum">     428 </span>            :      *  @param  __e  One of the members of the event enum.<span class="lineNum">     429 </span>            :      *  @param  __b  Reference to the ios_base object.<span class="lineNum">     430 </span>            :      *  @param  __i  The integer provided when the callback was registered.<span class="lineNum">     431 </span>            :      *<span class="lineNum">     432 </span>            :      *  Event callbacks are user defined functions that get called during<span class="lineNum">     433 </span>            :      *  several ios_base and basic_ios functions, specifically imbue(),<span class="lineNum">     434 </span>            :      *  copyfmt(), and ~ios().<span class="lineNum">     435 </span>            :     */<span class="lineNum">     436 </span>            :     typedef void (*event_callback) (event __e, ios_base&amp; __b, int __i);<span class="lineNum">     437 </span>            : <span class="lineNum">     438 </span>            :     /**<span class="lineNum">     439 </span>            :      *  @brief  Add the callback __fn with parameter __index.<span class="lineNum">     440 </span>            :      *  @param  __fn  The function to add.<span class="lineNum">     441 </span>            :      *  @param  __index  The integer to pass to the function when invoked.<span class="lineNum">     442 </span>            :      *<span class="lineNum">     443 </span>            :      *  Registers a function as an event callback with an integer parameter to<span class="lineNum">     444 </span>            :      *  be passed to the function when invoked.  Multiple copies of the<span class="lineNum">     445 </span>            :      *  function are allowed.  If there are multiple callbacks, they are<span class="lineNum">     446 </span>            :      *  invoked in the order they were registered.<span class="lineNum">     447 </span>            :     */<span class="lineNum">     448 </span>            :     void<span class="lineNum">     449 </span>            :     register_callback(event_callback __fn, int __index);<span class="lineNum">     450 </span>            : <span class="lineNum">     451 </span>            :   protected:<span class="lineNum">     452 </span>            :     streamsize          _M_precision;<span class="lineNum">     453 </span>            :     streamsize          _M_width;<span class="lineNum">     454 </span>            :     fmtflags            _M_flags;<span class="lineNum">     455 </span>            :     iostate             _M_exception;<span class="lineNum">     456 </span>            :     iostate             _M_streambuf_state;<span class="lineNum">     457 </span>            : <span class="lineNum">     458 </span>            :     // 27.4.2.6  Members for callbacks<span class="lineNum">     459 </span>            :     // 27.4.2.6  ios_base callbacks<span class="lineNum">     460 </span>            :     struct _Callback_list<span class="lineNum">     461 </span>            :     {<span class="lineNum">     462 </span>            :       // Data Members<span class="lineNum">     463 </span>            :       _Callback_list*           _M_next;<span class="lineNum">     464 </span>            :       ios_base::event_callback  _M_fn;<span class="lineNum">     465 </span>            :       int                       _M_index;<span class="lineNum">     466 </span>            :       _Atomic_word              _M_refcount;  // 0 means one reference.<span class="lineNum">     467 </span>            : <span class="lineNum">     468 </span>            :       _Callback_list(ios_base::event_callback __fn, int __index,<span class="lineNum">     469 </span>            :                      _Callback_list* __cb)<span class="lineNum">     470 </span>            :       : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }<span class="lineNum">     471 </span>            : <span class="lineNum">     472 </span>            :       void<span class="lineNum">     473 </span>            :       _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&amp;_M_refcount, 1); }<span class="lineNum">     474 </span>            : <span class="lineNum">     475 </span>            :       // 0 =&gt; OK to delete.<span class="lineNum">     476 </span>            :       int<span class="lineNum">     477 </span>            :       _M_remove_reference() <span class="lineNum">     478 </span>            :       {<span class="lineNum">     479 </span>            :         // Be race-detector-friendly.  For more info see bits/c++config.<span class="lineNum">     480 </span>            :         _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_refcount);<span class="lineNum">     481 </span>            :         int __res = __gnu_cxx::__exchange_and_add_dispatch(&amp;_M_refcount, -1);<span class="lineNum">     482 </span>            :         if (__res == 0)<span class="lineNum">     483 </span>            :           {<span class="lineNum">     484 </span>            :             _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_refcount);<span class="lineNum">     485 </span>            :           }<span class="lineNum">     486 </span>            :         return __res;<span class="lineNum">     487 </span>            :       }<span class="lineNum">     488 </span>            :     };<span class="lineNum">     489 </span>            : <span class="lineNum">     490 </span>            :      _Callback_list*    _M_callbacks;<span class="lineNum">     491 </span>            : <span class="lineNum">     492 </span>            :     void<span class="lineNum">     493 </span>            :     _M_call_callbacks(event __ev) throw();<span class="lineNum">     494 </span>            : <span class="lineNum">     495 </span>            :     void<span class="lineNum">     496 </span>            :     _M_dispose_callbacks(void) throw();<span class="lineNum">     497 </span>            : <span class="lineNum">     498 </span>            :     // 27.4.2.5  Members for iword/pword storage<span class="lineNum">     499 </span>            :     struct _Words<span class="lineNum">     500 </span>            :     {<span class="lineNum">     501 </span>            :       void*     _M_pword;<span class="lineNum">     502 </span>            :       long      _M_iword;<span class="lineNum">     503 </span>            :       _Words() : _M_pword(0), _M_iword(0) { }<span class="lineNum">     504 </span>            :     };<span class="lineNum">     505 </span>            : <span class="lineNum">     506 </span>            :     // Only for failed iword/pword calls.<span class="lineNum">     507 </span>            :     _Words              _M_word_zero;<span class="lineNum">     508 </span>            : <span class="lineNum">     509 </span>            :     // Guaranteed storage.<span class="lineNum">     510 </span>            :     // The first 5 iword and pword slots are reserved for internal use.<span class="lineNum">     511 </span>            :     enum { _S_local_word_size = 8 };<span class="lineNum">     512 </span>            :     _Words              _M_local_word[_S_local_word_size];<span class="lineNum">     513 </span>            : <span class="lineNum">     514 </span>            :     // Allocated storage.<span class="lineNum">     515 </span>            :     int                 _M_word_size;<span class="lineNum">     516 </span>            :     _Words*             _M_word;<span class="lineNum">     517 </span>            : <span class="lineNum">     518 </span>            :     _Words&amp;<span class="lineNum">     519 </span>            :     _M_grow_words(int __index, bool __iword);<span class="lineNum">     520 </span>            : <span class="lineNum">     521 </span>            :     // Members for locale and locale caching.<span class="lineNum">     522 </span>            :     locale              _M_ios_locale;<span class="lineNum">     523 </span>            : <span class="lineNum">     524 </span>            :     void<span class="lineNum">     525 </span>            :     _M_init() throw();<span class="lineNum">     526 </span>            : <span class="lineNum">     527 </span>            :   public:<span class="lineNum">     528 </span>            : <span class="lineNum">     529 </span>            :     // 27.4.2.1.6  Class ios_base::Init<span class="lineNum">     530 </span>            :     // Used to initialize standard streams. In theory, g++ could use<span class="lineNum">     531 </span>            :     // -finit-priority to order this stuff correctly without going<span class="lineNum">     532 </span>            :     // through these machinations.<span class="lineNum">     533 </span>            :     class Init<span class="lineNum">     534 </span>            :     {<span class="lineNum">     535 </span>            :       friend class ios_base;<span class="lineNum">     536 </span>            :     public:<span class="lineNum">     537 </span>            :       Init();<span class="lineNum">     538 </span>            :       ~Init();<span class="lineNum">     539 </span>            : <span class="lineNum">     540 </span>            :     private:<span class="lineNum">     541 </span>            :       static _Atomic_word       _S_refcount;<span class="lineNum">     542 </span>            :       static bool               _S_synced_with_stdio;<span class="lineNum">     543 </span>            :     };<span class="lineNum">     544 </span>            : <span class="lineNum">     545 </span>            :     // [27.4.2.2] fmtflags state functions<span class="lineNum">     546 </span>            :     /**<span class="lineNum">     547 </span>            :      *  @brief  Access to format flags.<span class="lineNum">     548 </span>            :      *  @return  The format control flags for both input and output.<span class="lineNum">     549 </span>            :     */<span class="lineNum">     550 </span>            :     fmtflags<span class="lineNum">     551 </span>            :     flags() const<span class="lineNum">     552 </span>            :     { return _M_flags; }<span class="lineNum">     553 </span>            : <span class="lineNum">     554 </span>            :     /**<span class="lineNum">     555 </span>            :      *  @brief  Setting new format flags all at once.<span class="lineNum">     556 </span>            :      *  @param  __fmtfl  The new flags to set.<span class="lineNum">     557 </span>            :      *  @return  The previous format control flags.<span class="lineNum">     558 </span>            :      *<span class="lineNum">     559 </span>            :      *  This function overwrites all the format flags with @a __fmtfl.<span class="lineNum">     560 </span>            :     */<span class="lineNum">     561 </span>            :     fmtflags<span class="lineNum">     562 </span>            :     flags(fmtflags __fmtfl)<span class="lineNum">     563 </span>            :     {<span class="lineNum">     564 </span>            :       fmtflags __old = _M_flags;<span class="lineNum">     565 </span>            :       _M_flags = __fmtfl;<span class="lineNum">     566 </span>            :       return __old;<span class="lineNum">     567 </span>            :     }<span class="lineNum">     568 </span>            : <span class="lineNum">     569 </span>            :     /**<span class="lineNum">     570 </span>            :      *  @brief  Setting new format flags.<span class="lineNum">     571 </span>            :      *  @param  __fmtfl  Additional flags to set.<span class="lineNum">     572 </span>            :      *  @return  The previous format control flags.<span class="lineNum">     573 </span>            :      *<span class="lineNum">     574 </span>            :      *  This function sets additional flags in format control.  Flags that<span class="lineNum">     575 </span>            :      *  were previously set remain set.<span class="lineNum">     576 </span>            :     */<span class="lineNum">     577 </span>            :     fmtflags<span class="lineNum">     578 </span>            :     setf(fmtflags __fmtfl)<span class="lineNum">     579 </span>            :     {<span class="lineNum">     580 </span>            :       fmtflags __old = _M_flags;<span class="lineNum">     581 </span>            :       _M_flags |= __fmtfl;<span class="lineNum">     582 </span>            :       return __old;<span class="lineNum">     583 </span>            :     }<span class="lineNum">     584 </span>            : <span class="lineNum">     585 </span>            :     /**<span class="lineNum">     586 </span>            :      *  @brief  Setting new format flags.<span class="lineNum">     587 </span>            :      *  @param  __fmtfl  Additional flags to set.<span class="lineNum">     588 </span>            :      *  @param  __mask  The flags mask for @a fmtfl.<span class="lineNum">     589 </span>            :      *  @return  The previous format control flags.<span class="lineNum">     590 </span>            :      *<span class="lineNum">     591 </span>            :      *  This function clears @a mask in the format flags, then sets<span class="lineNum">     592 </span>            :      *  @a fmtfl @c &amp; @a mask.  An example mask is @c ios_base::adjustfield.<span class="lineNum">     593 </span>            :     */<span class="lineNum">     594 </span>            :     fmtflags<span class="lineNum">     595 </span>            :     setf(fmtflags __fmtfl, fmtflags __mask)<span class="lineNum">     596 </span>            :     {<span class="lineNum">     597 </span>            :       fmtflags __old = _M_flags;<span class="lineNum">     598 </span>            :       _M_flags &amp;= ~__mask;<span class="lineNum">     599 </span>            :       _M_flags |= (__fmtfl &amp; __mask);<span class="lineNum">     600 </span>            :       return __old;<span class="lineNum">     601 </span>            :     }<span class="lineNum">     602 </span>            : <span class="lineNum">     603 </span>            :     /**<span class="lineNum">     604 </span>            :      *  @brief  Clearing format flags.<span class="lineNum">     605 </span>            :      *  @param  __mask  The flags to unset.<span class="lineNum">     606 </span>            :      *<span class="lineNum">     607 </span>            :      *  This function clears @a __mask in the format flags.<span class="lineNum">     608 </span>            :     */<span class="lineNum">     609 </span>            :     void<span class="lineNum">     610 </span>            :     unsetf(fmtflags __mask)<span class="lineNum">     611 </span>            :     { _M_flags &amp;= ~__mask; }<span class="lineNum">     612 </span>            : <span class="lineNum">     613 </span>            :     /**<span class="lineNum">     614 </span>            :      *  @brief  Flags access.<span class="lineNum">     615 </span>            :      *  @return  The precision to generate on certain output operations.<span class="lineNum">     616 </span>            :      *<span class="lineNum">     617 </span>            :      *  Be careful if you try to give a definition of @a precision here; see<span class="lineNum">     618 </span>            :      *  DR 189.<span class="lineNum">     619 </span>            :     */<span class="lineNum">     620 </span>            :     streamsize<span class="lineNum">     621 </span>            :     precision() const<span class="lineNum">     622 </span>            :     { return _M_precision; }<span class="lineNum">     623 </span>            : <span class="lineNum">     624 </span>            :     /**<span class="lineNum">     625 </span>            :      *  @brief  Changing flags.<span class="lineNum">     626 </span>            :      *  @param  __prec  The new precision value.<span class="lineNum">     627 </span>            :      *  @return  The previous value of precision().<span class="lineNum">     628 </span>            :     */<span class="lineNum">     629 </span>            :     streamsize<span class="lineNum">     630 </span>            :     precision(streamsize __prec)<span class="lineNum">     631 </span>            :     {<span class="lineNum">     632 </span>            :       streamsize __old = _M_precision;<span class="lineNum">     633 </span>            :       _M_precision = __prec;<span class="lineNum">     634 </span>            :       return __old;<span class="lineNum">     635 </span>            :     }<span class="lineNum">     636 </span>            : <span class="lineNum">     637 </span>            :     /**<span class="lineNum">     638 </span>            :      *  @brief  Flags access.<span class="lineNum">     639 </span>            :      *  @return  The minimum field width to generate on output operations.<span class="lineNum">     640 </span>            :      *<span class="lineNum">     641 </span>            :      *  &lt;em&gt;Minimum field width&lt;/em&gt; refers to the number of characters.<span class="lineNum">     642 </span>            :     */<span class="lineNum">     643 </span>            :     streamsize<span class="lineNum">     644 </span>            :     width() const<span class="lineNum">     645 </span>            :     { return _M_width; }<span class="lineNum">     646 </span>            : <span class="lineNum">     647 </span>            :     /**<span class="lineNum">     648 </span>            :      *  @brief  Changing flags.<span class="lineNum">     649 </span>            :      *  @param  __wide  The new width value.<span class="lineNum">     650 </span>            :      *  @return  The previous value of width().<span class="lineNum">     651 </span>            :     */<span class="lineNum">     652 </span>            :     streamsize<span class="lineNum">     653 </span>            :     width(streamsize __wide)<span class="lineNum">     654 </span>            :     {<span class="lineNum">     655 </span>            :       streamsize __old = _M_width;<span class="lineNum">     656 </span>            :       _M_width = __wide;<span class="lineNum">     657 </span>            :       return __old;<span class="lineNum">     658 </span>            :     }<span class="lineNum">     659 </span>            : <span class="lineNum">     660 </span>            :     // [27.4.2.4] ios_base static members<span class="lineNum">     661 </span>            :     /**<span class="lineNum">     662 </span>            :      *  @brief  Interaction with the standard C I/O objects.<span class="lineNum">     663 </span>            :      *  @param  __sync  Whether to synchronize or not.<span class="lineNum">     664 </span>            :      *  @return  True if the standard streams were previously synchronized.<span class="lineNum">     665 </span>            :      *<span class="lineNum">     666 </span>            :      *  The synchronization referred to is @e only that between the standard<span class="lineNum">     667 </span>            :      *  C facilities (e.g., stdout) and the standard C++ objects (e.g.,<span class="lineNum">     668 </span>            :      *  cout).  User-declared streams are unaffected.  See<span class="lineNum">     669 </span>            :      *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch28s02.html<span class="lineNum">     670 </span>            :     */<span class="lineNum">     671 </span>            :     static bool<span class="lineNum">     672 </span>            :     sync_with_stdio(bool __sync = true);<span class="lineNum">     673 </span>            : <span class="lineNum">     674 </span>            :     // [27.4.2.3] ios_base locale functions<span class="lineNum">     675 </span>            :     /**<span class="lineNum">     676 </span>            :      *  @brief  Setting a new locale.<span class="lineNum">     677 </span>            :      *  @param  __loc  The new locale.<span class="lineNum">     678 </span>            :      *  @return  The previous locale.<span class="lineNum">     679 </span>            :      *<span class="lineNum">     680 </span>            :      *  Sets the new locale for this stream, and then invokes each callback<span class="lineNum">     681 </span>            :      *  with imbue_event.<span class="lineNum">     682 </span>            :     */<span class="lineNum">     683 </span>            :     locale<span class="lineNum">     684 </span>            :     imbue(const locale&amp; __loc) throw();<span class="lineNum">     685 </span>            : <span class="lineNum">     686 </span>            :     /**<span class="lineNum">     687 </span>            :      *  @brief  Locale access<span class="lineNum">     688 </span>            :      *  @return  A copy of the current locale.<span class="lineNum">     689 </span>            :      *<span class="lineNum">     690 </span>            :      *  If @c imbue(loc) has previously been called, then this function<span class="lineNum">     691 </span>            :      *  returns @c loc.  Otherwise, it returns a copy of @c std::locale(),<span class="lineNum">     692 </span>            :      *  the global C++ locale.<span class="lineNum">     693 </span>            :     */<span class="lineNum">     694 </span>            :     locale<span class="lineNum">     695 </span>            :     getloc() const<span class="lineNum">     696 </span>            :     { return _M_ios_locale; }<span class="lineNum">     697 </span>            : <span class="lineNum">     698 </span>            :     /**<span class="lineNum">     699 </span>            :      *  @brief  Locale access<span class="lineNum">     700 </span>            :      *  @return  A reference to the current locale.<span class="lineNum">     701 </span>            :      *<span class="lineNum">     702 </span>            :      *  Like getloc above, but returns a reference instead of<span class="lineNum">     703 </span>            :      *  generating a copy.<span class="lineNum">     704 </span>            :     */<span class="lineNum">     705 </span>            :     const locale&amp;<span class="lineNum">     706 </span>            :     _M_getloc() const<span class="lineNum">     707 </span>            :     { return _M_ios_locale; }<span class="lineNum">     708 </span>            : <span class="lineNum">     709 </span>            :     // [27.4.2.5] ios_base storage functions<span class="lineNum">     710 </span>            :     /**<span class="lineNum">     711 </span>            :      *  @brief  Access to unique indices.<span class="lineNum">     712 </span>            :      *  @return  An integer different from all previous calls.<span class="lineNum">     713 </span>            :      *<span class="lineNum">     714 </span>            :      *  This function returns a unique integer every time it is called.  It<span class="lineNum">     715 </span>            :      *  can be used for any purpose, but is primarily intended to be a unique<span class="lineNum">     716 </span>            :      *  index for the iword and pword functions.  The expectation is that an<span class="lineNum">     717 </span>            :      *  application calls xalloc in order to obtain an index in the iword and<span class="lineNum">     718 </span>            :      *  pword arrays that can be used without fear of conflict.<span class="lineNum">     719 </span>            :      *<span class="lineNum">     720 </span>            :      *  The implementation maintains a static variable that is incremented and<span class="lineNum">     721 </span>            :      *  returned on each invocation.  xalloc is guaranteed to return an index<span class="lineNum">     722 </span>            :      *  that is safe to use in the iword and pword arrays.<span class="lineNum">     723 </span>            :     */<span class="lineNum">     724 </span>            :     static int<span class="lineNum">     725 </span>            :     xalloc() throw();<span class="lineNum">     726 </span>            : <span class="lineNum">     727 </span>            :     /**<span class="lineNum">     728 </span>            :      *  @brief  Access to integer array.<span class="lineNum">     729 </span>            :      *  @param  __ix  Index into the array.<span class="lineNum">     730 </span>            :      *  @return  A reference to an integer associated with the index.<span class="lineNum">     731 </span>            :      *<span class="lineNum">     732 </span>            :      *  The iword function provides access to an array of integers that can be<span class="lineNum">     733 </span>            :      *  used for any purpose.  The array grows as required to hold the<span class="lineNum">     734 </span>            :      *  supplied index.  All integers in the array are initialized to 0.<span class="lineNum">     735 </span>            :      *<span class="lineNum">     736 </span>            :      *  The implementation reserves several indices.  You should use xalloc to<span class="lineNum">     737 </span>            :      *  obtain an index that is safe to use.  Also note that since the array<span class="lineNum">     738 </span>            :      *  can grow dynamically, it is not safe to hold onto the reference.<span class="lineNum">     739 </span>            :     */<span class="lineNum">     740 </span>            :     long&amp;<span class="lineNum">     741 </span>            :     iword(int __ix)<span class="lineNum">     742 </span>            :     {<span class="lineNum">     743 </span>            :       _Words&amp; __word = (__ix &lt; _M_word_size)<span class="lineNum">     744 </span>            :                         ? _M_word[__ix] : _M_grow_words(__ix, true);<span class="lineNum">     745 </span>            :       return __word._M_iword;<span class="lineNum">     746 </span>            :     }<span class="lineNum">     747 </span>            : <span class="lineNum">     748 </span>            :     /**<span class="lineNum">     749 </span>            :      *  @brief  Access to void pointer array.<span class="lineNum">     750 </span>            :      *  @param  __ix  Index into the array.<span class="lineNum">     751 </span>            :      *  @return  A reference to a void* associated with the index.<span class="lineNum">     752 </span>            :      *<span class="lineNum">     753 </span>            :      *  The pword function provides access to an array of pointers that can be<span class="lineNum">     754 </span>            :      *  used for any purpose.  The array grows as required to hold the<span class="lineNum">     755 </span>            :      *  supplied index.  All pointers in the array are initialized to 0.<span class="lineNum">     756 </span>            :      *<span class="lineNum">     757 </span>            :      *  The implementation reserves several indices.  You should use xalloc to<span class="lineNum">     758 </span>            :      *  obtain an index that is safe to use.  Also note that since the array<span class="lineNum">     759 </span>            :      *  can grow dynamically, it is not safe to hold onto the reference.<span class="lineNum">     760 </span>            :     */<span class="lineNum">     761 </span>            :     void*&amp;<span class="lineNum">     762 </span>            :     pword(int __ix)<span class="lineNum">     763 </span>            :     {<span class="lineNum">     764 </span>            :       _Words&amp; __word = (__ix &lt; _M_word_size)<span class="lineNum">     765 </span>            :                         ? _M_word[__ix] : _M_grow_words(__ix, false);<span class="lineNum">     766 </span>            :       return __word._M_pword;<span class="lineNum">     767 </span>            :     }<span class="lineNum">     768 </span>            : <span class="lineNum">     769 </span>            :     // Destructor<span class="lineNum">     770 </span>            :     /**<span class="lineNum">     771 </span>            :      *  Invokes each callback with erase_event.  Destroys local storage.<span class="lineNum">     772 </span>            :      *<span class="lineNum">     773 </span>            :      *  Note that the ios_base object for the standard streams never gets<span class="lineNum">     774 </span>            :      *  destroyed.  As a result, any callbacks registered with the standard<span class="lineNum">     775 </span>            :      *  streams will not get invoked with erase_event (unless copyfmt is<span class="lineNum">     776 </span>            :      *  used).<span class="lineNum">     777 </span>            :     */<span class="lineNum">     778 </span>            :     virtual ~ios_base();<span class="lineNum">     779 </span>            : <span class="lineNum">     780 </span>            :   protected:<span class="lineNum">     781 </span>            :     ios_base() throw ();<span class="lineNum">     782 </span>            : <span class="lineNum">     783 </span>            :   // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     784 </span>            :   // 50.  Copy constructor and assignment operator of ios_base<span class="lineNum">     785 </span>            :   private:<span class="lineNum">     786 </span>            :     ios_base(const ios_base&amp;);<span class="lineNum">     787 </span>            : <span class="lineNum">     788 </span>            :     ios_base&amp;<span class="lineNum">     789 </span>            :     operator=(const ios_base&amp;);<span class="lineNum">     790 </span>            :   };<span class="lineNum">     791 </span>            : <span class="lineNum">     792 </span>            :   // [27.4.5.1] fmtflags manipulators<span class="lineNum">     793 </span>            :   /// Calls base.setf(ios_base::boolalpha).<span class="lineNum">     794 </span>            :   inline ios_base&amp;<span class="lineNum">     795 </span>            :   boolalpha(ios_base&amp; __base)<span class="lineNum">     796 </span>            :   {<span class="lineNum">     797 </span>            :     __base.setf(ios_base::boolalpha);<span class="lineNum">     798 </span>            :     return __base;<span class="lineNum">     799 </span>            :   }<span class="lineNum">     800 </span>            : <span class="lineNum">     801 </span>            :   /// Calls base.unsetf(ios_base::boolalpha).<span class="lineNum">     802 </span>            :   inline ios_base&amp;<span class="lineNum">     803 </span>            :   noboolalpha(ios_base&amp; __base)<span class="lineNum">     804 </span>            :   {<span class="lineNum">     805 </span>            :     __base.unsetf(ios_base::boolalpha);<span class="lineNum">     806 </span>            :     return __base;<span class="lineNum">     807 </span>            :   }<span class="lineNum">     808 </span>            : <span class="lineNum">     809 </span>            :   /// Calls base.setf(ios_base::showbase).<span class="lineNum">     810 </span>            :   inline ios_base&amp;<span class="lineNum">     811 </span>            :   showbase(ios_base&amp; __base)<span class="lineNum">     812 </span>            :   {<span class="lineNum">     813 </span>            :     __base.setf(ios_base::showbase);<span class="lineNum">     814 </span>            :     return __base;<span class="lineNum">     815 </span>            :   }<span class="lineNum">     816 </span>            : <span class="lineNum">     817 </span>            :   /// Calls base.unsetf(ios_base::showbase).<span class="lineNum">     818 </span>            :   inline ios_base&amp;<span class="lineNum">     819 </span>            :   noshowbase(ios_base&amp; __base)<span class="lineNum">     820 </span>            :   {<span class="lineNum">     821 </span>            :     __base.unsetf(ios_base::showbase);<span class="lineNum">     822 </span>            :     return __base;<span class="lineNum">     823 </span>            :   }<span class="lineNum">     824 </span>            : <span class="lineNum">     825 </span>            :   /// Calls base.setf(ios_base::showpoint).<span class="lineNum">     826 </span>            :   inline ios_base&amp;<span class="lineNum">     827 </span>            :   showpoint(ios_base&amp; __base)<span class="lineNum">     828 </span>            :   {<span class="lineNum">     829 </span>            :     __base.setf(ios_base::showpoint);<span class="lineNum">     830 </span>            :     return __base;<span class="lineNum">     831 </span>            :   }<span class="lineNum">     832 </span>            : <span class="lineNum">     833 </span>            :   /// Calls base.unsetf(ios_base::showpoint).<span class="lineNum">     834 </span>            :   inline ios_base&amp;<span class="lineNum">     835 </span>            :   noshowpoint(ios_base&amp; __base)<span class="lineNum">     836 </span>            :   {<span class="lineNum">     837 </span>            :     __base.unsetf(ios_base::showpoint);<span class="lineNum">     838 </span>            :     return __base;<span class="lineNum">     839 </span>            :   }<span class="lineNum">     840 </span>            : <span class="lineNum">     841 </span>            :   /// Calls base.setf(ios_base::showpos).<span class="lineNum">     842 </span>            :   inline ios_base&amp;<span class="lineNum">     843 </span>            :   showpos(ios_base&amp; __base)<span class="lineNum">     844 </span>            :   {<span class="lineNum">     845 </span>            :     __base.setf(ios_base::showpos);<span class="lineNum">     846 </span>            :     return __base;<span class="lineNum">     847 </span>            :   }<span class="lineNum">     848 </span>            : <span class="lineNum">     849 </span>            :   /// Calls base.unsetf(ios_base::showpos).<span class="lineNum">     850 </span>            :   inline ios_base&amp;<span class="lineNum">     851 </span>            :   noshowpos(ios_base&amp; __base)<span class="lineNum">     852 </span>            :   {<span class="lineNum">     853 </span>            :     __base.unsetf(ios_base::showpos);<span class="lineNum">     854 </span>            :     return __base;<span class="lineNum">     855 </span>            :   }<span class="lineNum">     856 </span>            : <span class="lineNum">     857 </span>            :   /// Calls base.setf(ios_base::skipws).<span class="lineNum">     858 </span>            :   inline ios_base&amp;<span class="lineNum">     859 </span>            :   skipws(ios_base&amp; __base)<span class="lineNum">     860 </span>            :   {<span class="lineNum">     861 </span>            :     __base.setf(ios_base::skipws);<span class="lineNum">     862 </span>            :     return __base;<span class="lineNum">     863 </span>            :   }<span class="lineNum">     864 </span>            : <span class="lineNum">     865 </span>            :   /// Calls base.unsetf(ios_base::skipws).<span class="lineNum">     866 </span>            :   inline ios_base&amp;<span class="lineNum">     867 </span>            :   noskipws(ios_base&amp; __base)<span class="lineNum">     868 </span>            :   {<span class="lineNum">     869 </span>            :     __base.unsetf(ios_base::skipws);<span class="lineNum">     870 </span>            :     return __base;<span class="lineNum">     871 </span>            :   }<span class="lineNum">     872 </span>            : <span class="lineNum">     873 </span>            :   /// Calls base.setf(ios_base::uppercase).<span class="lineNum">     874 </span>            :   inline ios_base&amp;<span class="lineNum">     875 </span>            :   uppercase(ios_base&amp; __base)<span class="lineNum">     876 </span>            :   {<span class="lineNum">     877 </span>            :     __base.setf(ios_base::uppercase);<span class="lineNum">     878 </span>            :     return __base;<span class="lineNum">     879 </span>            :   }<span class="lineNum">     880 </span>            : <span class="lineNum">     881 </span>            :   /// Calls base.unsetf(ios_base::uppercase).<span class="lineNum">     882 </span>            :   inline ios_base&amp;<span class="lineNum">     883 </span>            :   nouppercase(ios_base&amp; __base)<span class="lineNum">     884 </span>            :   {<span class="lineNum">     885 </span>            :     __base.unsetf(ios_base::uppercase);<span class="lineNum">     886 </span>            :     return __base;<span class="lineNum">     887 </span>            :   }<span class="lineNum">     888 </span>            : <span class="lineNum">     889 </span>            :   /// Calls base.setf(ios_base::unitbuf).<span class="lineNum">     890 </span>            :   inline ios_base&amp;<span class="lineNum">     891 </span>            :   unitbuf(ios_base&amp; __base)<span class="lineNum">     892 </span>            :   {<span class="lineNum">     893 </span>            :      __base.setf(ios_base::unitbuf);<span class="lineNum">     894 </span>            :      return __base;<span class="lineNum">     895 </span>            :   }<span class="lineNum">     896 </span>            : <span class="lineNum">     897 </span>            :   /// Calls base.unsetf(ios_base::unitbuf).<span class="lineNum">     898 </span>            :   inline ios_base&amp;<span class="lineNum">     899 </span>            :   nounitbuf(ios_base&amp; __base)<span class="lineNum">     900 </span>            :   {<span class="lineNum">     901 </span>            :      __base.unsetf(ios_base::unitbuf);<span class="lineNum">     902 </span>            :      return __base;<span class="lineNum">     903 </span>            :   }<span class="lineNum">     904 </span>            : <span class="lineNum">     905 </span>            :   // [27.4.5.2] adjustfield manipulators<span class="lineNum">     906 </span>            :   /// Calls base.setf(ios_base::internal, ios_base::adjustfield).<span class="lineNum">     907 </span>            :   inline ios_base&amp;<span class="lineNum">     908 </span>            :   internal(ios_base&amp; __base)<span class="lineNum">     909 </span>            :   {<span class="lineNum">     910 </span>            :      __base.setf(ios_base::internal, ios_base::adjustfield);<span class="lineNum">     911 </span>            :      return __base;<span class="lineNum">     912 </span>            :   }<span class="lineNum">     913 </span>            : <span class="lineNum">     914 </span>            :   /// Calls base.setf(ios_base::left, ios_base::adjustfield).<span class="lineNum">     915 </span>            :   inline ios_base&amp;<span class="lineNum">     916 </span>            :   left(ios_base&amp; __base)<span class="lineNum">     917 </span>            :   {<span class="lineNum">     918 </span>            :     __base.setf(ios_base::left, ios_base::adjustfield);<span class="lineNum">     919 </span>            :     return __base;<span class="lineNum">     920 </span>            :   }<span class="lineNum">     921 </span>            : <span class="lineNum">     922 </span>            :   /// Calls base.setf(ios_base::right, ios_base::adjustfield).<span class="lineNum">     923 </span>            :   inline ios_base&amp;<span class="lineNum">     924 </span>            :   right(ios_base&amp; __base)<span class="lineNum">     925 </span>            :   {<span class="lineNum">     926 </span>            :     __base.setf(ios_base::right, ios_base::adjustfield);<span class="lineNum">     927 </span>            :     return __base;<span class="lineNum">     928 </span>            :   }<span class="lineNum">     929 </span>            : <span class="lineNum">     930 </span>            :   // [27.4.5.3] basefield manipulators<span class="lineNum">     931 </span>            :   /// Calls base.setf(ios_base::dec, ios_base::basefield).<span class="lineNum">     932 </span>            :   inline ios_base&amp;<span class="lineNum">     933 </span>            :   dec(ios_base&amp; __base)<span class="lineNum">     934 </span>            :   {<span class="lineNum">     935 </span>            :     __base.setf(ios_base::dec, ios_base::basefield);<span class="lineNum">     936 </span>            :     return __base;<span class="lineNum">     937 </span>            :   }<span class="lineNum">     938 </span>            : <span class="lineNum">     939 </span>            :   /// Calls base.setf(ios_base::hex, ios_base::basefield).<span class="lineNum">     940 </span>            :   inline ios_base&amp;<span class="lineNum">     941 </span>            :   hex(ios_base&amp; __base)<span class="lineNum">     942 </span>            :   {<span class="lineNum">     943 </span>            :     __base.setf(ios_base::hex, ios_base::basefield);<span class="lineNum">     944 </span>            :     return __base;<span class="lineNum">     945 </span>            :   }<span class="lineNum">     946 </span>            : <span class="lineNum">     947 </span>            :   /// Calls base.setf(ios_base::oct, ios_base::basefield).<span class="lineNum">     948 </span>            :   inline ios_base&amp;<span class="lineNum">     949 </span>            :   oct(ios_base&amp; __base)<span class="lineNum">     950 </span>            :   {<span class="lineNum">     951 </span>            :     __base.setf(ios_base::oct, ios_base::basefield);<span class="lineNum">     952 </span>            :     return __base;<span class="lineNum">     953 </span>            :   }<span class="lineNum">     954 </span>            : <span class="lineNum">     955 </span>            :   // [27.4.5.4] floatfield manipulators<span class="lineNum">     956 </span>            :   /// Calls base.setf(ios_base::fixed, ios_base::floatfield).<span class="lineNum">     957 </span>            :   inline ios_base&amp;<span class="lineNum">     958 </span>            :   fixed(ios_base&amp; __base)<span class="lineNum">     959 </span>            :   {<span class="lineNum">     960 </span>            :     __base.setf(ios_base::fixed, ios_base::floatfield);<span class="lineNum">     961 </span>            :     return __base;<span class="lineNum">     962 </span>            :   }<span class="lineNum">     963 </span>            : <span class="lineNum">     964 </span>            :   /// Calls base.setf(ios_base::scientific, ios_base::floatfield).<span class="lineNum">     965 </span>            :   inline ios_base&amp;<span class="lineNum">     966 </span>            :   scientific(ios_base&amp; __base)<span class="lineNum">     967 </span>            :   {<span class="lineNum">     968 </span>            :     __base.setf(ios_base::scientific, ios_base::floatfield);<span class="lineNum">     969 </span>            :     return __base;<span class="lineNum">     970 </span>            :   }<span class="lineNum">     971 </span>            : <span class="lineNum">     972 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     973 </span>            : } // namespace<span class="lineNum">     974 </span>            : <span class="lineNum">     975 </span>            : #endif /* _IOS_BASE_H */</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/ios_base.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/ios_base.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - ios_base.h<span style="font-size: 80%;"> (<a href="ios_base.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="ios_base.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="ios_base.h.gcov.html#155">_ZStorSt12_Ios_IostateS_</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/ios_base.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/ios_base.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - ios_base.h<span style="font-size: 80%;"> (<a href="ios_base.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="ios_base.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="ios_base.h.gcov.html#155">_ZStorSt12_Ios_IostateS_</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/ios_base.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/index/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/index/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/index/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - 4.8.2/bits</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">228</td>            <td class="headerCovTableEntry">332</td>            <td class="headerCovTableEntryLo">68.7 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">107</td>            <td class="headerCovTableEntry">145</td>            <td class="headerCovTableEntryLo">73.8 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/index/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/index/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/index/../glass.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><a href="index-sort-l.html"><img src="/2022/05/08/tool004/4.8.2/bits/index/../updown.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></a></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><a href="index-sort-f.html"><img src="/2022/05/08/tool004/4.8.2/bits/index/../updown.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></a></span></td>    </tr>    <tr>      <td class="coverFile"><a href="alloc_traits.h.gcov.html">alloc_traits.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../ruby.png" width="47" height="10" alt="47.1%"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="53" height="10" alt="47.1%"></td></tr></table>      </td>      <td class="coverPerLo">47.1&nbsp;%</td>      <td class="coverNumLo">8 / 17</td>      <td class="coverPerLo">50.0&nbsp;%</td>      <td class="coverNumLo">6 / 12</td>    </tr>    <tr>      <td class="coverFile"><a href="allocator.h.gcov.html">allocator.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">4 / 4</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">6 / 6</td>    </tr>    <tr>      <td class="coverFile"><a href="basic_ios.h.gcov.html">basic_ios.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 4</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="char_traits.h.gcov.html">char_traits.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="ios_base.h.gcov.html">ios_base.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="locale_facets.h.gcov.html">locale_facets.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 5</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="move.h.gcov.html">move.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../ruby.png" width="44" height="10" alt="44.4%"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="56" height="10" alt="44.4%"></td></tr></table>      </td>      <td class="coverPerLo">44.4&nbsp;%</td>      <td class="coverNumLo">4 / 9</td>      <td class="coverPerLo">42.9&nbsp;%</td>      <td class="coverNumLo">3 / 7</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_algobase.h.gcov.html">stl_algobase.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../ruby.png" width="60" height="10" alt="59.6%"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="40" height="10" alt="59.6%"></td></tr></table>      </td>      <td class="coverPerLo">59.6&nbsp;%</td>      <td class="coverNumLo">31 / 52</td>      <td class="coverPerLo">53.8&nbsp;%</td>      <td class="coverNumLo">14 / 26</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_construct.h.gcov.html">stl_construct.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">7 / 7</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">6 / 6</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_iterator.h.gcov.html">stl_iterator.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../amber.png" width="85" height="10" alt="84.6%"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="15" height="10" alt="84.6%"></td></tr></table>      </td>      <td class="coverPerMed">84.6&nbsp;%</td>      <td class="coverNumMed">11 / 13</td>      <td class="coverPerLo">66.7&nbsp;%</td>      <td class="coverNumLo">6 / 9</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_iterator_base_types.h.gcov.html">stl_iterator_base_types.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">4 / 4</td>      <td class="coverPerLo">60.0&nbsp;%</td>      <td class="coverNumLo">3 / 5</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_uninitialized.h.gcov.html">stl_uninitialized.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../emerald.png" width="92" height="10" alt="92.0%"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="8" height="10" alt="92.0%"></td></tr></table>      </td>      <td class="coverPerHi">92.0&nbsp;%</td>      <td class="coverNumHi">23 / 25</td>      <td class="coverPerHi">92.9&nbsp;%</td>      <td class="coverNumHi">13 / 14</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_vector.h.gcov.html">stl_vector.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../amber.png" width="86" height="10" alt="86.5%"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="14" height="10" alt="86.5%"></td></tr></table>      </td>      <td class="coverPerMed">86.5&nbsp;%</td>      <td class="coverNumMed">83 / 96</td>      <td class="coverPerMed">88.0&nbsp;%</td>      <td class="coverNumMed">44 / 50</td>    </tr>    <tr>      <td class="coverFile"><a href="vector.tcc.gcov.html">vector.tcc</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index/../ruby.png" width="58" height="10" alt="57.6%"><img src="/2022/05/08/tool004/4.8.2/bits/index/../snow.png" width="42" height="10" alt="57.6%"></td></tr></table>      </td>      <td class="coverPerLo">57.6&nbsp;%</td>      <td class="coverNumLo">53 / 92</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">6 / 6</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/index/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/index-sort-l/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/index-sort-l/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - 4.8.2/bits</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">228</td>            <td class="headerCovTableEntry">332</td>            <td class="headerCovTableEntryLo">68.7 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">107</td>            <td class="headerCovTableEntry">145</td>            <td class="headerCovTableEntryLo">73.8 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><a href="index.html"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../updown.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></a></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../glass.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><a href="index-sort-f.html"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../updown.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></a></span></td>    </tr>    <tr>      <td class="coverFile"><a href="char_traits.h.gcov.html">char_traits.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="ios_base.h.gcov.html">ios_base.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="basic_ios.h.gcov.html">basic_ios.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 4</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="locale_facets.h.gcov.html">locale_facets.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 5</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="move.h.gcov.html">move.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../ruby.png" width="44" height="10" alt="44.4%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="56" height="10" alt="44.4%"></td></tr></table>      </td>      <td class="coverPerLo">44.4&nbsp;%</td>      <td class="coverNumLo">4 / 9</td>      <td class="coverPerLo">42.9&nbsp;%</td>      <td class="coverNumLo">3 / 7</td>    </tr>    <tr>      <td class="coverFile"><a href="alloc_traits.h.gcov.html">alloc_traits.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../ruby.png" width="47" height="10" alt="47.1%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="53" height="10" alt="47.1%"></td></tr></table>      </td>      <td class="coverPerLo">47.1&nbsp;%</td>      <td class="coverNumLo">8 / 17</td>      <td class="coverPerLo">50.0&nbsp;%</td>      <td class="coverNumLo">6 / 12</td>    </tr>    <tr>      <td class="coverFile"><a href="vector.tcc.gcov.html">vector.tcc</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../ruby.png" width="58" height="10" alt="57.6%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="42" height="10" alt="57.6%"></td></tr></table>      </td>      <td class="coverPerLo">57.6&nbsp;%</td>      <td class="coverNumLo">53 / 92</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">6 / 6</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_algobase.h.gcov.html">stl_algobase.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../ruby.png" width="60" height="10" alt="59.6%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="40" height="10" alt="59.6%"></td></tr></table>      </td>      <td class="coverPerLo">59.6&nbsp;%</td>      <td class="coverNumLo">31 / 52</td>      <td class="coverPerLo">53.8&nbsp;%</td>      <td class="coverNumLo">14 / 26</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_iterator.h.gcov.html">stl_iterator.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../amber.png" width="85" height="10" alt="84.6%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="15" height="10" alt="84.6%"></td></tr></table>      </td>      <td class="coverPerMed">84.6&nbsp;%</td>      <td class="coverNumMed">11 / 13</td>      <td class="coverPerLo">66.7&nbsp;%</td>      <td class="coverNumLo">6 / 9</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_vector.h.gcov.html">stl_vector.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../amber.png" width="86" height="10" alt="86.5%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="14" height="10" alt="86.5%"></td></tr></table>      </td>      <td class="coverPerMed">86.5&nbsp;%</td>      <td class="coverNumMed">83 / 96</td>      <td class="coverPerMed">88.0&nbsp;%</td>      <td class="coverNumMed">44 / 50</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_uninitialized.h.gcov.html">stl_uninitialized.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../emerald.png" width="92" height="10" alt="92.0%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../snow.png" width="8" height="10" alt="92.0%"></td></tr></table>      </td>      <td class="coverPerHi">92.0&nbsp;%</td>      <td class="coverNumHi">23 / 25</td>      <td class="coverPerHi">92.9&nbsp;%</td>      <td class="coverNumHi">13 / 14</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_iterator_base_types.h.gcov.html">stl_iterator_base_types.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">4 / 4</td>      <td class="coverPerLo">60.0&nbsp;%</td>      <td class="coverNumLo">3 / 5</td>    </tr>    <tr>      <td class="coverFile"><a href="allocator.h.gcov.html">allocator.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">4 / 4</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">6 / 6</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_construct.h.gcov.html">stl_construct.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">7 / 7</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">6 / 6</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-l/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/index-sort-f/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/index-sort-f/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - 4.8.2/bits</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">228</td>            <td class="headerCovTableEntry">332</td>            <td class="headerCovTableEntryLo">68.7 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">107</td>            <td class="headerCovTableEntry">145</td>            <td class="headerCovTableEntryLo">73.8 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><a href="index.html"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../updown.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></a></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><a href="index-sort-l.html"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../updown.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></a></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../glass.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></span></td>    </tr>    <tr>      <td class="coverFile"><a href="char_traits.h.gcov.html">char_traits.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="ios_base.h.gcov.html">ios_base.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 2</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="basic_ios.h.gcov.html">basic_ios.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 4</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="locale_facets.h.gcov.html">locale_facets.h</a></td>      <td class="coverBar" align="center">                <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="100" height="10" alt="0.0%"></td></tr></table>      </td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 5</td>      <td class="coverPerLo">0.0&nbsp;%</td>      <td class="coverNumLo">0 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="move.h.gcov.html">move.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../ruby.png" width="44" height="10" alt="44.4%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="56" height="10" alt="44.4%"></td></tr></table>      </td>      <td class="coverPerLo">44.4&nbsp;%</td>      <td class="coverNumLo">4 / 9</td>      <td class="coverPerLo">42.9&nbsp;%</td>      <td class="coverNumLo">3 / 7</td>    </tr>    <tr>      <td class="coverFile"><a href="alloc_traits.h.gcov.html">alloc_traits.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../ruby.png" width="47" height="10" alt="47.1%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="53" height="10" alt="47.1%"></td></tr></table>      </td>      <td class="coverPerLo">47.1&nbsp;%</td>      <td class="coverNumLo">8 / 17</td>      <td class="coverPerLo">50.0&nbsp;%</td>      <td class="coverNumLo">6 / 12</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_algobase.h.gcov.html">stl_algobase.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../ruby.png" width="60" height="10" alt="59.6%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="40" height="10" alt="59.6%"></td></tr></table>      </td>      <td class="coverPerLo">59.6&nbsp;%</td>      <td class="coverNumLo">31 / 52</td>      <td class="coverPerLo">53.8&nbsp;%</td>      <td class="coverNumLo">14 / 26</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_iterator_base_types.h.gcov.html">stl_iterator_base_types.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">4 / 4</td>      <td class="coverPerLo">60.0&nbsp;%</td>      <td class="coverNumLo">3 / 5</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_iterator.h.gcov.html">stl_iterator.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../amber.png" width="85" height="10" alt="84.6%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="15" height="10" alt="84.6%"></td></tr></table>      </td>      <td class="coverPerMed">84.6&nbsp;%</td>      <td class="coverNumMed">11 / 13</td>      <td class="coverPerLo">66.7&nbsp;%</td>      <td class="coverNumLo">6 / 9</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_vector.h.gcov.html">stl_vector.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../amber.png" width="86" height="10" alt="86.5%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="14" height="10" alt="86.5%"></td></tr></table>      </td>      <td class="coverPerMed">86.5&nbsp;%</td>      <td class="coverNumMed">83 / 96</td>      <td class="coverPerMed">88.0&nbsp;%</td>      <td class="coverNumMed">44 / 50</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_uninitialized.h.gcov.html">stl_uninitialized.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../emerald.png" width="92" height="10" alt="92.0%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="8" height="10" alt="92.0%"></td></tr></table>      </td>      <td class="coverPerHi">92.0&nbsp;%</td>      <td class="coverNumHi">23 / 25</td>      <td class="coverPerHi">92.9&nbsp;%</td>      <td class="coverNumHi">13 / 14</td>    </tr>    <tr>      <td class="coverFile"><a href="allocator.h.gcov.html">allocator.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">4 / 4</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">6 / 6</td>    </tr>    <tr>      <td class="coverFile"><a href="vector.tcc.gcov.html">vector.tcc</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../ruby.png" width="58" height="10" alt="57.6%"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../snow.png" width="42" height="10" alt="57.6%"></td></tr></table>      </td>      <td class="coverPerLo">57.6&nbsp;%</td>      <td class="coverNumLo">53 / 92</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">6 / 6</td>    </tr>    <tr>      <td class="coverFile"><a href="stl_construct.h.gcov.html">stl_construct.h</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">7 / 7</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">6 / 6</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/index-sort-f/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/char_traits.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/char_traits.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/char_traits.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - char_traits.h<span style="font-size: 80%;"> (source / <a href="char_traits.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Character Traits for use by standard string and iostream -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 1997-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /** @file bits/char_traits.h<span class="lineNum">      26 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      27 </span>            :  *  Do not attempt to use it directly. @headername{string}<span class="lineNum">      28 </span>            :  */<span class="lineNum">      29 </span>            : <span class="lineNum">      30 </span>            : //<span class="lineNum">      31 </span>            : // ISO C++ 14882: 21  Strings library<span class="lineNum">      32 </span>            : //<span class="lineNum">      33 </span>            : <span class="lineNum">      34 </span>            : #ifndef _CHAR_TRAITS_H<span class="lineNum">      35 </span>            : #define _CHAR_TRAITS_H 1<span class="lineNum">      36 </span>            : <span class="lineNum">      37 </span>            : #pragma GCC system_header<span class="lineNum">      38 </span>            : <span class="lineNum">      39 </span>            : #include &lt;bits/stl_algobase.h&gt;  // std::copy, std::fill_n<span class="lineNum">      40 </span>            : #include &lt;bits/postypes.h&gt;      // For streampos<span class="lineNum">      41 </span>            : #include &lt;cwchar&gt;               // For WEOF, wmemmove, wmemset, etc.<span class="lineNum">      42 </span>            : <span class="lineNum">      43 </span>            : namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)<span class="lineNum">      44 </span>            : {<span class="lineNum">      45 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      46 </span>            : <span class="lineNum">      47 </span>            :   /**<span class="lineNum">      48 </span>            :    *  @brief  Mapping from character type to associated types.<span class="lineNum">      49 </span>            :    *<span class="lineNum">      50 </span>            :    *  @note This is an implementation class for the generic version<span class="lineNum">      51 </span>            :    *  of char_traits.  It defines int_type, off_type, pos_type, and<span class="lineNum">      52 </span>            :    *  state_type.  By default these are unsigned long, streamoff,<span class="lineNum">      53 </span>            :    *  streampos, and mbstate_t.  Users who need a different set of<span class="lineNum">      54 </span>            :    *  types, but who don't need to change the definitions of any function<span class="lineNum">      55 </span>            :    *  defined in char_traits, can specialize __gnu_cxx::_Char_types<span class="lineNum">      56 </span>            :    *  while leaving __gnu_cxx::char_traits alone. */<span class="lineNum">      57 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">      58 </span>            :     struct _Char_types<span class="lineNum">      59 </span>            :     {<span class="lineNum">      60 </span>            :       typedef unsigned long   int_type;<span class="lineNum">      61 </span>            :       typedef std::streampos  pos_type;<span class="lineNum">      62 </span>            :       typedef std::streamoff  off_type;<span class="lineNum">      63 </span>            :       typedef std::mbstate_t  state_type;<span class="lineNum">      64 </span>            :     };<span class="lineNum">      65 </span>            : <span class="lineNum">      66 </span>            : <span class="lineNum">      67 </span>            :   /**<span class="lineNum">      68 </span>            :    *  @brief  Base class used to implement std::char_traits.<span class="lineNum">      69 </span>            :    *<span class="lineNum">      70 </span>            :    *  @note For any given actual character type, this definition is<span class="lineNum">      71 </span>            :    *  probably wrong.  (Most of the member functions are likely to be<span class="lineNum">      72 </span>            :    *  right, but the int_type and state_type typedefs, and the eof()<span class="lineNum">      73 </span>            :    *  member function, are likely to be wrong.)  The reason this class<span class="lineNum">      74 </span>            :    *  exists is so users can specialize it.  Classes in namespace std<span class="lineNum">      75 </span>            :    *  may not be specialized for fundamental types, but classes in<span class="lineNum">      76 </span>            :    *  namespace __gnu_cxx may be.<span class="lineNum">      77 </span>            :    *<span class="lineNum">      78 </span>            :    *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt05ch13s03.html<span class="lineNum">      79 </span>            :    *  for advice on how to make use of this class for @a unusual character<span class="lineNum">      80 </span>            :    *  types. Also, check out include/ext/pod_char_traits.h.  <span class="lineNum">      81 </span>            :    */<span class="lineNum">      82 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">      83 </span>            :     struct char_traits<span class="lineNum">      84 </span>            :     {<span class="lineNum">      85 </span>            :       typedef _CharT                                    char_type;<span class="lineNum">      86 </span>            :       typedef typename _Char_types&lt;_CharT&gt;::int_type    int_type;<span class="lineNum">      87 </span>            :       typedef typename _Char_types&lt;_CharT&gt;::pos_type    pos_type;<span class="lineNum">      88 </span>            :       typedef typename _Char_types&lt;_CharT&gt;::off_type    off_type;<span class="lineNum">      89 </span>            :       typedef typename _Char_types&lt;_CharT&gt;::state_type  state_type;<span class="lineNum">      90 </span>            : <span class="lineNum">      91 </span>            :       static void<span class="lineNum">      92 </span>            :       assign(char_type&amp; __c1, const char_type&amp; __c2)<span class="lineNum">      93 </span>            :       { __c1 = __c2; }<span class="lineNum">      94 </span>            : <span class="lineNum">      95 </span>            :       static _GLIBCXX_CONSTEXPR bool<span class="lineNum">      96 </span>            :       eq(const char_type&amp; __c1, const char_type&amp; __c2)<span class="lineNum">      97 </span>            :       { return __c1 == __c2; }<span class="lineNum">      98 </span>            : <span class="lineNum">      99 </span>            :       static _GLIBCXX_CONSTEXPR bool<span class="lineNum">     100 </span>            :       lt(const char_type&amp; __c1, const char_type&amp; __c2)<span class="lineNum">     101 </span>            :       { return __c1 &lt; __c2; }<span class="lineNum">     102 </span>            : <span class="lineNum">     103 </span>            :       static int<span class="lineNum">     104 </span>            :       compare(const char_type* __s1, const char_type* __s2, std::size_t __n);<span class="lineNum">     105 </span>            : <span class="lineNum">     106 </span>            :       static std::size_t<span class="lineNum">     107 </span>            :       length(const char_type* __s);<span class="lineNum">     108 </span>            : <span class="lineNum">     109 </span>            :       static const char_type*<span class="lineNum">     110 </span>            :       find(const char_type* __s, std::size_t __n, const char_type&amp; __a);<span class="lineNum">     111 </span>            : <span class="lineNum">     112 </span>            :       static char_type*<span class="lineNum">     113 </span>            :       move(char_type* __s1, const char_type* __s2, std::size_t __n);<span class="lineNum">     114 </span>            : <span class="lineNum">     115 </span>            :       static char_type*<span class="lineNum">     116 </span>            :       copy(char_type* __s1, const char_type* __s2, std::size_t __n);<span class="lineNum">     117 </span>            : <span class="lineNum">     118 </span>            :       static char_type*<span class="lineNum">     119 </span>            :       assign(char_type* __s, std::size_t __n, char_type __a);<span class="lineNum">     120 </span>            : <span class="lineNum">     121 </span>            :       static _GLIBCXX_CONSTEXPR char_type<span class="lineNum">     122 </span>            :       to_char_type(const int_type&amp; __c)<span class="lineNum">     123 </span>            :       { return static_cast&lt;char_type&gt;(__c); }<span class="lineNum">     124 </span>            : <span class="lineNum">     125 </span>            :       static _GLIBCXX_CONSTEXPR int_type<span class="lineNum">     126 </span>            :       to_int_type(const char_type&amp; __c)<span class="lineNum">     127 </span>            :       { return static_cast&lt;int_type&gt;(__c); }<span class="lineNum">     128 </span>            : <span class="lineNum">     129 </span>            :       static _GLIBCXX_CONSTEXPR bool<span class="lineNum">     130 </span>            :       eq_int_type(const int_type&amp; __c1, const int_type&amp; __c2)<span class="lineNum">     131 </span>            :       { return __c1 == __c2; }<span class="lineNum">     132 </span>            : <span class="lineNum">     133 </span>            :       static _GLIBCXX_CONSTEXPR int_type<span class="lineNum">     134 </span>            :       eof()<span class="lineNum">     135 </span>            :       { return static_cast&lt;int_type&gt;(_GLIBCXX_STDIO_EOF); }<span class="lineNum">     136 </span>            : <span class="lineNum">     137 </span>            :       static _GLIBCXX_CONSTEXPR int_type<span class="lineNum">     138 </span>            :       not_eof(const int_type&amp; __c)<span class="lineNum">     139 </span>            :       { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }<span class="lineNum">     140 </span>            :     };<span class="lineNum">     141 </span>            : <span class="lineNum">     142 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     143 </span>            :     int<span class="lineNum">     144 </span>            :     char_traits&lt;_CharT&gt;::<span class="lineNum">     145 </span>            :     compare(const char_type* __s1, const char_type* __s2, std::size_t __n)<span class="lineNum">     146 </span>            :     {<span class="lineNum">     147 </span>            :       for (std::size_t __i = 0; __i &lt; __n; ++__i)<span class="lineNum">     148 </span>            :         if (lt(__s1[__i], __s2[__i]))<span class="lineNum">     149 </span>            :           return -1;<span class="lineNum">     150 </span>            :         else if (lt(__s2[__i], __s1[__i]))<span class="lineNum">     151 </span>            :           return 1;<span class="lineNum">     152 </span>            :       return 0;<span class="lineNum">     153 </span>            :     }<span class="lineNum">     154 </span>            : <span class="lineNum">     155 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     156 </span>            :     std::size_t<span class="lineNum">     157 </span>            :     char_traits&lt;_CharT&gt;::<span class="lineNum">     158 </span>            :     length(const char_type* __p)<span class="lineNum">     159 </span>            :     {<span class="lineNum">     160 </span>            :       std::size_t __i = 0;<span class="lineNum">     161 </span>            :       while (!eq(__p[__i], char_type()))<span class="lineNum">     162 </span>            :         ++__i;<span class="lineNum">     163 </span>            :       return __i;<span class="lineNum">     164 </span>            :     }<span class="lineNum">     165 </span>            : <span class="lineNum">     166 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     167 </span>            :     const typename char_traits&lt;_CharT&gt;::char_type*<span class="lineNum">     168 </span>            :     char_traits&lt;_CharT&gt;::<span class="lineNum">     169 </span>            :     find(const char_type* __s, std::size_t __n, const char_type&amp; __a)<span class="lineNum">     170 </span>            :     {<span class="lineNum">     171 </span>            :       for (std::size_t __i = 0; __i &lt; __n; ++__i)<span class="lineNum">     172 </span>            :         if (eq(__s[__i], __a))<span class="lineNum">     173 </span>            :           return __s + __i;<span class="lineNum">     174 </span>            :       return 0;<span class="lineNum">     175 </span>            :     }<span class="lineNum">     176 </span>            : <span class="lineNum">     177 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     178 </span>            :     typename char_traits&lt;_CharT&gt;::char_type*<span class="lineNum">     179 </span>            :     char_traits&lt;_CharT&gt;::<span class="lineNum">     180 </span>            :     move(char_type* __s1, const char_type* __s2, std::size_t __n)<span class="lineNum">     181 </span>            :     {<span class="lineNum">     182 </span>            :       return static_cast&lt;_CharT*&gt;(__builtin_memmove(__s1, __s2,<span class="lineNum">     183 </span>            :                                                     __n * sizeof(char_type)));<span class="lineNum">     184 </span>            :     }<span class="lineNum">     185 </span>            : <span class="lineNum">     186 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     187 </span>            :     typename char_traits&lt;_CharT&gt;::char_type*<span class="lineNum">     188 </span>            :     char_traits&lt;_CharT&gt;::<span class="lineNum">     189 </span>            :     copy(char_type* __s1, const char_type* __s2, std::size_t __n)<span class="lineNum">     190 </span>            :     {<span class="lineNum">     191 </span>            :       // NB: Inline std::copy so no recursive dependencies.<span class="lineNum">     192 </span>            :       std::copy(__s2, __s2 + __n, __s1);<span class="lineNum">     193 </span>            :       return __s1;<span class="lineNum">     194 </span>            :     }<span class="lineNum">     195 </span>            : <span class="lineNum">     196 </span>            :   template&lt;typename _CharT&gt;<span class="lineNum">     197 </span>            :     typename char_traits&lt;_CharT&gt;::char_type*<span class="lineNum">     198 </span>            :     char_traits&lt;_CharT&gt;::<span class="lineNum">     199 </span>            :     assign(char_type* __s, std::size_t __n, char_type __a)<span class="lineNum">     200 </span>            :     {<span class="lineNum">     201 </span>            :       // NB: Inline std::fill_n so no recursive dependencies.<span class="lineNum">     202 </span>            :       std::fill_n(__s, __n, __a);<span class="lineNum">     203 </span>            :       return __s;<span class="lineNum">     204 </span>            :     }<span class="lineNum">     205 </span>            : <span class="lineNum">     206 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     207 </span>            : } // namespace<span class="lineNum">     208 </span>            : <span class="lineNum">     209 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">     210 </span>            : {<span class="lineNum">     211 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">     212 </span>            : <span class="lineNum">     213 </span>            :   // 21.1<span class="lineNum">     214 </span>            :   /**<span class="lineNum">     215 </span>            :    *  @brief  Basis for explicit traits specializations.<span class="lineNum">     216 </span>            :    *<span class="lineNum">     217 </span>            :    *  @note  For any given actual character type, this definition is<span class="lineNum">     218 </span>            :    *  probably wrong.  Since this is just a thin wrapper around<span class="lineNum">     219 </span>            :    *  __gnu_cxx::char_traits, it is possible to achieve a more<span class="lineNum">     220 </span>            :    *  appropriate definition by specializing __gnu_cxx::char_traits.<span class="lineNum">     221 </span>            :    *<span class="lineNum">     222 </span>            :    *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt05ch13s03.html<span class="lineNum">     223 </span>            :    *  for advice on how to make use of this class for @a unusual character<span class="lineNum">     224 </span>            :    *  types. Also, check out include/ext/pod_char_traits.h.<span class="lineNum">     225 </span>            :   */<span class="lineNum">     226 </span>            :   template&lt;class _CharT&gt;<span class="lineNum">     227 </span>            :     struct char_traits : public __gnu_cxx::char_traits&lt;_CharT&gt;<span class="lineNum">     228 </span>            :     { };<span class="lineNum">     229 </span>            : <span class="lineNum">     230 </span>            : <span class="lineNum">     231 </span>            :   /// 21.1.3.1  char_traits specializations<span class="lineNum">     232 </span>            :   template&lt;&gt;<span class="lineNum">     233 </span>            :     struct char_traits&lt;char&gt;<span class="lineNum">     234 </span>            :     {<span class="lineNum">     235 </span>            :       typedef char              char_type;<span class="lineNum">     236 </span>            :       typedef int               int_type;<span class="lineNum">     237 </span>            :       typedef streampos         pos_type;<span class="lineNum">     238 </span>            :       typedef streamoff         off_type;<span class="lineNum">     239 </span>            :       typedef mbstate_t         state_type;<span class="lineNum">     240 </span>            : <span class="lineNum">     241 </span>            :       static void<span class="lineNum">     242 </span>            :       assign(char_type&amp; __c1, const char_type&amp; __c2) _GLIBCXX_NOEXCEPT<span class="lineNum">     243 </span>            :       { __c1 = __c2; }<span class="lineNum">     244 </span>            : <span class="lineNum">     245 </span>            :       static _GLIBCXX_CONSTEXPR bool<span class="lineNum">     246 </span>            :       eq(const char_type&amp; __c1, const char_type&amp; __c2) _GLIBCXX_NOEXCEPT<span class="lineNum">     247 </span>            :       { return __c1 == __c2; }<span class="lineNum">     248 </span>            : <span class="lineNum">     249 </span>            :       static _GLIBCXX_CONSTEXPR bool<span class="lineNum">     250 </span>            :       lt(const char_type&amp; __c1, const char_type&amp; __c2) _GLIBCXX_NOEXCEPT<span class="lineNum">     251 </span>            :       { return __c1 &lt; __c2; }<span class="lineNum">     252 </span>            : <span class="lineNum">     253 </span>            :       static int<span class="lineNum">     254 </span>            :       compare(const char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     255 </span>            :       { return __builtin_memcmp(__s1, __s2, __n); }<a name="256"><span class="lineNum">     256 </span>            : </a><span class="lineNum">     257 </span>            :       static size_t<span class="lineNum">     258 </span><span class="lineNoCov">          0 :       length(const char_type* __s)</span><span class="lineNum">     259 </span><span class="lineNoCov">          0 :       { return __builtin_strlen(__s); }</span><span class="lineNum">     260 </span>            : <span class="lineNum">     261 </span>            :       static const char_type*<span class="lineNum">     262 </span>            :       find(const char_type* __s, size_t __n, const char_type&amp; __a)<span class="lineNum">     263 </span>            :       { return static_cast&lt;const char_type*&gt;(__builtin_memchr(__s, __a, __n)); }<span class="lineNum">     264 </span>            : <span class="lineNum">     265 </span>            :       static char_type*<span class="lineNum">     266 </span>            :       move(char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     267 </span>            :       { return static_cast&lt;char_type*&gt;(__builtin_memmove(__s1, __s2, __n)); }<span class="lineNum">     268 </span>            : <span class="lineNum">     269 </span>            :       static char_type*<span class="lineNum">     270 </span>            :       copy(char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     271 </span>            :       { return static_cast&lt;char_type*&gt;(__builtin_memcpy(__s1, __s2, __n)); }<span class="lineNum">     272 </span>            : <span class="lineNum">     273 </span>            :       static char_type*<span class="lineNum">     274 </span>            :       assign(char_type* __s, size_t __n, char_type __a)<span class="lineNum">     275 </span>            :       { return static_cast&lt;char_type*&gt;(__builtin_memset(__s, __a, __n)); }<span class="lineNum">     276 </span>            : <span class="lineNum">     277 </span>            :       static _GLIBCXX_CONSTEXPR char_type<span class="lineNum">     278 </span>            :       to_char_type(const int_type&amp; __c) _GLIBCXX_NOEXCEPT<span class="lineNum">     279 </span>            :       { return static_cast&lt;char_type&gt;(__c); }<span class="lineNum">     280 </span>            : <span class="lineNum">     281 </span>            :       // To keep both the byte 0xff and the eof symbol 0xffffffff<span class="lineNum">     282 </span>            :       // from ending up as 0xffffffff.<span class="lineNum">     283 </span>            :       static _GLIBCXX_CONSTEXPR int_type<span class="lineNum">     284 </span>            :       to_int_type(const char_type&amp; __c) _GLIBCXX_NOEXCEPT<span class="lineNum">     285 </span>            :       { return static_cast&lt;int_type&gt;(static_cast&lt;unsigned char&gt;(__c)); }<span class="lineNum">     286 </span>            : <span class="lineNum">     287 </span>            :       static _GLIBCXX_CONSTEXPR bool<span class="lineNum">     288 </span>            :       eq_int_type(const int_type&amp; __c1, const int_type&amp; __c2) _GLIBCXX_NOEXCEPT<span class="lineNum">     289 </span>            :       { return __c1 == __c2; }<span class="lineNum">     290 </span>            : <span class="lineNum">     291 </span>            :       static _GLIBCXX_CONSTEXPR int_type<span class="lineNum">     292 </span>            :       eof() _GLIBCXX_NOEXCEPT<span class="lineNum">     293 </span>            :       { return static_cast&lt;int_type&gt;(_GLIBCXX_STDIO_EOF); }<span class="lineNum">     294 </span>            : <span class="lineNum">     295 </span>            :       static _GLIBCXX_CONSTEXPR int_type<span class="lineNum">     296 </span>            :       not_eof(const int_type&amp; __c) _GLIBCXX_NOEXCEPT<span class="lineNum">     297 </span>            :       { return (__c == eof()) ? 0 : __c; }<span class="lineNum">     298 </span>            :   };<span class="lineNum">     299 </span>            : <span class="lineNum">     300 </span>            : <span class="lineNum">     301 </span>            : #ifdef _GLIBCXX_USE_WCHAR_T<span class="lineNum">     302 </span>            :   /// 21.1.3.2  char_traits specializations<span class="lineNum">     303 </span>            :   template&lt;&gt;<span class="lineNum">     304 </span>            :     struct char_traits&lt;wchar_t&gt;<span class="lineNum">     305 </span>            :     {<span class="lineNum">     306 </span>            :       typedef wchar_t           char_type;<span class="lineNum">     307 </span>            :       typedef wint_t            int_type;<span class="lineNum">     308 </span>            :       typedef streamoff         off_type;<span class="lineNum">     309 </span>            :       typedef wstreampos        pos_type;<span class="lineNum">     310 </span>            :       typedef mbstate_t         state_type;<span class="lineNum">     311 </span>            : <span class="lineNum">     312 </span>            :       static void<span class="lineNum">     313 </span>            :       assign(char_type&amp; __c1, const char_type&amp; __c2) _GLIBCXX_NOEXCEPT<span class="lineNum">     314 </span>            :       { __c1 = __c2; }<span class="lineNum">     315 </span>            : <span class="lineNum">     316 </span>            :       static _GLIBCXX_CONSTEXPR bool<span class="lineNum">     317 </span>            :       eq(const char_type&amp; __c1, const char_type&amp; __c2) _GLIBCXX_NOEXCEPT<span class="lineNum">     318 </span>            :       { return __c1 == __c2; }<span class="lineNum">     319 </span>            : <span class="lineNum">     320 </span>            :       static _GLIBCXX_CONSTEXPR bool<span class="lineNum">     321 </span>            :       lt(const char_type&amp; __c1, const char_type&amp; __c2) _GLIBCXX_NOEXCEPT<span class="lineNum">     322 </span>            :       { return __c1 &lt; __c2; }<span class="lineNum">     323 </span>            : <span class="lineNum">     324 </span>            :       static int<span class="lineNum">     325 </span>            :       compare(const char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     326 </span>            :       { return wmemcmp(__s1, __s2, __n); }<span class="lineNum">     327 </span>            : <span class="lineNum">     328 </span>            :       static size_t<span class="lineNum">     329 </span>            :       length(const char_type* __s)<span class="lineNum">     330 </span>            :       { return wcslen(__s); }<span class="lineNum">     331 </span>            : <span class="lineNum">     332 </span>            :       static const char_type*<span class="lineNum">     333 </span>            :       find(const char_type* __s, size_t __n, const char_type&amp; __a)<span class="lineNum">     334 </span>            :       { return wmemchr(__s, __a, __n); }<span class="lineNum">     335 </span>            : <span class="lineNum">     336 </span>            :       static char_type*<span class="lineNum">     337 </span>            :       move(char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     338 </span>            :       { return wmemmove(__s1, __s2, __n); }<span class="lineNum">     339 </span>            : <span class="lineNum">     340 </span>            :       static char_type*<span class="lineNum">     341 </span>            :       copy(char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     342 </span>            :       { return wmemcpy(__s1, __s2, __n); }<span class="lineNum">     343 </span>            : <span class="lineNum">     344 </span>            :       static char_type*<span class="lineNum">     345 </span>            :       assign(char_type* __s, size_t __n, char_type __a)<span class="lineNum">     346 </span>            :       { return wmemset(__s, __a, __n); }<span class="lineNum">     347 </span>            : <span class="lineNum">     348 </span>            :       static _GLIBCXX_CONSTEXPR char_type<span class="lineNum">     349 </span>            :       to_char_type(const int_type&amp; __c) _GLIBCXX_NOEXCEPT<span class="lineNum">     350 </span>            :       { return char_type(__c); }<span class="lineNum">     351 </span>            : <span class="lineNum">     352 </span>            :       static _GLIBCXX_CONSTEXPR int_type<span class="lineNum">     353 </span>            :       to_int_type(const char_type&amp; __c) _GLIBCXX_NOEXCEPT<span class="lineNum">     354 </span>            :       { return int_type(__c); }<span class="lineNum">     355 </span>            : <span class="lineNum">     356 </span>            :       static _GLIBCXX_CONSTEXPR bool<span class="lineNum">     357 </span>            :       eq_int_type(const int_type&amp; __c1, const int_type&amp; __c2) _GLIBCXX_NOEXCEPT<span class="lineNum">     358 </span>            :       { return __c1 == __c2; }<span class="lineNum">     359 </span>            : <span class="lineNum">     360 </span>            :       static _GLIBCXX_CONSTEXPR int_type<span class="lineNum">     361 </span>            :       eof() _GLIBCXX_NOEXCEPT<span class="lineNum">     362 </span>            :       { return static_cast&lt;int_type&gt;(WEOF); }<span class="lineNum">     363 </span>            : <span class="lineNum">     364 </span>            :       static _GLIBCXX_CONSTEXPR int_type<span class="lineNum">     365 </span>            :       not_eof(const int_type&amp; __c) _GLIBCXX_NOEXCEPT<span class="lineNum">     366 </span>            :       { return eq_int_type(__c, eof()) ? 0 : __c; }<span class="lineNum">     367 </span>            :   };<span class="lineNum">     368 </span>            : #endif //_GLIBCXX_USE_WCHAR_T<span class="lineNum">     369 </span>            : <span class="lineNum">     370 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     371 </span>            : } // namespace<span class="lineNum">     372 </span>            : <span class="lineNum">     373 </span>            : #if ((__cplusplus &gt;= 201103L) \<span class="lineNum">     374 </span>            :      &amp;&amp; defined(_GLIBCXX_USE_C99_STDINT_TR1))<span class="lineNum">     375 </span>            : <span class="lineNum">     376 </span>            : #include &lt;cstdint&gt;<span class="lineNum">     377 </span>            : <span class="lineNum">     378 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">     379 </span>            : {<span class="lineNum">     380 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">     381 </span>            : <span class="lineNum">     382 </span>            :   template&lt;&gt;<span class="lineNum">     383 </span>            :     struct char_traits&lt;char16_t&gt;<span class="lineNum">     384 </span>            :     {<span class="lineNum">     385 </span>            :       typedef char16_t          char_type;<span class="lineNum">     386 </span>            :       typedef uint_least16_t    int_type;<span class="lineNum">     387 </span>            :       typedef streamoff         off_type;<span class="lineNum">     388 </span>            :       typedef u16streampos      pos_type;<span class="lineNum">     389 </span>            :       typedef mbstate_t         state_type;<span class="lineNum">     390 </span>            : <span class="lineNum">     391 </span>            :       static void<span class="lineNum">     392 </span>            :       assign(char_type&amp; __c1, const char_type&amp; __c2) noexcept<span class="lineNum">     393 </span>            :       { __c1 = __c2; }<span class="lineNum">     394 </span>            : <span class="lineNum">     395 </span>            :       static constexpr bool<span class="lineNum">     396 </span>            :       eq(const char_type&amp; __c1, const char_type&amp; __c2) noexcept<span class="lineNum">     397 </span>            :       { return __c1 == __c2; }<span class="lineNum">     398 </span>            : <span class="lineNum">     399 </span>            :       static constexpr bool<span class="lineNum">     400 </span>            :       lt(const char_type&amp; __c1, const char_type&amp; __c2) noexcept<span class="lineNum">     401 </span>            :       { return __c1 &lt; __c2; }<span class="lineNum">     402 </span>            : <span class="lineNum">     403 </span>            :       static int<span class="lineNum">     404 </span>            :       compare(const char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     405 </span>            :       {<span class="lineNum">     406 </span>            :         for (size_t __i = 0; __i &lt; __n; ++__i)<span class="lineNum">     407 </span>            :           if (lt(__s1[__i], __s2[__i]))<span class="lineNum">     408 </span>            :             return -1;<span class="lineNum">     409 </span>            :           else if (lt(__s2[__i], __s1[__i]))<span class="lineNum">     410 </span>            :             return 1;<span class="lineNum">     411 </span>            :         return 0;<span class="lineNum">     412 </span>            :       }<span class="lineNum">     413 </span>            : <span class="lineNum">     414 </span>            :       static size_t<span class="lineNum">     415 </span>            :       length(const char_type* __s)<span class="lineNum">     416 </span>            :       {<span class="lineNum">     417 </span>            :         size_t __i = 0;<span class="lineNum">     418 </span>            :         while (!eq(__s[__i], char_type()))<span class="lineNum">     419 </span>            :           ++__i;<span class="lineNum">     420 </span>            :         return __i;<span class="lineNum">     421 </span>            :       }<span class="lineNum">     422 </span>            : <span class="lineNum">     423 </span>            :       static const char_type*<span class="lineNum">     424 </span>            :       find(const char_type* __s, size_t __n, const char_type&amp; __a)<span class="lineNum">     425 </span>            :       {<span class="lineNum">     426 </span>            :         for (size_t __i = 0; __i &lt; __n; ++__i)<span class="lineNum">     427 </span>            :           if (eq(__s[__i], __a))<span class="lineNum">     428 </span>            :             return __s + __i;<span class="lineNum">     429 </span>            :         return 0;<span class="lineNum">     430 </span>            :       }<span class="lineNum">     431 </span>            : <span class="lineNum">     432 </span>            :       static char_type*<span class="lineNum">     433 </span>            :       move(char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     434 </span>            :       {<span class="lineNum">     435 </span>            :         return (static_cast&lt;char_type*&gt;<span class="lineNum">     436 </span>            :                 (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));<span class="lineNum">     437 </span>            :       }<span class="lineNum">     438 </span>            : <span class="lineNum">     439 </span>            :       static char_type*<span class="lineNum">     440 </span>            :       copy(char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     441 </span>            :       {<span class="lineNum">     442 </span>            :         return (static_cast&lt;char_type*&gt;<span class="lineNum">     443 </span>            :                 (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));<span class="lineNum">     444 </span>            :       }<span class="lineNum">     445 </span>            : <span class="lineNum">     446 </span>            :       static char_type*<span class="lineNum">     447 </span>            :       assign(char_type* __s, size_t __n, char_type __a)<span class="lineNum">     448 </span>            :       {<span class="lineNum">     449 </span>            :         for (size_t __i = 0; __i &lt; __n; ++__i)<span class="lineNum">     450 </span>            :           assign(__s[__i], __a);<span class="lineNum">     451 </span>            :         return __s;<span class="lineNum">     452 </span>            :       }<span class="lineNum">     453 </span>            : <span class="lineNum">     454 </span>            :       static constexpr char_type<span class="lineNum">     455 </span>            :       to_char_type(const int_type&amp; __c) noexcept<span class="lineNum">     456 </span>            :       { return char_type(__c); }<span class="lineNum">     457 </span>            : <span class="lineNum">     458 </span>            :       static constexpr int_type<span class="lineNum">     459 </span>            :       to_int_type(const char_type&amp; __c) noexcept<span class="lineNum">     460 </span>            :       { return int_type(__c); }<span class="lineNum">     461 </span>            : <span class="lineNum">     462 </span>            :       static constexpr bool<span class="lineNum">     463 </span>            :       eq_int_type(const int_type&amp; __c1, const int_type&amp; __c2) noexcept<span class="lineNum">     464 </span>            :       { return __c1 == __c2; }<span class="lineNum">     465 </span>            : <span class="lineNum">     466 </span>            :       static constexpr int_type<span class="lineNum">     467 </span>            :       eof() noexcept<span class="lineNum">     468 </span>            :       { return static_cast&lt;int_type&gt;(-1); }<span class="lineNum">     469 </span>            : <span class="lineNum">     470 </span>            :       static constexpr int_type<span class="lineNum">     471 </span>            :       not_eof(const int_type&amp; __c) noexcept<span class="lineNum">     472 </span>            :       { return eq_int_type(__c, eof()) ? 0 : __c; }<span class="lineNum">     473 </span>            :     };<span class="lineNum">     474 </span>            : <span class="lineNum">     475 </span>            :   template&lt;&gt;<span class="lineNum">     476 </span>            :     struct char_traits&lt;char32_t&gt;<span class="lineNum">     477 </span>            :     {<span class="lineNum">     478 </span>            :       typedef char32_t          char_type;<span class="lineNum">     479 </span>            :       typedef uint_least32_t    int_type;<span class="lineNum">     480 </span>            :       typedef streamoff         off_type;<span class="lineNum">     481 </span>            :       typedef u32streampos      pos_type;<span class="lineNum">     482 </span>            :       typedef mbstate_t         state_type;<span class="lineNum">     483 </span>            : <span class="lineNum">     484 </span>            :       static void<span class="lineNum">     485 </span>            :       assign(char_type&amp; __c1, const char_type&amp; __c2) noexcept<span class="lineNum">     486 </span>            :       { __c1 = __c2; }<span class="lineNum">     487 </span>            : <span class="lineNum">     488 </span>            :       static constexpr bool<span class="lineNum">     489 </span>            :       eq(const char_type&amp; __c1, const char_type&amp; __c2) noexcept<span class="lineNum">     490 </span>            :       { return __c1 == __c2; }<span class="lineNum">     491 </span>            : <span class="lineNum">     492 </span>            :       static constexpr bool<span class="lineNum">     493 </span>            :       lt(const char_type&amp; __c1, const char_type&amp; __c2) noexcept<span class="lineNum">     494 </span>            :       { return __c1 &lt; __c2; }<span class="lineNum">     495 </span>            : <span class="lineNum">     496 </span>            :       static int<span class="lineNum">     497 </span>            :       compare(const char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     498 </span>            :       {<span class="lineNum">     499 </span>            :         for (size_t __i = 0; __i &lt; __n; ++__i)<span class="lineNum">     500 </span>            :           if (lt(__s1[__i], __s2[__i]))<span class="lineNum">     501 </span>            :             return -1;<span class="lineNum">     502 </span>            :           else if (lt(__s2[__i], __s1[__i]))<span class="lineNum">     503 </span>            :             return 1;<span class="lineNum">     504 </span>            :         return 0;<span class="lineNum">     505 </span>            :       }<span class="lineNum">     506 </span>            : <span class="lineNum">     507 </span>            :       static size_t<span class="lineNum">     508 </span>            :       length(const char_type* __s)<span class="lineNum">     509 </span>            :       {<span class="lineNum">     510 </span>            :         size_t __i = 0;<span class="lineNum">     511 </span>            :         while (!eq(__s[__i], char_type()))<span class="lineNum">     512 </span>            :           ++__i;<span class="lineNum">     513 </span>            :         return __i;<span class="lineNum">     514 </span>            :       }<span class="lineNum">     515 </span>            : <span class="lineNum">     516 </span>            :       static const char_type*<span class="lineNum">     517 </span>            :       find(const char_type* __s, size_t __n, const char_type&amp; __a)<span class="lineNum">     518 </span>            :       {<span class="lineNum">     519 </span>            :         for (size_t __i = 0; __i &lt; __n; ++__i)<span class="lineNum">     520 </span>            :           if (eq(__s[__i], __a))<span class="lineNum">     521 </span>            :             return __s + __i;<span class="lineNum">     522 </span>            :         return 0;<span class="lineNum">     523 </span>            :       }<span class="lineNum">     524 </span>            : <span class="lineNum">     525 </span>            :       static char_type*<span class="lineNum">     526 </span>            :       move(char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     527 </span>            :       {<span class="lineNum">     528 </span>            :         return (static_cast&lt;char_type*&gt;<span class="lineNum">     529 </span>            :                 (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));<span class="lineNum">     530 </span>            :       }<span class="lineNum">     531 </span>            : <span class="lineNum">     532 </span>            :       static char_type*<span class="lineNum">     533 </span>            :       copy(char_type* __s1, const char_type* __s2, size_t __n)<span class="lineNum">     534 </span>            :       { <span class="lineNum">     535 </span>            :         return (static_cast&lt;char_type*&gt;<span class="lineNum">     536 </span>            :                 (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));<span class="lineNum">     537 </span>            :       }<span class="lineNum">     538 </span>            : <span class="lineNum">     539 </span>            :       static char_type*<span class="lineNum">     540 </span>            :       assign(char_type* __s, size_t __n, char_type __a)<span class="lineNum">     541 </span>            :       {<span class="lineNum">     542 </span>            :         for (size_t __i = 0; __i &lt; __n; ++__i)<span class="lineNum">     543 </span>            :           assign(__s[__i], __a);<span class="lineNum">     544 </span>            :         return __s;<span class="lineNum">     545 </span>            :       }<span class="lineNum">     546 </span>            : <span class="lineNum">     547 </span>            :       static constexpr char_type<span class="lineNum">     548 </span>            :       to_char_type(const int_type&amp; __c) noexcept<span class="lineNum">     549 </span>            :       { return char_type(__c); }<span class="lineNum">     550 </span>            : <span class="lineNum">     551 </span>            :       static constexpr int_type<span class="lineNum">     552 </span>            :       to_int_type(const char_type&amp; __c) noexcept<span class="lineNum">     553 </span>            :       { return int_type(__c); }<span class="lineNum">     554 </span>            : <span class="lineNum">     555 </span>            :       static constexpr bool<span class="lineNum">     556 </span>            :       eq_int_type(const int_type&amp; __c1, const int_type&amp; __c2) noexcept<span class="lineNum">     557 </span>            :       { return __c1 == __c2; }<span class="lineNum">     558 </span>            : <span class="lineNum">     559 </span>            :       static constexpr int_type<span class="lineNum">     560 </span>            :       eof() noexcept<span class="lineNum">     561 </span>            :       { return static_cast&lt;int_type&gt;(-1); }<span class="lineNum">     562 </span>            : <span class="lineNum">     563 </span>            :       static constexpr int_type<span class="lineNum">     564 </span>            :       not_eof(const int_type&amp; __c) noexcept<span class="lineNum">     565 </span>            :       { return eq_int_type(__c, eof()) ? 0 : __c; }<span class="lineNum">     566 </span>            :     };<span class="lineNum">     567 </span>            : <span class="lineNum">     568 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     569 </span>            : } // namespace<span class="lineNum">     570 </span>            : <span class="lineNum">     571 </span>            : #endif <span class="lineNum">     572 </span>            : <span class="lineNum">     573 </span>            : #endif // _CHAR_TRAITS_H</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/char_traits.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/char_traits.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - char_traits.h<span style="font-size: 80%;"> (<a href="char_traits.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="char_traits.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="char_traits.h.gcov.html#256">_ZNSt11char_traitsIcE6lengthEPKc</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/char_traits.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/char_traits.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - char_traits.h<span style="font-size: 80%;"> (<a href="char_traits.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="char_traits.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="char_traits.h.gcov.html#256">_ZNSt11char_traitsIcE6lengthEPKc</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/char_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/basic_ios.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/basic_ios.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - basic_ios.h<span style="font-size: 80%;"> (source / <a href="basic_ios.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Iostreams base classes -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 1997-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /** @file bits/basic_ios.h<span class="lineNum">      26 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      27 </span>            :  *  Do not attempt to use it directly. @headername{ios}<span class="lineNum">      28 </span>            :  */<span class="lineNum">      29 </span>            : <span class="lineNum">      30 </span>            : #ifndef _BASIC_IOS_H<span class="lineNum">      31 </span>            : #define _BASIC_IOS_H 1<span class="lineNum">      32 </span>            : <span class="lineNum">      33 </span>            : #pragma GCC system_header<span class="lineNum">      34 </span>            : <span class="lineNum">      35 </span>            : #include &lt;bits/localefwd.h&gt;<span class="lineNum">      36 </span>            : #include &lt;bits/locale_classes.h&gt;<span class="lineNum">      37 </span>            : #include &lt;bits/locale_facets.h&gt;<span class="lineNum">      38 </span>            : #include &lt;bits/streambuf_iterator.h&gt;<span class="lineNum">      39 </span>            : <span class="lineNum">      40 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      41 </span>            : {<span class="lineNum">      42 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      43 </span>            : <a name="44"><span class="lineNum">      44 </span>            :   template&lt;typename _Facet&gt;</a><span class="lineNum">      45 </span>            :     inline const _Facet&amp;<span class="lineNum">      46 </span><span class="lineNoCov">          0 :     __check_facet(const _Facet* __f)</span><span class="lineNum">      47 </span>            :     {<span class="lineNum">      48 </span><span class="lineNoCov">          0 :       if (!__f)</span><span class="lineNum">      49 </span><span class="lineNoCov">          0 :         __throw_bad_cast();</span><span class="lineNum">      50 </span><span class="lineNoCov">          0 :       return *__f;</span><span class="lineNum">      51 </span>            :     }<span class="lineNum">      52 </span>            : <span class="lineNum">      53 </span>            :   /**<span class="lineNum">      54 </span>            :    *  @brief Template class basic_ios, virtual base class for all<span class="lineNum">      55 </span>            :    *  stream classes. <span class="lineNum">      56 </span>            :    *  @ingroup io<span class="lineNum">      57 </span>            :    *<span class="lineNum">      58 </span>            :    *  @tparam _CharT  Type of character stream.<span class="lineNum">      59 </span>            :    *  @tparam _Traits  Traits for character type, defaults to<span class="lineNum">      60 </span>            :    *                   char_traits&lt;_CharT&gt;.<span class="lineNum">      61 </span>            :    *<span class="lineNum">      62 </span>            :    *  Most of the member functions called dispatched on stream objects<span class="lineNum">      63 </span>            :    *  (e.g., @c std::cout.foo(bar);) are consolidated in this class.<span class="lineNum">      64 </span>            :   */<span class="lineNum">      65 </span>            :   template&lt;typename _CharT, typename _Traits&gt;<span class="lineNum">      66 </span>            :     class basic_ios : public ios_base<span class="lineNum">      67 </span>            :     {<span class="lineNum">      68 </span>            :     public:<span class="lineNum">      69 </span>            :       //@{<span class="lineNum">      70 </span>            :       /**<span class="lineNum">      71 </span>            :        *  These are standard types.  They permit a standardized way of<span class="lineNum">      72 </span>            :        *  referring to names of (or names dependent on) the template<span class="lineNum">      73 </span>            :        *  parameters, which are specific to the implementation.<span class="lineNum">      74 </span>            :       */<span class="lineNum">      75 </span>            :       typedef _CharT                                 char_type;<span class="lineNum">      76 </span>            :       typedef typename _Traits::int_type             int_type;<span class="lineNum">      77 </span>            :       typedef typename _Traits::pos_type             pos_type;<span class="lineNum">      78 </span>            :       typedef typename _Traits::off_type             off_type;<span class="lineNum">      79 </span>            :       typedef _Traits                                traits_type;<span class="lineNum">      80 </span>            :       //@}<span class="lineNum">      81 </span>            : <span class="lineNum">      82 </span>            :       //@{<span class="lineNum">      83 </span>            :       /**<span class="lineNum">      84 </span>            :        *  These are non-standard types.<span class="lineNum">      85 </span>            :       */<span class="lineNum">      86 </span>            :       typedef ctype&lt;_CharT&gt;                          __ctype_type;<span class="lineNum">      87 </span>            :       typedef num_put&lt;_CharT, ostreambuf_iterator&lt;_CharT, _Traits&gt; &gt;<span class="lineNum">      88 </span>            :                                                      __num_put_type;<span class="lineNum">      89 </span>            :       typedef num_get&lt;_CharT, istreambuf_iterator&lt;_CharT, _Traits&gt; &gt;<span class="lineNum">      90 </span>            :                                                      __num_get_type;<span class="lineNum">      91 </span>            :       //@}<span class="lineNum">      92 </span>            : <span class="lineNum">      93 </span>            :       // Data members:<span class="lineNum">      94 </span>            :     protected:<span class="lineNum">      95 </span>            :       basic_ostream&lt;_CharT, _Traits&gt;*                _M_tie;<span class="lineNum">      96 </span>            :       mutable char_type                              _M_fill;<span class="lineNum">      97 </span>            :       mutable bool                                   _M_fill_init;<span class="lineNum">      98 </span>            :       basic_streambuf&lt;_CharT, _Traits&gt;*              _M_streambuf;<span class="lineNum">      99 </span>            : <span class="lineNum">     100 </span>            :       // Cached use_facet&lt;ctype&gt;, which is based on the current locale info.<span class="lineNum">     101 </span>            :       const __ctype_type*                            _M_ctype;<span class="lineNum">     102 </span>            :       // For ostream.<span class="lineNum">     103 </span>            :       const __num_put_type*                          _M_num_put;<span class="lineNum">     104 </span>            :       // For istream.<span class="lineNum">     105 </span>            :       const __num_get_type*                          _M_num_get;<span class="lineNum">     106 </span>            : <span class="lineNum">     107 </span>            :     public:<span class="lineNum">     108 </span>            :       //@{<span class="lineNum">     109 </span>            :       /**<span class="lineNum">     110 </span>            :        *  @brief  The quick-and-easy status check.<span class="lineNum">     111 </span>            :        *<span class="lineNum">     112 </span>            :        *  This allows you to write constructs such as<span class="lineNum">     113 </span>            :        *  &lt;code&gt;if (!a_stream) ...&lt;/code&gt; and &lt;code&gt;while (a_stream) ...&lt;/code&gt;<span class="lineNum">     114 </span>            :       */<span class="lineNum">     115 </span>            :       operator void*() const<span class="lineNum">     116 </span>            :       { return this-&gt;fail() ? 0 : const_cast&lt;basic_ios*&gt;(this); }<span class="lineNum">     117 </span>            : <span class="lineNum">     118 </span>            :       bool<span class="lineNum">     119 </span>            :       operator!() const<span class="lineNum">     120 </span>            :       { return this-&gt;fail(); }<span class="lineNum">     121 </span>            :       //@}<span class="lineNum">     122 </span>            : <span class="lineNum">     123 </span>            :       /**<span class="lineNum">     124 </span>            :        *  @brief  Returns the error state of the stream buffer.<span class="lineNum">     125 </span>            :        *  @return  A bit pattern (well, isn't everything?)<span class="lineNum">     126 </span>            :        *<span class="lineNum">     127 </span>            :        *  See std::ios_base::iostate for the possible bit values.  Most<span class="lineNum">     128 </span>            :        *  users will call one of the interpreting wrappers, e.g., good().<span class="lineNum">     129 </span>            :       */<span class="lineNum">     130 </span>            :       iostate<span class="lineNum">     131 </span>            :       rdstate() const<span class="lineNum">     132 </span>            :       { return _M_streambuf_state; }<span class="lineNum">     133 </span>            : <span class="lineNum">     134 </span>            :       /**<span class="lineNum">     135 </span>            :        *  @brief  [Re]sets the error state.<span class="lineNum">     136 </span>            :        *  @param  __state  The new state flag(s) to set.<span class="lineNum">     137 </span>            :        *<span class="lineNum">     138 </span>            :        *  See std::ios_base::iostate for the possible bit values.  Most<span class="lineNum">     139 </span>            :        *  users will not need to pass an argument.<span class="lineNum">     140 </span>            :       */<span class="lineNum">     141 </span>            :       void<span class="lineNum">     142 </span>            :       clear(iostate __state = goodbit);<span class="lineNum">     143 </span>            : <span class="lineNum">     144 </span>            :       /**<span class="lineNum">     145 </span>            :        *  @brief  Sets additional flags in the error state.<span class="lineNum">     146 </span>            :        *  @param  __state  The additional state flag(s) to set.<span class="lineNum">     147 </span>            :        *<span class="lineNum">     148 </span>            :        *  See std::ios_base::iostate for the possible bit values.<span class="lineNum">     149 </span>            :       */<span class="lineNum">     150 </span>            :       void<span class="lineNum">     151 </span>            :       setstate(iostate __state)<span class="lineNum">     152 </span>            :       { this-&gt;clear(this-&gt;rdstate() | __state); }<span class="lineNum">     153 </span>            : <span class="lineNum">     154 </span>            :       // Flip the internal state on for the proper state bits, then<span class="lineNum">     155 </span>            :       // rethrows the propagated exception if bit also set in<span class="lineNum">     156 </span>            :       // exceptions().<span class="lineNum">     157 </span>            :       void<span class="lineNum">     158 </span>            :       _M_setstate(iostate __state)<span class="lineNum">     159 </span>            :       {<span class="lineNum">     160 </span>            :         // 27.6.1.2.1 Common requirements.<span class="lineNum">     161 </span>            :         // Turn this on without causing an ios::failure to be thrown.<span class="lineNum">     162 </span>            :         _M_streambuf_state |= __state;<span class="lineNum">     163 </span>            :         if (this-&gt;exceptions() &amp; __state)<span class="lineNum">     164 </span>            :           __throw_exception_again;<span class="lineNum">     165 </span>            :       }<span class="lineNum">     166 </span>            : <span class="lineNum">     167 </span>            :       /**<span class="lineNum">     168 </span>            :        *  @brief  Fast error checking.<span class="lineNum">     169 </span>            :        *  @return  True if no error flags are set.<span class="lineNum">     170 </span>            :        *<span class="lineNum">     171 </span>            :        *  A wrapper around rdstate.<span class="lineNum">     172 </span>            :       */<span class="lineNum">     173 </span>            :       bool<span class="lineNum">     174 </span>            :       good() const<span class="lineNum">     175 </span>            :       { return this-&gt;rdstate() == 0; }<span class="lineNum">     176 </span>            : <span class="lineNum">     177 </span>            :       /**<span class="lineNum">     178 </span>            :        *  @brief  Fast error checking.<span class="lineNum">     179 </span>            :        *  @return  True if the eofbit is set.<span class="lineNum">     180 </span>            :        *<span class="lineNum">     181 </span>            :        *  Note that other iostate flags may also be set.<span class="lineNum">     182 </span>            :       */<span class="lineNum">     183 </span>            :       bool<span class="lineNum">     184 </span>            :       eof() const<span class="lineNum">     185 </span>            :       { return (this-&gt;rdstate() &amp; eofbit) != 0; }<span class="lineNum">     186 </span>            : <span class="lineNum">     187 </span>            :       /**<span class="lineNum">     188 </span>            :        *  @brief  Fast error checking.<span class="lineNum">     189 </span>            :        *  @return  True if either the badbit or the failbit is set.<span class="lineNum">     190 </span>            :        *<span class="lineNum">     191 </span>            :        *  Checking the badbit in fail() is historical practice.<span class="lineNum">     192 </span>            :        *  Note that other iostate flags may also be set.<span class="lineNum">     193 </span>            :       */<span class="lineNum">     194 </span>            :       bool<span class="lineNum">     195 </span>            :       fail() const<span class="lineNum">     196 </span>            :       { return (this-&gt;rdstate() &amp; (badbit | failbit)) != 0; }<span class="lineNum">     197 </span>            : <span class="lineNum">     198 </span>            :       /**<span class="lineNum">     199 </span>            :        *  @brief  Fast error checking.<span class="lineNum">     200 </span>            :        *  @return  True if the badbit is set.<span class="lineNum">     201 </span>            :        *<span class="lineNum">     202 </span>            :        *  Note that other iostate flags may also be set.<span class="lineNum">     203 </span>            :       */<span class="lineNum">     204 </span>            :       bool<span class="lineNum">     205 </span>            :       bad() const<span class="lineNum">     206 </span>            :       { return (this-&gt;rdstate() &amp; badbit) != 0; }<span class="lineNum">     207 </span>            : <span class="lineNum">     208 </span>            :       /**<span class="lineNum">     209 </span>            :        *  @brief  Throwing exceptions on errors.<span class="lineNum">     210 </span>            :        *  @return  The current exceptions mask.<span class="lineNum">     211 </span>            :        *<span class="lineNum">     212 </span>            :        *  This changes nothing in the stream.  See the one-argument version<span class="lineNum">     213 </span>            :        *  of exceptions(iostate) for the meaning of the return value.<span class="lineNum">     214 </span>            :       */<span class="lineNum">     215 </span>            :       iostate<span class="lineNum">     216 </span>            :       exceptions() const<span class="lineNum">     217 </span>            :       { return _M_exception; }<span class="lineNum">     218 </span>            : <span class="lineNum">     219 </span>            :       /**<span class="lineNum">     220 </span>            :        *  @brief  Throwing exceptions on errors.<span class="lineNum">     221 </span>            :        *  @param  __except  The new exceptions mask.<span class="lineNum">     222 </span>            :        *<span class="lineNum">     223 </span>            :        *  By default, error flags are set silently.  You can set an<span class="lineNum">     224 </span>            :        *  exceptions mask for each stream; if a bit in the mask becomes set<span class="lineNum">     225 </span>            :        *  in the error flags, then an exception of type<span class="lineNum">     226 </span>            :        *  std::ios_base::failure is thrown.<span class="lineNum">     227 </span>            :        *<span class="lineNum">     228 </span>            :        *  If the error flag is already set when the exceptions mask is<span class="lineNum">     229 </span>            :        *  added, the exception is immediately thrown.  Try running the<span class="lineNum">     230 </span>            :        *  following under GCC 3.1 or later:<span class="lineNum">     231 </span>            :        *  @code<span class="lineNum">     232 </span>            :        *  #include &lt;iostream&gt;<span class="lineNum">     233 </span>            :        *  #include &lt;fstream&gt;<span class="lineNum">     234 </span>            :        *  #include &lt;exception&gt;<span class="lineNum">     235 </span>            :        *<span class="lineNum">     236 </span>            :        *  int main()<span class="lineNum">     237 </span>            :        *  {<span class="lineNum">     238 </span>            :        *      std::set_terminate (__gnu_cxx::__verbose_terminate_handler);<span class="lineNum">     239 </span>            :        *<span class="lineNum">     240 </span>            :        *      std::ifstream f (&quot;/etc/motd&quot;);<span class="lineNum">     241 </span>            :        *<span class="lineNum">     242 </span>            :        *      std::cerr &lt;&lt; &quot;Setting badbit\n&quot;;<span class="lineNum">     243 </span>            :        *      f.setstate (std::ios_base::badbit);<span class="lineNum">     244 </span>            :        *<span class="lineNum">     245 </span>            :        *      std::cerr &lt;&lt; &quot;Setting exception mask\n&quot;;<span class="lineNum">     246 </span>            :        *      f.exceptions (std::ios_base::badbit);<span class="lineNum">     247 </span>            :        *  }<span class="lineNum">     248 </span>            :        *  @endcode<span class="lineNum">     249 </span>            :       */<span class="lineNum">     250 </span>            :       void<span class="lineNum">     251 </span>            :       exceptions(iostate __except)<span class="lineNum">     252 </span>            :       {<span class="lineNum">     253 </span>            :         _M_exception = __except;<span class="lineNum">     254 </span>            :         this-&gt;clear(_M_streambuf_state);<span class="lineNum">     255 </span>            :       }<span class="lineNum">     256 </span>            : <span class="lineNum">     257 </span>            :       // Constructor/destructor:<span class="lineNum">     258 </span>            :       /**<span class="lineNum">     259 </span>            :        *  @brief  Constructor performs initialization.<span class="lineNum">     260 </span>            :        *<span class="lineNum">     261 </span>            :        *  The parameter is passed by derived streams.<span class="lineNum">     262 </span>            :       */<span class="lineNum">     263 </span>            :       explicit<span class="lineNum">     264 </span>            :       basic_ios(basic_streambuf&lt;_CharT, _Traits&gt;* __sb)<span class="lineNum">     265 </span>            :       : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),<span class="lineNum">     266 </span>            :         _M_ctype(0), _M_num_put(0), _M_num_get(0)<span class="lineNum">     267 </span>            :       { this-&gt;init(__sb); }<span class="lineNum">     268 </span>            : <span class="lineNum">     269 </span>            :       /**<span class="lineNum">     270 </span>            :        *  @brief  Empty.<span class="lineNum">     271 </span>            :        *<span class="lineNum">     272 </span>            :        *  The destructor does nothing.  More specifically, it does not<span class="lineNum">     273 </span>            :        *  destroy the streambuf held by rdbuf().<span class="lineNum">     274 </span>            :       */<span class="lineNum">     275 </span>            :       virtual<span class="lineNum">     276 </span>            :       ~basic_ios() { }<span class="lineNum">     277 </span>            : <span class="lineNum">     278 </span>            :       // Members:<span class="lineNum">     279 </span>            :       /**<span class="lineNum">     280 </span>            :        *  @brief  Fetches the current @e tied stream.<span class="lineNum">     281 </span>            :        *  @return  A pointer to the tied stream, or NULL if the stream is<span class="lineNum">     282 </span>            :        *           not tied.<span class="lineNum">     283 </span>            :        *<span class="lineNum">     284 </span>            :        *  A stream may be @e tied (or synchronized) to a second output<span class="lineNum">     285 </span>            :        *  stream.  When this stream performs any I/O, the tied stream is<span class="lineNum">     286 </span>            :        *  first flushed.  For example, @c std::cin is tied to @c std::cout.<span class="lineNum">     287 </span>            :       */<span class="lineNum">     288 </span>            :       basic_ostream&lt;_CharT, _Traits&gt;*<span class="lineNum">     289 </span>            :       tie() const<span class="lineNum">     290 </span>            :       { return _M_tie; }<span class="lineNum">     291 </span>            : <span class="lineNum">     292 </span>            :       /**<span class="lineNum">     293 </span>            :        *  @brief  Ties this stream to an output stream.<span class="lineNum">     294 </span>            :        *  @param  __tiestr  The output stream.<span class="lineNum">     295 </span>            :        *  @return  The previously tied output stream, or NULL if the stream<span class="lineNum">     296 </span>            :        *           was not tied.<span class="lineNum">     297 </span>            :        *<span class="lineNum">     298 </span>            :        *  This sets up a new tie; see tie() for more.<span class="lineNum">     299 </span>            :       */<span class="lineNum">     300 </span>            :       basic_ostream&lt;_CharT, _Traits&gt;*<span class="lineNum">     301 </span>            :       tie(basic_ostream&lt;_CharT, _Traits&gt;* __tiestr)<span class="lineNum">     302 </span>            :       {<span class="lineNum">     303 </span>            :         basic_ostream&lt;_CharT, _Traits&gt;* __old = _M_tie;<span class="lineNum">     304 </span>            :         _M_tie = __tiestr;<span class="lineNum">     305 </span>            :         return __old;<span class="lineNum">     306 </span>            :       }<span class="lineNum">     307 </span>            : <span class="lineNum">     308 </span>            :       /**<span class="lineNum">     309 </span>            :        *  @brief  Accessing the underlying buffer.<span class="lineNum">     310 </span>            :        *  @return  The current stream buffer.<span class="lineNum">     311 </span>            :        *<span class="lineNum">     312 </span>            :        *  This does not change the state of the stream.<span class="lineNum">     313 </span>            :       */<span class="lineNum">     314 </span>            :       basic_streambuf&lt;_CharT, _Traits&gt;*<span class="lineNum">     315 </span>            :       rdbuf() const<span class="lineNum">     316 </span>            :       { return _M_streambuf; }<span class="lineNum">     317 </span>            : <span class="lineNum">     318 </span>            :       /**<span class="lineNum">     319 </span>            :        *  @brief  Changing the underlying buffer.<span class="lineNum">     320 </span>            :        *  @param  __sb  The new stream buffer.<span class="lineNum">     321 </span>            :        *  @return  The previous stream buffer.<span class="lineNum">     322 </span>            :        *<span class="lineNum">     323 </span>            :        *  Associates a new buffer with the current stream, and clears the<span class="lineNum">     324 </span>            :        *  error state.<span class="lineNum">     325 </span>            :        *<span class="lineNum">     326 </span>            :        *  Due to historical accidents which the LWG refuses to correct, the<span class="lineNum">     327 </span>            :        *  I/O library suffers from a design error:  this function is hidden<span class="lineNum">     328 </span>            :        *  in derived classes by overrides of the zero-argument @c rdbuf(),<span class="lineNum">     329 </span>            :        *  which is non-virtual for hysterical raisins.  As a result, you<span class="lineNum">     330 </span>            :        *  must use explicit qualifications to access this function via any<span class="lineNum">     331 </span>            :        *  derived class.  For example:<span class="lineNum">     332 </span>            :        *<span class="lineNum">     333 </span>            :        *  @code<span class="lineNum">     334 </span>            :        *  std::fstream     foo;         // or some other derived type<span class="lineNum">     335 </span>            :        *  std::streambuf*  p = .....;<span class="lineNum">     336 </span>            :        *<span class="lineNum">     337 </span>            :        *  foo.ios::rdbuf(p);            // ios == basic_ios&lt;char&gt;<span class="lineNum">     338 </span>            :        *  @endcode<span class="lineNum">     339 </span>            :       */<span class="lineNum">     340 </span>            :       basic_streambuf&lt;_CharT, _Traits&gt;*<span class="lineNum">     341 </span>            :       rdbuf(basic_streambuf&lt;_CharT, _Traits&gt;* __sb);<span class="lineNum">     342 </span>            : <span class="lineNum">     343 </span>            :       /**<span class="lineNum">     344 </span>            :        *  @brief  Copies fields of __rhs into this.<span class="lineNum">     345 </span>            :        *  @param  __rhs  The source values for the copies.<span class="lineNum">     346 </span>            :        *  @return  Reference to this object.<span class="lineNum">     347 </span>            :        *<span class="lineNum">     348 </span>            :        *  All fields of __rhs are copied into this object except that rdbuf()<span class="lineNum">     349 </span>            :        *  and rdstate() remain unchanged.  All values in the pword and iword<span class="lineNum">     350 </span>            :        *  arrays are copied.  Before copying, each callback is invoked with<span class="lineNum">     351 </span>            :        *  erase_event.  After copying, each (new) callback is invoked with<span class="lineNum">     352 </span>            :        *  copyfmt_event.  The final step is to copy exceptions().<span class="lineNum">     353 </span>            :       */<span class="lineNum">     354 </span>            :       basic_ios&amp;<span class="lineNum">     355 </span>            :       copyfmt(const basic_ios&amp; __rhs);<span class="lineNum">     356 </span>            : <span class="lineNum">     357 </span>            :       /**<span class="lineNum">     358 </span>            :        *  @brief  Retrieves the @a empty character.<span class="lineNum">     359 </span>            :        *  @return  The current fill character.<span class="lineNum">     360 </span>            :        *<span class="lineNum">     361 </span>            :        *  It defaults to a space (' ') in the current locale.<span class="lineNum">     362 </span>            :       */<span class="lineNum">     363 </span>            :       char_type<span class="lineNum">     364 </span>            :       fill() const<span class="lineNum">     365 </span>            :       {<span class="lineNum">     366 </span>            :         if (!_M_fill_init)<span class="lineNum">     367 </span>            :           {<span class="lineNum">     368 </span>            :             _M_fill = this-&gt;widen(' ');<span class="lineNum">     369 </span>            :             _M_fill_init = true;<span class="lineNum">     370 </span>            :           }<span class="lineNum">     371 </span>            :         return _M_fill;<span class="lineNum">     372 </span>            :       }<span class="lineNum">     373 </span>            : <span class="lineNum">     374 </span>            :       /**<span class="lineNum">     375 </span>            :        *  @brief  Sets a new @a empty character.<span class="lineNum">     376 </span>            :        *  @param  __ch  The new character.<span class="lineNum">     377 </span>            :        *  @return  The previous fill character.<span class="lineNum">     378 </span>            :        *<span class="lineNum">     379 </span>            :        *  The fill character is used to fill out space when P+ characters<span class="lineNum">     380 </span>            :        *  have been requested (e.g., via setw), Q characters are actually<span class="lineNum">     381 </span>            :        *  used, and Q&lt;P.  It defaults to a space (' ') in the current locale.<span class="lineNum">     382 </span>            :       */<span class="lineNum">     383 </span>            :       char_type<span class="lineNum">     384 </span>            :       fill(char_type __ch)<span class="lineNum">     385 </span>            :       {<span class="lineNum">     386 </span>            :         char_type __old = this-&gt;fill();<span class="lineNum">     387 </span>            :         _M_fill = __ch;<span class="lineNum">     388 </span>            :         return __old;<span class="lineNum">     389 </span>            :       }<span class="lineNum">     390 </span>            : <span class="lineNum">     391 </span>            :       // Locales:<span class="lineNum">     392 </span>            :       /**<span class="lineNum">     393 </span>            :        *  @brief  Moves to a new locale.<span class="lineNum">     394 </span>            :        *  @param  __loc  The new locale.<span class="lineNum">     395 </span>            :        *  @return  The previous locale.<span class="lineNum">     396 </span>            :        *<span class="lineNum">     397 </span>            :        *  Calls @c ios_base::imbue(loc), and if a stream buffer is associated<span class="lineNum">     398 </span>            :        *  with this stream, calls that buffer's @c pubimbue(loc).<span class="lineNum">     399 </span>            :        *<span class="lineNum">     400 </span>            :        *  Additional l10n notes are at<span class="lineNum">     401 </span>            :        *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html<span class="lineNum">     402 </span>            :       */<span class="lineNum">     403 </span>            :       locale<span class="lineNum">     404 </span>            :       imbue(const locale&amp; __loc);<span class="lineNum">     405 </span>            : <span class="lineNum">     406 </span>            :       /**<span class="lineNum">     407 </span>            :        *  @brief  Squeezes characters.<span class="lineNum">     408 </span>            :        *  @param  __c  The character to narrow.<span class="lineNum">     409 </span>            :        *  @param  __dfault  The character to narrow.<span class="lineNum">     410 </span>            :        *  @return  The narrowed character.<span class="lineNum">     411 </span>            :        *<span class="lineNum">     412 </span>            :        *  Maps a character of @c char_type to a character of @c char,<span class="lineNum">     413 </span>            :        *  if possible.<span class="lineNum">     414 </span>            :        *<span class="lineNum">     415 </span>            :        *  Returns the result of<span class="lineNum">     416 </span>            :        *  @code<span class="lineNum">     417 </span>            :        *    std::use_facet&lt;ctype&lt;char_type&gt; &gt;(getloc()).narrow(c,dfault)<span class="lineNum">     418 </span>            :        *  @endcode<span class="lineNum">     419 </span>            :        *<span class="lineNum">     420 </span>            :        *  Additional l10n notes are at<span class="lineNum">     421 </span>            :        *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html<span class="lineNum">     422 </span>            :       */<span class="lineNum">     423 </span>            :       char<span class="lineNum">     424 </span>            :       narrow(char_type __c, char __dfault) const<span class="lineNum">     425 </span>            :       { return __check_facet(_M_ctype).narrow(__c, __dfault); }<span class="lineNum">     426 </span>            : <span class="lineNum">     427 </span>            :       /**<span class="lineNum">     428 </span>            :        *  @brief  Widens characters.<span class="lineNum">     429 </span>            :        *  @param  __c  The character to widen.<span class="lineNum">     430 </span>            :        *  @return  The widened character.<span class="lineNum">     431 </span>            :        *<span class="lineNum">     432 </span>            :        *  Maps a character of @c char to a character of @c char_type.<span class="lineNum">     433 </span>            :        *<span class="lineNum">     434 </span>            :        *  Returns the result of<span class="lineNum">     435 </span>            :        *  @code<span class="lineNum">     436 </span>            :        *    std::use_facet&lt;ctype&lt;char_type&gt; &gt;(getloc()).widen(c)<span class="lineNum">     437 </span>            :        *  @endcode<span class="lineNum">     438 </span>            :        *<span class="lineNum">     439 </span>            :        *  Additional l10n notes are at<span class="lineNum">     440 </span>            :        *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html<span class="lineNum">     441 </span>            :       */<span class="lineNum">     442 </span>            :       char_type<span class="lineNum">     443 </span>            :       widen(char __c) const<span class="lineNum">     444 </span>            :       { return __check_facet(_M_ctype).widen(__c); }<span class="lineNum">     445 </span>            : <span class="lineNum">     446 </span>            :     protected:<span class="lineNum">     447 </span>            :       // 27.4.5.1  basic_ios constructors<span class="lineNum">     448 </span>            :       /**<span class="lineNum">     449 </span>            :        *  @brief  Empty.<span class="lineNum">     450 </span>            :        *<span class="lineNum">     451 </span>            :        *  The default constructor does nothing and is not normally<span class="lineNum">     452 </span>            :        *  accessible to users.<span class="lineNum">     453 </span>            :       */<span class="lineNum">     454 </span>            :       basic_ios()<span class="lineNum">     455 </span>            :       : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), <span class="lineNum">     456 </span>            :         _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)<span class="lineNum">     457 </span>            :       { }<span class="lineNum">     458 </span>            : <span class="lineNum">     459 </span>            :       /**<span class="lineNum">     460 </span>            :        *  @brief  All setup is performed here.<span class="lineNum">     461 </span>            :        *<span class="lineNum">     462 </span>            :        *  This is called from the public constructor.  It is not virtual and<span class="lineNum">     463 </span>            :        *  cannot be redefined.<span class="lineNum">     464 </span>            :       */<span class="lineNum">     465 </span>            :       void<span class="lineNum">     466 </span>            :       init(basic_streambuf&lt;_CharT, _Traits&gt;* __sb);<span class="lineNum">     467 </span>            : <span class="lineNum">     468 </span>            :       void<span class="lineNum">     469 </span>            :       _M_cache_locale(const locale&amp; __loc);<span class="lineNum">     470 </span>            :     };<span class="lineNum">     471 </span>            : <span class="lineNum">     472 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     473 </span>            : } // namespace<span class="lineNum">     474 </span>            : <span class="lineNum">     475 </span>            : #include &lt;bits/basic_ios.tcc&gt;<span class="lineNum">     476 </span>            : <span class="lineNum">     477 </span>            : #endif /* _BASIC_IOS_H */</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/basic_ios.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - basic_ios.h<span style="font-size: 80%;"> (<a href="basic_ios.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="basic_ios.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="basic_ios.h.gcov.html#44">_ZSt13__check_facetISt5ctypeIcEERKT_PS3_</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/basic_ios.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - basic_ios.h<span style="font-size: 80%;"> (<a href="basic_ios.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryLo">0.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="basic_ios.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="basic_ios.h.gcov.html#44">_ZSt13__check_facetISt5ctypeIcEERKT_PS3_</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/basic_ios.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/alloc_traits.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - alloc_traits.h<span style="font-size: 80%;"> (source / <a href="alloc_traits.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">8</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntryLo">47.1 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">12</td>            <td class="headerCovTableEntryLo">50.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Allocator traits -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2011-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /** @file bits/alloc_traits.h<span class="lineNum">      26 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      27 </span>            :  *  Do not attempt to use it directly. @headername{memory}<span class="lineNum">      28 </span>            :  */<span class="lineNum">      29 </span>            : <span class="lineNum">      30 </span>            : #ifndef _ALLOC_TRAITS_H<span class="lineNum">      31 </span>            : #define _ALLOC_TRAITS_H 1<span class="lineNum">      32 </span>            : <span class="lineNum">      33 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      34 </span>            : <span class="lineNum">      35 </span>            : #include &lt;bits/memoryfwd.h&gt;<span class="lineNum">      36 </span>            : #include &lt;bits/ptr_traits.h&gt;<span class="lineNum">      37 </span>            : #include &lt;ext/numeric_traits.h&gt;<span class="lineNum">      38 </span>            : <span class="lineNum">      39 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      40 </span>            : {<span class="lineNum">      41 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      42 </span>            : <span class="lineNum">      43 </span>            :   template&lt;typename _Alloc, typename _Tp&gt;<span class="lineNum">      44 </span>            :     class __alloctr_rebind_helper<span class="lineNum">      45 </span>            :     {<span class="lineNum">      46 </span>            :       template&lt;typename _Alloc2, typename _Tp2&gt;<span class="lineNum">      47 </span>            :         static constexpr bool<span class="lineNum">      48 </span>            :         _S_chk(typename _Alloc2::template rebind&lt;_Tp2&gt;::other*)<span class="lineNum">      49 </span>            :         { return true; }<span class="lineNum">      50 </span>            : <span class="lineNum">      51 </span>            :       template&lt;typename, typename&gt;<span class="lineNum">      52 </span>            :         static constexpr bool<span class="lineNum">      53 </span>            :         _S_chk(...)<span class="lineNum">      54 </span>            :         { return false; }<span class="lineNum">      55 </span>            : <span class="lineNum">      56 </span>            :     public:<span class="lineNum">      57 </span>            :       static const bool __value = _S_chk&lt;_Alloc, _Tp&gt;(nullptr);<span class="lineNum">      58 </span>            :     };<span class="lineNum">      59 </span>            : <span class="lineNum">      60 </span>            :   template&lt;typename _Alloc, typename _Tp&gt;<span class="lineNum">      61 </span>            :     const bool __alloctr_rebind_helper&lt;_Alloc, _Tp&gt;::__value;<span class="lineNum">      62 </span>            : <span class="lineNum">      63 </span>            :   template&lt;typename _Alloc, typename _Tp,<span class="lineNum">      64 </span>            :            bool = __alloctr_rebind_helper&lt;_Alloc, _Tp&gt;::__value&gt;<span class="lineNum">      65 </span>            :     struct __alloctr_rebind;<span class="lineNum">      66 </span>            : <span class="lineNum">      67 </span>            :   template&lt;typename _Alloc, typename _Tp&gt;<span class="lineNum">      68 </span>            :     struct __alloctr_rebind&lt;_Alloc, _Tp, true&gt;<span class="lineNum">      69 </span>            :     {<span class="lineNum">      70 </span>            :       typedef typename _Alloc::template rebind&lt;_Tp&gt;::other __type;<span class="lineNum">      71 </span>            :     };<span class="lineNum">      72 </span>            : <span class="lineNum">      73 </span>            :   template&lt;template&lt;typename, typename...&gt; class _Alloc, typename _Tp,<span class="lineNum">      74 </span>            :             typename _Up, typename... _Args&gt;<span class="lineNum">      75 </span>            :     struct __alloctr_rebind&lt;_Alloc&lt;_Up, _Args...&gt;, _Tp, false&gt;<span class="lineNum">      76 </span>            :     {<span class="lineNum">      77 </span>            :       typedef _Alloc&lt;_Tp, _Args...&gt; __type;<span class="lineNum">      78 </span>            :     };<span class="lineNum">      79 </span>            : <span class="lineNum">      80 </span>            :   /**<span class="lineNum">      81 </span>            :    * @brief  Uniform interface to all allocator types.<span class="lineNum">      82 </span>            :    * @ingroup allocators<span class="lineNum">      83 </span>            :   */<span class="lineNum">      84 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">      85 </span>            :     struct allocator_traits<span class="lineNum">      86 </span>            :     {<span class="lineNum">      87 </span>            :       /// The allocator type<span class="lineNum">      88 </span>            :       typedef _Alloc allocator_type;<span class="lineNum">      89 </span>            :       /// The allocated type<span class="lineNum">      90 </span>            :       typedef typename _Alloc::value_type value_type;<span class="lineNum">      91 </span>            : <span class="lineNum">      92 </span>            : #define _GLIBCXX_ALLOC_TR_NESTED_TYPE(_NTYPE, _ALT) \<span class="lineNum">      93 </span>            :   private: \<span class="lineNum">      94 </span>            :   template&lt;typename _Tp&gt; \<span class="lineNum">      95 </span>            :     static typename _Tp::_NTYPE _S_##_NTYPE##_helper(_Tp*); \<span class="lineNum">      96 </span>            :   static _ALT _S_##_NTYPE##_helper(...); \<span class="lineNum">      97 </span>            :     typedef decltype(_S_##_NTYPE##_helper((_Alloc*)0)) __##_NTYPE; \<span class="lineNum">      98 </span>            :   public:<span class="lineNum">      99 </span>            : <span class="lineNum">     100 </span>            : _GLIBCXX_ALLOC_TR_NESTED_TYPE(pointer, value_type*)<span class="lineNum">     101 </span>            : <span class="lineNum">     102 </span>            :       /**<span class="lineNum">     103 </span>            :        * @brief   The allocator's pointer type.<span class="lineNum">     104 </span>            :        *<span class="lineNum">     105 </span>            :        * @c Alloc::pointer if that type exists, otherwise @c value_type*<span class="lineNum">     106 </span>            :       */<span class="lineNum">     107 </span>            :       typedef __pointer pointer;<span class="lineNum">     108 </span>            : <span class="lineNum">     109 </span>            : _GLIBCXX_ALLOC_TR_NESTED_TYPE(const_pointer,<span class="lineNum">     110 </span>            :   typename pointer_traits&lt;pointer&gt;::template rebind&lt;const value_type&gt;)<span class="lineNum">     111 </span>            : <span class="lineNum">     112 </span>            :       /**<span class="lineNum">     113 </span>            :        * @brief   The allocator's const pointer type.<span class="lineNum">     114 </span>            :        *<span class="lineNum">     115 </span>            :        * @c Alloc::const_pointer if that type exists, otherwise<span class="lineNum">     116 </span>            :        * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const value_type&gt; &lt;/tt&gt;<span class="lineNum">     117 </span>            :       */<span class="lineNum">     118 </span>            :       typedef __const_pointer const_pointer;<span class="lineNum">     119 </span>            : <span class="lineNum">     120 </span>            : _GLIBCXX_ALLOC_TR_NESTED_TYPE(void_pointer,<span class="lineNum">     121 </span>            :   typename pointer_traits&lt;pointer&gt;::template rebind&lt;void&gt;)<span class="lineNum">     122 </span>            : <span class="lineNum">     123 </span>            :       /**<span class="lineNum">     124 </span>            :        * @brief   The allocator's void pointer type.<span class="lineNum">     125 </span>            :        *<span class="lineNum">     126 </span>            :        * @c Alloc::void_pointer if that type exists, otherwise<span class="lineNum">     127 </span>            :        * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;void&gt; &lt;/tt&gt;<span class="lineNum">     128 </span>            :       */<span class="lineNum">     129 </span>            :       typedef __void_pointer void_pointer;<span class="lineNum">     130 </span>            : <span class="lineNum">     131 </span>            : _GLIBCXX_ALLOC_TR_NESTED_TYPE(const_void_pointer,<span class="lineNum">     132 </span>            :   typename pointer_traits&lt;pointer&gt;::template rebind&lt;const void&gt;)<span class="lineNum">     133 </span>            : <span class="lineNum">     134 </span>            :       /**<span class="lineNum">     135 </span>            :        * @brief   The allocator's const void pointer type.<span class="lineNum">     136 </span>            :        *<span class="lineNum">     137 </span>            :        * @c Alloc::const_void_pointer if that type exists, otherwise<span class="lineNum">     138 </span>            :        * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt; &lt;/tt&gt;<span class="lineNum">     139 </span>            :       */<span class="lineNum">     140 </span>            :       typedef __const_void_pointer const_void_pointer;<span class="lineNum">     141 </span>            : <span class="lineNum">     142 </span>            : _GLIBCXX_ALLOC_TR_NESTED_TYPE(difference_type,<span class="lineNum">     143 </span>            :                               typename pointer_traits&lt;pointer&gt;::difference_type)<span class="lineNum">     144 </span>            : <span class="lineNum">     145 </span>            :       /**<span class="lineNum">     146 </span>            :        * @brief   The allocator's difference type<span class="lineNum">     147 </span>            :        *<span class="lineNum">     148 </span>            :        * @c Alloc::difference_type if that type exists, otherwise<span class="lineNum">     149 </span>            :        * &lt;tt&gt; pointer_traits&lt;pointer&gt;::difference_type &lt;/tt&gt;<span class="lineNum">     150 </span>            :       */<span class="lineNum">     151 </span>            :       typedef __difference_type difference_type;<span class="lineNum">     152 </span>            : <span class="lineNum">     153 </span>            : _GLIBCXX_ALLOC_TR_NESTED_TYPE(size_type,<span class="lineNum">     154 </span>            :                               typename make_unsigned&lt;difference_type&gt;::type)<span class="lineNum">     155 </span>            : <span class="lineNum">     156 </span>            :       /**<span class="lineNum">     157 </span>            :        * @brief   The allocator's size type<span class="lineNum">     158 </span>            :        *<span class="lineNum">     159 </span>            :        * @c Alloc::size_type if that type exists, otherwise<span class="lineNum">     160 </span>            :        * &lt;tt&gt; make_unsigned&lt;difference_type&gt;::type &lt;/tt&gt;<span class="lineNum">     161 </span>            :       */<span class="lineNum">     162 </span>            :       typedef __size_type size_type;<span class="lineNum">     163 </span>            : <span class="lineNum">     164 </span>            : _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_copy_assignment,<span class="lineNum">     165 </span>            :                               false_type)<span class="lineNum">     166 </span>            : <span class="lineNum">     167 </span>            :       /**<span class="lineNum">     168 </span>            :        * @brief   How the allocator is propagated on copy assignment<span class="lineNum">     169 </span>            :        *<span class="lineNum">     170 </span>            :        * @c Alloc::propagate_on_container_copy_assignment if that type exists,<span class="lineNum">     171 </span>            :        * otherwise @c false_type<span class="lineNum">     172 </span>            :       */<span class="lineNum">     173 </span>            :       typedef __propagate_on_container_copy_assignment<span class="lineNum">     174 </span>            :         propagate_on_container_copy_assignment;<span class="lineNum">     175 </span>            : <span class="lineNum">     176 </span>            : _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_move_assignment,<span class="lineNum">     177 </span>            :                               false_type)<span class="lineNum">     178 </span>            : <span class="lineNum">     179 </span>            :       /**<span class="lineNum">     180 </span>            :        * @brief   How the allocator is propagated on move assignment<span class="lineNum">     181 </span>            :        *<span class="lineNum">     182 </span>            :        * @c Alloc::propagate_on_container_move_assignment if that type exists,<span class="lineNum">     183 </span>            :        * otherwise @c false_type<span class="lineNum">     184 </span>            :       */<span class="lineNum">     185 </span>            :       typedef __propagate_on_container_move_assignment<span class="lineNum">     186 </span>            :         propagate_on_container_move_assignment;<span class="lineNum">     187 </span>            : <span class="lineNum">     188 </span>            : _GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,<span class="lineNum">     189 </span>            :                               false_type)<span class="lineNum">     190 </span>            : <span class="lineNum">     191 </span>            :       /**<span class="lineNum">     192 </span>            :        * @brief   How the allocator is propagated on swap<span class="lineNum">     193 </span>            :        *<span class="lineNum">     194 </span>            :        * @c Alloc::propagate_on_container_swap if that type exists,<span class="lineNum">     195 </span>            :        * otherwise @c false_type<span class="lineNum">     196 </span>            :       */<span class="lineNum">     197 </span>            :       typedef __propagate_on_container_swap propagate_on_container_swap;<span class="lineNum">     198 </span>            : <span class="lineNum">     199 </span>            : #undef _GLIBCXX_ALLOC_TR_NESTED_TYPE<span class="lineNum">     200 </span>            : <span class="lineNum">     201 </span>            :       template&lt;typename _Tp&gt;<span class="lineNum">     202 </span>            :         using rebind_alloc = typename __alloctr_rebind&lt;_Alloc, _Tp&gt;::__type;<span class="lineNum">     203 </span>            :       template&lt;typename _Tp&gt;<span class="lineNum">     204 </span>            :         using rebind_traits = allocator_traits&lt;rebind_alloc&lt;_Tp&gt;&gt;;<span class="lineNum">     205 </span>            : <span class="lineNum">     206 </span>            :     private:<span class="lineNum">     207 </span>            :       template&lt;typename _Alloc2&gt;<span class="lineNum">     208 </span>            :         struct __allocate_helper<span class="lineNum">     209 </span>            :         {<span class="lineNum">     210 </span>            :           template&lt;typename _Alloc3,<span class="lineNum">     211 </span>            :             typename = decltype(std::declval&lt;_Alloc3*&gt;()-&gt;allocate(<span class="lineNum">     212 </span>            :                   std::declval&lt;size_type&gt;(),<span class="lineNum">     213 </span>            :                   std::declval&lt;const_void_pointer&gt;()))&gt;<span class="lineNum">     214 </span>            :             static true_type __test(int);<span class="lineNum">     215 </span>            : <span class="lineNum">     216 </span>            :           template&lt;typename&gt;<span class="lineNum">     217 </span>            :             static false_type __test(...);<span class="lineNum">     218 </span>            : <span class="lineNum">     219 </span>            :           typedef decltype(__test&lt;_Alloc&gt;(0)) type;<span class="lineNum">     220 </span>            :           static const bool value = type::value;<span class="lineNum">     221 </span>            :         };<span class="lineNum">     222 </span>            : <span class="lineNum">     223 </span>            :       template&lt;typename _Alloc2&gt;<span class="lineNum">     224 </span>            :         static typename<span class="lineNum">     225 </span>            :         enable_if&lt;__allocate_helper&lt;_Alloc2&gt;::value, pointer&gt;::type<span class="lineNum">     226 </span>            :         _S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer __hint)<span class="lineNum">     227 </span>            :         { return __a.allocate(__n, __hint); }<span class="lineNum">     228 </span>            : <span class="lineNum">     229 </span>            :       template&lt;typename _Alloc2&gt;<span class="lineNum">     230 </span>            :         static typename<span class="lineNum">     231 </span>            :         enable_if&lt;!__allocate_helper&lt;_Alloc2&gt;::value, pointer&gt;::type<span class="lineNum">     232 </span>            :         _S_allocate(_Alloc2&amp; __a, size_type __n, ...)<span class="lineNum">     233 </span>            :         { return __a.allocate(__n); }<span class="lineNum">     234 </span>            : <span class="lineNum">     235 </span>            :       template&lt;typename _Tp, typename... _Args&gt;<span class="lineNum">     236 </span>            :         struct __construct_helper<span class="lineNum">     237 </span>            :         {<span class="lineNum">     238 </span>            :           template&lt;typename _Alloc2,<span class="lineNum">     239 </span>            :             typename = decltype(std::declval&lt;_Alloc2*&gt;()-&gt;construct(<span class="lineNum">     240 </span>            :                   std::declval&lt;_Tp*&gt;(), std::declval&lt;_Args&gt;()...))&gt;<span class="lineNum">     241 </span>            :             static true_type __test(int);<span class="lineNum">     242 </span>            : <span class="lineNum">     243 </span>            :           template&lt;typename&gt;<span class="lineNum">     244 </span>            :             static false_type __test(...);<span class="lineNum">     245 </span>            : <span class="lineNum">     246 </span>            :           typedef decltype(__test&lt;_Alloc&gt;(0)) type;<span class="lineNum">     247 </span>            :           static const bool value = type::value;<span class="lineNum">     248 </span>            :         };<span class="lineNum">     249 </span>            : <span class="lineNum">     250 </span>            :       template&lt;typename _Tp, typename... _Args&gt;<a name="251"><span class="lineNum">     251 </span>            :         static typename</a><span class="lineNum">     252 </span>            :         enable_if&lt;__construct_helper&lt;_Tp, _Args...&gt;::value, void&gt;::type<span class="lineNum">     253 </span><span class="lineCov">        980 :         _S_construct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)</span><span class="lineNum">     254 </span><span class="lineCov">        980 :         { __a.construct(__p, std::forward&lt;_Args&gt;(__args)...); }</span><span class="lineNum">     255 </span>            : <span class="lineNum">     256 </span>            :       template&lt;typename _Tp, typename... _Args&gt;<span class="lineNum">     257 </span>            :         static typename<span class="lineNum">     258 </span>            :         enable_if&lt;__and_&lt;__not_&lt;__construct_helper&lt;_Tp, _Args...&gt;&gt;,<span class="lineNum">     259 </span>            :                          is_constructible&lt;_Tp, _Args...&gt;&gt;::value, void&gt;::type<span class="lineNum">     260 </span>            :         _S_construct(_Alloc&amp;, _Tp* __p, _Args&amp;&amp;... __args)<span class="lineNum">     261 </span>            :         { ::new((void*)__p) _Tp(std::forward&lt;_Args&gt;(__args)...); }<span class="lineNum">     262 </span>            : <span class="lineNum">     263 </span>            :       template&lt;typename _Tp&gt;<span class="lineNum">     264 </span>            :         struct __destroy_helper<span class="lineNum">     265 </span>            :         {<span class="lineNum">     266 </span>            :           template&lt;typename _Alloc2,<span class="lineNum">     267 </span>            :             typename = decltype(std::declval&lt;_Alloc2*&gt;()-&gt;destroy(<span class="lineNum">     268 </span>            :                   std::declval&lt;_Tp*&gt;()))&gt;<span class="lineNum">     269 </span>            :             static true_type __test(int);<span class="lineNum">     270 </span>            : <span class="lineNum">     271 </span>            :           template&lt;typename&gt;<span class="lineNum">     272 </span>            :             static false_type __test(...);<span class="lineNum">     273 </span>            : <span class="lineNum">     274 </span>            :           typedef decltype(__test&lt;_Alloc&gt;(0)) type;<span class="lineNum">     275 </span>            :           static const bool value = type::value;<span class="lineNum">     276 </span>            :         };<span class="lineNum">     277 </span>            : <a name="278"><span class="lineNum">     278 </span>            :       template&lt;typename _Tp&gt;</a><span class="lineNum">     279 </span>            :         static typename enable_if&lt;__destroy_helper&lt;_Tp&gt;::value, void&gt;::type<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         _S_destroy(_Alloc&amp; __a, _Tp* __p)</span><span class="lineNum">     281 </span><span class="lineNoCov">          0 :         { __a.destroy(__p); }</span><span class="lineNum">     282 </span>            : <span class="lineNum">     283 </span>            :       template&lt;typename _Tp&gt;<span class="lineNum">     284 </span>            :         static typename enable_if&lt;!__destroy_helper&lt;_Tp&gt;::value, void&gt;::type<span class="lineNum">     285 </span>            :         _S_destroy(_Alloc&amp;, _Tp* __p)<span class="lineNum">     286 </span>            :         { __p-&gt;~_Tp(); }<span class="lineNum">     287 </span>            : <span class="lineNum">     288 </span>            :       template&lt;typename _Alloc2&gt;<span class="lineNum">     289 </span>            :         struct __maxsize_helper<span class="lineNum">     290 </span>            :         {<span class="lineNum">     291 </span>            :           template&lt;typename _Alloc3,<span class="lineNum">     292 </span>            :             typename = decltype(std::declval&lt;_Alloc3*&gt;()-&gt;max_size())&gt;<span class="lineNum">     293 </span>            :             static true_type __test(int);<span class="lineNum">     294 </span>            : <span class="lineNum">     295 </span>            :           template&lt;typename&gt;<span class="lineNum">     296 </span>            :             static false_type __test(...);<span class="lineNum">     297 </span>            : <span class="lineNum">     298 </span>            :           typedef decltype(__test&lt;_Alloc2&gt;(0)) type;<span class="lineNum">     299 </span>            :           static const bool value = type::value;<span class="lineNum">     300 </span>            :         };<span class="lineNum">     301 </span>            : <span class="lineNum">     302 </span>            :       template&lt;typename _Alloc2&gt;<a name="303"><span class="lineNum">     303 </span>            :         static typename</a><span class="lineNum">     304 </span>            :         enable_if&lt;__maxsize_helper&lt;_Alloc2&gt;::value, size_type&gt;::type<span class="lineNum">     305 </span><span class="lineCov">         92 :         _S_max_size(_Alloc2&amp; __a)</span><span class="lineNum">     306 </span><span class="lineCov">         92 :         { return __a.max_size(); }</span><span class="lineNum">     307 </span>            : <span class="lineNum">     308 </span>            :       template&lt;typename _Alloc2&gt;<span class="lineNum">     309 </span>            :         static typename<span class="lineNum">     310 </span>            :         enable_if&lt;!__maxsize_helper&lt;_Alloc2&gt;::value, size_type&gt;::type<span class="lineNum">     311 </span>            :         _S_max_size(_Alloc2&amp;)<span class="lineNum">     312 </span>            :         { return __gnu_cxx::__numeric_traits&lt;size_type&gt;::__max; }<span class="lineNum">     313 </span>            : <span class="lineNum">     314 </span>            :       template&lt;typename _Alloc2&gt;<span class="lineNum">     315 </span>            :         struct __select_helper<span class="lineNum">     316 </span>            :         {<span class="lineNum">     317 </span>            :           template&lt;typename _Alloc3, typename<span class="lineNum">     318 </span>            :             = decltype(std::declval&lt;_Alloc3*&gt;()<span class="lineNum">     319 </span>            :                 -&gt;select_on_container_copy_construction())&gt;<span class="lineNum">     320 </span>            :             static true_type __test(int);<span class="lineNum">     321 </span>            : <span class="lineNum">     322 </span>            :           template&lt;typename&gt;<span class="lineNum">     323 </span>            :             static false_type __test(...);<span class="lineNum">     324 </span>            : <span class="lineNum">     325 </span>            :           typedef decltype(__test&lt;_Alloc2&gt;(0)) type;<span class="lineNum">     326 </span>            :           static const bool value = type::value;<span class="lineNum">     327 </span>            :         };<span class="lineNum">     328 </span>            :       template&lt;typename _Alloc2&gt;<span class="lineNum">     329 </span>            :         static typename<span class="lineNum">     330 </span>            :         enable_if&lt;__select_helper&lt;_Alloc2&gt;::value, _Alloc2&gt;::type<span class="lineNum">     331 </span>            :         _S_select(_Alloc2&amp; __a)<span class="lineNum">     332 </span>            :         { return __a.select_on_container_copy_construction(); }<span class="lineNum">     333 </span>            : <span class="lineNum">     334 </span>            :       template&lt;typename _Alloc2&gt;<span class="lineNum">     335 </span>            :         static typename<span class="lineNum">     336 </span>            :         enable_if&lt;!__select_helper&lt;_Alloc2&gt;::value, _Alloc2&gt;::type<span class="lineNum">     337 </span>            :         _S_select(_Alloc2&amp; __a)<span class="lineNum">     338 </span>            :         { return __a; }<span class="lineNum">     339 </span>            : <span class="lineNum">     340 </span>            :     public:<span class="lineNum">     341 </span>            : <span class="lineNum">     342 </span>            :       /**<span class="lineNum">     343 </span>            :        *  @brief  Allocate memory.<span class="lineNum">     344 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     345 </span>            :        *  @param  __n  The number of objects to allocate space for.<span class="lineNum">     346 </span>            :        *<span class="lineNum">     347 </span>            :        *  Calls @c a.allocate(n)<span class="lineNum">     348 </span>            :       */<span class="lineNum">     349 </span>            :       static pointer<span class="lineNum">     350 </span>            :       allocate(_Alloc&amp; __a, size_type __n)<span class="lineNum">     351 </span>            :       { return __a.allocate(__n); }<span class="lineNum">     352 </span>            : <span class="lineNum">     353 </span>            :       /**<span class="lineNum">     354 </span>            :        *  @brief  Allocate memory.<span class="lineNum">     355 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     356 </span>            :        *  @param  __n  The number of objects to allocate space for.<span class="lineNum">     357 </span>            :        *  @param  __hint Aid to locality.<span class="lineNum">     358 </span>            :        *  @return Memory of suitable size and alignment for @a n objects<span class="lineNum">     359 </span>            :        *          of type @c value_type<span class="lineNum">     360 </span>            :        *<span class="lineNum">     361 </span>            :        *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt; if that expression is<span class="lineNum">     362 </span>            :        *  well-formed, otherwise returns @c a.allocate(n)<span class="lineNum">     363 </span>            :       */<span class="lineNum">     364 </span>            :       static pointer<span class="lineNum">     365 </span>            :       allocate(_Alloc&amp; __a, size_type __n, const_void_pointer __hint)<span class="lineNum">     366 </span>            :       { return _S_allocate(__a, __n, __hint); }<span class="lineNum">     367 </span>            : <span class="lineNum">     368 </span>            :       /**<span class="lineNum">     369 </span>            :        *  @brief  Deallocate memory.<span class="lineNum">     370 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     371 </span>            :        *  @param  __p  Pointer to the memory to deallocate.<span class="lineNum">     372 </span>            :        *  @param  __n  The number of objects space was allocated for.<span class="lineNum">     373 </span>            :        *<span class="lineNum">     374 </span>            :        *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;<span class="lineNum">     375 </span>            :       */<span class="lineNum">     376 </span>            :       static void deallocate(_Alloc&amp; __a, pointer __p, size_type __n)<span class="lineNum">     377 </span>            :       { __a.deallocate(__p, __n); }<span class="lineNum">     378 </span>            : <span class="lineNum">     379 </span>            :       /**<span class="lineNum">     380 </span>            :        *  @brief  Construct an object of type @a _Tp<span class="lineNum">     381 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     382 </span>            :        *  @param  __p  Pointer to memory of suitable size and alignment for Tp<span class="lineNum">     383 </span>            :        *  @param  __args Constructor arguments.<span class="lineNum">     384 </span>            :        *<span class="lineNum">     385 </span>            :        *  Calls &lt;tt&gt; __a.construct(__p, std::forward&lt;Args&gt;(__args)...) &lt;/tt&gt;<span class="lineNum">     386 </span>            :        *  if that expression is well-formed, otherwise uses placement-new<span class="lineNum">     387 </span>            :        *  to construct an object of type @a _Tp at location @a __p from the<span class="lineNum">     388 </span>            :        *  arguments @a __args...<a name="389"><span class="lineNum">     389 </span>            :       */</a><span class="lineNum">     390 </span>            :       template&lt;typename _Tp, typename... _Args&gt;<span class="lineNum">     391 </span><span class="lineCov">        980 :         static auto construct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)</span><span class="lineNum">     392 </span>            :         -&gt; decltype(_S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...))<span class="lineNum">     393 </span><span class="lineCov">        980 :         { _S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...); }</span><span class="lineNum">     394 </span>            : <span class="lineNum">     395 </span>            :       /**<span class="lineNum">     396 </span>            :        *  @brief  Destroy an object of type @a _Tp<span class="lineNum">     397 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     398 </span>            :        *  @param  __p  Pointer to the object to destroy<span class="lineNum">     399 </span>            :        *<span class="lineNum">     400 </span>            :        *  Calls @c __a.destroy(__p) if that expression is well-formed,<span class="lineNum">     401 </span>            :        *  otherwise calls @c __p-&gt;~_Tp()<a name="402"><span class="lineNum">     402 </span>            :       */</a><span class="lineNum">     403 </span>            :       template &lt;class _Tp&gt;<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         static void destroy(_Alloc&amp; __a, _Tp* __p)</span><span class="lineNum">     405 </span><span class="lineNoCov">          0 :         { _S_destroy(__a, __p); }</span><span class="lineNum">     406 </span>            : <span class="lineNum">     407 </span>            :       /**<span class="lineNum">     408 </span>            :        *  @brief  The maximum supported allocation size<span class="lineNum">     409 </span>            :        *  @param  __a  An allocator.<span class="lineNum">     410 </span>            :        *  @return @c __a.max_size() or @c numeric_limits&lt;size_type&gt;::max()<span class="lineNum">     411 </span>            :        *<span class="lineNum">     412 </span>            :        *  Returns @c __a.max_size() if that expression is well-formed,<a name="413"><span class="lineNum">     413 </span>            :        *  otherwise returns @c numeric_limits&lt;size_type&gt;::max()</a><span class="lineNum">     414 </span>            :       */<span class="lineNum">     415 </span><span class="lineCov">         92 :       static size_type max_size(const _Alloc&amp; __a)</span><span class="lineNum">     416 </span><span class="lineCov">         92 :       { return _S_max_size(__a); }</span><span class="lineNum">     417 </span>            : <span class="lineNum">     418 </span>            :       /**<span class="lineNum">     419 </span>            :        *  @brief  Obtain an allocator to use when copying a container.<span class="lineNum">     420 </span>            :        *  @param  __rhs  An allocator.<span class="lineNum">     421 </span>            :        *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs<span class="lineNum">     422 </span>            :        *<span class="lineNum">     423 </span>            :        *  Returns @c __rhs.select_on_container_copy_construction() if that<span class="lineNum">     424 </span>            :        *  expression is well-formed, otherwise returns @a __rhs<span class="lineNum">     425 </span>            :       */<span class="lineNum">     426 </span>            :       static _Alloc<span class="lineNum">     427 </span>            :       select_on_container_copy_construction(const _Alloc&amp; __rhs)<span class="lineNum">     428 </span>            :       { return _S_select(__rhs); }<span class="lineNum">     429 </span>            :     };<span class="lineNum">     430 </span>            : <span class="lineNum">     431 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     432 </span>            :   template&lt;typename _Alloc2&gt;<span class="lineNum">     433 </span>            :     const bool allocator_traits&lt;_Alloc&gt;::__allocate_helper&lt;_Alloc2&gt;::value;<span class="lineNum">     434 </span>            : <span class="lineNum">     435 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     436 </span>            :   template&lt;typename _Tp, typename... _Args&gt;<span class="lineNum">     437 </span>            :     const bool<span class="lineNum">     438 </span>            :     allocator_traits&lt;_Alloc&gt;::__construct_helper&lt;_Tp, _Args...&gt;::value;<span class="lineNum">     439 </span>            : <span class="lineNum">     440 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     441 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     442 </span>            :     const bool allocator_traits&lt;_Alloc&gt;::__destroy_helper&lt;_Tp&gt;::value;<span class="lineNum">     443 </span>            : <span class="lineNum">     444 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     445 </span>            :   template&lt;typename _Alloc2&gt;<span class="lineNum">     446 </span>            :     const bool allocator_traits&lt;_Alloc&gt;::__maxsize_helper&lt;_Alloc2&gt;::value;<span class="lineNum">     447 </span>            : <span class="lineNum">     448 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     449 </span>            :   template&lt;typename _Alloc2&gt;<span class="lineNum">     450 </span>            :     const bool allocator_traits&lt;_Alloc&gt;::__select_helper&lt;_Alloc2&gt;::value;<span class="lineNum">     451 </span>            : <span class="lineNum">     452 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     453 </span>            :     inline void<span class="lineNum">     454 </span>            :     __do_alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two, true_type)<span class="lineNum">     455 </span>            :     { __one = __two; }<span class="lineNum">     456 </span>            : <span class="lineNum">     457 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     458 </span>            :     inline void<span class="lineNum">     459 </span>            :     __do_alloc_on_copy(_Alloc&amp;, const _Alloc&amp;, false_type)<span class="lineNum">     460 </span>            :     { }<span class="lineNum">     461 </span>            : <span class="lineNum">     462 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     463 </span>            :     inline void __alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two)<span class="lineNum">     464 </span>            :     {<span class="lineNum">     465 </span>            :       typedef allocator_traits&lt;_Alloc&gt; __traits;<span class="lineNum">     466 </span>            :       typedef typename __traits::propagate_on_container_copy_assignment __pocca;<span class="lineNum">     467 </span>            :       __do_alloc_on_copy(__one, __two, __pocca());<span class="lineNum">     468 </span>            :     }<span class="lineNum">     469 </span>            : <span class="lineNum">     470 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     471 </span>            :     inline _Alloc __alloc_on_copy(const _Alloc&amp; __a)<span class="lineNum">     472 </span>            :     {<span class="lineNum">     473 </span>            :       typedef allocator_traits&lt;_Alloc&gt; __traits;<span class="lineNum">     474 </span>            :       return __traits::select_on_container_copy_construction(__a);<span class="lineNum">     475 </span>            :     }<span class="lineNum">     476 </span>            : <span class="lineNum">     477 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     478 </span>            :     inline void __do_alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two, true_type)<span class="lineNum">     479 </span>            :     { __one = std::move(__two); }<span class="lineNum">     480 </span>            : <span class="lineNum">     481 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     482 </span>            :     inline void __do_alloc_on_move(_Alloc&amp;, _Alloc&amp;, false_type)<span class="lineNum">     483 </span>            :     { }<span class="lineNum">     484 </span>            : <span class="lineNum">     485 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     486 </span>            :     inline void __alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two)<span class="lineNum">     487 </span>            :     {<span class="lineNum">     488 </span>            :       typedef allocator_traits&lt;_Alloc&gt; __traits;<span class="lineNum">     489 </span>            :       typedef typename __traits::propagate_on_container_move_assignment __pocma;<span class="lineNum">     490 </span>            :       __do_alloc_on_move(__one, __two, __pocma());<span class="lineNum">     491 </span>            :     }<span class="lineNum">     492 </span>            : <span class="lineNum">     493 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     494 </span>            :     inline void __do_alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two, true_type)<span class="lineNum">     495 </span>            :     {<span class="lineNum">     496 </span>            :       using std::swap;<span class="lineNum">     497 </span>            :       swap(__one, __two);<span class="lineNum">     498 </span>            :     }<a name="499"><span class="lineNum">     499 </span>            : </a><span class="lineNum">     500 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     inline void __do_alloc_on_swap(_Alloc&amp;, _Alloc&amp;, false_type)</span><span class="lineNum">     502 </span><span class="lineNoCov">          0 :     { }</span><a name="503"><span class="lineNum">     503 </span>            : </a><span class="lineNum">     504 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     inline void __alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two)</span><span class="lineNum">     506 </span>            :     {<span class="lineNum">     507 </span>            :       typedef allocator_traits&lt;_Alloc&gt; __traits;<span class="lineNum">     508 </span>            :       typedef typename __traits::propagate_on_container_swap __pocs;<span class="lineNum">     509 </span><span class="lineNoCov">          0 :       __do_alloc_on_swap(__one, __two, __pocs());</span><span class="lineNum">     510 </span><span class="lineNoCov">          0 :     }</span><span class="lineNum">     511 </span>            : <span class="lineNum">     512 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     513 </span>            :     class __is_copy_insertable_impl<span class="lineNum">     514 </span>            :     {<span class="lineNum">     515 </span>            :       typedef allocator_traits&lt;_Alloc&gt; _Traits;<span class="lineNum">     516 </span>            : <span class="lineNum">     517 </span>            :       template&lt;typename _Up, typename<span class="lineNum">     518 </span>            :                = decltype(_Traits::construct(std::declval&lt;_Alloc&amp;&gt;(),<span class="lineNum">     519 </span>            :                                              std::declval&lt;_Up*&gt;(),<span class="lineNum">     520 </span>            :                                              std::declval&lt;const _Up&amp;&gt;()))&gt;<span class="lineNum">     521 </span>            :         static true_type<span class="lineNum">     522 </span>            :         _M_select(int);<span class="lineNum">     523 </span>            : <span class="lineNum">     524 </span>            :       template&lt;typename _Up&gt;<span class="lineNum">     525 </span>            :         static false_type<span class="lineNum">     526 </span>            :         _M_select(...);<span class="lineNum">     527 </span>            : <span class="lineNum">     528 </span>            :     public:<span class="lineNum">     529 </span>            :       typedef decltype(_M_select&lt;typename _Alloc::value_type&gt;(0)) type;<span class="lineNum">     530 </span>            :     };<span class="lineNum">     531 </span>            : <span class="lineNum">     532 </span>            :   // true if _Alloc::value_type is CopyInsertable into containers using _Alloc<span class="lineNum">     533 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     534 </span>            :     struct __is_copy_insertable<span class="lineNum">     535 </span>            :     : __is_copy_insertable_impl&lt;_Alloc&gt;::type<span class="lineNum">     536 </span>            :     { };<span class="lineNum">     537 </span>            : <span class="lineNum">     538 </span>            :   // std::allocator&lt;_Tp&gt; just requires CopyConstructible<span class="lineNum">     539 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     540 </span>            :     struct __is_copy_insertable&lt;allocator&lt;_Tp&gt;&gt;<span class="lineNum">     541 </span>            :     : is_copy_constructible&lt;_Tp&gt;<span class="lineNum">     542 </span>            :     { };<span class="lineNum">     543 </span>            : <span class="lineNum">     544 </span>            :   // Used to allow copy construction of unordered containers<span class="lineNum">     545 </span>            :   template&lt;bool&gt; struct __allow_copy_cons { };<span class="lineNum">     546 </span>            : <span class="lineNum">     547 </span>            :   // Used to delete copy constructor of unordered containers<span class="lineNum">     548 </span>            :   template&lt;&gt;<span class="lineNum">     549 </span>            :     struct __allow_copy_cons&lt;false&gt;<span class="lineNum">     550 </span>            :     {<span class="lineNum">     551 </span>            :       __allow_copy_cons() = default;<span class="lineNum">     552 </span>            :       __allow_copy_cons(const __allow_copy_cons&amp;) = delete;<span class="lineNum">     553 </span>            :       __allow_copy_cons(__allow_copy_cons&amp;&amp;) = default;<span class="lineNum">     554 </span>            :       __allow_copy_cons&amp; operator=(const __allow_copy_cons&amp;) = default;<span class="lineNum">     555 </span>            :       __allow_copy_cons&amp; operator=(__allow_copy_cons&amp;&amp;) = default;<span class="lineNum">     556 </span>            :     };<span class="lineNum">     557 </span>            : <span class="lineNum">     558 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     559 </span>            :     using __check_copy_constructible<span class="lineNum">     560 </span>            :       = __allow_copy_cons&lt;__is_copy_insertable&lt;_Alloc&gt;::value&gt;;<span class="lineNum">     561 </span>            : <span class="lineNum">     562 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     563 </span>            : } // namespace std<span class="lineNum">     564 </span>            : <span class="lineNum">     565 </span>            : #endif<span class="lineNum">     566 </span>            : #endif</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/alloc_traits.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - alloc_traits.h<span style="font-size: 80%;"> (<a href="alloc_traits.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">8</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntryLo">47.1 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">12</td>            <td class="headerCovTableEntryLo">50.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="alloc_traits.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#278">_ZNSt16allocator_traitsISaIdEE10_S_destroyIdEENSt9enable_ifIXsrNS1_16__destroy_helperIT_EE5valueEvE4typeERS0_PS5_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#303">_ZNSt16allocator_traitsISaIdEE11_S_max_sizeIKS0_EENSt9enable_ifIXsrNS1_16__maxsize_helperIT_EE5valueEmE4typeERS6_</a></td>              <td class="coverFnHi">92</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#251">_ZNSt16allocator_traitsISaIdEE12_S_constructIdIRKdEEENSt9enable_ifIXsrNS1_18__construct_helperIT_IDpT0_EEE5valueEvE4typeERS0_PS7_DpOS8_</a></td>              <td class="coverFnHi">588</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#251">_ZNSt16allocator_traitsISaIdEE12_S_constructIdIdEEENSt9enable_ifIXsrNS1_18__construct_helperIT_IDpT0_EEE5valueEvE4typeERS0_PS5_DpOS6_</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#402">_ZNSt16allocator_traitsISaIdEE7destroyIdEEvRS0_PT_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#413">_ZNSt16allocator_traitsISaIdEE8max_sizeERKS0_</a></td>              <td class="coverFnHi">92</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#389">_ZNSt16allocator_traitsISaIdEE9constructIdIRKdEEEDTcl12_S_constructfp_fp0_spcl7forwardIT0_Efp1_EEERS0_PT_DpOS5_</a></td>              <td class="coverFnHi">588</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#389">_ZNSt16allocator_traitsISaIdEE9constructIdIdEEEDTcl12_S_constructfp_fp0_spcl7forwardIT0_Efp1_EEERS0_PT_DpOS3_</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#503">_ZSt15__alloc_on_swapISaIdEEvRT_S2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#503">_ZSt15__alloc_on_swapISaIiEEvRT_S2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#499">_ZSt18__do_alloc_on_swapISaIdEEvRT_S2_St17integral_constantIbLb0EE</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#499">_ZSt18__do_alloc_on_swapISaIiEEvRT_S2_St17integral_constantIbLb0EE</a></td>              <td class="coverFnLo">0</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/alloc_traits.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - alloc_traits.h<span style="font-size: 80%;"> (<a href="alloc_traits.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">8</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntryLo">47.1 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">12</td>            <td class="headerCovTableEntryLo">50.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="alloc_traits.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#278">_ZNSt16allocator_traitsISaIdEE10_S_destroyIdEENSt9enable_ifIXsrNS1_16__destroy_helperIT_EE5valueEvE4typeERS0_PS5_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#402">_ZNSt16allocator_traitsISaIdEE7destroyIdEEvRS0_PT_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#503">_ZSt15__alloc_on_swapISaIdEEvRT_S2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#503">_ZSt15__alloc_on_swapISaIiEEvRT_S2_</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#499">_ZSt18__do_alloc_on_swapISaIdEEvRT_S2_St17integral_constantIbLb0EE</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#499">_ZSt18__do_alloc_on_swapISaIiEEvRT_S2_St17integral_constantIbLb0EE</a></td>              <td class="coverFnLo">0</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#303">_ZNSt16allocator_traitsISaIdEE11_S_max_sizeIKS0_EENSt9enable_ifIXsrNS1_16__maxsize_helperIT_EE5valueEmE4typeERS6_</a></td>              <td class="coverFnHi">92</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#413">_ZNSt16allocator_traitsISaIdEE8max_sizeERKS0_</a></td>              <td class="coverFnHi">92</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#251">_ZNSt16allocator_traitsISaIdEE12_S_constructIdIdEEENSt9enable_ifIXsrNS1_18__construct_helperIT_IDpT0_EEE5valueEvE4typeERS0_PS5_DpOS6_</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#389">_ZNSt16allocator_traitsISaIdEE9constructIdIdEEEDTcl12_S_constructfp_fp0_spcl7forwardIT0_Efp1_EEERS0_PT_DpOS3_</a></td>              <td class="coverFnHi">392</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#251">_ZNSt16allocator_traitsISaIdEE12_S_constructIdIRKdEEENSt9enable_ifIXsrNS1_18__construct_helperIT_IDpT0_EEE5valueEvE4typeERS0_PS7_DpOS8_</a></td>              <td class="coverFnHi">588</td>            </tr>    <tr>              <td class="coverFn"><a href="alloc_traits.h.gcov.html#389">_ZNSt16allocator_traitsISaIdEE9constructIdIRKdEEEDTcl12_S_constructfp_fp0_spcl7forwardIT0_Efp1_EEERS0_PT_DpOS5_</a></td>              <td class="coverFnHi">588</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/alloc_traits.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/allocator.h.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/allocator.h.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/allocator.h</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - allocator.h<span style="font-size: 80%;"> (source / <a href="allocator.h.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Allocators -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2001-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /*<span class="lineNum">      26 </span>            :  * Copyright (c) 1996-1997<span class="lineNum">      27 </span>            :  * Silicon Graphics Computer Systems, Inc.<span class="lineNum">      28 </span>            :  *<span class="lineNum">      29 </span>            :  * Permission to use, copy, modify, distribute and sell this software<span class="lineNum">      30 </span>            :  * and its documentation for any purpose is hereby granted without fee,<span class="lineNum">      31 </span>            :  * provided that the above copyright notice appear in all copies and<span class="lineNum">      32 </span>            :  * that both that copyright notice and this permission notice appear<span class="lineNum">      33 </span>            :  * in supporting documentation.  Silicon Graphics makes no<span class="lineNum">      34 </span>            :  * representations about the suitability of this software for any<span class="lineNum">      35 </span>            :  * purpose.  It is provided &quot;as is&quot; without express or implied warranty.<span class="lineNum">      36 </span>            :  */<span class="lineNum">      37 </span>            : <span class="lineNum">      38 </span>            : /** @file bits/allocator.h<span class="lineNum">      39 </span>            :  *  This is an internal header file, included by other library headers.<span class="lineNum">      40 </span>            :  *  Do not attempt to use it directly. @headername{memory}<span class="lineNum">      41 </span>            :  */<span class="lineNum">      42 </span>            : <span class="lineNum">      43 </span>            : #ifndef _ALLOCATOR_H<span class="lineNum">      44 </span>            : #define _ALLOCATOR_H 1<span class="lineNum">      45 </span>            : <span class="lineNum">      46 </span>            : #include &lt;bits/c++allocator.h&gt; // Define the base class to std::allocator.<span class="lineNum">      47 </span>            : #include &lt;bits/memoryfwd.h&gt;<span class="lineNum">      48 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      49 </span>            : #include &lt;type_traits&gt;<span class="lineNum">      50 </span>            : #endif<span class="lineNum">      51 </span>            : <span class="lineNum">      52 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      53 </span>            : {<span class="lineNum">      54 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      55 </span>            : <span class="lineNum">      56 </span>            :   /**<span class="lineNum">      57 </span>            :    *  @addtogroup allocators<span class="lineNum">      58 </span>            :    *  @{<span class="lineNum">      59 </span>            :    */<span class="lineNum">      60 </span>            : <span class="lineNum">      61 </span>            :   /// allocator&lt;void&gt; specialization.<span class="lineNum">      62 </span>            :   template&lt;&gt;<span class="lineNum">      63 </span>            :     class allocator&lt;void&gt;<span class="lineNum">      64 </span>            :     {<span class="lineNum">      65 </span>            :     public:<span class="lineNum">      66 </span>            :       typedef size_t      size_type;<span class="lineNum">      67 </span>            :       typedef ptrdiff_t   difference_type;<span class="lineNum">      68 </span>            :       typedef void*       pointer;<span class="lineNum">      69 </span>            :       typedef const void* const_pointer;<span class="lineNum">      70 </span>            :       typedef void        value_type;<span class="lineNum">      71 </span>            : <span class="lineNum">      72 </span>            :       template&lt;typename _Tp1&gt;<span class="lineNum">      73 </span>            :         struct rebind<span class="lineNum">      74 </span>            :         { typedef allocator&lt;_Tp1&gt; other; };<span class="lineNum">      75 </span>            : <span class="lineNum">      76 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">      77 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">      78 </span>            :       // 2103. std::allocator propagate_on_container_move_assignment<span class="lineNum">      79 </span>            :       typedef true_type propagate_on_container_move_assignment;<span class="lineNum">      80 </span>            : #endif<span class="lineNum">      81 </span>            :     };<span class="lineNum">      82 </span>            : <span class="lineNum">      83 </span>            :   /**<span class="lineNum">      84 </span>            :    * @brief  The @a standard allocator, as per [20.4].<span class="lineNum">      85 </span>            :    *<span class="lineNum">      86 </span>            :    *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html<span class="lineNum">      87 </span>            :    *  for further details.<span class="lineNum">      88 </span>            :    *<span class="lineNum">      89 </span>            :    *  @tparam  _Tp  Type of allocated object.<span class="lineNum">      90 </span>            :    */<span class="lineNum">      91 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">      92 </span>            :     class allocator: public __allocator_base&lt;_Tp&gt;<span class="lineNum">      93 </span>            :     {<span class="lineNum">      94 </span>            :    public:<span class="lineNum">      95 </span>            :       typedef size_t     size_type;<span class="lineNum">      96 </span>            :       typedef ptrdiff_t  difference_type;<span class="lineNum">      97 </span>            :       typedef _Tp*       pointer;<span class="lineNum">      98 </span>            :       typedef const _Tp* const_pointer;<span class="lineNum">      99 </span>            :       typedef _Tp&amp;       reference;<span class="lineNum">     100 </span>            :       typedef const _Tp&amp; const_reference;<span class="lineNum">     101 </span>            :       typedef _Tp        value_type;<span class="lineNum">     102 </span>            : <span class="lineNum">     103 </span>            :       template&lt;typename _Tp1&gt;<span class="lineNum">     104 </span>            :         struct rebind<span class="lineNum">     105 </span>            :         { typedef allocator&lt;_Tp1&gt; other; };<span class="lineNum">     106 </span>            : <span class="lineNum">     107 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     108 </span>            :       // _GLIBCXX_RESOLVE_LIB_DEFECTS<span class="lineNum">     109 </span>            :       // 2103. std::allocator propagate_on_container_move_assignment<span class="lineNum">     110 </span>            :       typedef true_type propagate_on_container_move_assignment;<a name="111"><span class="lineNum">     111 </span>            : #endif</a><span class="lineNum">     112 </span>            : <a name="113"><span class="lineNum">     113 </span><span class="lineCov">         36 :       allocator() throw() { }</span></a><span class="lineNum">     114 </span>            : <span class="lineNum">     115 </span><span class="lineCov">         36 :       allocator(const allocator&amp; __a) throw()</span><span class="lineNum">     116 </span><span class="lineCov">         36 :       : __allocator_base&lt;_Tp&gt;(__a) { }</span><span class="lineNum">     117 </span>            : <span class="lineNum">     118 </span>            :       template&lt;typename _Tp1&gt;<a name="119"><span class="lineNum">     119 </span>            :         allocator(const allocator&lt;_Tp1&gt;&amp;) throw() { }</a><span class="lineNum">     120 </span>            : <span class="lineNum">     121 </span><span class="lineCov">         72 :       ~allocator() throw() { }</span><span class="lineNum">     122 </span>            : <span class="lineNum">     123 </span>            :       // Inherit everything else.<span class="lineNum">     124 </span>            :     };<span class="lineNum">     125 </span>            : <span class="lineNum">     126 </span>            :   template&lt;typename _T1, typename _T2&gt;<span class="lineNum">     127 </span>            :     inline bool<span class="lineNum">     128 </span>            :     operator==(const allocator&lt;_T1&gt;&amp;, const allocator&lt;_T2&gt;&amp;)<span class="lineNum">     129 </span>            :     { return true; }<span class="lineNum">     130 </span>            : <span class="lineNum">     131 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     132 </span>            :     inline bool<span class="lineNum">     133 </span>            :     operator==(const allocator&lt;_Tp&gt;&amp;, const allocator&lt;_Tp&gt;&amp;)<span class="lineNum">     134 </span>            :     { return true; }<span class="lineNum">     135 </span>            : <span class="lineNum">     136 </span>            :   template&lt;typename _T1, typename _T2&gt;<span class="lineNum">     137 </span>            :     inline bool<span class="lineNum">     138 </span>            :     operator!=(const allocator&lt;_T1&gt;&amp;, const allocator&lt;_T2&gt;&amp;)<span class="lineNum">     139 </span>            :     { return false; }<span class="lineNum">     140 </span>            : <span class="lineNum">     141 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     142 </span>            :     inline bool<span class="lineNum">     143 </span>            :     operator!=(const allocator&lt;_Tp&gt;&amp;, const allocator&lt;_Tp&gt;&amp;)<span class="lineNum">     144 </span>            :     { return false; }<span class="lineNum">     145 </span>            : <span class="lineNum">     146 </span>            :   /// @} group allocator<span class="lineNum">     147 </span>            : <span class="lineNum">     148 </span>            :   // Inhibit implicit instantiations for required instantiations,<span class="lineNum">     149 </span>            :   // which are defined via explicit instantiations elsewhere.<span class="lineNum">     150 </span>            : #if _GLIBCXX_EXTERN_TEMPLATE<span class="lineNum">     151 </span>            :   extern template class allocator&lt;char&gt;;<span class="lineNum">     152 </span>            :   extern template class allocator&lt;wchar_t&gt;;<span class="lineNum">     153 </span>            : #endif<span class="lineNum">     154 </span>            : <span class="lineNum">     155 </span>            :   // Undefine.<span class="lineNum">     156 </span>            : #undef __allocator_base<span class="lineNum">     157 </span>            : <span class="lineNum">     158 </span>            :   // To implement Option 3 of DR 431.<span class="lineNum">     159 </span>            :   template&lt;typename _Alloc, bool = __is_empty(_Alloc)&gt;<span class="lineNum">     160 </span>            :     struct __alloc_swap<span class="lineNum">     161 </span>            :     { static void _S_do_it(_Alloc&amp;, _Alloc&amp;) { } };<span class="lineNum">     162 </span>            : <span class="lineNum">     163 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     164 </span>            :     struct __alloc_swap&lt;_Alloc, false&gt;<span class="lineNum">     165 </span>            :     {<span class="lineNum">     166 </span>            :       static void<span class="lineNum">     167 </span>            :       _S_do_it(_Alloc&amp; __one, _Alloc&amp; __two)<span class="lineNum">     168 </span>            :       {<span class="lineNum">     169 </span>            :         // Precondition: swappable allocators.<span class="lineNum">     170 </span>            :         if (__one != __two)<span class="lineNum">     171 </span>            :           swap(__one, __two);<span class="lineNum">     172 </span>            :       }<span class="lineNum">     173 </span>            :     };<span class="lineNum">     174 </span>            : <span class="lineNum">     175 </span>            :   // Optimize for stateless allocators.<span class="lineNum">     176 </span>            :   template&lt;typename _Alloc, bool = __is_empty(_Alloc)&gt;<span class="lineNum">     177 </span>            :     struct __alloc_neq<span class="lineNum">     178 </span>            :     {<span class="lineNum">     179 </span>            :       static bool<span class="lineNum">     180 </span>            :       _S_do_it(const _Alloc&amp;, const _Alloc&amp;)<span class="lineNum">     181 </span>            :       { return false; }<span class="lineNum">     182 </span>            :     };<span class="lineNum">     183 </span>            : <span class="lineNum">     184 </span>            :   template&lt;typename _Alloc&gt;<span class="lineNum">     185 </span>            :     struct __alloc_neq&lt;_Alloc, false&gt;<span class="lineNum">     186 </span>            :     {<span class="lineNum">     187 </span>            :       static bool<span class="lineNum">     188 </span>            :       _S_do_it(const _Alloc&amp; __one, const _Alloc&amp; __two)<span class="lineNum">     189 </span>            :       { return __one != __two; }<span class="lineNum">     190 </span>            :     };<span class="lineNum">     191 </span>            : <span class="lineNum">     192 </span>            : #if __cplusplus &gt;= 201103L<span class="lineNum">     193 </span>            :   template&lt;typename _Tp, bool<span class="lineNum">     194 </span>            :     = __or_&lt;is_copy_constructible&lt;typename _Tp::value_type&gt;,<span class="lineNum">     195 </span>            :             is_nothrow_move_constructible&lt;typename _Tp::value_type&gt;&gt;::value&gt;<span class="lineNum">     196 </span>            :     struct __shrink_to_fit_aux<span class="lineNum">     197 </span>            :     { static bool _S_do_it(_Tp&amp;) { return false; } };<span class="lineNum">     198 </span>            : <span class="lineNum">     199 </span>            :   template&lt;typename _Tp&gt;<span class="lineNum">     200 </span>            :     struct __shrink_to_fit_aux&lt;_Tp, true&gt;<span class="lineNum">     201 </span>            :     {<span class="lineNum">     202 </span>            :       static bool<span class="lineNum">     203 </span>            :       _S_do_it(_Tp&amp; __c)<span class="lineNum">     204 </span>            :       {<span class="lineNum">     205 </span>            :         __try<span class="lineNum">     206 </span>            :           {<span class="lineNum">     207 </span>            :             _Tp(__make_move_if_noexcept_iterator(__c.begin()),<span class="lineNum">     208 </span>            :                 __make_move_if_noexcept_iterator(__c.end()),<span class="lineNum">     209 </span>            :                 __c.get_allocator()).swap(__c);<span class="lineNum">     210 </span>            :             return true;<span class="lineNum">     211 </span>            :           }<span class="lineNum">     212 </span>            :         __catch(...)<span class="lineNum">     213 </span>            :           { return false; }<span class="lineNum">     214 </span>            :       }<span class="lineNum">     215 </span>            :     };<span class="lineNum">     216 </span>            : #endif<span class="lineNum">     217 </span>            : <span class="lineNum">     218 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     219 </span>            : } // namespace std<span class="lineNum">     220 </span>            : <span class="lineNum">     221 </span>            : #endif</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.gcov/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/allocator.h.func/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/allocator.h.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/allocator.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - allocator.h<span style="font-size: 80%;"> (<a href="allocator.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func/../glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="allocator.h.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func/../updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#113">_ZNSaIdEC2ERKS_</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#111">_ZNSaIdEC2Ev</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#119">_ZNSaIdED2Ev</a></td>              <td class="coverFnHi">34</td>            </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#113">_ZNSaIiEC2ERKS_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#111">_ZNSaIiEC2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#119">_ZNSaIiED2Ev</a></td>              <td class="coverFnHi">2</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/bits/allocator.h.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/bits/allocator.h.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/bits/allocator.h - functions</title>  <link rel="stylesheet" type="text/css" href="../../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">4.8.2/bits</a> - allocator.h<span style="font-size: 80%;"> (<a href="allocator.h.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntry">4</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntry">6</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="allocator.h.func.html"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func-sort-c/../updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func-sort-c/../glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#113">_ZNSaIiEC2ERKS_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#111">_ZNSaIiEC2Ev</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#119">_ZNSaIiED2Ev</a></td>              <td class="coverFnHi">2</td>            </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#113">_ZNSaIdEC2ERKS_</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#111">_ZNSaIdEC2Ev</a></td>              <td class="coverFnHi">17</td>            </tr>    <tr>              <td class="coverFn"><a href="allocator.h.gcov.html#119">_ZNSaIdED2Ev</a></td>              <td class="coverFnHi">34</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/bits/allocator.h.func-sort-c/../glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/new.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/new.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/new</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/new.gcov/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">4.8.2</a> - new<span style="font-size: 80%;"> (source / <a href="new.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/new.gcov/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/new.gcov/glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // The -*- C++ -*- dynamic memory management header.</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 1994-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : <span class="lineNum">       5 </span>            : // This file is part of GCC.<span class="lineNum">       6 </span>            : //<span class="lineNum">       7 </span>            : // GCC is free software; you can redistribute it and/or modify<span class="lineNum">       8 </span>            : // it under the terms of the GNU General Public License as published by<span class="lineNum">       9 </span>            : // the Free Software Foundation; either version 3, or (at your option)<span class="lineNum">      10 </span>            : // any later version.<span class="lineNum">      11 </span>            : // <span class="lineNum">      12 </span>            : // GCC is distributed in the hope that it will be useful,<span class="lineNum">      13 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      14 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      15 </span>            : // GNU General Public License for more details.<span class="lineNum">      16 </span>            : // <span class="lineNum">      17 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      18 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      19 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      20 </span>            : <span class="lineNum">      21 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      22 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      23 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      24 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      25 </span>            : <span class="lineNum">      26 </span>            : /** @file new<span class="lineNum">      27 </span>            :  *  This is a Standard C++ Library header.<span class="lineNum">      28 </span>            :  *<span class="lineNum">      29 </span>            :  *  The header @c new defines several functions to manage dynamic memory and<span class="lineNum">      30 </span>            :  *  handling memory allocation errors; see<span class="lineNum">      31 </span>            :  *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.<span class="lineNum">      32 </span>            :  */<span class="lineNum">      33 </span>            : <span class="lineNum">      34 </span>            : #ifndef _NEW<span class="lineNum">      35 </span>            : #define _NEW<span class="lineNum">      36 </span>            : <span class="lineNum">      37 </span>            : #pragma GCC system_header<span class="lineNum">      38 </span>            : <span class="lineNum">      39 </span>            : #include &lt;bits/c++config.h&gt;<span class="lineNum">      40 </span>            : #include &lt;exception&gt;<span class="lineNum">      41 </span>            : <span class="lineNum">      42 </span>            : #pragma GCC visibility push(default)<span class="lineNum">      43 </span>            : <span class="lineNum">      44 </span>            : extern &quot;C++&quot; {<span class="lineNum">      45 </span>            : <span class="lineNum">      46 </span>            : namespace std <span class="lineNum">      47 </span>            : {<span class="lineNum">      48 </span>            :   /**<span class="lineNum">      49 </span>            :    *  @brief  Exception possibly thrown by @c new.<span class="lineNum">      50 </span>            :    *  @ingroup exceptions<span class="lineNum">      51 </span>            :    *<span class="lineNum">      52 </span>            :    *  @c bad_alloc (or classes derived from it) is used to report allocation<span class="lineNum">      53 </span>            :    *  errors from the throwing forms of @c new.  */<span class="lineNum">      54 </span>            :   class bad_alloc : public exception <span class="lineNum">      55 </span>            :   {<span class="lineNum">      56 </span>            :   public:<span class="lineNum">      57 </span>            :     bad_alloc() throw() { }<span class="lineNum">      58 </span>            : <span class="lineNum">      59 </span>            :     // This declaration is not useless:<span class="lineNum">      60 </span>            :     // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118<span class="lineNum">      61 </span>            :     virtual ~bad_alloc() throw();<span class="lineNum">      62 </span>            : <span class="lineNum">      63 </span>            :     // See comment in eh_exception.cc.<span class="lineNum">      64 </span>            :     virtual const char* what() const throw();<span class="lineNum">      65 </span>            :   };<span class="lineNum">      66 </span>            : <span class="lineNum">      67 </span>            :   struct nothrow_t { };<span class="lineNum">      68 </span>            : <span class="lineNum">      69 </span>            :   extern const nothrow_t nothrow;<span class="lineNum">      70 </span>            : <span class="lineNum">      71 </span>            :   /** If you write your own error handler to be called by @c new, it must<span class="lineNum">      72 </span>            :    *  be of this type.  */<span class="lineNum">      73 </span>            :   typedef void (*new_handler)();<span class="lineNum">      74 </span>            : <span class="lineNum">      75 </span>            :   /// Takes a replacement handler as the argument, returns the<span class="lineNum">      76 </span>            :   /// previous handler.<span class="lineNum">      77 </span>            :   new_handler set_new_handler(new_handler) throw();<span class="lineNum">      78 </span>            : } // namespace std<span class="lineNum">      79 </span>            : <span class="lineNum">      80 </span>            : //@{<span class="lineNum">      81 </span>            : /** These are replaceable signatures:<span class="lineNum">      82 </span>            :  *  - normal single new and delete (no arguments, throw @c bad_alloc on error)<span class="lineNum">      83 </span>            :  *  - normal array new and delete (same)<span class="lineNum">      84 </span>            :  *  - @c nothrow single new and delete (take a @c nothrow argument, return<span class="lineNum">      85 </span>            :  *    @c NULL on error)<span class="lineNum">      86 </span>            :  *  - @c nothrow array new and delete (same)<span class="lineNum">      87 </span>            :  *<span class="lineNum">      88 </span>            :  *  Placement new and delete signatures (take a memory address argument,<span class="lineNum">      89 </span>            :  *  does nothing) may not be replaced by a user's program.<span class="lineNum">      90 </span>            : */<span class="lineNum">      91 </span>            : void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)<span class="lineNum">      92 </span>            :   __attribute__((__externally_visible__));<span class="lineNum">      93 </span>            : void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)<span class="lineNum">      94 </span>            :   __attribute__((__externally_visible__));<span class="lineNum">      95 </span>            : void operator delete(void*) _GLIBCXX_USE_NOEXCEPT<span class="lineNum">      96 </span>            :   __attribute__((__externally_visible__));<span class="lineNum">      97 </span>            : void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT<span class="lineNum">      98 </span>            :   __attribute__((__externally_visible__));<span class="lineNum">      99 </span>            : void* operator new(std::size_t, const std::nothrow_t&amp;) _GLIBCXX_USE_NOEXCEPT<span class="lineNum">     100 </span>            :   __attribute__((__externally_visible__));<span class="lineNum">     101 </span>            : void* operator new[](std::size_t, const std::nothrow_t&amp;) _GLIBCXX_USE_NOEXCEPT<span class="lineNum">     102 </span>            :   __attribute__((__externally_visible__));<span class="lineNum">     103 </span>            : void operator delete(void*, const std::nothrow_t&amp;) _GLIBCXX_USE_NOEXCEPT<span class="lineNum">     104 </span>            :   __attribute__((__externally_visible__));<span class="lineNum">     105 </span>            : void operator delete[](void*, const std::nothrow_t&amp;) _GLIBCXX_USE_NOEXCEPT<span class="lineNum">     106 </span>            :   __attribute__((__externally_visible__));<a name="107"><span class="lineNum">     107 </span>            : </a><span class="lineNum">     108 </span>            : // Default placement versions of operator new.<span class="lineNum">     109 </span><span class="lineCov">       1960 : inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT</span><span class="lineNum">     110 </span><span class="lineCov">       1960 : { return __p; }</span><span class="lineNum">     111 </span>            : inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT<span class="lineNum">     112 </span>            : { return __p; }<span class="lineNum">     113 </span>            : <span class="lineNum">     114 </span>            : // Default placement versions of operator delete.<span class="lineNum">     115 </span>            : inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }<span class="lineNum">     116 </span>            : inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }<span class="lineNum">     117 </span>            : //@}<span class="lineNum">     118 </span>            : } // extern &quot;C++&quot;<span class="lineNum">     119 </span>            : <span class="lineNum">     120 </span>            : #pragma GCC visibility pop<span class="lineNum">     121 </span>            : <span class="lineNum">     122 </span>            : #endif</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/new.gcov/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/new.func/"/>
    <url>/2022/05/08/tool004/4.8.2/new.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/new - functions</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/new.func/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">4.8.2</a> - new<span style="font-size: 80%;"> (<a href="new.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/new.func/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/new.func/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/new.func/glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="new.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/new.func/updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="new.gcov.html#107">_ZnwmPv</a></td>              <td class="coverFnHi">980</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/new.func/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/new.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/new.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/new - functions</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/new.func-sort-c/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">4.8.2</a> - new<span style="font-size: 80%;"> (<a href="new.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntry">2</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/new.func-sort-c/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/new.func-sort-c/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="new.func.html"><img src="/2022/05/08/tool004/4.8.2/new.func-sort-c/updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/new.func-sort-c/glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="new.gcov.html#107">_ZnwmPv</a></td>              <td class="coverFnHi">980</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/new.func-sort-c/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/iostream.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/iostream.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/iostream</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/iostream.gcov/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">4.8.2</a> - iostream<span style="font-size: 80%;"> (source / <a href="iostream.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntryHi">-</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/iostream.gcov/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/iostream.gcov/glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // Standard iostream objects -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 1997-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /** @file include/iostream<span class="lineNum">      26 </span>            :  *  This is a Standard C++ Library header.<span class="lineNum">      27 </span>            :  */<span class="lineNum">      28 </span>            : <span class="lineNum">      29 </span>            : //<span class="lineNum">      30 </span>            : // ISO C++ 14882: 27.3  Standard iostream objects<span class="lineNum">      31 </span>            : //<span class="lineNum">      32 </span>            : <span class="lineNum">      33 </span>            : #ifndef _GLIBCXX_IOSTREAM<span class="lineNum">      34 </span>            : #define _GLIBCXX_IOSTREAM 1<span class="lineNum">      35 </span>            : <span class="lineNum">      36 </span>            : #pragma GCC system_header<span class="lineNum">      37 </span>            : <span class="lineNum">      38 </span>            : #include &lt;bits/c++config.h&gt;<span class="lineNum">      39 </span>            : #include &lt;ostream&gt;<span class="lineNum">      40 </span>            : #include &lt;istream&gt;<span class="lineNum">      41 </span>            : <span class="lineNum">      42 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      43 </span>            : {<span class="lineNum">      44 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      45 </span>            : <span class="lineNum">      46 </span>            :   /**<span class="lineNum">      47 </span>            :    *  @name Standard Stream Objects<span class="lineNum">      48 </span>            :    *<span class="lineNum">      49 </span>            :    *  The &amp;lt;iostream&amp;gt; header declares the eight &lt;em&gt;standard stream<span class="lineNum">      50 </span>            :    *  objects&lt;/em&gt;.  For other declarations, see<span class="lineNum">      51 </span>            :    *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/io.html<span class="lineNum">      52 </span>            :    *  and the @link iosfwd I/O forward declarations @endlink<span class="lineNum">      53 </span>            :    *<span class="lineNum">      54 </span>            :    *  They are required by default to cooperate with the global C<span class="lineNum">      55 </span>            :    *  library's @c FILE streams, and to be available during program<span class="lineNum">      56 </span>            :    *  startup and termination. For more information, see the section of the<span class="lineNum">      57 </span>            :    *  manual linked to above.<span class="lineNum">      58 </span>            :   */<span class="lineNum">      59 </span>            :   //@{<span class="lineNum">      60 </span>            :   extern istream cin;           /// Linked to standard input<span class="lineNum">      61 </span>            :   extern ostream cout;          /// Linked to standard output<span class="lineNum">      62 </span>            :   extern ostream cerr;          /// Linked to standard error (unbuffered)<span class="lineNum">      63 </span>            :   extern ostream clog;          /// Linked to standard error (buffered)<span class="lineNum">      64 </span>            : <span class="lineNum">      65 </span>            : #ifdef _GLIBCXX_USE_WCHAR_T<span class="lineNum">      66 </span>            :   extern wistream wcin;         /// Linked to standard input<span class="lineNum">      67 </span>            :   extern wostream wcout;        /// Linked to standard output<span class="lineNum">      68 </span>            :   extern wostream wcerr;        /// Linked to standard error (unbuffered)<span class="lineNum">      69 </span>            :   extern wostream wclog;        /// Linked to standard error (buffered)<span class="lineNum">      70 </span>            : #endif<span class="lineNum">      71 </span>            :   //@}<span class="lineNum">      72 </span>            : <span class="lineNum">      73 </span>            :   // For construction of filebuffers for cout, cin, cerr, clog et. al.<span class="lineNum">      74 </span><span class="lineCov">          2 :   static ios_base::Init __ioinit;</span><span class="lineNum">      75 </span>            : <span class="lineNum">      76 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">      77 </span>            : } // namespace<span class="lineNum">      78 </span>            : <span class="lineNum">      79 </span>            : #endif /* _GLIBCXX_IOSTREAM */</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/iostream.gcov/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/iostream.func/"/>
    <url>/2022/05/08/tool004/4.8.2/iostream.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/iostream - functions</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/iostream.func/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">4.8.2</a> - iostream<span style="font-size: 80%;"> (<a href="iostream.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntryHi">-</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/iostream.func/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/iostream.func/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/iostream.func/glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="iostream.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/iostream.func/updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/iostream.func/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/iostream.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/iostream.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/iostream - functions</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/iostream.func-sort-c/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">4.8.2</a> - iostream<span style="font-size: 80%;"> (<a href="iostream.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntry">1</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntry">0</td>            <td class="headerCovTableEntryHi">-</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/iostream.func-sort-c/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/iostream.func-sort-c/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="iostream.func.html"><img src="/2022/05/08/tool004/4.8.2/iostream.func-sort-c/updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/iostream.func-sort-c/glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/iostream.func-sort-c/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/index/"/>
    <url>/2022/05/08/tool004/4.8.2/index/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/index/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - 4.8.2</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">10</td>            <td class="headerCovTableEntry">10</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/index/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/index/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/index/glass.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><a href="index-sort-l.html"><img src="/2022/05/08/tool004/4.8.2/index/updown.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></a></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><a href="index-sort-f.html"><img src="/2022/05/08/tool004/4.8.2/index/updown.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></a></span></td>    </tr>    <tr>      <td class="coverFile"><a href="chrono.gcov.html">chrono</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/index/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">14 / 14</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">9 / 9</td>    </tr>    <tr>      <td class="coverFile"><a href="iostream.gcov.html">iostream</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/index/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">1 / 1</td>      <td class="coverPerHi">-</td>      <td class="coverNumHi">0 / 0</td>    </tr>    <tr>      <td class="coverFile"><a href="new.gcov.html">new</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/index/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">2 / 2</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">1 / 1</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/index/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/index-sort-l/"/>
    <url>/2022/05/08/tool004/4.8.2/index-sort-l/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/index-sort-l/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - 4.8.2</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">10</td>            <td class="headerCovTableEntry">10</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/index-sort-l/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/index-sort-l/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><a href="index.html"><img src="/2022/05/08/tool004/4.8.2/index-sort-l/updown.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></a></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/index-sort-l/glass.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><a href="index-sort-f.html"><img src="/2022/05/08/tool004/4.8.2/index-sort-l/updown.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></a></span></td>    </tr>    <tr>      <td class="coverFile"><a href="iostream.gcov.html">iostream</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/index-sort-l/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">1 / 1</td>      <td class="coverPerHi">-</td>      <td class="coverNumHi">0 / 0</td>    </tr>    <tr>      <td class="coverFile"><a href="new.gcov.html">new</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/index-sort-l/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">2 / 2</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">1 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="chrono.gcov.html">chrono</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/index-sort-l/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">14 / 14</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">9 / 9</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/index-sort-l/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/index-sort-f/"/>
    <url>/2022/05/08/tool004/4.8.2/index-sort-f/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/index-sort-f/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - 4.8.2</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntry">17</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">10</td>            <td class="headerCovTableEntry">10</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/index-sort-f/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/index-sort-f/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Filename <span class="tableHeadSort"><a href="index.html"><img src="/2022/05/08/tool004/4.8.2/index-sort-f/updown.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></a></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><a href="index-sort-l.html"><img src="/2022/05/08/tool004/4.8.2/index-sort-f/updown.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></a></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/index-sort-f/glass.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></span></td>    </tr>    <tr>      <td class="coverFile"><a href="iostream.gcov.html">iostream</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/index-sort-f/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">1 / 1</td>      <td class="coverPerHi">-</td>      <td class="coverNumHi">0 / 0</td>    </tr>    <tr>      <td class="coverFile"><a href="new.gcov.html">new</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/index-sort-f/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">2 / 2</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">1 / 1</td>    </tr>    <tr>      <td class="coverFile"><a href="chrono.gcov.html">chrono</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/4.8.2/index-sort-f/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">14 / 14</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">9 / 9</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/index-sort-f/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/chrono.gcov/"/>
    <url>/2022/05/08/tool004/4.8.2/chrono.gcov/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/chrono</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/chrono.gcov/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">4.8.2</a> - chrono<span style="font-size: 80%;"> (source / <a href="chrono.func-sort-c.html">functions</a>)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/chrono.gcov/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/chrono.gcov/glass.png" width="3" height="3" alt></td></tr>  </table>  <table cellpadding="0" cellspacing="0" border="0">    <tr>      <td><br></td>    </tr>    <tr>      <td><pre class="sourceHeading">          Line data    Source code</pre><pre class="source"><a name="1"><span class="lineNum">       1 </span>            : // &lt;chrono&gt; -*- C++ -*-</a><span class="lineNum">       2 </span>            : <span class="lineNum">       3 </span>            : // Copyright (C) 2008-2013 Free Software Foundation, Inc.<span class="lineNum">       4 </span>            : //<span class="lineNum">       5 </span>            : // This file is part of the GNU ISO C++ Library.  This library is free<span class="lineNum">       6 </span>            : // software; you can redistribute it and/or modify it under the<span class="lineNum">       7 </span>            : // terms of the GNU General Public License as published by the<span class="lineNum">       8 </span>            : // Free Software Foundation; either version 3, or (at your option)<span class="lineNum">       9 </span>            : // any later version.<span class="lineNum">      10 </span>            : <span class="lineNum">      11 </span>            : // This library is distributed in the hope that it will be useful,<span class="lineNum">      12 </span>            : // but WITHOUT ANY WARRANTY; without even the implied warranty of<span class="lineNum">      13 </span>            : // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<span class="lineNum">      14 </span>            : // GNU General Public License for more details.<span class="lineNum">      15 </span>            : <span class="lineNum">      16 </span>            : // Under Section 7 of GPL version 3, you are granted additional<span class="lineNum">      17 </span>            : // permissions described in the GCC Runtime Library Exception, version<span class="lineNum">      18 </span>            : // 3.1, as published by the Free Software Foundation.<span class="lineNum">      19 </span>            : <span class="lineNum">      20 </span>            : // You should have received a copy of the GNU General Public License and<span class="lineNum">      21 </span>            : // a copy of the GCC Runtime Library Exception along with this program;<span class="lineNum">      22 </span>            : // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<span class="lineNum">      23 </span>            : // &lt;http://www.gnu.org/licenses/&gt;.<span class="lineNum">      24 </span>            : <span class="lineNum">      25 </span>            : /** @file include/chrono<span class="lineNum">      26 </span>            :  *  This is a Standard C++ Library header.<span class="lineNum">      27 </span>            :  */<span class="lineNum">      28 </span>            : <span class="lineNum">      29 </span>            : #ifndef _GLIBCXX_CHRONO<span class="lineNum">      30 </span>            : #define _GLIBCXX_CHRONO 1<span class="lineNum">      31 </span>            : <span class="lineNum">      32 </span>            : #pragma GCC system_header<span class="lineNum">      33 </span>            : <span class="lineNum">      34 </span>            : #if __cplusplus &lt; 201103L<span class="lineNum">      35 </span>            : # include &lt;bits/c++0x_warning.h&gt;<span class="lineNum">      36 </span>            : #else<span class="lineNum">      37 </span>            : <span class="lineNum">      38 </span>            : #include &lt;ratio&gt;<span class="lineNum">      39 </span>            : #include &lt;type_traits&gt;<span class="lineNum">      40 </span>            : #include &lt;limits&gt;<span class="lineNum">      41 </span>            : #include &lt;ctime&gt;<span class="lineNum">      42 </span>            : <span class="lineNum">      43 </span>            : #ifdef _GLIBCXX_USE_C99_STDINT_TR1<span class="lineNum">      44 </span>            : <span class="lineNum">      45 </span>            : namespace std _GLIBCXX_VISIBILITY(default)<span class="lineNum">      46 </span>            : {<span class="lineNum">      47 </span>            :   /**<span class="lineNum">      48 </span>            :    * @defgroup chrono Time<span class="lineNum">      49 </span>            :    * @ingroup utilities<span class="lineNum">      50 </span>            :    *<span class="lineNum">      51 </span>            :    * Classes and functions for time.<span class="lineNum">      52 </span>            :    * @{<span class="lineNum">      53 </span>            :    */<span class="lineNum">      54 </span>            : <span class="lineNum">      55 </span>            :   /** @namespace std::chrono<span class="lineNum">      56 </span>            :    *  @brief ISO C++ 2011 entities sub-namespace for time and date.<span class="lineNum">      57 </span>            :    */<span class="lineNum">      58 </span>            :   namespace chrono<span class="lineNum">      59 </span>            :   {<span class="lineNum">      60 </span>            :   _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      61 </span>            : <span class="lineNum">      62 </span>            :     template&lt;typename _Rep, typename _Period = ratio&lt;1&gt;&gt;<span class="lineNum">      63 </span>            :       struct duration;<span class="lineNum">      64 </span>            : <span class="lineNum">      65 </span>            :     template&lt;typename _Clock, typename _Dur = typename _Clock::duration&gt;<span class="lineNum">      66 </span>            :       struct time_point;<span class="lineNum">      67 </span>            : <span class="lineNum">      68 </span>            :   _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">      69 </span>            :   }<span class="lineNum">      70 </span>            : <span class="lineNum">      71 </span>            : _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">      72 </span>            : <span class="lineNum">      73 </span>            :   // 20.11.4.3 specialization of common_type (for duration, sfinae-friendly)<span class="lineNum">      74 </span>            :   <span class="lineNum">      75 </span>            :   template&lt;typename _CT, typename _Period1, typename _Period2&gt;<span class="lineNum">      76 </span>            :     struct __duration_common_type_wrapper<span class="lineNum">      77 </span>            :     {<span class="lineNum">      78 </span>            :     private:<span class="lineNum">      79 </span>            :       typedef __static_gcd&lt;_Period1::num, _Period2::num&gt; __gcd_num;<span class="lineNum">      80 </span>            :       typedef __static_gcd&lt;_Period1::den, _Period2::den&gt; __gcd_den;<span class="lineNum">      81 </span>            :       typedef typename _CT::type __cr;<span class="lineNum">      82 </span>            :       typedef ratio&lt;__gcd_num::value,<span class="lineNum">      83 </span>            :         (_Period1::den / __gcd_den::value) * _Period2::den&gt; __r;<span class="lineNum">      84 </span>            :     public:<span class="lineNum">      85 </span>            :       typedef __success_type&lt;chrono::duration&lt;__cr, __r&gt;&gt; type;<span class="lineNum">      86 </span>            :     };<span class="lineNum">      87 </span>            : <span class="lineNum">      88 </span>            :   template&lt;typename _Period1, typename _Period2&gt;<span class="lineNum">      89 </span>            :     struct __duration_common_type_wrapper&lt;__failure_type, _Period1, _Period2&gt;<span class="lineNum">      90 </span>            :     { typedef __failure_type type; };<span class="lineNum">      91 </span>            : <span class="lineNum">      92 </span>            :   template&lt;typename _Rep1, typename _Period1, typename _Rep2, typename _Period2&gt;<span class="lineNum">      93 </span>            :     struct common_type&lt;chrono::duration&lt;_Rep1, _Period1&gt;,<span class="lineNum">      94 </span>            :              chrono::duration&lt;_Rep2, _Period2&gt;&gt;<span class="lineNum">      95 </span>            :     : public __duration_common_type_wrapper&lt;typename __member_type_wrapper&lt;<span class="lineNum">      96 </span>            :              common_type&lt;_Rep1, _Rep2&gt;&gt;::type, _Period1, _Period2&gt;::type<span class="lineNum">      97 </span>            :     { };<span class="lineNum">      98 </span>            : <span class="lineNum">      99 </span>            :   // 20.11.4.3 specialization of common_type (for time_point, sfinae-friendly)<span class="lineNum">     100 </span>            :   <span class="lineNum">     101 </span>            :   template&lt;typename _CT, typename _Clock&gt;<span class="lineNum">     102 </span>            :     struct __timepoint_common_type_wrapper<span class="lineNum">     103 </span>            :     {<span class="lineNum">     104 </span>            :       typedef __success_type&lt;chrono::time_point&lt;_Clock, typename _CT::type&gt;&gt;<span class="lineNum">     105 </span>            :         type;<span class="lineNum">     106 </span>            :     };<span class="lineNum">     107 </span>            : <span class="lineNum">     108 </span>            :   template&lt;typename _Clock&gt;<span class="lineNum">     109 </span>            :     struct __timepoint_common_type_wrapper&lt;__failure_type, _Clock&gt;<span class="lineNum">     110 </span>            :     { typedef __failure_type type; };<span class="lineNum">     111 </span>            : <span class="lineNum">     112 </span>            :   template&lt;typename _Clock, typename _Duration1, typename _Duration2&gt;<span class="lineNum">     113 </span>            :     struct common_type&lt;chrono::time_point&lt;_Clock, _Duration1&gt;,<span class="lineNum">     114 </span>            :              chrono::time_point&lt;_Clock, _Duration2&gt;&gt;<span class="lineNum">     115 </span>            :     : public __timepoint_common_type_wrapper&lt;typename __member_type_wrapper&lt;<span class="lineNum">     116 </span>            :              common_type&lt;_Duration1, _Duration2&gt;&gt;::type, _Clock&gt;::type<span class="lineNum">     117 </span>            :     { };<span class="lineNum">     118 </span>            : <span class="lineNum">     119 </span>            : _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     120 </span>            : <span class="lineNum">     121 </span>            :   namespace chrono<span class="lineNum">     122 </span>            :   {<span class="lineNum">     123 </span>            :   _GLIBCXX_BEGIN_NAMESPACE_VERSION<span class="lineNum">     124 </span>            : <span class="lineNum">     125 </span>            :     // Primary template for duration_cast impl.<span class="lineNum">     126 </span>            :     template&lt;typename _ToDur, typename _CF, typename _CR,<span class="lineNum">     127 </span>            :              bool _NumIsOne = false, bool _DenIsOne = false&gt;<span class="lineNum">     128 </span>            :       struct __duration_cast_impl<span class="lineNum">     129 </span>            :       {<span class="lineNum">     130 </span>            :         template&lt;typename _Rep, typename _Period&gt;<span class="lineNum">     131 </span>            :           static constexpr _ToDur<span class="lineNum">     132 </span>            :           __cast(const duration&lt;_Rep, _Period&gt;&amp; __d)<span class="lineNum">     133 </span>            :           {<span class="lineNum">     134 </span>            :             typedef typename _ToDur::rep                        __to_rep;<span class="lineNum">     135 </span>            :             return _ToDur(static_cast&lt;__to_rep&gt;(static_cast&lt;_CR&gt;(__d.count())<span class="lineNum">     136 </span>            :               * static_cast&lt;_CR&gt;(_CF::num)<span class="lineNum">     137 </span>            :               / static_cast&lt;_CR&gt;(_CF::den)));<span class="lineNum">     138 </span>            :           }<span class="lineNum">     139 </span>            :       };<span class="lineNum">     140 </span>            : <span class="lineNum">     141 </span>            :     template&lt;typename _ToDur, typename _CF, typename _CR&gt;<span class="lineNum">     142 </span>            :       struct __duration_cast_impl&lt;_ToDur, _CF, _CR, true, true&gt;<span class="lineNum">     143 </span>            :       {<span class="lineNum">     144 </span>            :         template&lt;typename _Rep, typename _Period&gt;<span class="lineNum">     145 </span>            :           static constexpr _ToDur<span class="lineNum">     146 </span>            :           __cast(const duration&lt;_Rep, _Period&gt;&amp; __d)<span class="lineNum">     147 </span>            :           {<span class="lineNum">     148 </span>            :             typedef typename _ToDur::rep                        __to_rep;<span class="lineNum">     149 </span>            :             return _ToDur(static_cast&lt;__to_rep&gt;(__d.count()));<span class="lineNum">     150 </span>            :           }<span class="lineNum">     151 </span>            :       };<span class="lineNum">     152 </span>            : <span class="lineNum">     153 </span>            :     template&lt;typename _ToDur, typename _CF, typename _CR&gt;<span class="lineNum">     154 </span>            :       struct __duration_cast_impl&lt;_ToDur, _CF, _CR, true, false&gt;<span class="lineNum">     155 </span>            :       {<a name="156"><span class="lineNum">     156 </span>            :         template&lt;typename _Rep, typename _Period&gt;</a><span class="lineNum">     157 </span>            :           static constexpr _ToDur<span class="lineNum">     158 </span><span class="lineCov">          2 :           __cast(const duration&lt;_Rep, _Period&gt;&amp; __d)</span><span class="lineNum">     159 </span>            :           {<span class="lineNum">     160 </span>            :             typedef typename _ToDur::rep                        __to_rep;<span class="lineNum">     161 </span>            :             return _ToDur(static_cast&lt;__to_rep&gt;(<span class="lineNum">     162 </span><span class="lineCov">          2 :               static_cast&lt;_CR&gt;(__d.count()) / static_cast&lt;_CR&gt;(_CF::den)));</span><span class="lineNum">     163 </span>            :           }<span class="lineNum">     164 </span>            :       };<span class="lineNum">     165 </span>            : <span class="lineNum">     166 </span>            :     template&lt;typename _ToDur, typename _CF, typename _CR&gt;<span class="lineNum">     167 </span>            :       struct __duration_cast_impl&lt;_ToDur, _CF, _CR, false, true&gt;<span class="lineNum">     168 </span>            :       {<span class="lineNum">     169 </span>            :         template&lt;typename _Rep, typename _Period&gt;<span class="lineNum">     170 </span>            :           static constexpr _ToDur<span class="lineNum">     171 </span>            :           __cast(const duration&lt;_Rep, _Period&gt;&amp; __d)<span class="lineNum">     172 </span>            :           {<span class="lineNum">     173 </span>            :             typedef typename _ToDur::rep                        __to_rep;<span class="lineNum">     174 </span>            :             return _ToDur(static_cast&lt;__to_rep&gt;(<span class="lineNum">     175 </span>            :               static_cast&lt;_CR&gt;(__d.count()) * static_cast&lt;_CR&gt;(_CF::num)));<span class="lineNum">     176 </span>            :           }<span class="lineNum">     177 </span>            :       };<span class="lineNum">     178 </span>            : <span class="lineNum">     179 </span>            :     template&lt;typename _Tp&gt;<span class="lineNum">     180 </span>            :       struct __is_duration<span class="lineNum">     181 </span>            :       : std::false_type<span class="lineNum">     182 </span>            :       { };<span class="lineNum">     183 </span>            : <span class="lineNum">     184 </span>            :     template&lt;typename _Rep, typename _Period&gt;<span class="lineNum">     185 </span>            :       struct __is_duration&lt;duration&lt;_Rep, _Period&gt;&gt;<span class="lineNum">     186 </span>            :       : std::true_type<span class="lineNum">     187 </span>            :       { };<span class="lineNum">     188 </span>            : <span class="lineNum">     189 </span>            :     /// duration_cast<span class="lineNum">     190 </span>            :     template&lt;typename _ToDur, typename _Rep, typename _Period&gt;<a name="191"><span class="lineNum">     191 </span>            :       constexpr typename enable_if&lt;__is_duration&lt;_ToDur&gt;::value,</a><span class="lineNum">     192 </span>            :                                    _ToDur&gt;::type<span class="lineNum">     193 </span><span class="lineCov">          2 :       duration_cast(const duration&lt;_Rep, _Period&gt;&amp; __d)</span><span class="lineNum">     194 </span>            :       {<span class="lineNum">     195 </span>            :         typedef typename _ToDur::period                         __to_period;<span class="lineNum">     196 </span>            :         typedef typename _ToDur::rep                            __to_rep;<span class="lineNum">     197 </span>            :         typedef ratio_divide&lt;_Period, __to_period&gt;                __cf;<span class="lineNum">     198 </span>            :         typedef typename common_type&lt;__to_rep, _Rep, intmax_t&gt;::type<span class="lineNum">     199 </span>            :                                                                 __cr;<span class="lineNum">     200 </span>            :         typedef  __duration_cast_impl&lt;_ToDur, __cf, __cr,<span class="lineNum">     201 </span>            :                                       __cf::num == 1, __cf::den == 1&gt; __dc;<span class="lineNum">     202 </span><span class="lineCov">          2 :         return __dc::__cast(__d);</span><span class="lineNum">     203 </span>            :       }<span class="lineNum">     204 </span>            : <span class="lineNum">     205 </span>            :     /// treat_as_floating_point<span class="lineNum">     206 </span>            :     template&lt;typename _Rep&gt;<span class="lineNum">     207 </span>            :       struct treat_as_floating_point<span class="lineNum">     208 </span>            :       : is_floating_point&lt;_Rep&gt;<span class="lineNum">     209 </span>            :       { };<span class="lineNum">     210 </span>            : <span class="lineNum">     211 </span>            :     /// duration_values<span class="lineNum">     212 </span>            :     template&lt;typename _Rep&gt;<span class="lineNum">     213 </span>            :       struct duration_values<span class="lineNum">     214 </span>            :       {<span class="lineNum">     215 </span>            :         static constexpr _Rep<span class="lineNum">     216 </span>            :         zero()<span class="lineNum">     217 </span>            :         { return _Rep(0); }<span class="lineNum">     218 </span>            : <span class="lineNum">     219 </span>            :         static constexpr _Rep<span class="lineNum">     220 </span>            :         max()<span class="lineNum">     221 </span>            :         { return numeric_limits&lt;_Rep&gt;::max(); }<span class="lineNum">     222 </span>            : <span class="lineNum">     223 </span>            :         static constexpr _Rep<span class="lineNum">     224 </span>            :         min()<span class="lineNum">     225 </span>            :         { return numeric_limits&lt;_Rep&gt;::lowest(); }<span class="lineNum">     226 </span>            :       };<span class="lineNum">     227 </span>            : <span class="lineNum">     228 </span>            :     template&lt;typename _Tp&gt;<span class="lineNum">     229 </span>            :       struct __is_ratio<span class="lineNum">     230 </span>            :       : std::false_type<span class="lineNum">     231 </span>            :       { };<span class="lineNum">     232 </span>            : <span class="lineNum">     233 </span>            :     template&lt;intmax_t _Num, intmax_t _Den&gt;<span class="lineNum">     234 </span>            :       struct __is_ratio&lt;ratio&lt;_Num, _Den&gt;&gt;<span class="lineNum">     235 </span>            :       : std::true_type<span class="lineNum">     236 </span>            :       { };<span class="lineNum">     237 </span>            : <span class="lineNum">     238 </span>            :     /// duration<span class="lineNum">     239 </span>            :     template&lt;typename _Rep, typename _Period&gt;<span class="lineNum">     240 </span>            :       struct duration<span class="lineNum">     241 </span>            :       {<span class="lineNum">     242 </span>            :         typedef _Rep                                            rep;<span class="lineNum">     243 </span>            :         typedef _Period                                         period;<span class="lineNum">     244 </span>            : <span class="lineNum">     245 </span>            :         static_assert(!__is_duration&lt;_Rep&gt;::value, &quot;rep cannot be a duration&quot;);<span class="lineNum">     246 </span>            :         static_assert(__is_ratio&lt;_Period&gt;::value,<span class="lineNum">     247 </span>            :                       &quot;period must be a specialization of ratio&quot;);<span class="lineNum">     248 </span>            :         static_assert(_Period::num &gt; 0, &quot;period must be positive&quot;);<span class="lineNum">     249 </span>            : <span class="lineNum">     250 </span>            :         // 20.11.5.1 construction / copy / destroy<span class="lineNum">     251 </span>            :         constexpr duration() = default;<span class="lineNum">     252 </span>            : <span class="lineNum">     253 </span>            :         // NB: Make constexpr implicit. This cannot be explicitly<span class="lineNum">     254 </span>            :         // constexpr, as any UDT that is not a literal type with a<span class="lineNum">     255 </span>            :         // constexpr copy constructor will be ill-formed.<span class="lineNum">     256 </span>            :         duration(const duration&amp;) = default;<span class="lineNum">     257 </span>            : <span class="lineNum">     258 </span>            :         template&lt;typename _Rep2, typename = typename<span class="lineNum">     259 </span>            :                enable_if&lt;is_convertible&lt;_Rep2, rep&gt;::value<a name="260"><span class="lineNum">     260 </span>            :                          &amp;&amp; (treat_as_floating_point&lt;rep&gt;::value</a><span class="lineNum">     261 </span>            :                              || !treat_as_floating_point&lt;_Rep2&gt;::value)&gt;::type&gt;<span class="lineNum">     262 </span><span class="lineCov">          4 :           constexpr explicit duration(const _Rep2&amp; __rep)</span><span class="lineNum">     263 </span><span class="lineCov">          4 :           : __r(static_cast&lt;rep&gt;(__rep)) { }</span><span class="lineNum">     264 </span>            : <span class="lineNum">     265 </span>            :         template&lt;typename _Rep2, typename _Period2, typename = typename<span class="lineNum">     266 </span>            :                enable_if&lt;treat_as_floating_point&lt;rep&gt;::value<span class="lineNum">     267 </span>            :                          || (ratio_divide&lt;_Period2, period&gt;::den == 1<span class="lineNum">     268 </span>            :                              &amp;&amp; !treat_as_floating_point&lt;_Rep2&gt;::value)&gt;::type&gt;<span class="lineNum">     269 </span>            :           constexpr duration(const duration&lt;_Rep2, _Period2&gt;&amp; __d)<span class="lineNum">     270 </span>            :           : __r(duration_cast&lt;duration&gt;(__d).count()) { }<span class="lineNum">     271 </span>            : <span class="lineNum">     272 </span>            :         ~duration() = default;<span class="lineNum">     273 </span>            :         duration&amp; operator=(const duration&amp;) = default;<span class="lineNum">     274 </span>            : <a name="275"><span class="lineNum">     275 </span>            :         // 20.11.5.2 observer</a><span class="lineNum">     276 </span>            :         constexpr rep<span class="lineNum">     277 </span><span class="lineCov">          8 :         count() const</span><span class="lineNum">     278 </span><span class="lineCov">          8 :         { return __r; }</span><span class="lineNum">     279 </span>            : <span class="lineNum">     280 </span>            :         // 20.11.5.3 arithmetic<span class="lineNum">     281 </span>            :         constexpr duration<span class="lineNum">     282 </span>            :         operator+() const<span class="lineNum">     283 </span>            :         { return *this; }<span class="lineNum">     284 </span>            : <span class="lineNum">     285 </span>            :         constexpr duration<span class="lineNum">     286 </span>            :         operator-() const<span class="lineNum">     287 </span>            :         { return duration(-__r); }<span class="lineNum">     288 </span>            : <span class="lineNum">     289 </span>            :         duration&amp;<span class="lineNum">     290 </span>            :         operator++()<span class="lineNum">     291 </span>            :         {<span class="lineNum">     292 </span>            :           ++__r;<span class="lineNum">     293 </span>            :           return *this;<span class="lineNum">     294 </span>            :         }<span class="lineNum">     295 </span>            : <span class="lineNum">     296 </span>            :         duration<span class="lineNum">     297 </span>            :         operator++(int)<span class="lineNum">     298 </span>            :         { return duration(__r++); }<span class="lineNum">     299 </span>            : <span class="lineNum">     300 </span>            :         duration&amp;<span class="lineNum">     301 </span>            :         operator--()<span class="lineNum">     302 </span>            :         {<span class="lineNum">     303 </span>            :           --__r;<span class="lineNum">     304 </span>            :           return *this;<span class="lineNum">     305 </span>            :         }<span class="lineNum">     306 </span>            : <span class="lineNum">     307 </span>            :         duration<span class="lineNum">     308 </span>            :         operator--(int)<span class="lineNum">     309 </span>            :         { return duration(__r--); }<span class="lineNum">     310 </span>            : <span class="lineNum">     311 </span>            :         duration&amp;<span class="lineNum">     312 </span>            :         operator+=(const duration&amp; __d)<span class="lineNum">     313 </span>            :         {<span class="lineNum">     314 </span>            :           __r += __d.count();<span class="lineNum">     315 </span>            :           return *this;<span class="lineNum">     316 </span>            :         }<span class="lineNum">     317 </span>            : <span class="lineNum">     318 </span>            :         duration&amp;<span class="lineNum">     319 </span>            :         operator-=(const duration&amp; __d)<span class="lineNum">     320 </span>            :         {<span class="lineNum">     321 </span>            :           __r -= __d.count();<span class="lineNum">     322 </span>            :           return *this;<span class="lineNum">     323 </span>            :         }<span class="lineNum">     324 </span>            : <span class="lineNum">     325 </span>            :         duration&amp;<span class="lineNum">     326 </span>            :         operator*=(const rep&amp; __rhs)<span class="lineNum">     327 </span>            :         {<span class="lineNum">     328 </span>            :           __r *= __rhs;<span class="lineNum">     329 </span>            :           return *this;<span class="lineNum">     330 </span>            :         }<span class="lineNum">     331 </span>            : <span class="lineNum">     332 </span>            :         duration&amp;<span class="lineNum">     333 </span>            :         operator/=(const rep&amp; __rhs)<span class="lineNum">     334 </span>            :         {<span class="lineNum">     335 </span>            :           __r /= __rhs;<span class="lineNum">     336 </span>            :           return *this;<span class="lineNum">     337 </span>            :         }<span class="lineNum">     338 </span>            : <span class="lineNum">     339 </span>            :         // DR 934.<span class="lineNum">     340 </span>            :         template&lt;typename _Rep2 = rep&gt;<span class="lineNum">     341 </span>            :           typename enable_if&lt;!treat_as_floating_point&lt;_Rep2&gt;::value,<span class="lineNum">     342 </span>            :                              duration&amp;&gt;::type<span class="lineNum">     343 </span>            :           operator%=(const rep&amp; __rhs)<span class="lineNum">     344 </span>            :           {<span class="lineNum">     345 </span>            :             __r %= __rhs;<span class="lineNum">     346 </span>            :             return *this;<span class="lineNum">     347 </span>            :           }<span class="lineNum">     348 </span>            : <span class="lineNum">     349 </span>            :         template&lt;typename _Rep2 = rep&gt;<span class="lineNum">     350 </span>            :           typename enable_if&lt;!treat_as_floating_point&lt;_Rep2&gt;::value,<span class="lineNum">     351 </span>            :                              duration&amp;&gt;::type<span class="lineNum">     352 </span>            :           operator%=(const duration&amp; __d)<span class="lineNum">     353 </span>            :           {<span class="lineNum">     354 </span>            :             __r %= __d.count();<span class="lineNum">     355 </span>            :             return *this;<span class="lineNum">     356 </span>            :           }<span class="lineNum">     357 </span>            : <span class="lineNum">     358 </span>            :         // 20.11.5.4 special values<span class="lineNum">     359 </span>            :         static constexpr duration<span class="lineNum">     360 </span>            :         zero()<span class="lineNum">     361 </span>            :         { return duration(duration_values&lt;rep&gt;::zero()); }<span class="lineNum">     362 </span>            : <span class="lineNum">     363 </span>            :         static constexpr duration<span class="lineNum">     364 </span>            :         min()<span class="lineNum">     365 </span>            :         { return duration(duration_values&lt;rep&gt;::min()); }<span class="lineNum">     366 </span>            : <span class="lineNum">     367 </span>            :         static constexpr duration<span class="lineNum">     368 </span>            :         max()<span class="lineNum">     369 </span>            :         { return duration(duration_values&lt;rep&gt;::max()); }<span class="lineNum">     370 </span>            : <span class="lineNum">     371 </span>            :       private:<span class="lineNum">     372 </span>            :         rep __r;<span class="lineNum">     373 </span>            :       };<span class="lineNum">     374 </span>            : <span class="lineNum">     375 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     376 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     377 </span>            :       constexpr typename common_type&lt;duration&lt;_Rep1, _Period1&gt;,<span class="lineNum">     378 </span>            :                                      duration&lt;_Rep2, _Period2&gt;&gt;::type<span class="lineNum">     379 </span>            :       operator+(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,<span class="lineNum">     380 </span>            :                 const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     381 </span>            :       {<span class="lineNum">     382 </span>            :         typedef duration&lt;_Rep1, _Period1&gt;                 __dur1;<span class="lineNum">     383 </span>            :         typedef duration&lt;_Rep2, _Period2&gt;                 __dur2;<span class="lineNum">     384 </span>            :         typedef typename common_type&lt;__dur1,__dur2&gt;::type __cd;<span class="lineNum">     385 </span>            :         return __cd(__cd(__lhs).count() + __cd(__rhs).count());<span class="lineNum">     386 </span>            :       }<span class="lineNum">     387 </span>            : <span class="lineNum">     388 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     389 </span>            :              typename _Rep2, typename _Period2&gt;<a name="390"><span class="lineNum">     390 </span>            :       constexpr typename common_type&lt;duration&lt;_Rep1, _Period1&gt;,</a><span class="lineNum">     391 </span>            :                                      duration&lt;_Rep2, _Period2&gt;&gt;::type<span class="lineNum">     392 </span><span class="lineCov">          2 :       operator-(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,</span><span class="lineNum">     393 </span>            :                 const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     394 </span>            :       {<span class="lineNum">     395 </span>            :         typedef duration&lt;_Rep1, _Period1&gt;                 __dur1;<span class="lineNum">     396 </span>            :         typedef duration&lt;_Rep2, _Period2&gt;                 __dur2;<span class="lineNum">     397 </span>            :         typedef typename common_type&lt;__dur1,__dur2&gt;::type __cd;<span class="lineNum">     398 </span><span class="lineCov">          2 :         return __cd(__cd(__lhs).count() - __cd(__rhs).count());</span><span class="lineNum">     399 </span>            :       }<span class="lineNum">     400 </span>            : <span class="lineNum">     401 </span>            :     template&lt;typename _Rep1, typename _Rep2, bool =<span class="lineNum">     402 </span>            :              is_convertible&lt;_Rep2,<span class="lineNum">     403 </span>            :                             typename common_type&lt;_Rep1, _Rep2&gt;::type&gt;::value&gt;<span class="lineNum">     404 </span>            :       struct __common_rep_type { };<span class="lineNum">     405 </span>            : <span class="lineNum">     406 </span>            :     template&lt;typename _Rep1, typename _Rep2&gt;<span class="lineNum">     407 </span>            :       struct __common_rep_type&lt;_Rep1, _Rep2, true&gt;<span class="lineNum">     408 </span>            :       { typedef typename common_type&lt;_Rep1, _Rep2&gt;::type type; };<span class="lineNum">     409 </span>            : <span class="lineNum">     410 </span>            :     template&lt;typename _Rep1, typename _Period, typename _Rep2&gt;<span class="lineNum">     411 </span>            :       constexpr<span class="lineNum">     412 </span>            :       duration&lt;typename __common_rep_type&lt;_Rep1, _Rep2&gt;::type, _Period&gt;<span class="lineNum">     413 </span>            :       operator*(const duration&lt;_Rep1, _Period&gt;&amp; __d, const _Rep2&amp; __s)<span class="lineNum">     414 </span>            :       {<span class="lineNum">     415 </span>            :         typedef duration&lt;typename common_type&lt;_Rep1, _Rep2&gt;::type, _Period&gt;<span class="lineNum">     416 </span>            :           __cd;<span class="lineNum">     417 </span>            :         return __cd(__cd(__d).count() * __s);<span class="lineNum">     418 </span>            :       }<span class="lineNum">     419 </span>            : <span class="lineNum">     420 </span>            :     template&lt;typename _Rep1, typename _Rep2, typename _Period&gt;<span class="lineNum">     421 </span>            :       constexpr<span class="lineNum">     422 </span>            :       duration&lt;typename __common_rep_type&lt;_Rep2, _Rep1&gt;::type, _Period&gt;<span class="lineNum">     423 </span>            :       operator*(const _Rep1&amp; __s, const duration&lt;_Rep2, _Period&gt;&amp; __d)<span class="lineNum">     424 </span>            :       { return __d * __s; }<span class="lineNum">     425 </span>            : <span class="lineNum">     426 </span>            :     template&lt;typename _Rep1, typename _Period, typename _Rep2&gt;<span class="lineNum">     427 </span>            :       constexpr duration&lt;typename __common_rep_type&lt;_Rep1, typename<span class="lineNum">     428 </span>            :         enable_if&lt;!__is_duration&lt;_Rep2&gt;::value, _Rep2&gt;::type&gt;::type, _Period&gt;<span class="lineNum">     429 </span>            :       operator/(const duration&lt;_Rep1, _Period&gt;&amp; __d, const _Rep2&amp; __s)<span class="lineNum">     430 </span>            :       {<span class="lineNum">     431 </span>            :         typedef duration&lt;typename common_type&lt;_Rep1, _Rep2&gt;::type, _Period&gt;<span class="lineNum">     432 </span>            :           __cd;<span class="lineNum">     433 </span>            :         return __cd(__cd(__d).count() / __s);<span class="lineNum">     434 </span>            :       }<span class="lineNum">     435 </span>            : <span class="lineNum">     436 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     437 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     438 </span>            :       constexpr typename common_type&lt;_Rep1, _Rep2&gt;::type<span class="lineNum">     439 </span>            :       operator/(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,<span class="lineNum">     440 </span>            :                 const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     441 </span>            :       {<span class="lineNum">     442 </span>            :         typedef duration&lt;_Rep1, _Period1&gt;                 __dur1;<span class="lineNum">     443 </span>            :         typedef duration&lt;_Rep2, _Period2&gt;                 __dur2;<span class="lineNum">     444 </span>            :         typedef typename common_type&lt;__dur1,__dur2&gt;::type __cd;<span class="lineNum">     445 </span>            :         return __cd(__lhs).count() / __cd(__rhs).count();<span class="lineNum">     446 </span>            :       }<span class="lineNum">     447 </span>            : <span class="lineNum">     448 </span>            :     // DR 934.<span class="lineNum">     449 </span>            :     template&lt;typename _Rep1, typename _Period, typename _Rep2&gt;<span class="lineNum">     450 </span>            :       constexpr duration&lt;typename __common_rep_type&lt;_Rep1, typename<span class="lineNum">     451 </span>            :         enable_if&lt;!__is_duration&lt;_Rep2&gt;::value, _Rep2&gt;::type&gt;::type, _Period&gt;<span class="lineNum">     452 </span>            :       operator%(const duration&lt;_Rep1, _Period&gt;&amp; __d, const _Rep2&amp; __s)<span class="lineNum">     453 </span>            :       {<span class="lineNum">     454 </span>            :         typedef duration&lt;typename common_type&lt;_Rep1, _Rep2&gt;::type, _Period&gt;<span class="lineNum">     455 </span>            :           __cd;<span class="lineNum">     456 </span>            :         return __cd(__cd(__d).count() % __s);<span class="lineNum">     457 </span>            :       }<span class="lineNum">     458 </span>            : <span class="lineNum">     459 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     460 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     461 </span>            :       constexpr typename common_type&lt;duration&lt;_Rep1, _Period1&gt;,<span class="lineNum">     462 </span>            :                                      duration&lt;_Rep2, _Period2&gt;&gt;::type<span class="lineNum">     463 </span>            :       operator%(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,<span class="lineNum">     464 </span>            :                 const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     465 </span>            :       {<span class="lineNum">     466 </span>            :         typedef duration&lt;_Rep1, _Period1&gt;                 __dur1;<span class="lineNum">     467 </span>            :         typedef duration&lt;_Rep2, _Period2&gt;                 __dur2;<span class="lineNum">     468 </span>            :         typedef typename common_type&lt;__dur1,__dur2&gt;::type __cd;<span class="lineNum">     469 </span>            :         return __cd(__cd(__lhs).count() % __cd(__rhs).count());<span class="lineNum">     470 </span>            :       }<span class="lineNum">     471 </span>            : <span class="lineNum">     472 </span>            :     // comparisons<span class="lineNum">     473 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     474 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     475 </span>            :       constexpr bool<span class="lineNum">     476 </span>            :       operator==(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,<span class="lineNum">     477 </span>            :                  const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     478 </span>            :       {<span class="lineNum">     479 </span>            :         typedef duration&lt;_Rep1, _Period1&gt;                 __dur1;<span class="lineNum">     480 </span>            :         typedef duration&lt;_Rep2, _Period2&gt;                 __dur2;<span class="lineNum">     481 </span>            :         typedef typename common_type&lt;__dur1,__dur2&gt;::type __ct;<span class="lineNum">     482 </span>            :         return __ct(__lhs).count() == __ct(__rhs).count();<span class="lineNum">     483 </span>            :       }<span class="lineNum">     484 </span>            : <span class="lineNum">     485 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     486 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     487 </span>            :       constexpr bool<span class="lineNum">     488 </span>            :       operator&lt;(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,<span class="lineNum">     489 </span>            :                 const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     490 </span>            :       {<span class="lineNum">     491 </span>            :         typedef duration&lt;_Rep1, _Period1&gt;                 __dur1;<span class="lineNum">     492 </span>            :         typedef duration&lt;_Rep2, _Period2&gt;                 __dur2;<span class="lineNum">     493 </span>            :         typedef typename common_type&lt;__dur1,__dur2&gt;::type __ct;<span class="lineNum">     494 </span>            :         return __ct(__lhs).count() &lt; __ct(__rhs).count();<span class="lineNum">     495 </span>            :       }<span class="lineNum">     496 </span>            : <span class="lineNum">     497 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     498 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     499 </span>            :       constexpr bool<span class="lineNum">     500 </span>            :       operator!=(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,<span class="lineNum">     501 </span>            :                  const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     502 </span>            :       { return !(__lhs == __rhs); }<span class="lineNum">     503 </span>            : <span class="lineNum">     504 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     505 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     506 </span>            :       constexpr bool<span class="lineNum">     507 </span>            :       operator&lt;=(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,<span class="lineNum">     508 </span>            :                  const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     509 </span>            :       { return !(__rhs &lt; __lhs); }<span class="lineNum">     510 </span>            : <span class="lineNum">     511 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     512 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     513 </span>            :       constexpr bool<span class="lineNum">     514 </span>            :       operator&gt;(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,<span class="lineNum">     515 </span>            :                 const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     516 </span>            :       { return __rhs &lt; __lhs; }<span class="lineNum">     517 </span>            : <span class="lineNum">     518 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     519 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     520 </span>            :       constexpr bool<span class="lineNum">     521 </span>            :       operator&gt;=(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,<span class="lineNum">     522 </span>            :                  const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     523 </span>            :       { return !(__lhs &lt; __rhs); }<span class="lineNum">     524 </span>            : <span class="lineNum">     525 </span>            :     /// nanoseconds<span class="lineNum">     526 </span>            :     typedef duration&lt;int64_t, nano&gt;       nanoseconds;<span class="lineNum">     527 </span>            : <span class="lineNum">     528 </span>            :     /// microseconds<span class="lineNum">     529 </span>            :     typedef duration&lt;int64_t, micro&gt;      microseconds;<span class="lineNum">     530 </span>            : <span class="lineNum">     531 </span>            :     /// milliseconds<span class="lineNum">     532 </span>            :     typedef duration&lt;int64_t, milli&gt;      milliseconds;<span class="lineNum">     533 </span>            : <span class="lineNum">     534 </span>            :     /// seconds<span class="lineNum">     535 </span>            :     typedef duration&lt;int64_t&gt;             seconds;<span class="lineNum">     536 </span>            : <span class="lineNum">     537 </span>            :     /// minutes<span class="lineNum">     538 </span>            :     typedef duration&lt;int, ratio&lt; 60&gt;&gt;       minutes;<span class="lineNum">     539 </span>            : <span class="lineNum">     540 </span>            :     /// hours<span class="lineNum">     541 </span>            :     typedef duration&lt;int, ratio&lt;3600&gt;&gt;      hours;<span class="lineNum">     542 </span>            : <span class="lineNum">     543 </span>            :     /// time_point<span class="lineNum">     544 </span>            :     template&lt;typename _Clock, typename _Dur&gt;<span class="lineNum">     545 </span>            :       struct time_point<span class="lineNum">     546 </span>            :       {<span class="lineNum">     547 </span>            :         typedef _Clock                                          clock;<span class="lineNum">     548 </span>            :         typedef _Dur                                            duration;<span class="lineNum">     549 </span>            :         typedef typename duration::rep                          rep;<span class="lineNum">     550 </span>            :         typedef typename duration::period                       period;<span class="lineNum">     551 </span>            : <span class="lineNum">     552 </span>            :         constexpr time_point() : __d(duration::zero())<span class="lineNum">     553 </span>            :         { }<span class="lineNum">     554 </span>            : <span class="lineNum">     555 </span>            :         constexpr explicit time_point(const duration&amp; __dur)<span class="lineNum">     556 </span>            :         : __d(__dur)<span class="lineNum">     557 </span>            :         { }<span class="lineNum">     558 </span>            : <span class="lineNum">     559 </span>            :         // conversions<span class="lineNum">     560 </span>            :         template&lt;typename _Dur2&gt;<span class="lineNum">     561 </span>            :           constexpr time_point(const time_point&lt;clock, _Dur2&gt;&amp; __t)<span class="lineNum">     562 </span>            :           : __d(__t.time_since_epoch())<span class="lineNum">     563 </span>            :           { }<span class="lineNum">     564 </span>            : <a name="565"><span class="lineNum">     565 </span>            :         // observer</a><span class="lineNum">     566 </span>            :         constexpr duration<span class="lineNum">     567 </span><span class="lineCov">          4 :         time_since_epoch() const</span><span class="lineNum">     568 </span><span class="lineCov">          4 :         { return __d; }</span><span class="lineNum">     569 </span>            : <span class="lineNum">     570 </span>            :         // arithmetic<span class="lineNum">     571 </span>            :         time_point&amp;<span class="lineNum">     572 </span>            :         operator+=(const duration&amp; __dur)<span class="lineNum">     573 </span>            :         {<span class="lineNum">     574 </span>            :           __d += __dur;<span class="lineNum">     575 </span>            :           return *this;<span class="lineNum">     576 </span>            :         }<span class="lineNum">     577 </span>            : <span class="lineNum">     578 </span>            :         time_point&amp;<span class="lineNum">     579 </span>            :         operator-=(const duration&amp; __dur)<span class="lineNum">     580 </span>            :         {<span class="lineNum">     581 </span>            :           __d -= __dur;<span class="lineNum">     582 </span>            :           return *this;<span class="lineNum">     583 </span>            :         }<span class="lineNum">     584 </span>            : <span class="lineNum">     585 </span>            :         // special values<span class="lineNum">     586 </span>            :         static constexpr time_point<span class="lineNum">     587 </span>            :         min()<span class="lineNum">     588 </span>            :         { return time_point(duration::min()); }<span class="lineNum">     589 </span>            : <span class="lineNum">     590 </span>            :         static constexpr time_point<span class="lineNum">     591 </span>            :         max()<span class="lineNum">     592 </span>            :         { return time_point(duration::max()); }<span class="lineNum">     593 </span>            : <span class="lineNum">     594 </span>            :       private:<span class="lineNum">     595 </span>            :         duration __d;<span class="lineNum">     596 </span>            :       };<span class="lineNum">     597 </span>            : <span class="lineNum">     598 </span>            :     /// time_point_cast<span class="lineNum">     599 </span>            :     template&lt;typename _ToDur, typename _Clock, typename _Dur&gt;<span class="lineNum">     600 </span>            :       constexpr typename enable_if&lt;__is_duration&lt;_ToDur&gt;::value,<span class="lineNum">     601 </span>            :                                    time_point&lt;_Clock, _ToDur&gt;&gt;::type<span class="lineNum">     602 </span>            :       time_point_cast(const time_point&lt;_Clock, _Dur&gt;&amp; __t)<span class="lineNum">     603 </span>            :       {<span class="lineNum">     604 </span>            :         typedef time_point&lt;_Clock, _ToDur&gt;                        __time_point;<span class="lineNum">     605 </span>            :         return __time_point(duration_cast&lt;_ToDur&gt;(__t.time_since_epoch()));<span class="lineNum">     606 </span>            :       }<span class="lineNum">     607 </span>            : <span class="lineNum">     608 </span>            :     template&lt;typename _Clock, typename _Dur1,<span class="lineNum">     609 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     610 </span>            :       constexpr time_point&lt;_Clock,<span class="lineNum">     611 </span>            :         typename common_type&lt;_Dur1, duration&lt;_Rep2, _Period2&gt;&gt;::type&gt;<span class="lineNum">     612 </span>            :       operator+(const time_point&lt;_Clock, _Dur1&gt;&amp; __lhs,<span class="lineNum">     613 </span>            :                 const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     614 </span>            :       {<span class="lineNum">     615 </span>            :         typedef duration&lt;_Rep2, _Period2&gt;                 __dur2;<span class="lineNum">     616 </span>            :         typedef typename common_type&lt;_Dur1,__dur2&gt;::type  __ct;<span class="lineNum">     617 </span>            :         typedef time_point&lt;_Clock, __ct&gt;                  __time_point;<span class="lineNum">     618 </span>            :         return __time_point(__lhs.time_since_epoch() + __rhs);<span class="lineNum">     619 </span>            :       }<span class="lineNum">     620 </span>            : <span class="lineNum">     621 </span>            :     template&lt;typename _Rep1, typename _Period1,<span class="lineNum">     622 </span>            :              typename _Clock, typename _Dur2&gt;<span class="lineNum">     623 </span>            :       constexpr time_point&lt;_Clock,<span class="lineNum">     624 </span>            :         typename common_type&lt;duration&lt;_Rep1, _Period1&gt;, _Dur2&gt;::type&gt;<span class="lineNum">     625 </span>            :       operator+(const duration&lt;_Rep1, _Period1&gt;&amp; __lhs,<span class="lineNum">     626 </span>            :                 const time_point&lt;_Clock, _Dur2&gt;&amp; __rhs)<span class="lineNum">     627 </span>            :       { <span class="lineNum">     628 </span>            :         typedef duration&lt;_Rep1, _Period1&gt;                 __dur1;<span class="lineNum">     629 </span>            :         typedef typename common_type&lt;__dur1,_Dur2&gt;::type  __ct;<span class="lineNum">     630 </span>            :         typedef time_point&lt;_Clock, __ct&gt;                  __time_point;<span class="lineNum">     631 </span>            :         return __time_point(__rhs.time_since_epoch() + __lhs); <span class="lineNum">     632 </span>            :       }<span class="lineNum">     633 </span>            : <span class="lineNum">     634 </span>            :     template&lt;typename _Clock, typename _Dur1,<span class="lineNum">     635 </span>            :              typename _Rep2, typename _Period2&gt;<span class="lineNum">     636 </span>            :       constexpr time_point&lt;_Clock,<span class="lineNum">     637 </span>            :         typename common_type&lt;_Dur1, duration&lt;_Rep2, _Period2&gt;&gt;::type&gt;<span class="lineNum">     638 </span>            :       operator-(const time_point&lt;_Clock, _Dur1&gt;&amp; __lhs,<span class="lineNum">     639 </span>            :                 const duration&lt;_Rep2, _Period2&gt;&amp; __rhs)<span class="lineNum">     640 </span>            :       { <span class="lineNum">     641 </span>            :         typedef duration&lt;_Rep2, _Period2&gt;                 __dur2;<span class="lineNum">     642 </span>            :         typedef typename common_type&lt;_Dur1,__dur2&gt;::type  __ct;<span class="lineNum">     643 </span>            :         typedef time_point&lt;_Clock, __ct&gt;                  __time_point;<span class="lineNum">     644 </span>            :         return __time_point(__lhs.time_since_epoch() -__rhs); <span class="lineNum">     645 </span>            :       }<span class="lineNum">     646 </span>            : <a name="647"><span class="lineNum">     647 </span>            :     template&lt;typename _Clock, typename _Dur1, typename _Dur2&gt;</a><span class="lineNum">     648 </span>            :       constexpr typename common_type&lt;_Dur1, _Dur2&gt;::type<span class="lineNum">     649 </span><span class="lineCov">          2 :       operator-(const time_point&lt;_Clock, _Dur1&gt;&amp; __lhs,</span><span class="lineNum">     650 </span>            :                 const time_point&lt;_Clock, _Dur2&gt;&amp; __rhs)<span class="lineNum">     651 </span><span class="lineCov">          2 :       { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }</span><span class="lineNum">     652 </span>            : <span class="lineNum">     653 </span>            :     template&lt;typename _Clock, typename _Dur1, typename _Dur2&gt;<span class="lineNum">     654 </span>            :       constexpr bool<span class="lineNum">     655 </span>            :       operator==(const time_point&lt;_Clock, _Dur1&gt;&amp; __lhs,<span class="lineNum">     656 </span>            :                  const time_point&lt;_Clock, _Dur2&gt;&amp; __rhs)<span class="lineNum">     657 </span>            :       { return __lhs.time_since_epoch() == __rhs.time_since_epoch(); }<span class="lineNum">     658 </span>            : <span class="lineNum">     659 </span>            :     template&lt;typename _Clock, typename _Dur1, typename _Dur2&gt;<span class="lineNum">     660 </span>            :       constexpr bool<span class="lineNum">     661 </span>            :       operator!=(const time_point&lt;_Clock, _Dur1&gt;&amp; __lhs,<span class="lineNum">     662 </span>            :                  const time_point&lt;_Clock, _Dur2&gt;&amp; __rhs)<span class="lineNum">     663 </span>            :       { return !(__lhs == __rhs); }<span class="lineNum">     664 </span>            : <span class="lineNum">     665 </span>            :     template&lt;typename _Clock, typename _Dur1, typename _Dur2&gt;<span class="lineNum">     666 </span>            :       constexpr bool<span class="lineNum">     667 </span>            :       operator&lt;(const time_point&lt;_Clock, _Dur1&gt;&amp; __lhs,<span class="lineNum">     668 </span>            :                 const time_point&lt;_Clock, _Dur2&gt;&amp; __rhs)<span class="lineNum">     669 </span>            :       { return  __lhs.time_since_epoch() &lt; __rhs.time_since_epoch(); }<span class="lineNum">     670 </span>            : <span class="lineNum">     671 </span>            :     template&lt;typename _Clock, typename _Dur1, typename _Dur2&gt;<span class="lineNum">     672 </span>            :       constexpr bool<span class="lineNum">     673 </span>            :       operator&lt;=(const time_point&lt;_Clock, _Dur1&gt;&amp; __lhs,<span class="lineNum">     674 </span>            :                  const time_point&lt;_Clock, _Dur2&gt;&amp; __rhs)<span class="lineNum">     675 </span>            :       { return !(__rhs &lt; __lhs); }<span class="lineNum">     676 </span>            : <span class="lineNum">     677 </span>            :     template&lt;typename _Clock, typename _Dur1, typename _Dur2&gt;<span class="lineNum">     678 </span>            :       constexpr bool<span class="lineNum">     679 </span>            :       operator&gt;(const time_point&lt;_Clock, _Dur1&gt;&amp; __lhs,<span class="lineNum">     680 </span>            :                 const time_point&lt;_Clock, _Dur2&gt;&amp; __rhs)<span class="lineNum">     681 </span>            :       { return __rhs &lt; __lhs; }<span class="lineNum">     682 </span>            : <span class="lineNum">     683 </span>            :     template&lt;typename _Clock, typename _Dur1, typename _Dur2&gt;<span class="lineNum">     684 </span>            :       constexpr bool<span class="lineNum">     685 </span>            :       operator&gt;=(const time_point&lt;_Clock, _Dur1&gt;&amp; __lhs,<span class="lineNum">     686 </span>            :                  const time_point&lt;_Clock, _Dur2&gt;&amp; __rhs)<span class="lineNum">     687 </span>            :       { return !(__lhs &lt; __rhs); }<span class="lineNum">     688 </span>            : <span class="lineNum">     689 </span>            : <span class="lineNum">     690 </span>            :     // Clocks. <span class="lineNum">     691 </span>            : <span class="lineNum">     692 </span>            :     // Why nanosecond resolution as the default?  <span class="lineNum">     693 </span>            :     // Why have std::system_clock always count in the higest<span class="lineNum">     694 </span>            :     // resolution (ie nanoseconds), even if on some OSes the low 3<span class="lineNum">     695 </span>            :     // or 9 decimal digits will be always zero? This allows later<span class="lineNum">     696 </span>            :     // implementations to change the system_clock::now()<span class="lineNum">     697 </span>            :     // implementation any time to provide better resolution without<span class="lineNum">     698 </span>            :     // changing function signature or units.<span class="lineNum">     699 </span>            : <span class="lineNum">     700 </span>            :     // To support the (forward) evolution of the library's defined<span class="lineNum">     701 </span>            :     // clocks, wrap inside inline namespace so that the current<span class="lineNum">     702 </span>            :     // defintions of system_clock, steady_clock, and<span class="lineNum">     703 </span>            :     // high_resolution_clock types are uniquely mangled. This way, new<span class="lineNum">     704 </span>            :     // code can use the latests clocks, while the library can contain<span class="lineNum">     705 </span>            :     // compatibility definitions for previous versions.  At some<span class="lineNum">     706 </span>            :     // point, when these clocks settle down, the inlined namespaces<span class="lineNum">     707 </span>            :     // can be removed.  XXX GLIBCXX_ABI Deprecated<span class="lineNum">     708 </span>            :     inline namespace _V2 {<span class="lineNum">     709 </span>            : <span class="lineNum">     710 </span>            :     /**<span class="lineNum">     711 </span>            :      *  @brief System clock.<span class="lineNum">     712 </span>            :      *<span class="lineNum">     713 </span>            :      *  Time returned represents wall time from the system-wide clock.<span class="lineNum">     714 </span>            :     */<span class="lineNum">     715 </span>            :      struct system_clock<span class="lineNum">     716 </span>            :     {<span class="lineNum">     717 </span>            :       typedef chrono::nanoseconds                               duration;<span class="lineNum">     718 </span>            :       typedef duration::rep                                     rep;<span class="lineNum">     719 </span>            :       typedef duration::period                                  period;<span class="lineNum">     720 </span>            :       typedef chrono::time_point&lt;system_clock, duration&gt;  time_point;<span class="lineNum">     721 </span>            : <span class="lineNum">     722 </span>            :       static_assert(system_clock::duration::min()<span class="lineNum">     723 </span>            :                     &lt; system_clock::duration::zero(),<span class="lineNum">     724 </span>            :                     &quot;a clock's minimum duration cannot be less than its epoch&quot;);<span class="lineNum">     725 </span>            : <span class="lineNum">     726 </span>            :       static constexpr bool is_steady = false;<span class="lineNum">     727 </span>            : <span class="lineNum">     728 </span>            :       static time_point<span class="lineNum">     729 </span>            :       now() noexcept;<span class="lineNum">     730 </span>            : <span class="lineNum">     731 </span>            :       // Map to C API<span class="lineNum">     732 </span>            :       static std::time_t<span class="lineNum">     733 </span>            :       to_time_t(const time_point&amp; __t) noexcept<span class="lineNum">     734 </span>            :       {<span class="lineNum">     735 </span>            :         return std::time_t(duration_cast&lt;chrono::seconds&gt;<span class="lineNum">     736 </span>            :                            (__t.time_since_epoch()).count());<span class="lineNum">     737 </span>            :       }<span class="lineNum">     738 </span>            : <span class="lineNum">     739 </span>            :       static time_point<span class="lineNum">     740 </span>            :       from_time_t(std::time_t __t) noexcept<span class="lineNum">     741 </span>            :       {<span class="lineNum">     742 </span>            :         typedef chrono::time_point&lt;system_clock, seconds&gt; __from;<span class="lineNum">     743 </span>            :         return time_point_cast&lt;system_clock::duration&gt;<span class="lineNum">     744 </span>            :                (__from(chrono::seconds(__t)));<span class="lineNum">     745 </span>            :       }<span class="lineNum">     746 </span>            :     };<span class="lineNum">     747 </span>            : <span class="lineNum">     748 </span>            : <span class="lineNum">     749 </span>            :     /**<span class="lineNum">     750 </span>            :      *  @brief Monotonic clock<span class="lineNum">     751 </span>            :      *<span class="lineNum">     752 </span>            :      *  Time returned has the property of only increasing at a uniform rate.<span class="lineNum">     753 </span>            :     */<span class="lineNum">     754 </span>            :     struct steady_clock<span class="lineNum">     755 </span>            :     {<span class="lineNum">     756 </span>            :       typedef chrono::nanoseconds                               duration;<span class="lineNum">     757 </span>            :       typedef duration::rep                                     rep;<span class="lineNum">     758 </span>            :       typedef duration::period                                  period;<span class="lineNum">     759 </span>            :       typedef chrono::time_point&lt;steady_clock, duration&gt;  time_point;<span class="lineNum">     760 </span>            : <span class="lineNum">     761 </span>            :       static constexpr bool is_steady = true;<span class="lineNum">     762 </span>            : <span class="lineNum">     763 </span>            :       static time_point<span class="lineNum">     764 </span>            :       now() noexcept;<span class="lineNum">     765 </span>            :     };<span class="lineNum">     766 </span>            : <span class="lineNum">     767 </span>            : <span class="lineNum">     768 </span>            :     /**<span class="lineNum">     769 </span>            :      *  @brief Highest-resolution clock<span class="lineNum">     770 </span>            :      *<span class="lineNum">     771 </span>            :      *  This is the clock &quot;with the shortest tick period.&quot; Alias to<span class="lineNum">     772 </span>            :      *  std::system_clock until higher-than-nanosecond definitions<span class="lineNum">     773 </span>            :      *  become feasible.<span class="lineNum">     774 </span>            :     */<span class="lineNum">     775 </span>            :     using high_resolution_clock = system_clock;<span class="lineNum">     776 </span>            : <span class="lineNum">     777 </span>            :   } // end inline namespace _V2<span class="lineNum">     778 </span>            : <span class="lineNum">     779 </span>            :   _GLIBCXX_END_NAMESPACE_VERSION<span class="lineNum">     780 </span>            :   } // namespace chrono<span class="lineNum">     781 </span>            : <span class="lineNum">     782 </span>            :   // @} group chrono<span class="lineNum">     783 </span>            : } // namespace<span class="lineNum">     784 </span>            : <span class="lineNum">     785 </span>            : #endif //_GLIBCXX_USE_C99_STDINT_TR1<span class="lineNum">     786 </span>            : <span class="lineNum">     787 </span>            : #endif // C++11<span class="lineNum">     788 </span>            : <span class="lineNum">     789 </span>            : #endif //_GLIBCXX_CHRONO</pre>      </td>    </tr>  </table>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/chrono.gcov/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/chrono.func/"/>
    <url>/2022/05/08/tool004/4.8.2/chrono.func/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/chrono - functions</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/chrono.func/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">4.8.2</a> - chrono<span style="font-size: 80%;"> (<a href="chrono.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/chrono.func/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/chrono.func/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/chrono.func/glass.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><a href="chrono.func-sort-c.html"><img src="/2022/05/08/tool004/4.8.2/chrono.func/updown.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></a></span></td>    </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#565">_ZNKSt6chrono10time_pointINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv</a></td>              <td class="coverFnHi">2</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#275">_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv</a></td>              <td class="coverFnHi">3</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#275">_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000EEE5countEv</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#191">_ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000000EEEElS2_ILl1ELl1000000000EEEENSt9enable_ifIXsrNS_13__is_durationIT_EE5valueES8_E4typeERKNS1_IT0_T1_EE</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#156">_ZNSt6chrono20__duration_cast_implINS_8durationIlSt5ratioILl1ELl1000000EEEES2_ILl1ELl1000EElLb1ELb0EE6__castIlS2_ILl1ELl1000000000EEEES4_RKNS1_IT_T0_EE</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#260">_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC1IlvEERKT_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#260">_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000EEEC1IlvEERKT_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#647">_ZNSt6chronomiINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIIT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#390">_ZNSt6chronomiIlSt5ratioILl1ELl1000000000EElS2_EENSt11common_typeIINS_8durationIT_T0_EENS4_IT1_T2_EEEE4typeERKS7_RKSA_</a></td>              <td class="coverFnHi">1</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/chrono.func/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/4.8.2/chrono.func-sort-c/"/>
    <url>/2022/05/08/tool004/4.8.2/chrono.func-sort-c/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info - 4.8.2/chrono - functions</title>  <link rel="stylesheet" type="text/css" href="../gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/chrono.func-sort-c/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">4.8.2</a> - chrono<span style="font-size: 80%;"> (<a href="chrono.gcov.html">source</a> / functions)</span></td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntry">14</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntry">9</td>            <td class="headerCovTableEntryHi">100.0 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/4.8.2/chrono.func-sort-c/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/chrono.func-sort-c/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="60%" cellpadding="1" cellspacing="1" border="0">    <tr><td><br></td></tr>    <tr>      <td width="80%" class="tableHead">Function Name <span class="tableHeadSort"><a href="chrono.func.html"><img src="/2022/05/08/tool004/4.8.2/chrono.func-sort-c/updown.png" width="10" height="14" alt="Sort by function name" title="Sort by function name" border="0"></a></span></td>      <td width="20%" class="tableHead">Hit count <span class="tableHeadSort"><img src="/2022/05/08/tool004/4.8.2/chrono.func-sort-c/glass.png" width="10" height="14" alt="Sort by hit count" title="Sort by hit count" border="0"></span></td>    </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#275">_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000EEE5countEv</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#191">_ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000000EEEElS2_ILl1ELl1000000000EEEENSt9enable_ifIXsrNS_13__is_durationIT_EE5valueES8_E4typeERKNS1_IT0_T1_EE</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#156">_ZNSt6chrono20__duration_cast_implINS_8durationIlSt5ratioILl1ELl1000000EEEES2_ILl1ELl1000EElLb1ELb0EE6__castIlS2_ILl1ELl1000000000EEEES4_RKNS1_IT_T0_EE</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#260">_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC1IlvEERKT_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#260">_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000EEEC1IlvEERKT_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#647">_ZNSt6chronomiINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIIT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#390">_ZNSt6chronomiIlSt5ratioILl1ELl1000000000EElS2_EENSt11common_typeIINS_8durationIT_T0_EENS4_IT1_T2_EEEE4typeERKS7_RKSA_</a></td>              <td class="coverFnHi">1</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#565">_ZNKSt6chrono10time_pointINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv</a></td>              <td class="coverFnHi">2</td>            </tr>    <tr>              <td class="coverFn"><a href="chrono.gcov.html#275">_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv</a></td>              <td class="coverFnHi">3</td>            </tr>  </table>  <br>  </center>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/4.8.2/chrono.func-sort-c/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/index-sort-l/"/>
    <url>/2022/05/08/tool004/index-sort-l/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info</title>  <link rel="stylesheet" type="text/css" href="gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/index-sort-l/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue">top level</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">612</td>            <td class="headerCovTableEntry">730</td>            <td class="headerCovTableEntryMed">83.8 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">148</td>            <td class="headerCovTableEntry">190</td>            <td class="headerCovTableEntryMed">77.9 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/index-sort-l/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/index-sort-l/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Directory <span class="tableHeadSort"><a href="index.html"><img src="/2022/05/08/tool004/index-sort-l/updown.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></a></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><img src="/2022/05/08/tool004/index-sort-l/glass.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><a href="index-sort-f.html"><img src="/2022/05/08/tool004/index-sort-l/updown.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></a></span></td>    </tr>    <tr>      <td class="coverFile"><a href="4.8.2/bits/index.html">4.8.2/bits</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index-sort-l/ruby.png" width="69" height="10" alt="68.7%"><img src="/2022/05/08/tool004/index-sort-l/snow.png" width="31" height="10" alt="68.7%"></td></tr></table>      </td>      <td class="coverPerLo">68.7&nbsp;%</td>      <td class="coverNumLo">228 / 332</td>      <td class="coverPerLo">73.8&nbsp;%</td>      <td class="coverNumLo">107 / 145</td>    </tr>    <tr>      <td class="coverFile"><a href="4.8.2/ext/index.html">4.8.2/ext</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index-sort-l/amber.png" width="75" height="10" alt="75.0%"><img src="/2022/05/08/tool004/index-sort-l/snow.png" width="25" height="10" alt="75.0%"></td></tr></table>      </td>      <td class="coverPerMed">75.0&nbsp;%</td>      <td class="coverNumMed">12 / 16</td>      <td class="coverPerMed">82.4&nbsp;%</td>      <td class="coverNumMed">14 / 17</td>    </tr>    <tr>      <td class="coverFile"><a href="root/study/test02/IPCC/index.html">/root/study/test02/IPCC</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index-sort-l/emerald.png" width="97" height="10" alt="97.3%"><img src="/2022/05/08/tool004/index-sort-l/snow.png" width="3" height="10" alt="97.3%"></td></tr></table>      </td>      <td class="coverPerHi">97.3&nbsp;%</td>      <td class="coverNumHi">355 / 365</td>      <td class="coverPerHi">94.4&nbsp;%</td>      <td class="coverNumHi">17 / 18</td>    </tr>    <tr>      <td class="coverFile"><a href="4.8.2/index.html">4.8.2</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index-sort-l/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">17 / 17</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">10 / 10</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/index-sort-l/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/index-sort-f/"/>
    <url>/2022/05/08/tool004/index-sort-f/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info</title>  <link rel="stylesheet" type="text/css" href="gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/index-sort-f/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue">top level</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">612</td>            <td class="headerCovTableEntry">730</td>            <td class="headerCovTableEntryMed">83.8 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">148</td>            <td class="headerCovTableEntry">190</td>            <td class="headerCovTableEntryMed">77.9 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/index-sort-f/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/index-sort-f/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Directory <span class="tableHeadSort"><a href="index.html"><img src="/2022/05/08/tool004/index-sort-f/updown.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></a></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><a href="index-sort-l.html"><img src="/2022/05/08/tool004/index-sort-f/updown.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></a></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><img src="/2022/05/08/tool004/index-sort-f/glass.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></span></td>    </tr>    <tr>      <td class="coverFile"><a href="4.8.2/bits/index.html">4.8.2/bits</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index-sort-f/ruby.png" width="69" height="10" alt="68.7%"><img src="/2022/05/08/tool004/index-sort-f/snow.png" width="31" height="10" alt="68.7%"></td></tr></table>      </td>      <td class="coverPerLo">68.7&nbsp;%</td>      <td class="coverNumLo">228 / 332</td>      <td class="coverPerLo">73.8&nbsp;%</td>      <td class="coverNumLo">107 / 145</td>    </tr>    <tr>      <td class="coverFile"><a href="4.8.2/ext/index.html">4.8.2/ext</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index-sort-f/amber.png" width="75" height="10" alt="75.0%"><img src="/2022/05/08/tool004/index-sort-f/snow.png" width="25" height="10" alt="75.0%"></td></tr></table>      </td>      <td class="coverPerMed">75.0&nbsp;%</td>      <td class="coverNumMed">12 / 16</td>      <td class="coverPerMed">82.4&nbsp;%</td>      <td class="coverNumMed">14 / 17</td>    </tr>    <tr>      <td class="coverFile"><a href="root/study/test02/IPCC/index.html">/root/study/test02/IPCC</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index-sort-f/emerald.png" width="97" height="10" alt="97.3%"><img src="/2022/05/08/tool004/index-sort-f/snow.png" width="3" height="10" alt="97.3%"></td></tr></table>      </td>      <td class="coverPerHi">97.3&nbsp;%</td>      <td class="coverNumHi">355 / 365</td>      <td class="coverPerHi">94.4&nbsp;%</td>      <td class="coverNumHi">17 / 18</td>    </tr>    <tr>      <td class="coverFile"><a href="4.8.2/index.html">4.8.2</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index-sort-f/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">17 / 17</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">10 / 10</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/index-sort-f/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/index/"/>
    <url>/2022/05/08/tool004/index/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head>  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">  <title>LCOV - SLIC.info</title>  <link rel="stylesheet" type="text/css" href="gcov.css"></head><body>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="title">LCOV - code coverage report</td></tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/index/glass.png" width="3" height="3" alt></td></tr>    <tr>      <td width="100%">        <table cellpadding="1" border="0" width="100%">          <tr>            <td width="10%" class="headerItem">Current view:</td>            <td width="35%" class="headerValue">top level</td>            <td width="5%"></td>            <td width="15%"></td>            <td width="10%" class="headerCovTableHead">Hit</td>            <td width="10%" class="headerCovTableHead">Total</td>            <td width="15%" class="headerCovTableHead">Coverage</td>          </tr>          <tr>            <td class="headerItem">Test:</td>            <td class="headerValue">SLIC.info</td>            <td></td>            <td class="headerItem">Lines:</td>            <td class="headerCovTableEntry">612</td>            <td class="headerCovTableEntry">730</td>            <td class="headerCovTableEntryMed">83.8 %</td>          </tr>          <tr>            <td class="headerItem">Date:</td>            <td class="headerValue">2022-05-07 20:52:35</td>            <td></td>            <td class="headerItem">Functions:</td>            <td class="headerCovTableEntry">148</td>            <td class="headerCovTableEntry">190</td>            <td class="headerCovTableEntryMed">77.9 %</td>          </tr>          <tr><td><img src="/2022/05/08/tool004/index/glass.png" width="3" height="3" alt></td></tr>        </table>      </td>    </tr>    <tr><td class="ruler"><img src="/2022/05/08/tool004/index/glass.png" width="3" height="3" alt></td></tr>  </table>  <center>  <table width="80%" cellpadding="1" cellspacing="1" border="0">    <tr>      <td width="50%"><br></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>      <td width="10%"></td>    </tr>    <tr>      <td class="tableHead">Directory <span class="tableHeadSort"><img src="/2022/05/08/tool004/index/glass.png" width="10" height="14" alt="Sort by name" title="Sort by name" border="0"></span></td>      <td class="tableHead" colspan="3">Line Coverage <span class="tableHeadSort"><a href="index-sort-l.html"><img src="/2022/05/08/tool004/index/updown.png" width="10" height="14" alt="Sort by line coverage" title="Sort by line coverage" border="0"></a></span></td>      <td class="tableHead" colspan="2">Functions <span class="tableHeadSort"><a href="index-sort-f.html"><img src="/2022/05/08/tool004/index/updown.png" width="10" height="14" alt="Sort by function coverage" title="Sort by function coverage" border="0"></a></span></td>    </tr>    <tr>      <td class="coverFile"><a href="root/study/test02/IPCC/index.html">/root/study/test02/IPCC</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index/emerald.png" width="97" height="10" alt="97.3%"><img src="/2022/05/08/tool004/index/snow.png" width="3" height="10" alt="97.3%"></td></tr></table>      </td>      <td class="coverPerHi">97.3&nbsp;%</td>      <td class="coverNumHi">355 / 365</td>      <td class="coverPerHi">94.4&nbsp;%</td>      <td class="coverNumHi">17 / 18</td>    </tr>    <tr>      <td class="coverFile"><a href="4.8.2/index.html">4.8.2</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index/emerald.png" width="100" height="10" alt="100.0%"></td></tr></table>      </td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">17 / 17</td>      <td class="coverPerHi">100.0&nbsp;%</td>      <td class="coverNumHi">10 / 10</td>    </tr>    <tr>      <td class="coverFile"><a href="4.8.2/bits/index.html">4.8.2/bits</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index/ruby.png" width="69" height="10" alt="68.7%"><img src="/2022/05/08/tool004/index/snow.png" width="31" height="10" alt="68.7%"></td></tr></table>      </td>      <td class="coverPerLo">68.7&nbsp;%</td>      <td class="coverNumLo">228 / 332</td>      <td class="coverPerLo">73.8&nbsp;%</td>      <td class="coverNumLo">107 / 145</td>    </tr>    <tr>      <td class="coverFile"><a href="4.8.2/ext/index.html">4.8.2/ext</a></td>      <td class="coverBar" align="center">        <table border="0" cellspacing="0" cellpadding="1"><tr><td class="coverBarOutline"><img src="/2022/05/08/tool004/index/amber.png" width="75" height="10" alt="75.0%"><img src="/2022/05/08/tool004/index/snow.png" width="25" height="10" alt="75.0%"></td></tr></table>      </td>      <td class="coverPerMed">75.0&nbsp;%</td>      <td class="coverNumMed">12 / 16</td>      <td class="coverPerMed">82.4&nbsp;%</td>      <td class="coverNumMed">14 / 17</td>    </tr>  </table>  </center>  <br>  <table width="100%" border="0" cellspacing="0" cellpadding="0">    <tr><td class="ruler"><img src="/2022/05/08/tool004/index/glass.png" width="3" height="3" alt></td></tr>    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV version 1.13</a></td></tr>  </table>  <br></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/08/tool004/gcov/"/>
    <url>/2022/05/08/tool004/gcov/</url>
    
    <content type="html"><![CDATA[/* All views: initial background and text color */body{  color: #000000;  background-color: #FFFFFF;}/* All views: standard link format*/a:link{  color: #284FA8;  text-decoration: underline;}/* All views: standard link - visited format */a:visited{  color: #00CB40;  text-decoration: underline;}/* All views: standard link - activated format */a:active{  color: #FF0040;  text-decoration: underline;}/* All views: main title format */td.title{  text-align: center;  padding-bottom: 10px;  font-family: sans-serif;  font-size: 20pt;  font-style: italic;  font-weight: bold;}/* All views: header item format */td.headerItem{  text-align: right;  padding-right: 6px;  font-family: sans-serif;  font-weight: bold;  vertical-align: top;  white-space: nowrap;}/* All views: header item value format */td.headerValue{  text-align: left;  color: #284FA8;  font-family: sans-serif;  font-weight: bold;  white-space: nowrap;}/* All views: header item coverage table heading */td.headerCovTableHead{  text-align: center;  padding-right: 6px;  padding-left: 6px;  padding-bottom: 0px;  font-family: sans-serif;  font-size: 80%;  white-space: nowrap;}/* All views: header item coverage table entry */td.headerCovTableEntry{  text-align: right;  color: #284FA8;  font-family: sans-serif;  font-weight: bold;  white-space: nowrap;  padding-left: 12px;  padding-right: 4px;  background-color: #DAE7FE;}/* All views: header item coverage table entry for high coverage rate */td.headerCovTableEntryHi{  text-align: right;  color: #000000;  font-family: sans-serif;  font-weight: bold;  white-space: nowrap;  padding-left: 12px;  padding-right: 4px;  background-color: #A7FC9D;}/* All views: header item coverage table entry for medium coverage rate */td.headerCovTableEntryMed{  text-align: right;  color: #000000;  font-family: sans-serif;  font-weight: bold;  white-space: nowrap;  padding-left: 12px;  padding-right: 4px;  background-color: #FFEA20;}/* All views: header item coverage table entry for ow coverage rate */td.headerCovTableEntryLo{  text-align: right;  color: #000000;  font-family: sans-serif;  font-weight: bold;  white-space: nowrap;  padding-left: 12px;  padding-right: 4px;  background-color: #FF0000;}/* All views: header legend value for legend entry */td.headerValueLeg{  text-align: left;  color: #000000;  font-family: sans-serif;  font-size: 80%;  white-space: nowrap;  padding-top: 4px;}/* All views: color of horizontal ruler */td.ruler{  background-color: #6688D4;}/* All views: version string format */td.versionInfo{  text-align: center;  padding-top: 2px;  font-family: sans-serif;  font-style: italic;}/* Directory view/File view (all)/Test case descriptions:   table headline format */td.tableHead{  text-align: center;  color: #FFFFFF;  background-color: #6688D4;  font-family: sans-serif;  font-size: 120%;  font-weight: bold;  white-space: nowrap;  padding-left: 4px;  padding-right: 4px;}span.tableHeadSort{  padding-right: 4px;}/* Directory view/File view (all): filename entry format */td.coverFile{  text-align: left;  padding-left: 10px;  padding-right: 20px;   color: #284FA8;  background-color: #DAE7FE;  font-family: monospace;}/* Directory view/File view (all): bar-graph entry format*/td.coverBar{  padding-left: 10px;  padding-right: 10px;  background-color: #DAE7FE;}/* Directory view/File view (all): bar-graph outline color */td.coverBarOutline{  background-color: #000000;}/* Directory view/File view (all): percentage entry for files with   high coverage rate */td.coverPerHi{  text-align: right;  padding-left: 10px;  padding-right: 10px;  background-color: #A7FC9D;  font-weight: bold;  font-family: sans-serif;}/* Directory view/File view (all): line count entry for files with   high coverage rate */td.coverNumHi{  text-align: right;  padding-left: 10px;  padding-right: 10px;  background-color: #A7FC9D;  white-space: nowrap;  font-family: sans-serif;}/* Directory view/File view (all): percentage entry for files with   medium coverage rate */td.coverPerMed{  text-align: right;  padding-left: 10px;  padding-right: 10px;  background-color: #FFEA20;  font-weight: bold;  font-family: sans-serif;}/* Directory view/File view (all): line count entry for files with   medium coverage rate */td.coverNumMed{  text-align: right;  padding-left: 10px;  padding-right: 10px;  background-color: #FFEA20;  white-space: nowrap;  font-family: sans-serif;}/* Directory view/File view (all): percentage entry for files with   low coverage rate */td.coverPerLo{  text-align: right;  padding-left: 10px;  padding-right: 10px;  background-color: #FF0000;  font-weight: bold;  font-family: sans-serif;}/* Directory view/File view (all): line count entry for files with   low coverage rate */td.coverNumLo{  text-align: right;  padding-left: 10px;  padding-right: 10px;  background-color: #FF0000;  white-space: nowrap;  font-family: sans-serif;}/* File view (all): "show/hide details" link format */a.detail:link{  color: #B8D0FF;  font-size:80%;}/* File view (all): "show/hide details" link - visited format */a.detail:visited{  color: #B8D0FF;  font-size:80%;}/* File view (all): "show/hide details" link - activated format */a.detail:active{  color: #FFFFFF;  font-size:80%;}/* File view (detail): test name entry */td.testName{  text-align: right;  padding-right: 10px;  background-color: #DAE7FE;  font-family: sans-serif;}/* File view (detail): test percentage entry */td.testPer{  text-align: right;  padding-left: 10px;  padding-right: 10px;   background-color: #DAE7FE;  font-family: sans-serif;}/* File view (detail): test lines count entry */td.testNum{  text-align: right;  padding-left: 10px;  padding-right: 10px;   background-color: #DAE7FE;  font-family: sans-serif;}/* Test case descriptions: test name format*/dt{  font-family: sans-serif;  font-weight: bold;}/* Test case descriptions: description table body */td.testDescription{  padding-top: 10px;  padding-left: 30px;  padding-bottom: 10px;  padding-right: 30px;  background-color: #DAE7FE;}/* Source code view: function entry */td.coverFn{  text-align: left;  padding-left: 10px;  padding-right: 20px;   color: #284FA8;  background-color: #DAE7FE;  font-family: monospace;}/* Source code view: function entry zero count*/td.coverFnLo{  text-align: right;  padding-left: 10px;  padding-right: 10px;  background-color: #FF0000;  font-weight: bold;  font-family: sans-serif;}/* Source code view: function entry nonzero count*/td.coverFnHi{  text-align: right;  padding-left: 10px;  padding-right: 10px;  background-color: #DAE7FE;  font-weight: bold;  font-family: sans-serif;}/* Source code view: source code format */pre.source{  font-family: monospace;  white-space: pre;  margin-top: 2px;}/* Source code view: line number format */span.lineNum{  background-color: #EFE383;}/* Source code view: format for lines which were executed */td.lineCov,span.lineCov{  background-color: #CAD7FE;}/* Source code view: format for Cov legend */span.coverLegendCov{  padding-left: 10px;  padding-right: 10px;  padding-bottom: 2px;  background-color: #CAD7FE;}/* Source code view: format for lines which were not executed */td.lineNoCov,span.lineNoCov{  background-color: #FF6230;}/* Source code view: format for NoCov legend */span.coverLegendNoCov{  padding-left: 10px;  padding-right: 10px;  padding-bottom: 2px;  background-color: #FF6230;}/* Source code view (function table): standard link - visited format */td.lineNoCov > a:visited,td.lineCov > a:visited{    color: black;  text-decoration: underline;}  /* Source code view: format for lines which were executed only in a   previous version */span.lineDiffCov{  background-color: #B5F7AF;}/* Source code view: format for branches which were executed * and taken */span.branchCov{  background-color: #CAD7FE;}/* Source code view: format for branches which were executed * but not taken */span.branchNoCov{  background-color: #FF6230;}/* Source code view: format for branches which were not executed */span.branchNoExec{  background-color: #FF6230;}/* Source code view: format for the source code heading line */pre.sourceHeading{  white-space: pre;  font-family: monospace;  font-weight: bold;  margin: 0px;}/* All views: header legend value for low rate */td.headerValueLegL{  font-family: sans-serif;  text-align: center;  white-space: nowrap;  padding-left: 4px;  padding-right: 2px;  background-color: #FF0000;  font-size: 80%;}/* All views: header legend value for med rate */td.headerValueLegM{  font-family: sans-serif;  text-align: center;  white-space: nowrap;  padding-left: 2px;  padding-right: 2px;  background-color: #FFEA20;  font-size: 80%;}/* All views: header legend value for hi rate */td.headerValueLegH{  font-family: sans-serif;  text-align: center;  white-space: nowrap;  padding-left: 2px;  padding-right: 4px;  background-color: #A7FC9D;  font-size: 80%;}/* All views except source code view: legend format for low coverage */span.coverLegendCovLo{  padding-left: 10px;  padding-right: 10px;  padding-top: 2px;  background-color: #FF0000;}/* All views except source code view: legend format for med coverage */span.coverLegendCovMed{  padding-left: 10px;  padding-right: 10px;  padding-top: 2px;  background-color: #FFEA20;}/* All views except source code view: legend format for hi coverage */span.coverLegendCovHi{  padding-left: 10px;  padding-right: 10px;  padding-top: 2px;  background-color: #A7FC9D;}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>gcov代码覆盖率测试-完整样例-SLIC</title>
    <link href="/2022/05/08/tool004/"/>
    <url>/2022/05/08/tool004/</url>
    
    <content type="html"><![CDATA[<h2 id="gcov代码覆盖率测试-完整样例-SLIC"><a href="#gcov代码覆盖率测试-完整样例-SLIC" class="headerlink" title="gcov代码覆盖率测试-完整样例-SLIC"></a>gcov代码覆盖率测试-完整样例-SLIC</h2><h3 id="gcov代码覆盖率测试介绍："><a href="#gcov代码覆盖率测试介绍：" class="headerlink" title="gcov代码覆盖率测试介绍："></a>gcov代码覆盖率测试介绍：</h3><p><a href="https://xingyuanjie.top/2022/01/18/tool002/">gcov代码覆盖率测试 - 计算机奇妙之旅 (xingyuanjie.top)</a></p><h3 id="完整样例-SLIC："><a href="#完整样例-SLIC：" class="headerlink" title="完整样例-SLIC："></a>完整样例-SLIC：</h3>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
      <tag>gcov</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的存储</title>
    <link href="/2022/05/06/Algorithm037/"/>
    <url>/2022/05/06/Algorithm037/</url>
    
    <content type="html"><![CDATA[<h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxVertexNum 100<span class="hljs-comment">//顶点数目的最大值</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> VertexType;<span class="hljs-comment">//顶点的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> EdgeType;<span class="hljs-comment">//带权图中边上权值的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    VertexType Vex[MaxVertexNum];<span class="hljs-comment">//顶点表</span><br>    EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="hljs-comment">//邻接矩阵，边表</span><br>    <span class="hljs-keyword">int</span> vexnum,arcnum;<span class="hljs-comment">//图中当前顶点数和弧数</span><br>&#125;MGraph;<br></code></pre></td></tr></table></figure><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxVertexNum 100<span class="hljs-comment">//图中顶点数目的最大值</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>&#123;</span><span class="hljs-comment">//边表结点</span><br>    <span class="hljs-keyword">int</span> adjvex;<span class="hljs-comment">//该弧所指向的顶点的位置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一条弧的指针</span><br>    <span class="hljs-comment">//InfoType infp;//网的边权值</span><br>&#125;ArcNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VNode</span>&#123;</span><span class="hljs-comment">//顶点表结点</span><br>    VertexType data;<span class="hljs-comment">//顶点信息</span><br>    ArcNode *first;<span class="hljs-comment">//指向第一条依附该顶点的弧的指针</span><br>&#125;VNode,AdjList[MaxVertexNum];<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    AdjList vertices;<span class="hljs-comment">//邻接表</span><br>    <span class="hljs-keyword">int</span> vexnum,arcnum;<span class="hljs-comment">//图的顶点数和弧数</span><br>&#125;ALGraph;<span class="hljs-comment">//ALGraph是以邻接表存储的图的类型</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树、森林</title>
    <link href="/2022/05/05/Algorithm036/"/>
    <url>/2022/05/05/Algorithm036/</url>
    
    <content type="html"><![CDATA[<h2 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TREE_SIZE 100<span class="hljs-comment">//树中最多节点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//树的结点定义</span><br>    ElemType data;<span class="hljs-comment">//数据元素</span><br>    <span class="hljs-keyword">int</span> parent;<span class="hljs-comment">//双亲位置域</span><br>&#125;PTNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//树的类型定义</span><br>    PTNode nodes[MAX_TREE_SIZE];<span class="hljs-comment">//双亲表示</span><br>    <span class="hljs-keyword">int</span> n;<span class="hljs-comment">//节点数</span><br>&#125;PTree;<br></code></pre></td></tr></table></figure><h4 id="孩子兄弟法"><a href="#孩子兄弟法" class="headerlink" title="孩子兄弟法"></a>孩子兄弟法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> *<span class="hljs-title">firstchild</span>,*<span class="hljs-title">nextsibling</span>;</span><span class="hljs-comment">//第一个孩子和右兄弟指针</span><br>&#125;CSNode,*CSTree;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Tree</tag>
      
      <tag>森林</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线索二叉树</title>
    <link href="/2022/05/04/Algorithm035/"/>
    <url>/2022/05/04/Algorithm035/</url>
    
    <content type="html"><![CDATA[<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h3><p>线索二叉树的存储结构描述如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ltag = <span class="hljs-number">0</span> lchild域指示结点的左孩子<br>ltag = <span class="hljs-number">1</span> lchild域指示结点的前驱<br><span class="hljs-comment">//</span><br>rtag = <span class="hljs-number">0</span> rchild域指示结点的右孩子<br>rtag = <span class="hljs-number">1</span> rchild域指示结点的后继<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>    <span class="hljs-keyword">int</span> ltag,rtag;<span class="hljs-comment">//左右线索标志</span><br>&#125;ThreadNode，*ThreadTree;<br></code></pre></td></tr></table></figure><h3 id="中序线索二叉树的构造"><a href="#中序线索二叉树的构造" class="headerlink" title="中序线索二叉树的构造"></a>中序线索二叉树的构造</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InThread</span><span class="hljs-params">(ThreadTree &amp;p,ThreadNode &amp;pre)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">InThread</span>(p-&gt;lchild,pre);<span class="hljs-comment">//递归，线索化左子树</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;lchild==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//左子树为空，建立前驱线索</span><br>                p-&gt;lchild=pre;<br>                p-&gt;ltag=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="hljs-literal">NULL</span>)&#123;<br>                pre-&gt;rchild=p;<span class="hljs-comment">//建立前驱结点的后继线索</span><br>                pre-&gt;rtag=<span class="hljs-number">1</span>;<br>            &#125;<br>            pre=p;<span class="hljs-comment">//标记当前结点成为刚刚访问过的结点</span><br>            <span class="hljs-built_in">InThread</span>(p-&gt;rchild,pre);<span class="hljs-comment">//递归，线索化右子树</span><br>        &#125;<span class="hljs-comment">//if(p!=NULL)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateInThread</span><span class="hljs-params">(ThreadTree T)</span></span>&#123;<br>    ThreadTree pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//非空二叉树。线索化</span><br>        <span class="hljs-built_in">InThread</span>(T,pre);<span class="hljs-comment">//线索化二叉树</span><br>        pre-&gt;rchild=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//处理遍历的最后一个结点</span><br>        pre-&gt;rtag=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序线索二叉树的遍历"><a href="#中序线索二叉树的遍历" class="headerlink" title="中序线索二叉树的遍历"></a>中序线索二叉树的遍历</h3><p>1)求中序线索二叉树中中序序列下的第一个结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Thread *<span class="hljs-title">Firstnode</span><span class="hljs-params">(ThreadNode *p)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(p-&gt;ltag==<span class="hljs-number">0</span>) p=p-&gt;lchild;<span class="hljs-comment">//最左下结点（不一定是叶结点）</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>2)求中序线索二叉树中结点p在中序序列下的后继</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ThreadNode *<span class="hljs-title">Nextnode</span><span class="hljs-params">(ThreadNode *p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;rtag==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Firstnode</span>(p-&gt;rchild);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p-&gt;rchild;<span class="hljs-comment">//rtag==1直接返回后继线索</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3)利用上面两个算法，可以写出不含头节点的中序线索二叉树的中序遍历算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Inorder</span><span class="hljs-params">(ThreadNode *T)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(ThreadNode *p=Firstnode;p!=<span class="hljs-literal">NULL</span>;p=<span class="hljs-built_in">Nextnode</span>(p))<br>        <span class="hljs-built_in">visit</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Binary tree</tag>
      
      <tag>线索二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串的模式匹配算法-KMP算法</title>
    <link href="/2022/04/27/Algorithm034/"/>
    <url>/2022/04/27/Algorithm034/</url>
    
    <content type="html"><![CDATA[<h2 id="串的模式匹配算法-KMP算法"><a href="#串的模式匹配算法-KMP算法" class="headerlink" title="串的模式匹配算法-KMP算法"></a>串的模式匹配算法-KMP算法</h2><h3 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(SSting t,<span class="hljs-keyword">int</span> next[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;t.length)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||t.ch[i]==t.ch[j])<br>        &#123;<br>            i++;<br>            j++;<br>            next[i]=j;      <span class="hljs-comment">//若pi=pj,则next[j+i]=next[j]+1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j=next[j];      <span class="hljs-comment">//否则令j=next[j]，循环继续</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="KMP匹配算法"><a href="#KMP匹配算法" class="headerlink" title="KMP匹配算法"></a>KMP匹配算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Index_KMP</span><span class="hljs-params">(SSting s,SSting t,<span class="hljs-keyword">int</span> next[])</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i&lt;=s.length&amp;&amp;j&lt;=t.length)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||s.ch[i]==t.ch[j])<br>        &#123;<br>            j++;                    <span class="hljs-comment">//继续比较后续字符</span><br>            i++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j=next[j];              <span class="hljs-comment">//模式串向右移动</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;t.length)<br>    &#123;<br>        <span class="hljs-keyword">return</span> i-t.length;          <span class="hljs-comment">//匹配成功</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLEN 255<span class="hljs-comment">//预定义最大串长</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">char</span> ch[MAXLEN];<span class="hljs-comment">//每个分量存储一个字符</span><br>    <span class="hljs-keyword">int</span> length;<span class="hljs-comment">//串的实际长度</span><br>&#125;SSting;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(SSting t,<span class="hljs-keyword">int</span> next[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;t.length)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||t.ch[i]==t.ch[j])<br>        &#123;<br>            i++;<br>            j++;<br>            next[i]=j;      <span class="hljs-comment">//若pi=pj,则next[j+i]=next[j]+1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j=next[j];      <span class="hljs-comment">//否则令j=next[j]，循环继续</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Index_KMP</span><span class="hljs-params">(SSting s,SSting t,<span class="hljs-keyword">int</span> next[])</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i&lt;=s.length&amp;&amp;j&lt;=t.length)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||s.ch[i]==t.ch[j])<br>        &#123;<br>            j++;                    <span class="hljs-comment">//继续比较后续字符</span><br>            i++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j=next[j];              <span class="hljs-comment">//模式串向右移动</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;t.length)<br>    &#123;<br>        <span class="hljs-keyword">return</span> i-t.length;          <span class="hljs-comment">//匹配成功</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SSting a,b;<br>    string s1=<span class="hljs-string">&quot;ababcabcacbab&quot;</span>;<br>    string s2=<span class="hljs-string">&quot;abcac&quot;</span>;<br>    a.length=s1.<span class="hljs-built_in">size</span>();<br>    b.length=s2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> next[s2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">get_next</span>(b,next);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;s1.<span class="hljs-built_in">size</span>(); ++i) &#123;<span class="hljs-comment">//初始化</span><br>        a.ch[i+<span class="hljs-number">1</span>]=s1[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;s2.<span class="hljs-built_in">size</span>() ; ++j) &#123;<span class="hljs-comment">//初始化</span><br>        b.ch[j+<span class="hljs-number">1</span>]=s2[j];<br>    &#125;<br>    <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">Index_KMP</span>(a,b,next);<br>    <span class="hljs-keyword">if</span>(x!=<span class="hljs-number">0</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;找到了位置是：&quot;</span>&lt;&lt;x&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;没有找到&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">找到了位置是：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>String</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串-简单的模式匹配算法</title>
    <link href="/2022/04/27/Algorithm033/"/>
    <url>/2022/04/27/Algorithm033/</url>
    
    <content type="html"><![CDATA[<h2 id="串-简单的模式匹配算法"><a href="#串-简单的模式匹配算法" class="headerlink" title="串-简单的模式匹配算法"></a>串-简单的模式匹配算法</h2><h3 id="简单的模式匹配算法"><a href="#简单的模式匹配算法" class="headerlink" title="简单的模式匹配算法"></a>简单的模式匹配算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(SSting s,SSting t)</span>        <span class="hljs-comment">//简单的模式匹配算法</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=s.length &amp;&amp; j&lt;= t.length)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s.ch[i]==t.ch[j])<br>        &#123;<br>            i++;                      <span class="hljs-comment">//继续比较后继字符</span><br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;                        <span class="hljs-comment">//指针后退重新开始匹配</span><br>            i=i-j+<span class="hljs-number">2</span>;                  <span class="hljs-comment">//每次匹配失败后，都把模式t后移一位</span><br>            j=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;t.length) <span class="hljs-keyword">return</span> i-t.length;           <span class="hljs-comment">//返回与模式t中第一个字符相等的字符在主串s中的序号</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整程序源代码"><a href="#完整程序源代码" class="headerlink" title="完整程序源代码"></a>完整程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLEN 255<span class="hljs-comment">//预定义最大串长</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">char</span> ch[MAXLEN];<span class="hljs-comment">//每个分量存储一个字符</span><br>    <span class="hljs-keyword">int</span> length;<span class="hljs-comment">//串的实际长度</span><br>&#125;SSting;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(SSting s,SSting t)</span>        <span class="hljs-comment">//简单的模式匹配算法</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=s.length &amp;&amp; j&lt;= t.length)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s.ch[i]==t.ch[j])<br>        &#123;<br>            i++;                      <span class="hljs-comment">//继续比较后继字符</span><br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;                        <span class="hljs-comment">//指针后退重新开始匹配</span><br>            i=i-j+<span class="hljs-number">2</span>;                  <span class="hljs-comment">//每次匹配失败后，都把模式t后移一位</span><br>            j=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;t.length) <span class="hljs-keyword">return</span> i-t.length;           <span class="hljs-comment">//返回与模式t中第一个字符相等的字符在主串s中的序号</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SSting a,b;<br>    string s1=<span class="hljs-string">&quot;ababcabcacbab&quot;</span>;<br>    string s2=<span class="hljs-string">&quot;abcac&quot;</span>;<br>    a.length=s1.<span class="hljs-built_in">size</span>();<br>    b.length=s2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;s1.<span class="hljs-built_in">size</span>(); ++i) &#123;<span class="hljs-comment">//初始化</span><br>        a.ch[i+<span class="hljs-number">1</span>]=s1[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;s2.<span class="hljs-built_in">size</span>() ; ++j) &#123;<span class="hljs-comment">//初始化</span><br>        b.ch[j+<span class="hljs-number">1</span>]=s2[j];<br>    &#125;<br>    <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">Index</span>(a,b);<br>    <span class="hljs-keyword">if</span>(x!=<span class="hljs-number">0</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;找到了位置是：&quot;</span>&lt;&lt;x&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;没有找到&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">找到了位置是：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-036 网红点打卡攻略 (25 分)</title>
    <link href="/2022/04/23/Algorithm032/"/>
    <url>/2022/04/23/Algorithm032/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-036-网红点打卡攻略-25-分"><a href="#L2-036-网红点打卡攻略-25-分" class="headerlink" title="L2-036 网红点打卡攻略 (25 分)"></a>L2-036 网红点打卡攻略 (25 分)</h2><p>一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个正整数：网红点的个数 <em>N</em>（1&lt;<em>N</em>≤200）和网红点之间通路的条数 <em>M</em>。随后 <em>M</em> 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 <em>N</em> 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 <code>0</code>。</p><p>再下一行给出一个正整数 <em>K</em>，是待检验的攻略的数量。随后 <em>K</em> 行，每行给出一条待检攻略，格式为：</p><p><em>n</em> <em>V</em>1 <em>V</em>2 ⋯ Vn</p><p>其中 <em>n</em>(≤200) 是攻略中的网红点数，<em>Vi</em> 是路径上的网红点编号。这里假设你从家里出发，从 <em>V</em>1 开始打卡，最后从 <em>Vn</em> 回家。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在第一行输出满足要求的攻略的个数。</p><p>在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。</p><p>题目保证至少存在一个有效攻略，并且总路费不超过 109。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs in">6 13<br>0 5 2<br>6 2 2<br>6 0 1<br>3 4 2<br>1 5 2<br>2 5 1<br>3 1 1<br>4 1 2<br>1 6 1<br>6 3 2<br>1 2 1<br>4 5 3<br>2 0 2<br>7<br>6 5 1 4 3 6 2<br>6 5 2 1 6 3 4<br>8 6 2 1 6 3 4 5 2<br>3 2 1 5<br>6 6 1 3 4 5 2<br>7 6 2 1 3 4 5 2<br>6 5 2 1 4 3 6<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">3<br>5 11<br></code></pre></td></tr></table></figure><h3 id="样例说明："><a href="#样例说明：" class="headerlink" title="样例说明："></a>样例说明：</h3><p>第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。</p><p>第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 = 14；</p><p>第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 = 11，是一条更省钱的攻略；</p><p>第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 = 11，与第 5 条花费相同，但序号较大，所以不输出。</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<br><span class="hljs-keyword">int</span> minsize=INT_MAX;<span class="hljs-comment">//初始化为INT_MAX</span><br><span class="hljs-keyword">int</span> minid=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b]=c;<br>        g[b][a]=c;<br>    &#125;<br>    <span class="hljs-keyword">int</span> time;<br>    cin&gt;&gt;time;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-keyword">int</span> roll[k+<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">int</span> has[k+<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">memset</span>(has,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(has));<br>        roll[<span class="hljs-number">0</span>]=roll[k+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//起点和终点必定是家</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=k ; ++i) &#123;<br>            cin&gt;&gt;roll[i];<br>            <span class="hljs-keyword">if</span>(has[roll[i]]) has[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//每个打卡点仅能打卡一次</span><br>            <span class="hljs-keyword">else</span> has[roll[i]]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> tmpsize=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(k!=n||has[<span class="hljs-number">0</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=k+<span class="hljs-number">1</span> ; ++l) &#123;<br>            <span class="hljs-keyword">if</span>(g[roll[l<span class="hljs-number">-1</span>]][roll[l]]==<span class="hljs-number">0</span>)<br>            &#123;<br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tmpsize+=g[roll[l<span class="hljs-number">-1</span>]][roll[l]];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmpsize&lt;minsize)&#123;<br>                minsize=tmpsize;<br>                minid=j+<span class="hljs-number">1</span>;<br><br>            &#125;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    cout&lt;&lt;minid&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;minsize&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059">题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-039 清点代码库 (25 分)</title>
    <link href="/2022/04/23/Algorithm031/"/>
    <url>/2022/04/23/Algorithm031/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-039-清点代码库-25-分"><a href="#L2-039-清点代码库-25-分" class="headerlink" title="L2-039 清点代码库 (25 分)"></a>L2-039 清点代码库 (25 分)</h2><p><img src="/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg" alt="code.jpg"></p><p>上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”</p><p>这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 <strong>int</strong> 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出 2 个正整数，依次为 <em>N</em>（≤104）和 <em>M</em>（≤102），对应功能模块的个数和系列测试输入的个数。</p><p>随后 <em>N</em> 行，每行给出一个功能模块的 <em>M</em> 个对应输出，数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第一行输出不同功能的个数 <em>K</em>。随后 <em>K</em> 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。</p><p>注：所谓数列 { <em>A</em>1, …, <em>A</em>M } 比 { <em>B</em>1, …, <em>B</em>M } 大，是指存在 1≤i&lt;*M*，使得 *A*1=*B*1，…，*Ai*=*Bi* 成立，且 *Ai*+1&gt;<em>B</em>+1。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs in">7 3<br>35 28 74<br>-1 -1 22<br>28 74 35<br>-1 -1 22<br>11 66 0<br>35 28 74<br>35 28 74<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs out">4<br>3 35 28 74<br>2 -1 -1 22<br>1 11 66 0<br>1 28 74 35<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>利用map的映射关系</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; mp;   <span class="hljs-comment">//key，value</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; a,pair&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.second==b.second)<br>    &#123;<br>        <span class="hljs-keyword">return</span> a.first&lt;b.first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.second&gt;b.second;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            tmp.<span class="hljs-built_in">push_back</span>(num);<br>        &#125;<br>        mp[tmp]++;<br>        tmp.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    vector&lt;pair&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">v</span>(mp.<span class="hljs-built_in">begin</span>(),mp.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//把map类型转化成vector</span><br>    cout&lt;&lt;v.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmp);<span class="hljs-comment">//sort排序，注意终点和起点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;v.<span class="hljs-built_in">size</span>() ; ++k) &#123;<br>        cout&lt;&lt;v[k].second&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(i!=m<span class="hljs-number">-1</span>)&#123;<br>                cout&lt;&lt;v[k].first[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;v[k].first[i]&lt;&lt;endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362">题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>Vector</tag>
      
      <tag>Map</tag>
      
      <tag>Pair</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-005 集合相似度 (25 分)</title>
    <link href="/2022/04/23/Algorithm030/"/>
    <url>/2022/04/23/Algorithm030/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-005-集合相似度-25-分"><a href="#L2-005-集合相似度-25-分" class="headerlink" title="L2-005 集合相似度 (25 分)"></a>L2-005 集合相似度 (25 分)</h2><p>给定两个整数集合，它们的相似度定义为：Nc/Nt×100%。其中Nc是两个集合都有的不相等整数的个数，Nt是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤50），是集合的个数。随后<em>N</em>行，每行对应一个集合。每个集合首先给出一个正整数<em>M</em>（≤104），是集合中元素的个数；然后跟<em>M</em>个[0,109]区间内的整数。</p><p>之后一行给出一个正整数<em>K</em>（≤2000），随后<em>K</em>行，每行对应一对需要计算相似度的集合的编号（集合从1到<em>N</em>编号）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>3 99 87 101<br>4 87 101 5 87<br>7 99 101 18 5 135 18 99<br>2<br>1 2<br>1 3<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">50.00%<br>33.33%<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>双set模拟</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    set&lt;<span class="hljs-keyword">int</span>&gt; s[<span class="hljs-number">55</span>];<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            s[i].<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> find;<br>    cin&gt;&gt;find;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;find ; ++l) &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        set&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br>        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (it=s[a<span class="hljs-number">-1</span>].<span class="hljs-built_in">begin</span>(); it!=s[a<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>() ; it++) &#123;<br>            <span class="hljs-keyword">if</span>(s[b<span class="hljs-number">-1</span>].<span class="hljs-built_in">find</span>(*it)!=s[b<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//找到了</span><br>                cnt++;<span class="hljs-comment">//Nc</span><br>            &#125;<br>        &#125;<br>        sum=s[a<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>()+s[b<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>()-cnt;<span class="hljs-comment">//Nt=两个集合的总个数-相同个数</span><br>        <span class="hljs-keyword">double</span> ans=<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(cnt)/<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(sum))*<span class="hljs-number">100.0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf%\n&quot;</span>,ans);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805070149828608">题目详情 - L2-005 集合相似度 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL中map的使用</title>
    <link href="/2022/04/16/Algorithm029/"/>
    <url>/2022/04/16/Algorithm029/</url>
    
    <content type="html"><![CDATA[<h2 id="STL中map的使用"><a href="#STL中map的使用" class="headerlink" title="STL中map的使用"></a>STL中map的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>map 是 STL 的一个关联容器，它提供一对一的数据处理能力。</p><p>map 对象是<strong>模板类</strong>，需要<strong>关键字</strong>和<strong>存储对象</strong>两个模板参数：其中第一个参数称为关键字，每个关键字只能在 map 中出现一次；第二个参数称为该关键字的值。可以将关键字和存储对象理解为“{键，值}对”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt; mp;<br></code></pre></td></tr></table></figure><h3 id="map的数据插入操作"><a href="#map的数据插入操作" class="headerlink" title="map的数据插入操作"></a>map的数据插入操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//使用insert函数插入pair数据</span><br>mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;xingyuanjie&quot;</span>));<br><span class="hljs-comment">//使用数组方式插入数据</span><br>mp[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;wangzhouyang&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>说明：上面的两种方法是有区别的，用 insert 函数插入数据，涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能实现数据插入的；但是数组方式能够插入数据，插入的数据会覆盖该关键字之前对应的值。</strong></p><h3 id="map中数据的遍历"><a href="#map中数据的遍历" class="headerlink" title="map中数据的遍历"></a>map中数据的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br><span class="hljs-keyword">for</span> (it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++) &#123;<br>    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map中数据的查找"><a href="#map中数据的查找" class="headerlink" title="map中数据的查找"></a>map中数据的查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br>it=mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(it!=mp.<span class="hljs-built_in">end</span>())&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Find it, the relative value is: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;Can not find the relative value.&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map中数据的删除"><a href="#map中数据的删除" class="headerlink" title="map中数据的删除"></a>map中数据的删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br>it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br>mp.<span class="hljs-built_in">erase</span>(it);<br></code></pre></td></tr></table></figure><h3 id="map中数据的排序"><a href="#map中数据的排序" class="headerlink" title="map中数据的排序"></a>map中数据的排序</h3><p><strong>map 中的所有元素都会根据元素的键值，自动进行升序排序。</strong></p><h3 id="完整操作"><a href="#完整操作" class="headerlink" title="完整操作"></a>完整操作</h3><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;<span class="hljs-keyword">int</span>,string&gt; mp;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//使用insert函数插入pair数据</span><br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;xingyuanjie&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;shicheng&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;tanghaipeng&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;zhouyuhao&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;heqichuan&quot;</span>));<br>    <span class="hljs-comment">//使用数组方式插入数据</span><br>    mp[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;wangzhouyang&quot;</span>;<br>    <span class="hljs-comment">//map的遍历</span><br>    map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<br>    <span class="hljs-keyword">for</span> (it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++) &#123;<br>        cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//查找操作</span><br>    it=mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(it!=mp.<span class="hljs-built_in">end</span>())&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Find it, the relative value is: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Can not find the relative value.&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//删除操作</span><br>    it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br>    mp.<span class="hljs-built_in">erase</span>(it);<br>    <span class="hljs-keyword">for</span> (it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++) &#123;<br>        cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span> shicheng<br><span class="hljs-number">2</span> wangzhouyang<br><span class="hljs-number">3</span> xingyuanjie<br><span class="hljs-number">4</span> tanghaipeng<br><span class="hljs-number">5</span> heqichuan<br><span class="hljs-number">6</span> zhouyuhao<br>Find it, the relative value is: shicheng<br><span class="hljs-number">1</span> shicheng<br><span class="hljs-number">3</span> xingyuanjie<br><span class="hljs-number">4</span> tanghaipeng<br><span class="hljs-number">5</span> heqichuan<br><span class="hljs-number">6</span> zhouyuhao<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/liitdar/article/details/80009712">(20条消息) STL中map介绍_liitdar的博客-CSDN博客_stlmap</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-010 排座位 (25 分)</title>
    <link href="/2022/04/16/Algorithm028/"/>
    <url>/2022/04/16/Algorithm028/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-010-排座位-25-分"><a href="#L2-010-排座位-25-分" class="headerlink" title="L2-010 排座位 (25 分)"></a><strong>L2-010 排座位 (25 分)</strong></h2><p>布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出3个正整数：<code>N</code>（≤100），即前来参宴的宾客总人数，则这些人从1到<code>N</code>编号；<code>M</code>为已知两两宾客之间的关系数；<code>K</code>为查询的条数。随后<code>M</code>行，每行给出一对宾客之间的关系，格式为：<code>宾客1 宾客2 关系</code>，其中<code>关系</code>为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后<code>K</code>行，每行给出一对需要查询的宾客编号。</p><p>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出<code>No problem</code>；如果他们之间并不是朋友，但也不敌对，则输出<code>OK</code>；如果他们之间有敌对，然而也有共同的朋友，则输出<code>OK but...</code>；如果他们之间只有敌对关系，则输出<code>No way</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs in">7 8 4<br>5 6 1<br>2 7 -1<br>1 3 1<br>3 4 1<br>6 7 -1<br>1 2 1<br>1 4 1<br>2 3 -1<br>3 4<br>5 7<br>2 3<br>7 2<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs out">No problem<br>OK<br>OK but...<br>No way<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接矩阵 + 并查集</strong></p><p><strong>并查集具体链接：</strong></p><p><a href="https://xingyuanjie.top/2022/01/04/Algorithm004/">并查集 - 计算机奇妙之旅 (xingyuanjie.top)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> pre[<span class="hljs-number">100</span>];<span class="hljs-comment">//父节点</span><br><span class="hljs-keyword">int</span> deep[<span class="hljs-number">100</span>];<span class="hljs-comment">//深度</span><br><span class="hljs-keyword">int</span> g[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<span class="hljs-comment">//邻接矩阵建图</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        pre[i]=i;<br>        deep[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(pre[x]==x)&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> pre[x]=<span class="hljs-built_in">find</span>(pre[x]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    x=<span class="hljs-built_in">find</span>(x);<br>    y=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(deep[x]&lt;deep[y])&#123;<br>        pre[x]=y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        pre[y]=x;<br>        <span class="hljs-keyword">if</span>(deep[x]==deep[y])&#123;<br>            deep[x]++;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m,k;<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">105</span>);<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b]=g[b][a]=c;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-number">1</span>) <span class="hljs-built_in">unit</span>(a,b);<span class="hljs-comment">//如果是朋友则合并</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;k ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">1</span>&amp;&amp;g[b][a]==<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;No problem&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">0</span>&amp;&amp;g[b][a]==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;OK&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//两人毫无关系</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">-1</span>&amp;&amp;g[b][a]==<span class="hljs-number">-1</span>&amp;&amp;<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b)) cout&lt;&lt;<span class="hljs-string">&quot;OK but...&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//敌对且有共同朋友</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">-1</span>&amp;&amp;g[b][a]==<span class="hljs-number">-1</span>) cout&lt;&lt;<span class="hljs-string">&quot;No way&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//仅敌对</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/weixin_45260385/article/details/109752008">(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680">题目详情 - L2-010 排座位 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-009 抢红包 (25 分)</title>
    <link href="/2022/04/16/Algorithm027/"/>
    <url>/2022/04/16/Algorithm027/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-009-抢红包-25-分"><a href="#L2-009-抢红包-25-分" class="headerlink" title="L2-009 抢红包 (25 分)"></a><strong>L2-009 抢红包 (25 分)</strong></h2><p>没有人没抢过红包吧…… 这里给出<em>N</em>个人之间互相发红包、抢红包的记录，请你统计一下他们抢红包的收获。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤104），即参与发红包和抢红包的总人数，则这些人从1到<em>N</em>编号。随后<em>N</em>行，第<em>i</em>行给出编号为<em>i</em>的人发红包的记录，格式如下：</p><p><em>K     N</em>1 <em>P</em>1⋯ NK PK</p><p>其中<em>K</em>（0≤<em>K</em>≤20）是发出去的红包个数，<em>N</em>i<em>是抢到红包的人的编号，</em>Pi（&gt;0）是其抢到的红包金额（以分为单位）。注意：对于同一个人发出的红包，每人最多只能抢1次，不能重复抢。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照收入金额从高到低的递减顺序输出每个人的编号和收入金额（以元为单位，输出小数点后2位）。每个人的信息占一行，两数字间有1个空格。如果收入金额有并列，则按抢到红包的个数递减输出；如果还有并列，则按个人编号递增输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs in">10<br>3 2 22 10 58 8 125<br>5 1 345 3 211 5 233 7 13 8 101<br>1 7 8800<br>2 1 1000 2 1000<br>2 4 250 10 320<br>6 5 11 9 22 8 33 7 44 10 55 4 2<br>1 3 8800<br>2 1 23 2 123<br>1 8 250<br>4 2 121 4 516 7 112 9 10<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs out">1 11.63<br>2 3.63<br>8 3.63<br>3 2.11<br>7 1.69<br>6 -1.67<br>9 -2.18<br>10 -3.26<br>5 -3.26<br>4 -12.32<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>结构体 + Sort</strong></p><p><strong>需要注意的就是double类型相等的比较</strong></p><p><strong>首先，浮点数在计算机中并不能精确的表示，所以在判断两个double类型的数时需要其他的手段，而不是直接 a== b</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-keyword">int</span> id=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> money=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">double</span> dis=<span class="hljs-number">1e-6</span>;<span class="hljs-comment">//定义一个误差</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(student a,student b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a.money-b.money)&lt;dis)&#123;<span class="hljs-comment">//如果两个double型相减在误差的范围内，我们认定这两个double类型相等</span><br>        <span class="hljs-keyword">if</span>(a.cnt==b.cnt)&#123;<br>            <span class="hljs-keyword">return</span> a.id&lt;b.id;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> a.cnt&gt;b.cnt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.money&gt;b.money;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    student st[n+<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        st[i].id=i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> p;<br>            <span class="hljs-keyword">double</span> x;<br>            cin&gt;&gt;p&gt;&gt;x;<br>            st[p<span class="hljs-number">-1</span>].money+=x/<span class="hljs-number">100</span>;<br>            st[i].money-=x/<span class="hljs-number">100</span>;<br>            st[p<span class="hljs-number">-1</span>].cnt++;<span class="hljs-comment">//记录抢到的红包数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(st,st+n,cmp);<span class="hljs-comment">//sort从数组下标0开始排序，左闭右开</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;n ; ++k) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf\n&quot;</span>,st[k].id,st[k].money);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/dingpiao190/article/details/73512811?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">(20条消息) double类型是否相等的判断方法_dingpiao190的博客-CSDN博客_double判断相等</a></p><p><a href="https://blog.csdn.net/patrick_star_cowboy/article/details/82083392">(20条消息) 如何判断两个double类型的数是否相等？_Patrick-Star的博客-CSDN博客_两个double怎么判断相等</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805066890854400">题目详情 - L2-009 抢红包 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>结构体</tag>
      
      <tag>Double类型相等比较</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-003 月饼 (25 分)</title>
    <link href="/2022/04/15/Algorithm026/"/>
    <url>/2022/04/15/Algorithm026/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-003-月饼-25-分"><a href="#L2-003-月饼-25-分" class="headerlink" title="L2-003 月饼 (25 分)"></a>L2-003 月饼 (25 分)</h2><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 <em>N</em> 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 <em>D</em> 表示市场最大需求量。随后一行给出 <em>N</em> 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 <em>N</em> 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs in">3 20<br>18 15 10<br>75 72 45<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">94.50<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>贪心 + Sort</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mooncake</span>&#123;</span><br>    <span class="hljs-keyword">double</span> pow;<br>    <span class="hljs-keyword">double</span> price;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(mooncake a,mooncake b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.price*<span class="hljs-number">1.0</span>/a.pow&gt;b.price*<span class="hljs-number">1.0</span>/b.pow;<span class="hljs-comment">//返回单价高的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">double</span> d;<br>    cin&gt;&gt;n&gt;&gt;d;<br>    mooncake m[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin&gt;&gt;m[i].pow;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n ; ++j) &#123;<br>        cin&gt;&gt;m[j].price;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(m,m+n,cmp);<br>    <span class="hljs-keyword">double</span> price=<span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">double</span> tmpd=d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;n ; ++k) &#123;<span class="hljs-comment">//模拟求解</span><br>        <span class="hljs-keyword">if</span>(m[k].pow&lt;=tmpd)&#123;<br>            tmpd-=m[k].pow;<br>            price+=m[k].price;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m[k].pow&gt;tmpd)&#123;<br>            price+=tmpd*(m[k].price/m[k].pow);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f\n&quot;</span>,price);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805071789801472">题目详情 - L2-003 月饼 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>结构体</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-013 红色警报 (25 分)</title>
    <link href="/2022/04/15/Algorithm025/"/>
    <url>/2022/04/15/Algorithm025/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-013-红色警报-25-分"><a href="#L2-013-红色警报-25-分" class="headerlink" title="L2-013 红色警报 (25 分)"></a>L2-013 红色警报 (25 分)</h2><p>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个整数<code>N</code>（0 &lt; <code>N</code> ≤ 500）和<code>M</code>（≤ 5000），分别为城市个数（于是默认城市从0到<code>N</code>-1编号）和连接两城市的通路条数。随后<code>M</code>行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数<code>K</code>和随后的<code>K</code>个被攻占的城市的编号。</p><p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出<code>Red Alert: City k is lost!</code>，其中<code>k</code>是该城市的编号；否则只输出<code>City k is lost.</code>即可。如果该国失去了最后一个城市，则增加一行输出<code>Game Over.</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">5 4<br>0 1<br>1 3<br>3 0<br>0 4<br>5<br>1 2 0 4 3<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs out">City 1 is lost.<br>City 2 is lost.<br>Red Alert: City 0 is lost!<br>City 4 is lost.<br>City 3 is lost.<br>Game Over.<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接矩阵建图 + DFS统计连通分量数</strong></p><p><strong>对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数</strong></p><p><strong>无向图中的极大连通子图称为连通分量</strong></p><p><strong>极大连通子图必须连通，且包含尽可能多的顶点和边</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<span class="hljs-comment">//邻接矩阵存图</span><br><span class="hljs-keyword">int</span> visit[<span class="hljs-number">505</span>];<span class="hljs-comment">//标记访问数组</span><br><span class="hljs-keyword">int</span> lost[<span class="hljs-number">505</span>];<span class="hljs-comment">//记录被攻占的城市</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span></span>&#123;<span class="hljs-comment">//正常的DFS</span><br>    visit[node]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(visit[i]==<span class="hljs-number">0</span>&amp;&amp;g[node][i]==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfstrave</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(visit,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(visit));<span class="hljs-comment">//初始化访问数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(lost[i]==<span class="hljs-number">1</span>) visit[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//如果该城市被攻占，则标记他为以访问</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(visit[i]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(i);<br>            cnt++;      <span class="hljs-comment">//统计连通分量数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(lost,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(lost));<span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        g[a][b]=g[b][a]=<span class="hljs-number">1</span>;<span class="hljs-comment">//存储无向图</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-built_in">dfstrave</span>();<span class="hljs-comment">//获得初始的连通分量数</span><br>    <span class="hljs-keyword">int</span> k;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w=<span class="hljs-number">0</span>;w&lt;k;w++)&#123;<br>        <span class="hljs-keyword">int</span> city;<br>        cin&gt;&gt;city;<br>        lost[city]=<span class="hljs-number">1</span>;<span class="hljs-comment">//记录该城市被攻占</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(g[city][i]==<span class="hljs-number">1</span>)&#123;<br>                g[city][i]=g[i][city]=<span class="hljs-number">0</span>;<span class="hljs-comment">//标记和他相连的城市不再相连</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> tempcnt=<span class="hljs-built_in">dfstrave</span>();<span class="hljs-comment">//当前的连通分量</span><br>        <span class="hljs-keyword">if</span>(tempcnt&lt;=cnt)&#123;<span class="hljs-comment">//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;City %d is lost.\n&quot;</span>, city);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则，连通性被改变了</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Red Alert: City %d is lost!\n&quot;</span>, city);<br>        &#125;<br>        cnt=tempcnt;<span class="hljs-comment">//更新连通分量</span><br>        <span class="hljs-keyword">if</span>(w==n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//城市已经被攻占完毕</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over.\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208">题目详情 - L2-013 红色警报 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-011 玩转二叉树 (25 分)</title>
    <link href="/2022/04/14/Algorithm024/"/>
    <url>/2022/04/14/Algorithm024/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-011-玩转二叉树-25-分"><a href="#L2-011-玩转二叉树-25-分" class="headerlink" title="L2-011 玩转二叉树 (25 分)"></a><strong>L2-011 玩转二叉树 (25 分)</strong></h2><p>给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs in">7<br>1 2 3 4 5 6 7<br>4 1 3 2 6 5 7<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">4 6 1 7 5 3 2<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>镜面反转即为在层序遍历时交换左右子树的遍历顺序，左-&gt;右变成右-&gt;左</strong></p><p><strong>前序 + 中序 建树 + BFS</strong></p><p><strong>建树详细过程：</strong></p><p><a href="https://xingyuanjie.top/2022/04/07/Algorithm014/">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;BiTNode,*BiTree;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> in[<span class="hljs-number">35</span>];<br><span class="hljs-keyword">int</span> pre[<span class="hljs-number">35</span>];<br><span class="hljs-function">BiTree <span class="hljs-title">PostCreate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prel,<span class="hljs-keyword">int</span> prer,<span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<span class="hljs-comment">//前序加中序建树</span><br>    <span class="hljs-keyword">if</span>(prel&gt;prer)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>    root-&gt;data=pre[prel];<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inl; i &lt;=inr; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(pre[prel]==in[i])&#123;<br>            index=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> numleft=index-inl;<br>    root-&gt;lchild=<span class="hljs-built_in">PostCreate</span>(prel+<span class="hljs-number">1</span>,prel+numleft,inl,index<span class="hljs-number">-1</span>);<br>    root-&gt;rchild=<span class="hljs-built_in">PostCreate</span>(prel+numleft+<span class="hljs-number">1</span>,prer,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;BiTree&gt; q;<br>    q.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        BiTNode *tmp =q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(i!=n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//输出格式控制</span><br>            cout&lt;&lt;tmp-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;tmp-&gt;data;<br>        &#125;<br>        i++;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//镜面反转，左-&gt;右变成右-&gt;左</span><br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;rchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;lchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree tree;<br>    tree=<span class="hljs-literal">NULL</span>;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        cin&gt;&gt;in[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n ; ++j) &#123;<br>        cin&gt;&gt;pre[j];<br>    &#125;<br>    tree=<span class="hljs-built_in">PostCreate</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">LevelOrder</span>(tree);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784">题目详情 - L2-011 玩转二叉树 (25 分) (pintia.cn)</a></p><p><a href="https://xingyuanjie.top/2022/04/07/Algorithm014/">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-035 完全二叉树的层序遍历 (25 分)</title>
    <link href="/2022/04/14/Algorithm023/"/>
    <url>/2022/04/14/Algorithm023/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-035-完全二叉树的层序遍历-25-分"><a href="#L2-035-完全二叉树的层序遍历-25-分" class="headerlink" title="L2-035 完全二叉树的层序遍历 (25 分)"></a>L2-035 完全二叉树的层序遍历 (25 分)</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是<strong>完美二叉树</strong>。对于深度为 <em>D</em> 的，有 <em>N</em> 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 <em>N</em> 个结点，这样的树就是<strong>完全二叉树</strong>。</p><p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>N</em>（≤30），即树中结点个数。第二行给出后序遍历序列，为 <em>N</em> 个不超过 100 的正整数。同一行中所有数字都以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">8<br>91 71 2 34 10 15 55 18<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">18 34 55 71 2 10 15 91<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>后序遍历建树 + 完全二叉树性质</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> tree[<span class="hljs-number">10001</span>];<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//根据后序遍历建树</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i&lt;=n)&#123;<span class="hljs-comment">//当2*i&lt;=n时，结点i的左孩子编号为2*i，否则无左孩子</span><br>        <span class="hljs-built_in">post</span>(<span class="hljs-number">2</span>*i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>&lt;=n)&#123;<span class="hljs-comment">//当2*i+1&lt;=n时，结点i的右孩子编号为2*i+1，否则无右孩子</span><br>        <span class="hljs-built_in">post</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>);<br>    &#125;<br>    cin&gt;&gt;tree[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">post</span>(<span class="hljs-number">1</span>);           <span class="hljs-comment">//后序遍历建树</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<span class="hljs-comment">//顺序输出即为层序遍历</span><br>        <span class="hljs-keyword">if</span>(i!=n)&#123;<br>            cout&lt;&lt;tree[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;tree[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Binary tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-031 深入虎穴 (25 分)</title>
    <link href="/2022/04/13/Algorithm022/"/>
    <url>/2022/04/13/Algorithm022/</url>
    
    <content type="html"><![CDATA[<p>著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。</p><p>内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在一行中给出正整数 <em>N</em>（&lt;105），是门的数量。最后 <em>N</em> 行，第 <em>i</em> 行（1≤<em>i</em>≤<em>N</em>）按以下格式描述编号为 <em>i</em> 的那扇门背后能通向的门：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">K</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">[</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">...</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>其中 <code>K</code> 是通道的数量，其后是每扇门的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs in">13<br>3 2 3 4<br>2 5 6<br>1 7<br>1 8<br>1 9<br>0<br>2 11 10<br>1 13<br>0<br>0<br>1 12<br>0<br>0<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">12<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表 + BFS</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v[<span class="hljs-number">100005</span>];<br><span class="hljs-keyword">int</span> book[<span class="hljs-number">100005</span>];<br><span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//BFS</span><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<span class="hljs-comment">//根节点入队</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        x=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;v[x].<span class="hljs-built_in">size</span>() ; ++i) &#123;<br>            q.<span class="hljs-built_in">push</span>(v[x][i]);<br>        &#125;<br>    &#125;<span class="hljs-comment">//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</span><br>    <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=time ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            book[num]=<span class="hljs-number">1</span>;<br>            v[i].<span class="hljs-built_in">push_back</span>(num);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;=n ; ++k) &#123;<span class="hljs-comment">//找入口</span><br>        <span class="hljs-keyword">if</span>(book[k]==<span class="hljs-number">0</span>) start=k;<span class="hljs-comment">//没有门通向的门，即为入口</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">bfs</span>();<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888">题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-040 哲哲打游戏 (25 分)</title>
    <link href="/2022/04/13/Algorithm021/"/>
    <url>/2022/04/13/Algorithm021/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-040-哲哲打游戏-25-分"><a href="#L2-040-哲哲打游戏-25-分" class="headerlink" title="L2-040 哲哲打游戏 (25 分)"></a><strong>L2-040 哲哲打游戏 (25 分)</strong></h2><p>哲哲是一位硬核游戏玩家。最近一款名叫《达诺达诺》的新游戏刚刚上市，哲哲自然要快速攻略游戏，守护硬核游戏玩家的一切！</p><p>为简化模型，我们不妨假设游戏有 <em>N</em> 个剧情点，通过游戏里不同的操作或选择可以从某个剧情点去往另外一个剧情点。此外，游戏还设置了一些<strong>存档</strong>，在某个剧情点可以将玩家的游戏进度保存在一个档位上，读取存档后可以回到剧情点，重新进行操作或者选择，到达不同的剧情点。</p><p>为了追踪硬核游戏玩家哲哲的攻略进度，你打算写一个程序来完成这个工作。假设你已经知道了游戏的全部剧情点和流程，以及哲哲的游戏操作，请你输出哲哲的游戏进度。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行是两个正整数 <em>N</em> 和 <em>M</em> (1≤<em>N</em>,<em>M</em>≤105)，表示总共有 <em>N</em> 个剧情点，哲哲有 <em>M</em> 个游戏操作。</p><p>接下来的 <em>N</em> 行，每行对应一个剧情点的发展设定。第 <em>i</em> 行的第一个数字是 <em>K**i</em>，表示剧情点 <em>i</em> 通过一些操作或选择能去往下面 <em>K**i</em> 个剧情点；接下来有 <em>K**i</em> 个数字，第 <em>k</em> 个数字表示做第 <em>k</em> 个操作或选择可以去往的剧情点编号。</p><p>最后有 <em>M</em> 行，每行第一个数字是 0、1 或 2，分别表示：</p><ul><li>0 表示哲哲做出了某个操作或选择，后面紧接着一个数字 <em>j</em>，表示哲哲在当前剧情点做出了第 <em>j</em> 个选择。我们保证哲哲的选择永远是合法的。</li><li>1 表示哲哲进行了一次存档，后面紧接着是一个数字 <em>j</em>，表示存档放在了第 <em>j</em> 个档位上。</li><li>2 表示哲哲进行了一次读取存档的操作，后面紧接着是一个数字 <em>j</em>，表示读取了放在第 <em>j</em> 个位置的存档。</li></ul><p>约定：所有操作或选择以及剧情点编号都从 1 号开始。存档的档位不超过 100 个，编号也从 1 开始。游戏默认从 1 号剧情点开始。总的选项数（即 ∑<em>K**i</em>）不超过 106。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对于每个 1（即存档）操作，在一行中输出存档的剧情点编号。</p><p>最后一行输出哲哲最后到达的剧情点编号。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs in">10 11<br>3 2 3 4<br>1 6<br>3 4 7 5<br>1 3<br>1 9<br>2 3 5<br>3 1 8 5<br>1 9<br>2 8 10<br>0<br>1 1<br>0 3<br>0 1<br>1 2<br>0 2<br>0 2<br>2 2<br>0 3<br>0 1<br>1 1<br>0 2<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs out">1<br>3<br>9<br>10<br></code></pre></td></tr></table></figure><h3 id="样例解释："><a href="#样例解释：" class="headerlink" title="样例解释："></a>样例解释：</h3><p>简单给出样例中经过的剧情点顺序：</p><p>1 -&gt; 4 -&gt; 3 -&gt; 7 -&gt; 8 -&gt; 3 -&gt; 5 -&gt; 9 -&gt; 10。</p><p>档位 1 开始存的是 1 号剧情点；档位 2 存的是 3 号剧情点；档位 1 后来又存了 9 号剧情点。</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表 + 模拟，主要是理解题意</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> save[<span class="hljs-number">105</span>];<span class="hljs-comment">//存档点</span><br>    <span class="hljs-keyword">int</span> now=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前剧情点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> num;<br>        cin&gt;&gt;num;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;num ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> x;<br>            cin&gt;&gt;x;<br>            v[i].<span class="hljs-built_in">push_back</span>(x);<span class="hljs-comment">//邻接表存操作数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;k ; ++l) &#123;<span class="hljs-comment">//模拟过程</span><br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>)&#123;<br>            save[b]=now;<br>            cout&lt;&lt;now&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>)&#123;<br>            now=v[now][b<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">2</span>)&#123;<br>            now=save[b];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;now&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652363">题目详情 - L2-040 哲哲打游戏 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-027 名人堂与代金券 (25 分)</title>
    <link href="/2022/04/13/Algorithm020/"/>
    <url>/2022/04/13/Algorithm020/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-027-名人堂与代金券-25-分"><a href="#L2-027-名人堂与代金券-25-分" class="headerlink" title="L2-027 名人堂与代金券 (25 分)"></a>L2-027 名人堂与代金券 (25 分)</h2><p>对于在中国大学MOOC（<a href="http://www.icourse163.org/">http://www.icourse163.org/</a> ）学习“数据结构”课程的学生，想要获得一张合格证书，总评成绩必须达到 60 分及以上，并且有另加福利：总评分在 [G, 100] 区间内者，可以得到 50 元 PAT 代金券；在 [60, G) 区间内者，可以得到 20 元PAT代金券。全国考点通用，一年有效。同时任课老师还会把总评成绩前 K 名的学生列入课程“名人堂”。本题就请你编写程序，帮助老师列出名人堂的学生，并统计一共发出了面值多少元的 PAT 代金券。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出 3 个整数，分别是 N（不超过 10 000 的正整数，为学生总数）、G（在 (60,100) 区间内的整数，为题面中描述的代金券等级分界线）、K（不超过 100 且不超过 N 的正整数，为进入名人堂的最低名次）。接下来 N 行，每行给出一位学生的账号（长度不超过15位、不带空格的字符串）和总评成绩（区间 [0, 100] 内的整数），其间以空格分隔。题目保证没有重复的账号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出发出的 PAT 代金券的总面值。然后按总评成绩非升序输出进入名人堂的学生的名次、账号和成绩，其间以 1 个空格分隔。需要注意的是：成绩相同的学生享有并列的排名，排名并列时，按账号的字母序升序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs in">10 80 5<br>cy@zju.edu.cn 78<br>cy@pat-edu.com 87<br>1001@qq.com 65<br>uh-oh@163.com 96<br>test@126.com 39<br>anyone@qq.com 87<br>zoe@mit.edu 80<br>jack@ucla.edu 88<br>bob@cmu.edu 80<br>ken@163.com 70<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs out">360<br>1 uh-oh@163.com 96<br>2 jack@ucla.edu 88<br>3 anyone@qq.com 87<br>3 cy@pat-edu.com 87<br>5 bob@cmu.edu 80<br>5 zoe@mit.edu 80<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>结构体数组+sort排序，需要注意输出格式控制</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-keyword">int</span> score=<span class="hljs-number">0</span>;<br>    string email;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(student a,student b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.score==b.score) <span class="hljs-keyword">return</span> a.email&lt;b.email;<span class="hljs-comment">//如果分数相同返回字典序小的</span><br>    <span class="hljs-keyword">return</span> a.score&gt;b.score;<span class="hljs-comment">//返回分数最大的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,g,k;<br>    cin&gt;&gt;n&gt;&gt;g&gt;&gt;k;<br>    student st[n];<br>    <span class="hljs-keyword">int</span> money=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<span class="hljs-comment">//输入加存钱</span><br>        cin&gt;&gt;st[i].email&gt;&gt;st[i].score;<br>        <span class="hljs-keyword">if</span>(g&lt;=st[i].score&amp;&amp;st[i].score&lt;=<span class="hljs-number">100</span>)&#123;<br>            money+=<span class="hljs-number">50</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">60</span>&lt;=st[i].score&amp;&amp;st[i].score&lt;g)&#123;<br>            money+=<span class="hljs-number">20</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(st,st+n,cmp);<span class="hljs-comment">//排序</span><br>    cout&lt;&lt;money&lt;&lt;endl;<br>    <span class="hljs-keyword">int</span> cnt =<span class="hljs-number">1</span>;<span class="hljs-comment">//用来判断用否超过名人堂个数</span><br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-comment">//遍历st结构体数组</span><br>    <span class="hljs-keyword">int</span> same=<span class="hljs-number">1</span>;<span class="hljs-comment">//分数相同的个数</span><br>    <span class="hljs-keyword">int</span> fscore=st[<span class="hljs-number">0</span>].score;<span class="hljs-comment">//用来判断分数是否相同</span><br>    <span class="hljs-comment">//这道题就格式输出需要注意下！</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><br>        <span class="hljs-keyword">if</span>(fscore==st[i].score)&#123;<br>            cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].email&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].score&lt;&lt;endl;<span class="hljs-comment">//相同即输出</span><br>            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>) same++;<span class="hljs-comment">//不为0号，则same++。</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(fscore&gt;st[i].score)&#123;<br>            cnt=cnt+same;<span class="hljs-comment">//不等，更新cnt值</span><br>            same=<span class="hljs-number">1</span>;<span class="hljs-comment">//更新same值</span><br>            <span class="hljs-keyword">if</span>(cnt&gt;k)&#123; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//大于名人堂个数结束</span><br>            cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].email&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].score&lt;&lt;endl;<br>            fscore=st[i].score;<span class="hljs-comment">//更新用来判断分数是否相同的fscore</span><br><br>        &#125;<br>        i++;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805055176163328">题目详情 - L2-027 名人堂与代金券 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-026 小字辈 (25 分)</title>
    <link href="/2022/04/13/Algorithm019/"/>
    <url>/2022/04/13/Algorithm019/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-026-小字辈-25-分"><a href="#L2-026-小字辈-25-分" class="headerlink" title="L2-026 小字辈 (25 分)"></a><strong>L2-026 小字辈 (25 分)</strong></h2><p>本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父/母。家谱中辈分最高的老祖宗对应的父/母编号为 -1。一行中的数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">9<br>2 6 5 5 -1 5 6 4 7<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">4<br>1 9<br></code></pre></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表建树+BFS</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; tree[<span class="hljs-number">100005</span>];<span class="hljs-comment">//邻接表建树</span><br><span class="hljs-keyword">int</span> deeptree[<span class="hljs-number">100005</span>];<span class="hljs-comment">//记录树的深度</span><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> root;<span class="hljs-comment">//根节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//bfs</span><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<span class="hljs-comment">//根节点入队</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        x=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;tree[x].<span class="hljs-built_in">size</span>() ; ++i) &#123;<br>            deeptree[tree[x][i]]=deeptree[x]+<span class="hljs-number">1</span>;<span class="hljs-comment">//每一层的深度为上一层加1</span><br>            q.<span class="hljs-built_in">push</span>(tree[x][i]);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> deeptree[x];<span class="hljs-comment">//返回最后一个结点的深度，即深度的最大值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> a[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        cin&gt;&gt;a[i];<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">-1</span>)&#123;<br>            root=i;<span class="hljs-comment">//找根节点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ; ++j) &#123;<span class="hljs-comment">//建树</span><br>        tree[a[j]].<span class="hljs-built_in">push_back</span>(j);<span class="hljs-comment">//j是a[j]的孩子节点</span><br>        <span class="hljs-keyword">if</span>(a[j]==<span class="hljs-number">-1</span>) deeptree[j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//初始化根节点深度为1</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">bfs</span>();<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">int</span> maxdeepcnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录最大深度的个数</span><br>    <span class="hljs-keyword">int</span> tmp[n];<span class="hljs-comment">//找最大深度的id</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;=n ; ++k) &#123;<br>        <span class="hljs-keyword">if</span>(ans==deeptree[k])&#123;<br>            maxdeepcnt++;<br>            tmp[maxdeepcnt]=k;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//输出格式控制</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=maxdeepcnt ; ++l) &#123;<br>        <span class="hljs-keyword">if</span>(l!=maxdeepcnt) cout&lt;&lt;tmp[l]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;tmp[l]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808">题目详情 - L2-026 小字辈 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-023 图着色问题 (25 分)</title>
    <link href="/2022/04/12/Algorithm018/"/>
    <url>/2022/04/12/Algorithm018/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-023-图着色问题-25-分"><a href="#L2-023-图着色问题-25-分" class="headerlink" title="L2-023 图着色问题 (25 分)"></a>L2-023 图着色问题 (25 分)</h2><p>图着色问题是一个著名的NP完全问题。给定无向图<em>G</em>=(<em>V</em>,<em>E</em>)，问可否用<em>K</em>种颜色为<em>V</em>中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？</p><p>但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出3个整数<em>V</em>（0&lt;<em>V</em>≤500）、<em>E</em>（≥0）和<em>K</em>（0&lt;<em>K</em>≤<em>V</em>），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到<em>V</em>编号。随后<em>E</em>行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数<em>N</em>（≤20），是待检查的颜色分配方案的个数。随后<em>N</em>行，每行顺次给出<em>V</em>个顶点的颜色（第<em>i</em>个数字表示第<em>i</em>个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每种颜色分配方案，如果是图着色问题的一个解则输出<code>Yes</code>，否则输出<code>No</code>，每句占一行。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><img src="/2022/04/12/Algorithm018/graph.png" alt="graph" style="zoom: 67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs in">6 8 3<br>2 1<br>1 3<br>4 6<br>2 5<br>2 4<br>5 4<br>5 6<br>3 6<br>4<br>1 2 3 3 1 2<br>4 5 6 6 4 5<br>1 2 3 4 5 6<br>2 3 4 2 3 4<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs out">Yes<br>Yes<br>No<br>No<br></code></pre></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>Set + 邻接表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> v,e,k;<br>    cin&gt;&gt;v&gt;&gt;e&gt;&gt;k;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; g[<span class="hljs-number">505</span>];<span class="hljs-comment">//邻接表</span><br>    <span class="hljs-keyword">int</span> color[<span class="hljs-number">505</span>];<span class="hljs-comment">//记录颜色</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;e ; ++i) &#123;       <span class="hljs-comment">//建立邻接表</span><br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        g[a].<span class="hljs-built_in">push_back</span>(b);<br>        g[b].<span class="hljs-built_in">push_back</span>(a);<br>    &#125;<br>    <span class="hljs-keyword">int</span> time;<br>    cin&gt;&gt;time;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>        set&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-comment">//用来统计颜色总数</span><br>        s.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=v; ++i) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            color[i]=num;<br>            s.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()!=k)&#123;<span class="hljs-comment">//如果颜色数不等于k即非法</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=v ; ++l) &#123;<span class="hljs-comment">//遍历邻接表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;g[l].<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">if</span>(color[l]==color[g[l][i]])&#123;<span class="hljs-comment">//如果相邻结点颜色一样则为假</span><br>                    flag=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805057298481152">题目详情 - L2-023 图着色问题 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-022 重排链表 (25 分)</title>
    <link href="/2022/04/12/Algorithm017/"/>
    <url>/2022/04/12/Algorithm017/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-022-重排链表-25-分"><a href="#L2-022-重排链表-25-分" class="headerlink" title="L2-022 重排链表 (25 分)"></a>L2-022 重排链表 (25 分)</h2><p>给定一个单链表 <em>L</em>1→<em>L</em>2→⋯→<em>Ln</em>−1→<em>Ln</em>，请编写程序将链表重新排列为 <em>Ln</em>→<em>L</em>1→<em>Ln</em>−1→<em>L</em>2→⋯。例如：给定<em>L</em>为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数<em>N</em> (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。</p><p>接下来有<em>N</em>行，每行格式为：</p><figure class="highlight purebasic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span><br></code></pre></td></tr></table></figure><p>其中<code>Address</code>是结点地址；<code>Data</code>是该结点保存的数据，为不超过105的正整数；<code>Next</code>是下一结点的地址。题目保证给出的链表上至少有两个结点。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">00100 6<br>00000 4 99999<br>00100 1 12309<br>68237 6 -1<br>33218 3 00000<br>99999 5 68237<br>12309 2 33218<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs out">68237 6 00100<br>00100 1 99999<br>99999 5 12309<br>12309 2 00000<br>00000 4 33218<br>33218 3 -1<br></code></pre></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>利用双向链表，头尾指针来模拟</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linklist</span>&#123;</span><br>    <span class="hljs-keyword">int</span> address=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录当前结点的地址，虽然也没用到</span><br>    <span class="hljs-keyword">int</span> data=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录数据域</span><br>    <span class="hljs-keyword">int</span> next=<span class="hljs-number">0</span>;<span class="hljs-comment">//指向下一个结点的地址</span><br>    <span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>;<span class="hljs-comment">//指向上一个结点的地址</span><br>&#125;l[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> start,back=<span class="hljs-number">-1</span>;<span class="hljs-comment">//头尾指针</span><br>    <span class="hljs-keyword">int</span> tmp;<span class="hljs-comment">//用来遍历当前链表用于统计链表的长度</span><br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;start&gt;&gt;n;<br>    tmp=start;<br>    <span class="hljs-keyword">int</span> address, data, next;<br>    l[start].pre=<span class="hljs-number">-1</span>;   <span class="hljs-comment">//初始化第一个结点的前一个结点位置为-1</span><br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;  <span class="hljs-comment">//记录链表长</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>       cin&gt;&gt;address&gt;&gt;data&gt;&gt;next;<br>       l[address].address=address;<br>       l[address].data=data;<br>       l[address].next=next;<br>       <span class="hljs-keyword">if</span>(next!=<span class="hljs-number">-1</span>)&#123;<br>           l[next].pre=address;<span class="hljs-comment">//设值上一个结点的地址</span><br>       &#125;<br>    &#125;<br>    <span class="hljs-comment">//这道题比较坑的地方是会出现不是这个链表的结点，所以n不是真正的链表长，需要统计真正的链表长</span><br>    <span class="hljs-comment">//如果没注意这点，第三个测试点会不通过，不过也能得到21分</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        cnt++;<span class="hljs-comment">//统计链表长</span><br>        <span class="hljs-keyword">if</span>(l[tmp].next==<span class="hljs-number">-1</span>)&#123;<br>            back=tmp;       <span class="hljs-comment">//尾指针</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        tmp=l[tmp].next;<br>    &#125;<br>    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//flag=0动尾指针,flag=1动头指针。我并没有改变原来链表！</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;cnt ; ++k) &#123;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(k==cnt<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %d\n&quot;</span>,l[back].address,l[back].data,<span class="hljs-number">-1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>,l[back].address,l[back].data,start);<br>                &#125;<br>                back=l[back].pre;<br>                flag=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(k==cnt<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %d\n&quot;</span>,l[start].address,l[start].data,<span class="hljs-number">-1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>,l[start].address,l[start].data,back);<br>                &#125;<br>                start=l[start].next;<br>                flag=<span class="hljs-number">0</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805057860517888">题目详情 - L2-022 重排链表 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>LinkList</tag>
      
      <tag>双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-021 点赞狂魔 (25 分)</title>
    <link href="/2022/04/11/Algorithm016/"/>
    <url>/2022/04/11/Algorithm016/</url>
    
    <content type="html"><![CDATA[<h1 id="L2-021-点赞狂魔-25-分"><a href="#L2-021-点赞狂魔-25-分" class="headerlink" title="L2-021 点赞狂魔 (25 分)"></a>L2-021 点赞狂魔 (25 分)</h1><p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤100），是待统计的用户数。随后<em>N</em>行，每行列出一位用户的点赞标签。格式为“<code>Name</code> <em>K</em> <em>F</em>1⋯<em>F**K</em>”，其中<code>Name</code>是不超过8个英文小写字母的非空用户名，1≤<em>K</em>≤1000，<em>F**i</em>（<em>i</em>=1,⋯,<em>K</em>）是特性标签的编号，我们将所有特性标签从 1 到 107 编号。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用<code>-</code>补齐缺失，例如<code>mike jenny -</code>就表示只有2人。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">5<br>bob 11 101 102 103 104 105 106 107 108 108 107 107<br>peter 8 1 2 3 4 3 2 5 1<br>chris 12 1 2 3 4 5 6 7 8 9 1 2 3<br>john 10 8 7 6 5 4 3 2 1 7 5<br>jack 9 6 7 8 9 10 11 12 13 14<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">jack chris john<br></code></pre></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>结构体数组 + sort排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span>&#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">10</span>];<br>    set&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-comment">//set容器中的每个元素值唯一</span><br>    <span class="hljs-keyword">int</span> all=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录点赞次数</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(person a,person b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.s.<span class="hljs-built_in">size</span>()==b.s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a.all&lt;b.all;<span class="hljs-comment">//如果有并列，则输出标签出现次数平均值最小的那个</span><br>    <span class="hljs-keyword">return</span> a.s.<span class="hljs-built_in">size</span>()&gt;b.s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//点赞的不同标签的数量最多的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    person p[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        cin&gt;&gt;p[i].name;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        p[i].all=time;<span class="hljs-comment">//记录点赞次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; time; ++j) &#123;<br>            <span class="hljs-keyword">int</span> tmp;<br>            cin&gt;&gt;tmp;<br>            p[i].s.<span class="hljs-built_in">insert</span>(tmp);<span class="hljs-comment">//插入set容器</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(p,p+n,cmp);<span class="hljs-comment">//排序</span><br>    <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">3</span>)&#123;<br>        cout&lt;&lt;p[<span class="hljs-number">0</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p[<span class="hljs-number">1</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p[<span class="hljs-number">2</span>].name&lt;&lt;endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)&#123;<br>        cout&lt;&lt;p[<span class="hljs-number">0</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p[<span class="hljs-number">1</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>        cout&lt;&lt;p[<span class="hljs-number">0</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805058485469184">题目详情 - L2-021 点赞狂魔 (25 分) (pintia.cn)</a></p><p><a href="https://blog.csdn.net/changjiale110/article/details/79108447">(19条消息) STL中的set使用方法详细！！！！_知足–常乐的博客-CSDN博客_set stl</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的STL中字符串string自带方法find查找</title>
    <link href="/2022/04/08/Algorithm015/"/>
    <url>/2022/04/08/Algorithm015/</url>
    
    <content type="html"><![CDATA[<h1 id="C-的STL中字符串string自带方法find查找"><a href="#C-的STL中字符串string自带方法find查找" class="headerlink" title="C++的STL中字符串string自带方法find查找"></a>C++的STL中字符串string自带方法find查找</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;abcd&quot;</span>;<br>cout &lt;&lt; str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-comment">//返回的是下标的值而不是指针或是迭代器</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;abcd&quot;</span><br>string sub = <span class="hljs-string">&quot;cd&quot;</span><br><span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">find</span>(sub)!=string::npos)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;找到了&quot;</span>&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;没有找到&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>要是没有找到，返回的是str::npos<br>注意，只有string的find方法是返回的下标，因为string是顺序索引，set,map,multiset,multimap都不是顺序索引的数据结构，所以返回的是迭代器。</p><h2 id="样例一-L1-070-吃火锅-15-分"><a href="#样例一-L1-070-吃火锅-15-分" class="headerlink" title="样例一:L1-070 吃火锅 (15 分)"></a>样例一:<strong>L1-070 吃火锅 (15 分)</strong></h2><p><strong>题目链接：</strong></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053</a></p><p><img src="/2022/04/08/Algorithm015/68518b64-f2f7-4694-aaeb-d32afe657f7b.jpg" alt="chg.jpg"></p><p>以上图片来自微信朋友圈：这种天气你有什么破事打电话给我基本没用。但是如果你说“吃火锅”，那就厉害了，我们的故事就开始了。</p><p>本题要求你实现一个程序，自动检查你朋友给你发来的信息里有没有 <code>chi1 huo3 guo1</code>。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入每行给出一句不超过 80 个字符的、以回车结尾的朋友信息，信息为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。当读到某一行只有一个英文句点 <code>.</code> 时，输入结束，此行不算在朋友信息里。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出朋友信息的总条数。然后对朋友的每一行信息，检查其中是否包含 <code>chi1 huo3 guo1</code>，并且统计这样厉害的信息有多少条。在第二行中首先输出第一次出现 <code>chi1 huo3 guo1</code> 的信息是第几条（从 1 开始计数），然后输出这类信息的总条数，其间以一个空格分隔。题目保证输出的所有数字不超过 100。</p><p>如果朋友从头到尾都没提 <code>chi1 huo3 guo1</code> 这个关键词，则在第二行输出一个表情 <code>-_-#</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">Hello!<br>are you there?<br>wantta chi1 huo3 guo1?<br>that&#x27;s so li hai le<br>our story begins from chi1 huo3 guo1 le<br>.<br></code></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">5<br>3 2<br></code></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">Hello!<br>are you there?<br>wantta qi huo3 guo1 chi1huo3guo1?<br>that&#x27;s so li hai le<br>our story begins from ci1 huo4 guo2 le<br>.<br></code></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">5<br>-_-#<br></code></pre></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来判断是否是第一次找到吃火锅</span><br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录总行数</span><br>    <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录有多少个吃火锅</span><br>    <span class="hljs-keyword">int</span> firstp=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录第一次出现吃火锅的位置</span><br>    string cmp=<span class="hljs-string">&quot;chi1 huo3 guo1&quot;</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        string s;<br>        s.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">getline</span>(cin,s);<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>&amp;&amp;s==<span class="hljs-string">&quot;.&quot;</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        string tmp =s;<br>        <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">find</span>(cmp)!=string::npos)&#123;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>) &#123;<br>                flag =<span class="hljs-number">1</span>;<br>                firstp = cnt+<span class="hljs-number">1</span>;<br>            &#125;<br>            count=count+<span class="hljs-number">1</span>;<br>        &#125;<br>        cnt=cnt+<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        cout&lt;&lt;cnt&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;-_-#&quot;</span>&lt;&lt;endl;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;cnt&lt;&lt;endl;<br>        cout&lt;&lt;firstp&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;count&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_50675813/article/details/113313343">(18条消息) c++STL中的find()函数 有两种使用方法_我们不生产代码，只是代码的搬运工的博客-CSDN博客_c++中find函数的使用方法</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Find</tag>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由遍历顺序构建二叉树(前序+中序;后序+中序)</title>
    <link href="/2022/04/07/Algorithm014/"/>
    <url>/2022/04/07/Algorithm014/</url>
    
    <content type="html"><![CDATA[<h1 id="由遍历顺序构建二叉树-前序-中序-后序-中序"><a href="#由遍历顺序构建二叉树-前序-中序-后序-中序" class="headerlink" title="由遍历顺序构建二叉树(前序+中序;后序+中序)"></a>由遍历顺序构建二叉树(前序+中序;后序+中序)</h1><h2 id="前序-中序"><a href="#前序-中序" class="headerlink" title="前序+中序"></a>前序+中序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BiTree <span class="hljs-title">PreAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prel,<span class="hljs-keyword">int</span> prer, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(prel&gt;prer)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<span class="hljs-comment">//记住分配空间</span><br>    root-&gt;data=preF[prel];<span class="hljs-comment">//前序遍历的第一个结点是根结点</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=inl;i&lt;=inr;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(preF[prel]==inF[i])&#123;<br>            index=i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//前序遍历的第一个结点是根结点,所以新的递归区间是prel+1,到prel+index-inl,</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+<span class="hljs-number">1</span>,prel+index-inl,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//前序遍历是根左右，所以新的递归区间是prel+index-inl+1,prep</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+index-inl+<span class="hljs-number">1</span>,prer,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="后序-中序"><a href="#后序-中序" class="headerlink" title="后序+中序"></a>后序+中序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BiTree <span class="hljs-title">PostAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> postl,<span class="hljs-keyword">int</span> postr, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(postl&gt;postr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>    root-&gt;data=posts[postr];<span class="hljs-comment">//后序遍历的最后一个结点是根结点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inl; i &lt;=inr ; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(posts[postr]==ins[i])<br>        &#123;<br>            index =i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//后续遍历的最后一个结点是根节点，所以新的递归区间是，postl,postl+index-inl-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl,postl+index-inl<span class="hljs-number">-1</span>,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//后序遍历是左右根，所以新的递归区间是postl+index-inl,postr-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl+index-inl,postr<span class="hljs-number">-1</span>,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h2><p><strong>前序+中序；后序+中序。递归调用可视化查看：(有助于理解递归调用过程)</strong></p><p><a href="https://pythontutor.com/">Python Tutor - Visualize Python, Java, C, C++, JavaScript, TypeScript, and Ruby code execution</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125;BiTNode,*BiTree;<br><span class="hljs-comment">//tree</span><br><span class="hljs-keyword">int</span> preF[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">int</span> inF[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//中序遍历</span><br><span class="hljs-comment">//trees</span><br><span class="hljs-keyword">int</span> posts[<span class="hljs-number">7</span>]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//后序遍历</span><br><span class="hljs-keyword">int</span> ins[<span class="hljs-number">7</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<span class="hljs-comment">//中序遍历</span><br><span class="hljs-function">BiTree <span class="hljs-title">PreAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prel,<span class="hljs-keyword">int</span> prer, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(prel&gt;prer)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<span class="hljs-comment">//记住分配空间</span><br>    root-&gt;data=preF[prel];<span class="hljs-comment">//前序遍历的第一个结点是根结点</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=inl;i&lt;=inr;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(preF[prel]==inF[i])&#123;<br>            index=i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//前序遍历的第一个结点是根结点,所以新的递归区间是prel+1,到prel+index-inl,</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+<span class="hljs-number">1</span>,prel+index-inl,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//前序遍历是根左右，所以新的递归区间是prel+index-inl+1,prep</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+index-inl+<span class="hljs-number">1</span>,prer,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function">BiTree <span class="hljs-title">PostAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> postl,<span class="hljs-keyword">int</span> postr, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(postl&gt;postr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>    root-&gt;data=posts[postr];<span class="hljs-comment">//后序遍历的最后一个结点是根结点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inl; i &lt;=inr ; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(posts[postr]==ins[i])<br>        &#123;<br>            index =i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//后续遍历的最后一个结点是根节点，所以新的递归区间是，postl,postl+index-inl-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl,postl+index-inl<span class="hljs-number">-1</span>,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//后序遍历是左右根，所以新的递归区间是postl+index-inl,postr-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl+index-inl,postr<span class="hljs-number">-1</span>,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;BiTree&gt; q;<br>    q.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        BiTNode *tmp =q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;tmp-&gt;data;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    BiTree tree;<br>    tree=<span class="hljs-literal">NULL</span>;<br>    tree=<span class="hljs-built_in">PreAndInCreateTree</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;输入为前序加中序遍历，输出他的层序遍历：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">LevelOrder</span>(tree);<br>    cout&lt;&lt;endl;<br>    BiTree trees;<br>    trees=<span class="hljs-literal">NULL</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;输入为后序加中序遍历，输出他的层序遍历：&quot;</span>&lt;&lt;endl;<br>    trees=<span class="hljs-built_in">PostAndInCreateTree</span>(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">LevelOrder</span>(trees);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入为前序加中序遍历，输出他的层序遍历：<br><span class="hljs-number">425136</span><br>输入为后序加中序遍历，输出他的层序遍历：<br><span class="hljs-number">4163572</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的前、中、后、层序遍历</title>
    <link href="/2022/04/07/Algorithm013/"/>
    <url>/2022/04/07/Algorithm013/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的前、中、后、层序遍历"><a href="#二叉树的前、中、后、层序遍历" class="headerlink" title="二叉树的前、中、后、层序遍历"></a>二叉树的前、中、后、层序遍历</h1><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="前序遍历建树"><a href="#前序遍历建树" class="headerlink" title="前序遍历建树"></a>前序遍历建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BiTree <span class="hljs-title">PreCreateTree</span><span class="hljs-params">(BiTree tree)</span></span>&#123;<br>    <span class="hljs-keyword">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        tree=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>        tree-&gt;data=ch;<br>        tree-&gt;lchild=<span class="hljs-built_in">PreCreateTree</span>(tree-&gt;lchild);<br>        tree-&gt;rchild=<span class="hljs-built_in">PreCreateTree</span>(tree-&gt;rchild);<br>        <span class="hljs-keyword">return</span> tree;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span><span class="hljs-comment">//先序遍历</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)<br>     &#123;<br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, root-&gt;data);<br>         <span class="hljs-built_in">PreOrder</span>(root-&gt;lchild);<br>         <span class="hljs-built_in">PreOrder</span>(root-&gt;rchild);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree root)</span><span class="hljs-comment">//中序遍历</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">InOrder</span>(root-&gt;lchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, root-&gt;data);<br>        <span class="hljs-built_in">InOrder</span>(root-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree root)</span><span class="hljs-comment">//后序遍历</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">PostOrder</span>(root-&gt;lchild);<br>        <span class="hljs-built_in">PostOrder</span>(root-&gt;rchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, root-&gt;data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="层序遍历-借助STL-queue-实现"><a href="#层序遍历-借助STL-queue-实现" class="headerlink" title="层序遍历(借助STL:queue)实现"></a>层序遍历(借助STL:queue)实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;BiTree&gt; q;<br>    q.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        BiTNode *tmp =q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;tmp-&gt;data;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125;BiTNode,*BiTree;<br><span class="hljs-function">BiTree <span class="hljs-title">PreCreateTree</span><span class="hljs-params">(BiTree tree)</span></span>&#123;<br>    <span class="hljs-keyword">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        tree=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>        tree-&gt;data=ch;<br>        tree-&gt;lchild=<span class="hljs-built_in">PreCreateTree</span>(tree-&gt;lchild);<br>        tree-&gt;rchild=<span class="hljs-built_in">PreCreateTree</span>(tree-&gt;rchild);<br>        <span class="hljs-keyword">return</span> tree;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree root)</span><span class="hljs-comment">//先序遍历</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)<br>     &#123;<br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, root-&gt;data);<br>         <span class="hljs-built_in">PreOrder</span>(root-&gt;lchild);<br>         <span class="hljs-built_in">PreOrder</span>(root-&gt;rchild);<br>     &#125;<br> &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree root)</span><span class="hljs-comment">//中序遍历</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">InOrder</span>(root-&gt;lchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, root-&gt;data);<br>        <span class="hljs-built_in">InOrder</span>(root-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree root)</span><span class="hljs-comment">//后序遍历</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">PostOrder</span>(root-&gt;lchild);<br>        <span class="hljs-built_in">PostOrder</span>(root-&gt;rchild);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, root-&gt;data);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;BiTree&gt; q;<br>    q.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        BiTNode *tmp =q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;tmp-&gt;data;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree tree;<br>    tree=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//按先序的方式输入二叉树的结点元素（注：输入#表示节点为空）</span><br>    <span class="hljs-comment">//例如这棵树为:ABC##DE#G##F###</span><br>    tree=<span class="hljs-built_in">PreCreateTree</span>(tree);<br>    cout&lt;&lt;<span class="hljs-string">&quot;前序遍历&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">PreOrder</span>(tree);<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;中序遍历&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">InOrder</span>(tree);<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;后序遍历&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">PostOrder</span>(tree);<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;层序遍历&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">LevelOrder</span>(tree);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">前序遍历<br>ABCDEGF<br>中序遍历<br>CBEGDFA<br>后序遍历<br>CGEFDBA<br>层序遍历<br>ABCDEFG<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的存储结构</title>
    <link href="/2022/04/06/Algorithm012/"/>
    <url>/2022/04/06/Algorithm012/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h2 id="1-顺序存储方式"><a href="#1-顺序存储方式" class="headerlink" title="1.顺序存储方式"></a>1.顺序存储方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 100</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    ElemType value;<span class="hljs-comment">//结点中的数据元素</span><br>    <span class="hljs-keyword">bool</span> isEmpty;<span class="hljs-comment">//结点是否为空</span><br>&#125;;<br><br>TreeNode t[MaxSize];<br></code></pre></td></tr></table></figure><h2 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="2.链式存储结构"></a>2.链式存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125;BiTNode,*BiTree;<br></code></pre></td></tr></table></figure><h2 id="3-三叉链表"><a href="#3-三叉链表" class="headerlink" title="3.三叉链表"></a>3.三叉链表</h2><p>三叉链表—方便找父节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">parent</span>;</span><span class="hljs-comment">//父结点指针</span><br>&#125;BiTNode,*BiTree;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串的存储结构</title>
    <link href="/2022/04/06/Algorithm011/"/>
    <url>/2022/04/06/Algorithm011/</url>
    
    <content type="html"><![CDATA[<h1 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h1><h2 id="1-定长顺序存储表示"><a href="#1-定长顺序存储表示" class="headerlink" title="1.定长顺序存储表示"></a>1.定长顺序存储表示</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLEN 255<span class="hljs-comment">//预定义最大串长</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">char</span> ch[MAXLEN];<span class="hljs-comment">//每个分量存储一个字符</span><br>    <span class="hljs-keyword">int</span> length;<span class="hljs-comment">//串的实际长度</span><br>&#125;SSting;<br></code></pre></td></tr></table></figure><h2 id="2-堆分配存储表示"><a href="#2-堆分配存储表示" class="headerlink" title="2.堆分配存储表示"></a>2.堆分配存储表示</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">char</span> *ch;<span class="hljs-comment">//按串长分配存储区，ch指向串的基地址</span><br>    <span class="hljs-keyword">int</span> length;<span class="hljs-comment">//串的长度</span><br>&#125;HString;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(六)-两个矩阵相加MPI版本</title>
    <link href="/2022/04/02/mpi006/"/>
    <url>/2022/04/02/mpi006/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI学习-六-两个矩阵相加MPI版本"><a href="#MPI学习-六-两个矩阵相加MPI版本" class="headerlink" title="MPI学习(六)-两个矩阵相加MPI版本"></a>MPI学习(六)-两个矩阵相加MPI版本</h1><p>这里，我们演示了两个简单的程序，一个是矩阵相加串行版本，一个是矩阵相加MPI版本</p><h2 id="串行版本"><a href="#串行版本" class="headerlink" title="串行版本"></a>串行版本</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<br><span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<br><span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<br><span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>&#125;;<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<br><span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<br><span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">17</span>,<span class="hljs-number">5</span>,<br><span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c)); <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>&#123;<br>c[i][j]=a[i][j]+b[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">11</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">15</span> <span class="hljs-number">17</span><br><span class="hljs-number">20</span> <span class="hljs-number">22</span> <span class="hljs-number">28</span> <span class="hljs-number">17</span><br><span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">35</span> <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><h2 id="MPI版本"><a href="#MPI版本" class="headerlink" title="MPI版本"></a>MPI版本</h2><h3 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h3><p>北京超级云计算中心A3分区</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>mpi/intel/2017.5</p><h3 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h3><p>mpicxx mpi006.c -o mpi006</p><h3 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h3><p>srun -p amd_256 -N 1 -n  5  ./mpi006(使用SLURM任务调度系统)</p><p>1个分区，核数为5</p><h3 id="程序源代码-1"><a href="#程序源代码-1" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc ,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<br><span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<br><span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<br><span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>&#125;;<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<br><span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<br><span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">17</span>,<span class="hljs-number">5</span>,<br><span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-keyword">int</span> tmp[<span class="hljs-number">4</span>];<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));<br><span class="hljs-keyword">int</span> myid, numprocs;<br>MPI_Status status;<br>MPI_Request request;<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc,&amp;argv);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;numprocs);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;myid);<br><span class="hljs-keyword">if</span>(myid == <span class="hljs-number">0</span>)<span class="hljs-comment">//0号进程接受来自其他进程的消息</span><br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;numprocs;i++)<br>&#123;<br><span class="hljs-built_in">MPI_Irecv</span>(&amp;c[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],<span class="hljs-number">4</span>,MPI_INT,i,<span class="hljs-number">0</span>,MPI_COMM_WORLD,&amp;request);<span class="hljs-comment">//采用非阻塞接受</span><br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//打印矩阵</span><br>&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(myid != <span class="hljs-number">0</span> )<span class="hljs-comment">//当进程不是0号进程时，则向0号进程发送消息</span><br>&#123;<br><span class="hljs-built_in">memset</span>(tmp,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(tmp));<span class="hljs-comment">//初始化tmp数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br>tmp[i]=a[myid<span class="hljs-number">-1</span>][i]+b[myid<span class="hljs-number">-1</span>][i];<span class="hljs-comment">//用tmp来临时存储相加结果，随后发送给0号进程</span><br><br>&#125;<br><span class="hljs-built_in">MPI_Isend</span>(&amp;tmp,<span class="hljs-number">4</span>,MPI_INT,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,MPI_COMM_WORLD,&amp;request);<span class="hljs-comment">//采用非阻塞发送</span><br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br>&#125;<br><span class="hljs-built_in">MPI_Finalize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="程序输出-1"><a href="#程序输出-1" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">11</span> <br><span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">15</span> <span class="hljs-number">17</span> <br><span class="hljs-number">20</span> <span class="hljs-number">22</span> <span class="hljs-number">28</span> <span class="hljs-number">17</span> <br><span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">35</span> <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2022/03/31/Algorithm010/"/>
    <url>/2022/03/31/Algorithm010/</url>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的顺序存储解构"><a href="#队列的顺序存储解构" class="headerlink" title="队列的顺序存储解构"></a>队列的顺序存储解构</h3><h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><p>队列的顺序存储类型可描述为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义队列中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放队列元素</span><br>    <span class="hljs-keyword">int</span> front,rear;<span class="hljs-comment">//队头指针和队尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><h4 id="循环队列的操作"><a href="#循环队列的操作" class="headerlink" title="循环队列的操作"></a>循环队列的操作</h4><p>(1)初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>    Q.rear=Q.front=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化队首、队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(2)判队空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//队空条件</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(3)入队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MaxSize==Q.front)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//队满则报错</span><br>    Q.data[Q.rear]=x;<br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队尾指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(4)出队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//队列空则报错</span><br>    x=Q.data[Q.front];<br>    Q.front=(Q.front+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队头指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="循环队列的完整操作"><a href="#循环队列的完整操作" class="headerlink" title="循环队列的完整操作"></a>循环队列的完整操作</h4><h5 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义队列中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放队列元素</span><br>    <span class="hljs-keyword">int</span> front,rear;<span class="hljs-comment">//队头指针和队尾指针</span><br>&#125;SqQueue;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>    Q.rear=Q.front=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化队首、队尾指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//队空条件</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MaxSize==Q.front)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//队满则报错</span><br>    Q.data[Q.rear]=x;<br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队尾指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//队列空则报错</span><br>    x=Q.data[Q.front];<br>    Q.front=(Q.front+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队头指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintSqQueue</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<span class="hljs-comment">//遍历操作 </span><br><span class="hljs-keyword">int</span> point = Q.front;<br><span class="hljs-keyword">while</span>(point!=Q.rear)<span class="hljs-comment">//如果point指向Q.rear说明遍历结束 </span><br>&#123;<span class="hljs-comment">//也就是point指向了队尾元素的下一个位置 </span><br>cout&lt;&lt;Q.data[point]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>point=(point+<span class="hljs-number">1</span>)%MaxSize;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>SqQueue Q;<span class="hljs-comment">//声明了一个顺序队列 </span><br><span class="hljs-built_in">InitQueue</span>(Q);<span class="hljs-comment">//初始化这个队列 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-built_in">EnQueue</span>(Q,i);<span class="hljs-comment">//入队操作 </span><br>&#125;<br><span class="hljs-built_in">PrintSqQueue</span>(Q);<span class="hljs-comment">//遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">DeQueue</span>(Q,x);<span class="hljs-comment">//出队 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是第&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;次出队&quot;</span>&lt;&lt;<span class="hljs-string">&quot;出队的元素是&quot;</span> &lt;&lt;x&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isEmpty</span>(Q))<span class="hljs-comment">//队列非空则遍历 </span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;当前队列为：&quot;</span>;<br><span class="hljs-built_in">PrintSqQueue</span>(Q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;此时的队列为空队列&quot;</span>&lt;&lt;endl;<br>&#125;<br><br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">1</span>次出队出队的元素是<span class="hljs-number">0</span><br>当前队列为：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">2</span>次出队出队的元素是<span class="hljs-number">1</span><br>当前队列为：<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">3</span>次出队出队的元素是<span class="hljs-number">2</span><br>当前队列为：<span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">4</span>次出队出队的元素是<span class="hljs-number">3</span><br>当前队列为：<span class="hljs-number">4</span><br>这是第<span class="hljs-number">5</span>次出队出队的元素是<span class="hljs-number">4</span><br>此时的队列为空队列<br></code></pre></td></tr></table></figure><h3 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h3><h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><p>队列的链式存储类型可描述为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><span class="hljs-comment">//链式队列结点</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LinkNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//链式队列</span><br>    LinkNode *front,*rear;<span class="hljs-comment">//队列的对头和队尾指针</span><br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><h4 id="链式队列的基本操作"><a href="#链式队列的基本操作" class="headerlink" title="链式队列的基本操作"></a>链式队列的基本操作</h4><p>(1)初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    Q.front = Q.rear=(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<span class="hljs-comment">//建立头结点</span><br>    Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始为空</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(2判队空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(3)入队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;<br>    LinkNode *s =(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<br>    s-&gt;data=x;<span class="hljs-comment">//创建新结点，插入到链尾</span><br>    s-&gt;next=<span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next=s;<br>    Q.rear=s;<br>&#125;<br></code></pre></td></tr></table></figure><p>(4)出队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//空队</span><br>    LinkNode *p =Q.front-&gt;next;<br>    x=p-&gt;data;<br>    Q.front-&gt;next=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear==p)&#123;<br>        Q.rear = Q.front;<span class="hljs-comment">//若原队列中只有一个结点，删除后变空</span><br>    &#125;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链式队列的完整操作"><a href="#链式队列的完整操作" class="headerlink" title="链式队列的完整操作"></a>链式队列的完整操作</h4><h5 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><span class="hljs-comment">//链式队列结点</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LinkNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//链式队列</span><br>    LinkNode *front,*rear;<span class="hljs-comment">//队列的对头和队尾指针</span><br>&#125;LinkQueue;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    Q.front = Q.rear=(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<span class="hljs-comment">//建立头结点</span><br>    Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始为空</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    LinkNode *s =(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<br>    s-&gt;data=x;<span class="hljs-comment">//创建新结点，插入到链尾</span><br>    s-&gt;next=<span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next=s;<br>    Q.rear=s;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,<span class="hljs-keyword">int</span> &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//空队</span><br>    LinkNode *p =Q.front-&gt;next;<br>    x=p-&gt;data;<br>    Q.front-&gt;next=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear==p)&#123;<br>        Q.rear = Q.front;<span class="hljs-comment">//若原队列中只有一个结点，删除后变空</span><br>    &#125;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintQueue</span><span class="hljs-params">(LinkQueue Q)</span><span class="hljs-comment">//遍历队列 </span></span><br><span class="hljs-function"></span>&#123;<br>LinkNode *tmp=Q.front-&gt;next;<span class="hljs-comment">//声明一个结点用于遍历</span><br><span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果这个结点为空则停止遍历</span><br>&#123;<span class="hljs-comment">//这里即tmp已经指向最后一个元素的-&gt;next</span><br>cout&lt;&lt;tmp-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//因为在初始化时已经置最后一个元素的-&gt;next=NULL</span><br>tmp=tmp-&gt;next;<span class="hljs-comment">//所以说这里只需要判断tmp为空即可</span><br>&#125;<br>cout&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>LinkQueue Q;<span class="hljs-comment">//声明链式一个队列 </span><br><span class="hljs-built_in">InitQueue</span>(Q);<span class="hljs-comment">//初始化队列 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">5</span>;i&gt;<span class="hljs-number">0</span>;i--)     <span class="hljs-comment">//创建队列 </span><br>&#123;<br><span class="hljs-built_in">EnQueue</span>(Q,i);<br>&#125;<br><span class="hljs-built_in">PrintQueue</span>(Q);      <span class="hljs-comment">//遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">DeQueue</span>(Q,x);<span class="hljs-comment">//出队 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是第&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;次出队&quot;</span>&lt;&lt;<span class="hljs-string">&quot;出队的元素是&quot;</span> &lt;&lt;x&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))<span class="hljs-comment">//队列非空则遍历 </span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;当前队列为：&quot;</span>;<br><span class="hljs-built_in">PrintQueue</span>(Q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;此时的队列为空队列&quot;</span>&lt;&lt;endl;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="程序输出：-1"><a href="#程序输出：-1" class="headerlink" title="程序输出："></a>程序输出：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">1</span>次出队出队的元素是<span class="hljs-number">5</span><br>当前队列为：<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">2</span>次出队出队的元素是<span class="hljs-number">4</span><br>当前队列为：<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">3</span>次出队出队的元素是<span class="hljs-number">3</span><br>当前队列为：<span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">4</span>次出队出队的元素是<span class="hljs-number">2</span><br>当前队列为：<span class="hljs-number">1</span><br>这是第<span class="hljs-number">5</span>次出队出队的元素是<span class="hljs-number">1</span><br>此时的队列为空队列<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2022/03/30/Algorithm009/"/>
    <url>/2022/03/30/Algorithm009/</url>
    
    <content type="html"><![CDATA[<h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><h3 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h3><p>栈的顺序存储类型可描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义栈中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放栈中元素</span><br>    <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶指针</span><br>&#125;SqStack;<br></code></pre></td></tr></table></figure><h3 id="顺序栈的基本运算"><a href="#顺序栈的基本运算" class="headerlink" title="顺序栈的基本运算"></a>顺序栈的基本运算</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;s)</span></span>&#123;<br>    s.top=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判栈空"><a href="#判栈空" class="headerlink" title="判栈空"></a>判栈空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//不空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;s,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == MaxSize<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈满，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s.data[++s.top]=x;<span class="hljs-comment">//指针先加1，在入栈</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;s,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    x=s.data[s.top--];<span class="hljs-comment">//先出栈，指针再减1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s,ElemType &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span> )<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   x=s.data[s.top];<span class="hljs-comment">//x记录栈顶元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序栈的完整操作"><a href="#顺序栈的完整操作" class="headerlink" title="顺序栈的完整操作"></a>顺序栈的完整操作</h3><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义栈中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放栈中元素</span><br>    <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶指针</span><br>&#125;SqStack;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;s)</span></span>&#123;<br>    s.top=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化栈顶指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//不空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;s,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == MaxSize<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈满，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s.data[++s.top]=x;<span class="hljs-comment">//指针先加1，在入栈</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;s,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    x=s.data[s.top--];<span class="hljs-comment">//先出栈，指针再减1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s,ElemType &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span> )<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   x=s.data[s.top];<span class="hljs-comment">//x记录栈顶元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintSqStack</span><span class="hljs-params">(SqStack s)</span><span class="hljs-comment">//遍历栈 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> tmp = s.top;<br><span class="hljs-keyword">while</span>(tmp!=<span class="hljs-number">-1</span>)<span class="hljs-comment">//如果tmp==-1说明遍历结束 </span><br>&#123; <br>cout&lt;&lt;s.data[tmp--]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>SqStack s;<span class="hljs-comment">//声明一个顺序栈 </span><br><span class="hljs-built_in">InitStack</span>(s);<span class="hljs-comment">//初始化一个顺序栈 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-built_in">Push</span>(s,i);<span class="hljs-comment">//入栈 </span><br>&#125;<br><span class="hljs-built_in">PrintSqStack</span>(s);<span class="hljs-comment">//遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<span class="hljs-comment">//为了对比GetTop和Pop操作 </span><br><span class="hljs-keyword">int</span> x; <br><span class="hljs-built_in">GetTop</span>(s,x);<span class="hljs-comment">//取栈顶元素 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是GetTop操作,栈顶元素为&quot;</span>&lt;&lt;x&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;这是GetTop操作后的栈遍历:&quot;</span>;<br><span class="hljs-built_in">PrintSqStack</span>(s); <br><span class="hljs-built_in">Pop</span>(s,x);<span class="hljs-comment">//出栈 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是Pop操作,出栈的元素为&quot;</span>&lt;&lt;x&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">StackEmpty</span>(s))<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;这是Pop操作后的栈遍历:&quot;</span>;<br><span class="hljs-built_in">PrintSqStack</span>(s); <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;此时栈空！&quot;</span>&lt;&lt;endl;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">5</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">5</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">4</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">4</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">3</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">3</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">2</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">2</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">1</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">1</span><br>此时栈空！<br></code></pre></td></tr></table></figure><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>栈的链式存储类型可描述为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Linknode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Linknode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span><br>&#125;*Linknode;<span class="hljs-comment">//栈类型操作</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双链表与静态链表</title>
    <link href="/2022/03/29/Algorithm008/"/>
    <url>/2022/03/29/Algorithm008/</url>
    
    <content type="html"><![CDATA[<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>双链表中结点类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>&#123;</span><span class="hljs-comment">//定义双链表结点类型</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span><span class="hljs-comment">//前驱和后继指针</span><br>&#125;DNode,*DLinkList;<br></code></pre></td></tr></table></figure><h3 id="双链表的插入操作"><a href="#双链表的插入操作" class="headerlink" title="双链表的插入操作"></a>双链表的插入操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p所指结点是s所指结点的前驱结点</span><br>s-&gt;next=p-&gt;next;           <span class="hljs-comment">//将结点*s插入到结点*p之后</span><br>p-&gt;next-&gt;prior=s;<br>s-&gt;prior=p;<br>p-&gt;next=s;<br></code></pre></td></tr></table></figure><h3 id="双链表的删除操作"><a href="#双链表的删除操作" class="headerlink" title="双链表的删除操作"></a>双链表的删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//删除双链表中结点*p的后继结点*q</span><br>p-&gt;next=q-&gt;next;<br>q-&gt;next-&gt;prior=p;<br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放节点空间</span><br></code></pre></td></tr></table></figure><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>静态链表结构类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//静态链表的最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//静态链表结构类型的定义</span><br>    ElemType data;<span class="hljs-comment">//储存数据元素</span><br>    <span class="hljs-keyword">int</span> next;<span class="hljs-comment">//下一个元素的数组下标</span><br>&#125;SLinkList[MaxSize];<br></code></pre></td></tr></table></figure><h3 id="对静态链表结构类型的定义的理解与猜想验证"><a href="#对静态链表结构类型的定义的理解与猜想验证" class="headerlink" title="对静态链表结构类型的定义的理解与猜想验证"></a>对静态链表结构类型的定义的理解与猜想验证</h3><p><img src="/2022/03/29/Algorithm008/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8-16485415016461.png" alt="静态链表"></p><p><img src="/2022/03/29/Algorithm008/123-16485415073922.png" alt="123"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表上的基本操作</title>
    <link href="/2022/03/28/Algorithm007/"/>
    <url>/2022/03/28/Algorithm007/</url>
    
    <content type="html"><![CDATA[<h2 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h2><p>单链表中结点类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span><br>&#125;LNode,*LinkList;<br></code></pre></td></tr></table></figure><h2 id="单链表上基本操作的实现"><a href="#单链表上基本操作的实现" class="headerlink" title="单链表上基本操作的实现"></a>单链表上基本操作的实现</h2><h3 id="1-采用头插法建立单链表"><a href="#1-采用头插法建立单链表" class="headerlink" title="1.采用头插法建立单链表"></a>1.采用头插法建立单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//逆向建立单链表</span><br>    LNode *s;<br>    <span class="hljs-keyword">int</span> x;<br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//创建头结点</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始化为空链表</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<span class="hljs-comment">//输入结点的值</span><br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<span class="hljs-comment">//输入9999表示结束</span><br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//建立新结点</span><br>        s-&gt;data = x;<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;<span class="hljs-comment">//将新结点插入表中，L为头指针</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-采用尾插法建立单链表"><a href="#2-采用尾插法建立单链表" class="headerlink" title="2.采用尾插法建立单链表"></a>2.采用尾插法建立单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">List_TailInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//正向建立单链表</span><br>    <span class="hljs-keyword">int</span> x;<span class="hljs-comment">//设置元素类型为整型</span><br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>    LNode *s,*r=L;<span class="hljs-comment">//r为表尾指针</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>        s-&gt;data=x;<br>        r-&gt;next = s;<br>        r = s;<span class="hljs-comment">//r指向新的表尾结点</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        <br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-按序号查找结点值"><a href="#3-按序号查找结点值" class="headerlink" title="3.按序号查找结点值"></a>3.按序号查找结点值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LNode *<span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<span class="hljs-comment">//计数，初始为1</span><br>    LNode *p = L-&gt;next;<span class="hljs-comment">//第1个结点指针赋给p</span><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> L;<span class="hljs-comment">//若i等于0，则返回头结点</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//若i无效，则返回NULL</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)<span class="hljs-comment">//从第一个结点开始找，查找第i个结点</span><br>    &#123;<br>        p=p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-按值查找表结点"><a href="#4-按值查找表结点" class="headerlink" title="4.按值查找表结点"></a>4.按值查找表结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,ElemType e)</span></span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=e)<span class="hljs-comment">//从第i个结点开始查找data域为e的结点</span><br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//找到后返回该结点指针，否则返回NULL</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-插入结点操作"><a href="#5-插入结点操作" class="headerlink" title="5.插入结点操作"></a>5.插入结点操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p所指结点是s所指结点的前驱结点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>LNode *p;<br>LNode *s=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//一定要分配空间！！！！！</span><br>s-&gt;data=x;<br>s-&gt;next=<span class="hljs-literal">NULL</span>; <br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>s-&gt;next =p-&gt;next;<br>p-&gt;next=s;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;插入值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> ; <br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对某一结点进行前插操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//注意与插入结点相对比!!!!!!!!</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delect</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//p所指结点是q所指结点的前驱结点</span><br>LNode *p;<br>LNode *q=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));   <span class="hljs-comment">//申请空间 </span><br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);    <span class="hljs-comment">//查找删除位置的前驱结点</span><br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>||p-&gt;next==<span class="hljs-literal">NULL</span>)          <span class="hljs-comment">//p==NULL是i值不合法的情况 </span><br>&#123;    <span class="hljs-comment">//p-&gt;next==NUll是i-1号结点后已无其他结点 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;删除值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">free</span>(q);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>q=p-&gt;next;<span class="hljs-comment">//令q指向被删除的结点</span><br>p-&gt;next=q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-删除结点操作"><a href="#6-删除结点操作" class="headerlink" title="6.删除结点操作"></a>6.删除结点操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p所指结点是q所指结点的前驱结点</span><br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>)<span class="hljs-comment">//查找删除位置的前驱结点</span><br>q=p-&gt;next;<span class="hljs-comment">//令q指向被删除的结点</span><br>p-&gt;next=q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放结点的储存空间</span><br></code></pre></td></tr></table></figure><p>拓展:删除结点*p</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">q=p-&gt;next;<span class="hljs-comment">//令q指向*p的后继节点</span><br>p-&gt;data = p-&gt;next-&gt;data<span class="hljs-comment">//和后继结点交换数据域</span><br>p-&gt;next = q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放后继结点的储存空间</span><br></code></pre></td></tr></table></figure><h2 id="单链表上基本操作的完整实现"><a href="#单链表上基本操作的完整实现" class="headerlink" title="单链表上基本操作的完整实现"></a>单链表上基本操作的完整实现</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span><br>&#125;LNode,*LinkList;<br><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//逆向建立单链表</span><br>    LNode *s;<br>    <span class="hljs-keyword">int</span> x;<br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//创建头结点</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始化为空链表</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<span class="hljs-comment">//输入结点的值</span><br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<span class="hljs-comment">//输入9999表示结束</span><br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//建立新结点</span><br>        s-&gt;data = x;<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;<span class="hljs-comment">//将新结点插入表中，L为头指针</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><span class="hljs-function">LNode *<span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<span class="hljs-comment">//计数，初始为1</span><br>    LNode *p = L-&gt;next;<span class="hljs-comment">//第1个结点指针赋给p</span><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> L;<span class="hljs-comment">//若i等于0，则返回头结点</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//若i无效，则返回NULL</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)<span class="hljs-comment">//从第一个结点开始找，查找第i个结点</span><br>    &#123;<br>        p=p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span><br>&#125;<br><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,ElemType e)</span></span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=e)<span class="hljs-comment">//从第i个结点开始查找data域为e的结点</span><br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//找到后返回该结点指针，否则返回NULL</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintLinkList</span><span class="hljs-params">(LinkList L)</span></span>&#123;        <span class="hljs-comment">//这段代码根据链表表尾结点的 next 指针指向 NULL 来遍历整个链表。</span><br>LNode *tmp = L-&gt;next;<br><span class="hljs-keyword">if</span>(tmp==<span class="hljs-literal">NULL</span>)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;链表为空&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> ; <br>&#125;<br><span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>cout&lt;&lt;tmp-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>tmp=tmp-&gt;next;<br>&#125;<br>cout&lt;&lt;endl; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>LNode *p;<br>LNode *s=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//申请空间 </span><br>s-&gt;data=x;<br>s-&gt;next=<span class="hljs-literal">NULL</span>; <br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>s-&gt;next =p-&gt;next;<br>p-&gt;next=s;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;插入值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> ; <br>&#125;<br><br>&#125;<br><span class="hljs-comment">//注意与插入结点相对比!!!!!!!!</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delect</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//p所指结点是q所指结点的前驱结点</span><br>LNode *p;<br>LNode *q=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));   <span class="hljs-comment">//申请空间 </span><br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);    <span class="hljs-comment">//查找删除位置的前驱结点</span><br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>||p-&gt;next==<span class="hljs-literal">NULL</span>)          <span class="hljs-comment">//p==NULL是i值不合法的情况 </span><br>&#123;    <span class="hljs-comment">//p-&gt;next==NUll是i-1号结点后已无其他结点 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;删除值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">free</span>(q);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>q=p-&gt;next;<span class="hljs-comment">//令q指向被删除的结点</span><br>p-&gt;next=q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>LinkList L;<span class="hljs-comment">//声明一个单链表 </span><br><span class="hljs-built_in">List_HeadInsert</span>(L);<span class="hljs-comment">//使用头插法插入4个元素，分别是1,2,3,4 </span><br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br>LNode *tmp;<br>tmp=<span class="hljs-built_in">GetElem</span>(L,<span class="hljs-number">2</span>);<span class="hljs-comment">//找到位置为2的元素 </span><br><span class="hljs-keyword">if</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;位置为2的元素是：&quot;</span>&lt;&lt;tmp-&gt;data&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;非法的位置&quot;</span>&lt;&lt;endl;<br>&#125;<br>tmp=<span class="hljs-built_in">LocateElem</span>(L,<span class="hljs-number">1</span>);<span class="hljs-comment">//找到值为1的元素</span><br><span class="hljs-keyword">if</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;存在值为1的元素：&quot;</span>&lt;&lt;tmp-&gt;data&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;没有找到该值&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br><span class="hljs-built_in">Insert</span>(L,<span class="hljs-number">5</span>,<span class="hljs-number">110</span>);<span class="hljs-comment">//在5这个位置插入元素110</span><br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br><span class="hljs-built_in">Delect</span>(L,<span class="hljs-number">2</span>);        <span class="hljs-comment">//删除位序为2的元素</span><br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>位置为<span class="hljs-number">2</span>的元素是：<span class="hljs-number">3</span><br>存在值为<span class="hljs-number">1</span>的元素：<span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">110</span><br><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表的定义</title>
    <link href="/2022/03/28/Algorithm006/"/>
    <url>/2022/03/28/Algorithm006/</url>
    
    <content type="html"><![CDATA[<h1 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h1><h2 id="1-单链表的定义"><a href="#1-单链表的定义" class="headerlink" title="1.单链表的定义"></a>1.单链表的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>      <span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;         <span class="hljs-comment">//每个结点存放一个数据元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-comment">//指针指向下一个节点</span><br>&#125;LNode,*LinkList;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>      <span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;         <span class="hljs-comment">//每个结点存放一个数据元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-comment">//指针指向下一个节点</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> <span class="hljs-title">LNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></td></tr></table></figure><p>这两种定义是一模一样的！</p><p>要表示一个单链表时，只需要声明一个头指针L，指向单链表的第一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">LNoode *L;      <span class="hljs-comment">//声明一个指向单链表第一个结点的指针</span><br><span class="hljs-comment">//或：</span><br>LinkList L;     <span class="hljs-comment">//声明一个指向单链表第一个结点的指针</span><br></code></pre></td></tr></table></figure><h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">LNode *L；<br><span class="hljs-comment">//和：</span><br>LinkList L;<br><span class="hljs-comment">//两者的区别就是强调不同</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/Algorithm006/%E6%BC%94%E7%A4%BA.png"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优先队列</title>
    <link href="/2022/03/11/Algorithm005/"/>
    <url>/2022/03/11/Algorithm005/</url>
    
    <content type="html"><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>定义：priority_queue&lt;Type, Container, Functional&gt;</p><p>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。</p><p>当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。<br>一般是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//升序队列，小顶堆</span><br>priority_queue &lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br><span class="hljs-comment">//降序队列，大顶堆</span><br>priority_queue &lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt; &gt;q;<br><br><span class="hljs-comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span><br></code></pre></td></tr></table></figure><h2 id="样例一P1090-NOIP2004-提高组-合并果子-USACO06NOV-Fence-Repair-G"><a href="#样例一P1090-NOIP2004-提高组-合并果子-USACO06NOV-Fence-Repair-G" class="headerlink" title="样例一P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G"></a>样例一P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p><p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p><p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p><p>例如有 33种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 、 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 =3+12=15 。可以证明 15为最小的体力耗费值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>共两行。<br>第一行是一个整数 n*(1≤<em>n</em>≤10000) ，表示果子的种类数。</p><p>第二行包含 <em>n</em> 个整数，用空格分隔，第 <em>i</em> 个整数 a<strong>i*(1≤*a</strong>i<em>≤20000) 是第 i</em> 种果子的数目。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^{31} 。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a><strong>输入 #1</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">3</span> <br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a><strong>输出 #1</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> num;<br>        cin&gt;&gt;num;<br>        q.<span class="hljs-built_in">push</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n<span class="hljs-number">-1</span> ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> a=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">int</span> b=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        ans+=a+b;<br>        q.<span class="hljs-built_in">push</span>(a+b);<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/huashanqingzhu/p/11040390.html">c++优先队列(priority_queue)用法详解 - 华山青竹 - 博客园 (cnblogs.com)</a></p><p>[P1090 <a href="https://www.luogu.com.cn/problem/P1090">NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perf-系统级性能分析工具</title>
    <link href="/2022/01/19/tool003/"/>
    <url>/2022/01/19/tool003/</url>
    
    <content type="html"><![CDATA[<p>系统级性能优化通常包括两个阶段：性能剖析（performance profiling）和代码优化。</p><p>性能剖析的目标是寻找性能瓶颈，查找引发性能问题的原因及热点代码。</p><p>代码优化的目标是针对具体性能问题而优化代码或编译选项，以改善软件性能。</p><p>在性能剖析阶段，需要借助于现有的profiling工具，如perf等。在代码优化阶段往往需要借助开发者的经验，编写简洁高效的代码，甚至在汇编级别合理使用各种指令，合理安排各种指令的执行顺序。</p><p>perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。<br>通过perf，应用程序可以利用PMU、tracepoint和内核中的计数器来进行性能统计。它不但可以分析制定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用程序和内核，从而全面理解应用程序中的性能瓶颈。</p><p>使用perf，可以分析程序运行期间发生的硬件事件，比如instructions retired、processor clock cycles等；也可以分析软件时间，比如page fault和进程切换。</p><p>perf是一款综合性分析工具，大到系统全局性性能，再小到进程线程级别，甚至到函数及汇编级别。</p><p>perf提供了十八般武器，可以拿大刀大卸八块，也可以拿起手术刀细致分析。</p><h1 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1. 背景知识"></a>1. 背景知识</h1><h2 id="1-1-tracepoints"><a href="#1-1-tracepoints" class="headerlink" title="1.1 tracepoints"></a>1.1 tracepoints</h2><p>tracepoints是散落在内核源码中的一些hook，它们可以在特定的代码被执行到时触发，这一特定可以被各种trace/debug工具所使用。</p><p>perf将tracepoint产生的时间记录下来，生成报告，通过分析这些报告，便可以了解程序运行期间内核的各种细节，对性能症状做出准确的诊断。</p><p>这些tracepint的对应的sysfs节点在/sys/kernel/debug/tracing/events目录下。</p><h2 id="1-2-硬件特性之cache"><a href="#1-2-硬件特性之cache" class="headerlink" title="1.2 硬件特性之cache"></a>1.2 硬件特性之cache</h2><p>内存读写是很快的，但是还是无法和处理器指令执行速度相比。为了从内存中读取指令和数据，处理器需要等待，用处理器时间来衡量，这种等待非常漫长。cache是一种SRAM，读写速度非常快，能和处理器相匹配。因此将常用的数据保存在cache中，处理器便无需等待，从而提高性能。cache的尺寸一般都很小，充分利用cache是软件调优非常重要部分。</p><h1 id="2-主要关注点"><a href="#2-主要关注点" class="headerlink" title="2. 主要关注点"></a>2. 主要关注点</h1><p>基于性能分析，可以进行算法优化（空间复杂度和时间复杂度权衡）、代码优化（提高执行速度、减少内存占用）。</p><p>评估程序对硬件资源的使用情况，例如各级cache的访问次数、各级cache的丢失次数、流水线停顿周期、前端总线访问次数等。</p><p>评估程序对操作系统资源的使用情况，系统调用次数、上下文切换次数、任务迁移次数。</p><p>事件可以分为三种：</p><ol><li>Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。</li><li>Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如进程切换，tick数等。</li><li>Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。</li></ol><h1 id="3-perf的使用"><a href="#3-perf的使用" class="headerlink" title="3. perf的使用"></a>3. perf的使用</h1><p>perf –help后可以看到perf的二级命令</p><p><img src="/2022/01/19/tool003/image-20220119120817508.png"></p><h2 id="3-1perf-list"><a href="#3-1perf-list" class="headerlink" title="3.1perf list"></a>3.1perf list</h2><p>perf list查看支持的事件类型</p><p><img src="/2022/01/19/tool003/image-20220119121131231.png"></p><h2 id="3-2perf-top"><a href="#3-2perf-top" class="headerlink" title="3.2perf top"></a>3.2perf top</h2><p>即可以正常显示perf top如下：</p><p>第一列：符号引发的性能事件的比例，指占用的cpu周期比例。</p><p>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。</p><p>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库；[k]表述此符号属于内核或模块。</p><p>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p><p><img src="/2022/01/19/tool003/image-20220119121453395.png"></p><h2 id="3-3-perf-stat"><a href="#3-3-perf-stat" class="headerlink" title="3.3 perf stat"></a>3.3 perf stat</h2><p>perf stat用于运行指令，并分析其统计结果。虽然perf top也可以指定pid，但是必须先启动应用才能查看信息。</p><p>perf stat能完整统计应用整个生命周期的信息。</p><p>命令格式为：</p><blockquote><p>perf stat [-e <EVENT> | –event=EVENT] [-a] <command><br>perf stat [-e <EVENT> | –event=EVENT] [-a] — <command> [<options>]</options></EVENT></EVENT></p></blockquote><p><img src="/2022/01/19/tool003/image-20220119122351095.png" alt="image-20220119122351095"></p><p><img src="/2022/01/19/tool003/C2DDB2280E83453D6D8FE0D11A4380C3.png"></p><p>cpu-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized = task-clock / time elapsed，CPU的占用率。</p><p>context-switches：程序在运行过程中上下文的切换次数。</p><p>CPU-migrations：程序在运行过程中发生的处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。</p><p>CPU迁移和上下文切换：发生上下文切换不一定会发生CPU迁移，而发生CPU迁移时肯定会发生上下文切换。发生上下文切换有可能只是把上下文从当前CPU中换出，下一次调度器还是将进程安排在这个CPU上执行。</p><p>page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。</p><p>cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles / task-clock算出。</p><p>stalled-cycles-frontend：指令读取或解码的质量步骤，未能按理想状态发挥并行左右，发生停滞的时钟周期。</p><p>stalled-cycles-backend：指令执行步骤，发生停滞的时钟周期。</p><p>instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。</p><p>branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p><h2 id="3-4-perf-record-amp-report"><a href="#3-4-perf-record-amp-report" class="headerlink" title="3.4 perf record &amp; report"></a>3.4 perf record &amp; report</h2><p>运行一个命令，并将其数据保存到perf.data中。随后，可以使用perf report进行分析。</p><p>perf record和perf report可以更精确的分析一个应用，perf record可以精确到函数级别。并且在函数里面混合显示汇编语言和代码。</p><p><img src="/2022/01/19/tool003/image-20220119123152290.png"></p><p>1.编译程序(这里以test.c为例子)</p><p><img src="/2022/01/19/tool003/image-20220119124049654.png"></p><p>2.perf record</p><p><img src="/2022/01/19/tool003/image-20220119124217563.png"></p><p>3.perf report</p><p><img src="/2022/01/19/tool003/image-20220119124149337.png"></p><p><img src="/2022/01/19/tool003/image-20220119124013315.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/arnoldlu/p/6241297.html">系统级性能分析工具perf的介绍与使用 - ArnoldLu - 博客园 (cnblogs.com)</a>-系统性能分析工具perf的介绍与使用</p><p><a href="https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=11304698501320722134&spm_id_from=333.337.0.0">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcov代码覆盖率测试</title>
    <link href="/2022/01/18/tool002/"/>
    <url>/2022/01/18/tool002/</url>
    
    <content type="html"><![CDATA[<h1 id="gcov代码覆盖率测试"><a href="#gcov代码覆盖率测试" class="headerlink" title="gcov代码覆盖率测试"></a>gcov代码覆盖率测试</h1><h2 id="gcov的简单介绍"><a href="#gcov的简单介绍" class="headerlink" title="gcov的简单介绍"></a>gcov的简单介绍</h2><p>1.gcov是一个测试代码覆盖率的工具。与GCC一起使用来分析程序，以帮助创建更高效、更快的运行代码，并发现程序的未测试部分<br>2.是一个命令行方式的控制台程序。需要结合lcov,gcovr等前端图形工具才能实现统计数据图形化<br>3.伴随GCC发布，不需要单独下载gcov工具。配合GCC共同实现对c/c++文件的语句覆盖和分支覆盖测试<br>4.与程序概要分析工具（profiling tool，例如gprof）一起工作，可以估计程序中哪段代码最耗时</p><h2 id="gcov能做什么"><a href="#gcov能做什么" class="headerlink" title="gcov能做什么"></a>gcov能做什么</h2><p>使用像gcov或gprof这样的分析器，您可以找到一些基本的性能统计数据：</p><ul><li>每一行代码执行的频率是多少</li><li>实际执行了哪些行代码，配合测试用例达到满意的覆盖率和预期工作</li><li>每段代码使用了多少计算时间，从而找到热点优化代码</li><li>gcov创建一个sourcefile.gcov的日志文件，此文件标识源文件sourcefile.c每一行执行的次数,您可以与gprof一起使用这些日志文件来帮助优化程序的性能。gprof提供了您可以使用的时间信息以及从gcov获得的信息。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.通过将一些代码行合并到一个函数中，可能不会提供足够的信息来查找代码使用大量计算机时间的“热点”。同样地，由于gcov按行(在最低的分辨率下)积累统计数据，它最适合于只在每行上放置一个语句的编程风格。如果您使用扩展到循环或其他控制结构的复杂宏，那么统计信息就没有那么有用了——它们只报告出现宏调用的行。如果您的复杂宏的行为类似于函数，那么您可以用inline fu替换它们。<br>2.gcov只在使用GCC编译的代码上工作。它与任何其他概要或测试覆盖机制不兼容。</p><h2 id="使用gcov的3个阶段"><a href="#使用gcov的3个阶段" class="headerlink" title="使用gcov的3个阶段"></a>使用gcov的3个阶段</h2><h3 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1.编译阶段"></a>1.编译阶段</h3><p>要开启gcov功能，需要在源码编译参数中加入-fprofile-arcs -ftest-coverage</p><ul><li>-ftest-coverage：在编译的时候产生.gcno文件，它包含了重建基本块图和相应的块的源码的行号的信息。</li><li>-fprofile-arcs：在运行编译过的程序的时候，会产生.gcda文件，它包含了弧跳变的次数等信息。</li></ul><p>以下我们以test.c这个程序为例子，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> a =<span class="hljs-number">20220118</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编译阶段：</strong></p><p><img src="/2022/01/18/tool002/image-20220118145007919.png"></p><h3 id="2-gcov收集代码运行信息"><a href="#2-gcov收集代码运行信息" class="headerlink" title="2. gcov收集代码运行信息"></a>2. gcov收集代码运行信息</h3><ul><li>运行<code>./test</code>产生<code>test.gcda</code>文件，其中包含了代码基本块和狐跳变次数统计信息</li></ul><p><img src="/2022/01/18/tool002/image-20220118145103922.png"></p><h4 id="3-生成gcov代码覆盖率报告"><a href="#3-生成gcov代码覆盖率报告" class="headerlink" title="3. 生成gcov代码覆盖率报告"></a>3. 生成gcov代码覆盖率报告</h4><ul><li>再次运行<code>gcov test.c</code>产生的<code>test.c.gcov</code>中包含了代码覆盖率数据,其数据的来源为<code>test.gcda</code></li></ul><p><img src="/2022/01/18/tool002/image-20220118145303290.png"></p><h3 id="4-查看生成gcov代码覆盖率报告"><a href="#4-查看生成gcov代码覆盖率报告" class="headerlink" title="4.查看生成gcov代码覆盖率报告"></a>4.查看生成gcov代码覆盖率报告</h3><p><img src="/2022/01/18/tool002/image-20220118145514099.png"></p><p>可以看到以下结果：</p><ul><li>其中<code>#####</code>表示未运行的行</li><li>每行前面的数字表示行运行的次数</li><li>—代表不必执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">-:    <span class="hljs-number">0</span>:Source:test.c<br>-:    <span class="hljs-number">0</span>:Graph:test.gcno<br>-:    <span class="hljs-number">0</span>:Data:test.gcda<br>-:    <span class="hljs-number">0</span>:Runs:<span class="hljs-number">1</span><br>-:    <span class="hljs-number">0</span>:Programs:<span class="hljs-number">1</span><br>-:    <span class="hljs-number">1</span>:<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">1</span>:    <span class="hljs-number">2</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">-:    3:</span>&#123;<br><span class="hljs-number">1</span>:    <span class="hljs-number">4</span>:        <span class="hljs-keyword">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-number">1</span>:    <span class="hljs-number">5</span>:        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-number">5</span>:    <span class="hljs-number">6</span>:        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>-:    <span class="hljs-number">7</span>:        &#123;<br><span class="hljs-number">4</span>:    <span class="hljs-number">8</span>:           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>-:    <span class="hljs-number">9</span>:        &#125;<br><span class="hljs-number">1</span>:   <span class="hljs-number">10</span>:        <span class="hljs-keyword">int</span> a =<span class="hljs-number">20220118</span>;<br><span class="hljs-number">1</span>:   <span class="hljs-number">11</span>:        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a);<br><span class="hljs-number">1</span>:   <span class="hljs-number">12</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>-:   <span class="hljs-number">13</span>:&#125;<br></code></pre></td></tr></table></figure><h2 id="配合lcov使用，图形化显示"><a href="#配合lcov使用，图形化显示" class="headerlink" title="配合lcov使用，图形化显示"></a>配合lcov使用，图形化显示</h2><p><strong>1.centos安装lcov:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">yum install lcov<br></code></pre></td></tr></table></figure><p><strong>2.运行lcov，生成相应信息</strong></p><p><img src="/2022/01/18/tool002/image-20220118151526665.png"></p><p>运行结果：</p><p><img src="/2022/01/18/tool002/image-20220118151553801.png"></p><p><strong>3.生成web可视化信息</strong></p><p><img src="/2022/01/18/tool002/image-20220118151821325.png"></p><p>运行结果：</p><p><img src="/2022/01/18/tool002/image-20220118151853477.png"></p><p><strong>4.打包result文件</strong></p><p><img src="/2022/01/18/tool002/image-20220118152629648.png"></p><p><strong>5.从服务器下载到本地</strong></p><p><img src="/2022/01/18/tool002/image-20220118152705023.png"></p><p><strong>6.查看web</strong></p><p>​                    1）查看index.html：</p><p><img src="/2022/01/18/tool002/image-20220118152825105.png"></p><p>​                        2）详细信息：</p><p><img src="/2022/01/18/tool002/image-20220118152908078.png"></p><p>上述界面包含：</p><ul><li>函数覆盖率（执行率）</li><li>代码行数覆盖率（执行率）</li><li>语句执行次数</li><li>源码级的详细信息</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/yanxiangyfg/article/details/80989680">(6条消息) gcov代码覆盖率测试-原理和实践总结_yanxiangyfg的专栏-CSDN博客_gcov代码覆盖率</a>-gcov代码覆盖率测试-原理和实践总结</p><p><a href="https://blog.csdn.net/u012247418/article/details/90137291">(6条消息) 代码覆盖率测试工具：gcov和lcov的使用_ARM-Linux-CSDN博客</a>-代码覆盖率测试工具：gcov和lcov的使用</p><p><a href="https://www.cnblogs.com/haoshine/p/5777735.html">linux文件夹打包命令 - 小作一个 - 博客园 (cnblogs.com)</a>-Linux文件打包命令</p><p><a href="https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=16561916178807634748&spm_id_from=333.337.0.0">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(五)-INT型数组相加操作</title>
    <link href="/2022/01/17/AVX005/"/>
    <url>/2022/01/17/AVX005/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX向量化学习-五-INT型数组相加操作"><a href="#AVX向量化学习-五-INT型数组相加操作" class="headerlink" title="AVX向量化学习(五)-INT型数组相加操作"></a>AVX向量化学习(五)-INT型数组相加操作</h1><p>使用AVX指令集进行2个INT型的数组相加操作</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m256i _mm256_loadu_si256 (__m256i <span class="hljs-keyword">const</span> * mem_addr)<br></code></pre></td></tr></table></figure><p><strong>Synopsis</strong></p><p>m256i _mm256_loadu_si256 (m256i const * mem_addr)<br>#include &lt;immintrin.h&gt;<br>Instruction: vmovdqu ymm, m256<br>CPUID Flags: AVX</p><p><strong>Description</strong></p><p>Load 256-bits of integer data from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">dst[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>] := MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr] <br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">7</td><td align="center">0.5</td></tr><tr><td align="left">Skylake</td><td align="center">7</td><td align="center">0.5</td></tr><tr><td align="left">Broadwell</td><td align="center">1</td><td align="center">0.25</td></tr><tr><td align="left">Haswell</td><td align="center">1</td><td align="center">0.25</td></tr><tr><td align="left">Ivy Bridge</td><td align="center">1</td><td align="center">0.5</td></tr></tbody></table><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m256i _mm256_add_epi32 (__m256i a, __m256i b)<br></code></pre></td></tr></table></figure><p><strong>Synopsis</strong></p><p>m256i _mm256_add_epi32 (m256i a, __m256i b)<br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd ymm, ymm, ymm<br>CPUID Flags: AVX2</p><p><strong>Description</strong></p><p>Add packed 32-bit integers in a and b, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FOR</span> j := <span class="hljs-number">0</span> to <span class="hljs-number">7</span> <br>     <span class="hljs-attribute">i</span> := j*<span class="hljs-number">32</span> <br>     <span class="hljs-attribute">dst</span>[i+<span class="hljs-number">31</span>:i] := a[i+<span class="hljs-number">31</span>:i] + b[i+<span class="hljs-number">31</span>:i] <br><span class="hljs-attribute">ENDFOR</span> <br><span class="hljs-attribute">dst</span>[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">1</td><td align="center">0.33</td></tr><tr><td align="left">Skylake</td><td align="center">1</td><td align="center">0.33</td></tr><tr><td align="left">Broadwell</td><td align="center">1</td><td align="center">0.5</td></tr><tr><td align="left">Haswell</td><td align="center">1</td><td align="center">0.5</td></tr></tbody></table><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">40</span>];<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">40</span>];<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> ans1[<span class="hljs-number">40</span>];    <span class="hljs-comment">//记录串行结果 </span><br><span class="hljs-keyword">int</span> ans2[<span class="hljs-number">40</span>]; <span class="hljs-comment">//记录AVX向量化后的结果</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br>a[i]=i;<br>b[i]=<span class="hljs-number">2</span>*i;<br>&#125;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br>ans1[i]=a[i]+b[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;串行计算结果：\n&quot;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans1[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>__m256i v0;<br>__m256i v1;<br>__m256i v2;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span><span class="hljs-number">-8</span>;i+=<span class="hljs-number">8</span>)<br>&#123;<br>v0 = _mm256_loadu_si256((<span class="hljs-keyword">const</span> __m256i*)(a+i)); <span class="hljs-comment">//强制类型转换</span><br>v1 = _mm256_loadu_si256((<span class="hljs-keyword">const</span> __m256i*)(b+i)); <span class="hljs-comment">//强制类型转化</span><br>v2 = _mm256_add_epi32(v0,v1);     <span class="hljs-comment">//v0+v1</span><br>_mm256_storeu_si256((__m256i*)(ans2+i),v2);<br><br>&#125;<span class="hljs-comment">//边界处理</span><br><span class="hljs-keyword">for</span> (;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br>ans2[i]=a[i]+b[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;并行计算结果：\n&quot;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans2[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">串行计算结果：<br><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">15</span> <span class="hljs-number">18</span> <span class="hljs-number">21</span> <span class="hljs-number">24</span> <span class="hljs-number">27</span> <span class="hljs-number">30</span> <span class="hljs-number">33</span> <span class="hljs-number">36</span> <span class="hljs-number">39</span> <span class="hljs-number">42</span> <span class="hljs-number">45</span> <span class="hljs-number">48</span> <span class="hljs-number">51</span> <span class="hljs-number">54</span> <span class="hljs-number">57</span> <span class="hljs-number">60</span> <span class="hljs-number">63</span> <span class="hljs-number">66</span> <span class="hljs-number">69</span> <span class="hljs-number">72</span> <span class="hljs-number">75</span> <span class="hljs-number">78</span> <span class="hljs-number">81</span> <span class="hljs-number">84</span> <span class="hljs-number">87</span> <span class="hljs-number">90</span> <span class="hljs-number">93</span> <span class="hljs-number">96</span> <span class="hljs-number">99</span> <span class="hljs-number">102</span> <span class="hljs-number">105</span> <span class="hljs-number">108</span> <span class="hljs-number">111</span> <span class="hljs-number">114</span> <span class="hljs-number">117</span><br>并行计算结果：<br><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">15</span> <span class="hljs-number">18</span> <span class="hljs-number">21</span> <span class="hljs-number">24</span> <span class="hljs-number">27</span> <span class="hljs-number">30</span> <span class="hljs-number">33</span> <span class="hljs-number">36</span> <span class="hljs-number">39</span> <span class="hljs-number">42</span> <span class="hljs-number">45</span> <span class="hljs-number">48</span> <span class="hljs-number">51</span> <span class="hljs-number">54</span> <span class="hljs-number">57</span> <span class="hljs-number">60</span> <span class="hljs-number">63</span> <span class="hljs-number">66</span> <span class="hljs-number">69</span> <span class="hljs-number">72</span> <span class="hljs-number">75</span> <span class="hljs-number">78</span> <span class="hljs-number">81</span> <span class="hljs-number">84</span> <span class="hljs-number">87</span> <span class="hljs-number">90</span> <span class="hljs-number">93</span> <span class="hljs-number">96</span> <span class="hljs-number">99</span> <span class="hljs-number">102</span> <span class="hljs-number">105</span> <span class="hljs-number">108</span> <span class="hljs-number">111</span> <span class="hljs-number">114</span> <span class="hljs-number">117</span><br></code></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>:     “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(四)-INT类型转化成DOUBLE类型</title>
    <link href="/2022/01/17/AVX004/"/>
    <url>/2022/01/17/AVX004/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX向量化学习-四-INT类型转化成DOUBLE类型"><a href="#AVX向量化学习-四-INT类型转化成DOUBLE类型" class="headerlink" title="AVX向量化学习(四)-INT类型转化成DOUBLE类型"></a>AVX向量化学习(四)-INT类型转化成DOUBLE类型</h1><p>使用AVX指令集把INT类型转化为DOUBLE类型</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m128i _mm_setr_epi32 (<span class="hljs-keyword">int</span> e3, <span class="hljs-keyword">int</span> e2, <span class="hljs-keyword">int</span> e1, <span class="hljs-keyword">int</span> e0)<br></code></pre></td></tr></table></figure><p><strong>Synopsis</strong></p><p>__m128i _mm_setr_epi32 (int e3, int e2, int e1, int e0)<br>#include &lt;emmintrin.h&gt;<br>Instruction: <strong>Sequence</strong><br>CPUID Flags: SSE2</p><p><strong>Description</strong></p><p>Set packed 32-bit integers in dst with the supplied values in reverse order.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">dst[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] := e3 <br>dst[<span class="hljs-number">63</span>:<span class="hljs-number">32</span>] := e2 <br>dst[<span class="hljs-number">95</span>:<span class="hljs-number">64</span>] := e1 <br>dst[<span class="hljs-number">127</span>:<span class="hljs-number">96</span>] := e0<br></code></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m256d _mm256_cvtepi32_pd (__m128i a)<br></code></pre></td></tr></table></figure><p><strong>Synopsis</strong></p><p>m256d _mm256_cvtepi32_pd (m128i a)<br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtdq2pd ymm, xmm<br>CPUID Flags: AVX</p><p><strong>Description</strong></p><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span> <br>    i := j*<span class="hljs-number">32</span> <br>    m := j*<span class="hljs-number">64</span> <br>    dst[m+<span class="hljs-number">63</span>:m] := <span class="hljs-built_in">Convert_Int32_To_FP64</span>(a[i+<span class="hljs-number">31</span>:i]) <br>ENDFOR <br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">7</td><td align="center">1</td></tr><tr><td align="left">Skylake</td><td align="center">7</td><td align="center">1</td></tr><tr><td align="left">Broadwell</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="left">Haswell</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="left">Ivy Bridge</td><td align="center">4</td><td align="center">1</td></tr></tbody></table><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>g++ int_to_double.cpp -msse2 -mavx -o test01</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>./test01</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    __m128i x = _mm_setr_epi32(a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>],a[<span class="hljs-number">3</span>]);   <span class="hljs-comment">//load</span><br> __m256d v5=_mm256_cvtepi32_pd(x);       <span class="hljs-comment">//convert</span><br>    _mm256_storeu_pd(b,v5);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>    &#123;<br>    cout&lt;&lt;b[i]&lt;&lt;endl;<br>&#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>:     “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gprof、gprof2dot.py、dot使用方法简介</title>
    <link href="/2022/01/09/tool001/"/>
    <url>/2022/01/09/tool001/</url>
    
    <content type="html"><![CDATA[<h1 id="gprof、gprof2dot-py、dot使用方法简介"><a href="#gprof、gprof2dot-py、dot使用方法简介" class="headerlink" title="gprof、gprof2dot.py、dot使用方法简介"></a>gprof、gprof2dot.py、dot使用方法简介</h1><h2 id="1-：gprof使用步骤如下，以SLIC为例："><a href="#1-：gprof使用步骤如下，以SLIC为例：" class="headerlink" title="(1)：gprof使用步骤如下，以SLIC为例："></a>(1)：gprof使用步骤如下，以SLIC为例：</h2><h3 id="1-在编译过程中添加-pg选项，命令如下："><a href="#1-在编译过程中添加-pg选项，命令如下：" class="headerlink" title="1 在编译过程中添加-pg选项，命令如下："></a>1 在编译过程中添加-pg选项，命令如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">gcc -pg SLIC.cpp -o SLIC<br></code></pre></td></tr></table></figure><h3 id="2-运行程序，运行结束之后会形成文件gmon-out，命令如下"><a href="#2-运行程序，运行结束之后会形成文件gmon-out，命令如下" class="headerlink" title="2 运行程序，运行结束之后会形成文件gmon.out，命令如下:"></a>2 运行程序，运行结束之后会形成文件gmon.out，命令如下:</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./SLIC</span><br></code></pre></td></tr></table></figure><h3 id="3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下："><a href="#3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下：" class="headerlink" title="3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下："></a>3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下：</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">gprof ./SLIC &gt; <span class="hljs-keyword">prof</span>.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>分析prof.log就可以获得程序的调用关系、函数执行时间等信息。对gprof的分析方法见以下blog</p><p><a href="http://blog.csdn.net/macky0668/article/details/6839517">http://blog.csdn.net/macky0668/article/details/6839517</a></p><h2 id="2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台"><a href="#2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台" class="headerlink" title="(2)：配合gprof2dot.py与dot工具的使用(我是安装在了Win10平台)"></a>(2)：配合<em>gprof2dot.py</em>与dot工具的使用(我是安装在了Win10平台)</h2><p>以上方法仍然存在一个问题就是分析结果不够直观，特别是函数的调用关系。因此为解决以上问题，可以配合<em>gprof2dot.py</em>与dot工具的使用。</p><h3 id="1-安装gprof2dot-py与dot"><a href="#1-安装gprof2dot-py与dot" class="headerlink" title="1.安装gprof2dot.py与dot"></a>1.安装<em>gprof2dot.py</em>与dot</h3><p><a href="https://github.com/jrfonseca/gprof2dot">GitHub - jrfonseca/gprof2dot: Converts profiling output to a dot graph.</a></p><h3 id="2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具"><a href="#2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具" class="headerlink" title="2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具"></a>2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具</h3><p><a href="https://graphviz.org/download/source/">Source Code | Graphviz</a></p><p>在使用上述工具前，还需要先产生prof.log文件，prof.log文件的产生方法见上文。</p><h3 id="3-首先通过命令行进入你安装gprof2dot-py的根目录："><a href="#3-首先通过命令行进入你安装gprof2dot-py的根目录：" class="headerlink" title="3.首先通过命令行进入你安装gprof2dot.py的根目录："></a>3.首先通过命令行进入你安装gprof2dot.py的根目录：</h3><p><img src="/2022/01/09/tool001/image-20220109165659998.png"></p><h3 id="4-通过以下命令即可得到函数调用图："><a href="#4-通过以下命令即可得到函数调用图：" class="headerlink" title="4.通过以下命令即可得到函数调用图："></a>4.通过以下命令即可得到函数调用图：</h3><p><img src="/2022/01/09/tool001/image-20220109170212157.png"></p><h3 id="5-结果如下："><a href="#5-结果如下：" class="headerlink" title="5.结果如下："></a>5.结果如下：</h3><p><img src="/2022/01/09/tool001/image-20220109170315471.png"></p><h2 id="3-：接上文补充几点可能无法产生gmon-out文件的情况："><a href="#3-：接上文补充几点可能无法产生gmon-out文件的情况：" class="headerlink" title="(3)：接上文补充几点可能无法产生gmon.out文件的情况："></a>(3)：接上文补充几点可能无法产生gmon.out文件的情况：</h2><p>  1.程序不是从main return或exit()退出，则可能不生成gmon.out。<br>  2.程序如果崩溃，可能不生成gmon.out。<br>  3.测试发现在虚拟机上运行，可能不生成gmon.out。<br>  4.程序忽略SIGPROF信号！一定不能捕获、忽略SIGPROF信号。man手册对SIGPROF的解释是：profiling timer expired. 如果忽略这个信号，gprof的输出则是：Each sample counts as 0.01 seconds. no time accumulated.<br>  5.如果程序运行时间非常短，则gprof可能无效</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://blog.csdn.net/u012927281/article/details/51132064">(4条消息) gprof、gprof2dot.py、dot使用方法简介_Andy.Wang的博客-CSDN博客_gprof2dot</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/01/04/Algorithm004/"/>
    <url>/2022/01/04/Algorithm004/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集（Disjoint Set）是一种非常精巧而实用的数据结构。用于处理不相交集合的合并问题。</p><p>并查集用来管理元素分组情况。并查集可以高效地进行如下操作。</p><p>1.查询元素 a和元素 b是否属于同一组。<br>2.合并元素 a和元素 b所在的组。<br><img src="/2022/01/04/Algorithm004/20191114081139557.png"></p><p><img src="/2022/01/04/Algorithm004/20191114081642983-16413015433853.png"></p><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><p>我们准备 n个节点来表示 n个元素。最开始时没有边。</p><p><img src="/2022/01/04/Algorithm004/20191114081846480.png"></p><h2 id="2-查询"><a href="#2-查询" class="headerlink" title="2.查询"></a>2.查询</h2><p>为了查询两个节点是否属于同一组，我们需要沿着树向上走，来查询包含这个元素的树的根是谁。如果两个节点走到了同一个根，那么就可以知道它们属于同一组。</p><p>在下图中，元素 2 和元素 5都走到了元素 1，因此它们属于同一组。另一方面，由于元素 7 走到的是元素 6，因此同元素 2或元素 5 属于不同组。</p><p><img src="/2022/01/04/Algorithm004/20191114082935860.png"></p><h2 id="3-合并"><a href="#3-合并" class="headerlink" title="3.合并"></a>3.合并</h2><p>像下图一样，从一个组的根向另一个组的根连边，这样两棵树就变成了一棵树， 也就把两个组合并为一个组了。</p><p><img src="/2022/01/04/Algorithm004/20191114082505100.png"></p><h2 id="4-路径压缩"><a href="#4-路径压缩" class="headerlink" title="4.路径压缩"></a>4.路径压缩</h2><p>上面的查询程序 find() 沿着搜索路径找到根结点，这条路径可能很长。</p><p>优化：沿路径返回时，顺便把 i 所属的集改成根结点。下次再搜，复杂度是 O(1)。</p><p>这种方法称为路径压缩，在递归过程中，整个搜索路径上的元素所属的集都被改为根结点。</p><p>路径压缩的思想是，我们只关心每个结点的父结点，而并不太关心树的真正的结构。路径压缩不仅优化了下次查询，而且也优化了合并，因为合并时也用到了查询。<br><img src="/2022/01/04/Algorithm004/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODE1MTg4,size_16,color_FFFFFF,t_70.png"><img src="/2022/01/04/Algorithm004/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODE1MTg4,size_16,color_FFFFFF,t_70-16413019286669.png"></p><h2 id="5-按秩合并"><a href="#5-按秩合并" class="headerlink" title="5.按秩合并"></a>5.按秩合并</h2><p>合并元素 x 和 y 时，先搜到它们的根结点；<br>合并这两个根结点：把一个根结点的集改成另一个根结点。<br>这两个根结点的高度不同，把高度较小的集合并到较大的集上，能减少树的高度。</p><p><img src="/2022/01/04/Algorithm004/20191114090118888.png"></p><p>这样，在初始化时就要用一个数组定义元素 i的高度，在合并时更改。</p><p>下面代码加入了上述两个优化，我们用编号代表每个元素。数组 par[ ]表示的是父亲的编号，par[ x ] = = x  时，x 是所在的树的根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> par[N];   <span class="hljs-comment">//父亲</span><br><span class="hljs-keyword">int</span> rank[N];  <span class="hljs-comment">//树的高度</span><br><br><span class="hljs-comment">// 初始化n个元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>par[i] = i;<br>rank[i] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查询树的根（路径压缩）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(par[x] == x)<br><span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> par[x] = <span class="hljs-built_in">find</span>(par[x]);<br>&#125;<br><br><span class="hljs-comment">// 合并x和y所属的集合（按秩合并）</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>x = <span class="hljs-built_in">find</span>(x);<br>y = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(x == y)  <span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span>(rank[x] &lt; rank[y])<br>par[x] = y;<br><span class="hljs-keyword">else</span><br>&#123;<br>par[y] = x;<br><span class="hljs-keyword">if</span>(rank[x] == rank[y])rank[x]++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="样题一：L2-024-部落-25-分"><a href="#样题一：L2-024-部落-25-分" class="headerlink" title="样题一：L2-024 部落 (25 分)"></a>样题一：<strong>L2-024 部落 (25 分)</strong></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查任意两个人是否属于同一个部落。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤104），是已知小圈子的个数。随后<em>N</em>行，每行按下列格式给出一个小圈子里的人：</p><p><em>K</em> <em>P</em>[1] <em>P</em>[2] ⋯ <em>P</em>[<em>K</em>]</p><p>其中<em>K</em>是小圈子里的人数，<em>P</em>[<em>i</em>]（<em>i</em>=1,⋯,<em>K</em>）是小圈子里每个人的编号。这里所有人的编号从1开始连续编号，最大编号不会超过104。</p><p>之后一行给出一个非负整数<em>Q</em>（≤104），是查询次数。随后<em>Q</em>行，每行给出一对被查询的人的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出<code>Y</code>，否则输出<code>N</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs in">4<br>3 10 1 2<br>2 3 4<br>4 1 5 7 8<br>3 9 6 4<br>2<br>10 5<br>3 7结尾无空行<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">10 2<br>Y<br>N结尾无空行<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  N=<span class="hljs-number">10005</span>;<br><span class="hljs-keyword">int</span> par[N];       <span class="hljs-comment">//父亲</span><br><span class="hljs-keyword">int</span> deep[N];      <span class="hljs-comment">//树的高度</span><br><span class="hljs-keyword">int</span> isroot[N];    <span class="hljs-comment">//用来记录互不相交的部落的个数。如果同属于一个部落，那个这个部落的元素的根节点都是一样的。</span><br>                  <span class="hljs-comment">//所以只要统计有多少个根节点就可以知道有多少个互不相交的部落个数</span><br>set&lt;<span class="hljs-keyword">int</span>&gt; st;      <span class="hljs-comment">//集合能很好的过滤到重复元素，可以很方便的用来统计不是重复元素的个数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        par[i] = i;<br>        deep[i] =<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(par[x] == x ) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> par[x] = <span class="hljs-built_in">find</span>(par[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    x=<span class="hljs-built_in">find</span>(x);<br>    y=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(deep[x]&lt;deep[y])<br>    &#123;<br>        par[x]=y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        par[y]=x;<br>        <span class="hljs-keyword">if</span>(deep[x]==deep[y]) deep[x]++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">10005</span>);<br>    <span class="hljs-built_in">memset</span>(isroot,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(isroot));<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> num,first;<br>        cin&gt;&gt;num&gt;&gt;first;<br>        st.<span class="hljs-built_in">insert</span>(first);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;num ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> next;<br>            cin&gt;&gt;next;<br>            st.<span class="hljs-built_in">insert</span>(next);<br>            <span class="hljs-built_in">unite</span>(first,next);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//寻找互不相交的部落</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=st.<span class="hljs-built_in">size</span>() ; ++l) &#123;<br>        isroot[<span class="hljs-built_in">find</span>(l)]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">1</span>; m &lt;=st.<span class="hljs-built_in">size</span>() ; ++m) &#123;<br>        ans+=isroot[m];<br>    &#125;<br>    cout&lt;&lt;st.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">int</span> time;<br>    cin&gt;&gt;time;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;time ; ++k) &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b))<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Y&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;N&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="相关资料："><a href="#相关资料：" class="headerlink" title="相关资料："></a>相关资料：</h2><p><a href="https://blog.csdn.net/qq_42815188/article/details/86769629">(3条消息) 并查集_早睡身体好hh-CSDN博客_并查集</a>：早睡身体好hh-并查集(CSDN)</p><h2 id="样题链接："><a href="#样题链接：" class="headerlink" title="样题链接："></a>样题链接：</h2><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805056736444416">题目详情 - L2-024 部落 (25 分) (pintia.cn)</a>：L2-024 部落 (25 分)</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径-Floyed和Dijkstra</title>
    <link href="/2022/01/03/Algorithm003/"/>
    <url>/2022/01/03/Algorithm003/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径-Floyed和Dijkstra"><a href="#最短路径-Floyed和Dijkstra" class="headerlink" title="最短路径-Floyed和Dijkstra"></a>最短路径-Floyed和Dijkstra</h1><h2 id="Floyed"><a href="#Floyed" class="headerlink" title="Floyed"></a>Floyed</h2><h3 id="样题一：P1364-医院设置"><a href="#样题一：P1364-医院设置" class="headerlink" title="样题一：P1364 医院设置"></a>样题一：P1364 医院设置</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设有一棵二叉树，如图：</p><p><img src="/2022/01/03/Algorithm003/166.png"></p><p>其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 11。如上图中，若医院建在1 处，则距离和 =4+12+2\times20+2\times40=136=4+12+2×20+2×40=136；若医院建在 33 处，则距离和 =4\times2+13+20+40=81=4×2+13+20+40=81。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>第一行一个整数 n<em>n</em>，表示树的结点数。</p><p>接下来的 n<em>n</em> 行每行描述了一个结点的状况，包含三个整数 w, u, v<em>w</em>,<em>u</em>,<em>v</em>，其中 w<em>w</em> 为居民人口数，u<em>u</em> 为左链接（为 00 表示无链接），v<em>v</em> 为右链接（为 00 表示无链接）。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>一个整数，表示最小距离和。</p><h4 id="输入输出样例："><a href="#输入输出样例：" class="headerlink" title="输入输出样例："></a>输入输出样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">13 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">40 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">81<br></code></pre></td></tr></table></figure><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> tree[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];   <span class="hljs-comment">//tree的作用邻接矩阵建树</span><br><span class="hljs-keyword">int</span> w[<span class="hljs-number">1000</span>],l,r;  <span class="hljs-comment">//w每个结点的居民人口数</span><br><span class="hljs-keyword">int</span> mindis;       <span class="hljs-comment">//最小记录和</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            tree[i][j]=<span class="hljs-number">0X3FFFFFFF</span>;    <span class="hljs-comment">//初始化邻接矩阵</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        tree[i][i]=<span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化</span><br>        cin&gt;&gt;w[i]&gt;&gt;l&gt;&gt;r;  <span class="hljs-comment">//读入数据</span><br>        <span class="hljs-keyword">if</span>(l&gt;<span class="hljs-number">0</span>) tree[i][l]=tree[l][i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(r&gt;<span class="hljs-number">0</span>) tree[i][r]=tree[r][i]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;=n ; ++k) <span class="hljs-comment">//用Floyed求任意两结点之间的最短路径</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(i!=k)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ; ++j) &#123;<br>                    <span class="hljs-keyword">if</span>(i!=j&amp;&amp;j!=k&amp;&amp;tree[i][k]+tree[k][j]&lt;tree[i][j])<br>                    &#123;<br>                        tree[i][j]=tree[i][k]+tree[k][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    mindis=INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//穷举医院建在N个结点，找出最短距离</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            sum+=tree[i][j]*w[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&lt;mindis) mindis=sum;<br>    &#125;<br>    cout&lt;&lt;mindis&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="样题二："><a href="#样题二：" class="headerlink" title="样题二："></a>样题二：</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p><img src="/2022/01/03/Algorithm003/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x5bm5fbWc=,size_16,color_FFFFFF,t_70.png"></p><p>输入n和m，代表n个节点，m条边，然后是m行输入，每行有x,y,z，代表x到y的路距离为z。<br>问题：从1出发到各点的最短路径</p><h4 id="测试样例："><a href="#测试样例：" class="headerlink" title="测试样例："></a>测试样例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">7</span> <span class="hljs-number">12</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">20</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">50</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">30</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">25</span><br><span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">70</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">40</span><br><span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">50</span><br><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">25</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">55</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span><br><span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">70</span><br><span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">50</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span><br><span class="hljs-attribute">70</span><br></code></pre></td></tr></table></figure><h4 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">int</span> mapdis[maxn][maxn];  <span class="hljs-comment">//表示x-&gt;y的距离(有向)</span><br><span class="hljs-keyword">int</span> dis[maxn];  <span class="hljs-comment">//代表最短路径长</span><br><span class="hljs-keyword">int</span> path[maxn];  <span class="hljs-comment">//记录前驱节点</span><br><span class="hljs-keyword">int</span> vis[maxn]; <span class="hljs-comment">//用来记录该点是否已经是最短路径的点</span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dis));<br>    <span class="hljs-built_in">memset</span>(path,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(path));<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>    <br>    dis[s]=<span class="hljs-number">0</span>;   <span class="hljs-comment">//自身到自身的距离是0</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; <span class="hljs-comment">//用来记录当轮的起始点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;dis[i]&lt;dis[k])     <span class="hljs-comment">//如果这个点还不为最短路径的点，并且这个点的路径是现在所有点中最小的</span><br>            &#123;<br>                k=i;      <span class="hljs-comment">//那么就记录这个点为当轮的起始点</span><br>                  <span class="hljs-comment">//特殊的这里第一次找到的是起点，及s=1。</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!k) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//所有点已经为最短路径的点，则返回</span><br>        vis[k]=<span class="hljs-number">1</span>;       <span class="hljs-comment">//标记该点为最短路径的点</span><br>        <span class="hljs-comment">//松弛操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ; ++j) &#123;   <br>            <span class="hljs-comment">//第一次循环只有起点的邻接点的距离被更新</span><br>            <span class="hljs-comment">//每次都更新找到，新找到的点的邻接点(新找到的点也就是当轮的起始点)</span><br>            <span class="hljs-keyword">if</span>(dis[j]&gt;dis[k]+mapdis[k][j])  <span class="hljs-comment">//最短路是由最短路+某一条固定路组成</span><br>            &#123;<br>                dis[j]=dis[k]+mapdis[k][j];<span class="hljs-comment">//路径被改变</span><br>                path[j]=k;<span class="hljs-comment">//重新记录前驱，最短路是由最短路+某一条固定路组成，所以前驱是有效的</span><br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-comment">//递归打印</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">print</span>(path[x]);<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(mapdis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(mapdis));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> x,y,z;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-comment">//记录x-&gt;y的距离</span><br>        mapdis[x][y]=z;<br>    &#125;<br>    <span class="hljs-built_in">Dijkstra</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//求1出发到各点的最短路径</span><br>    <span class="hljs-keyword">int</span> order;    <span class="hljs-comment">//读入终点</span><br>    cin&gt;&gt;order;<br>    <span class="hljs-built_in">print</span>(path[order]);  <span class="hljs-comment">//打印最短路径</span><br>    cout&lt;&lt;order&lt;&lt;endl;<br>    cout&lt;&lt;dis[order];    <span class="hljs-comment">//最短路径长</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="样题三：L2-001-紧急救援-25-分"><a href="#样题三：L2-001-紧急救援-25-分" class="headerlink" title="样题三：L2-001 紧急救援 (25 分)"></a>样题三：<strong>L2-001 紧急救援 (25 分)</strong></h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h4><p>输入第一行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0 ~ (<em>N</em>−1)；<em>M</em>是快速道路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。</p><p>第二行给出<em>N</em>个正整数，其中第<em>i</em>个数是第<em>i</em>个城市的救援队的数目，数字间以空格分隔。随后的<em>M</em>行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h4><p>第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从<em>S</em>到<em>D</em>的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span><br><span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">10</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>结尾无空行<br></code></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">2</span> <span class="hljs-number">60</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>结尾无空行<br></code></pre></td></tr></table></figure><h4 id="最短路径条数："><a href="#最短路径条数：" class="headerlink" title="最短路径条数："></a>最短路径条数：</h4><p>如果通过 <strong>index</strong> 点能把最短路径更新，那么最短路径条数就是从起点到<strong>index</strong>的最短路径条数。</p><p><img src="/2022/01/03/Algorithm003/134d3eff026ab567e3a337c45dda5d61.png"></p><p>例如这张图，如果<strong>index</strong>可以更新当前的最短路径，并且s通过1和2到达index点的距离都相等，那么从s到d的最短路径条数其实就是从s到index的最短路径条数，由此可以得到第一个式子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">num[i]=num[index];<br></code></pre></td></tr></table></figure><p>如果通过index点的周转，距离不变（依然是最小值），这说明通过index周转使得最短路径条数又多出了一部分，只需要用之前得到的最短路径条数加上num[index]即可，由此得出第二个式子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">num[i]+=num[index];<br></code></pre></td></tr></table></figure><h4 id="程序源代码：-2"><a href="#程序源代码：-2" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m,s,d;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">505</span>;<br><span class="hljs-keyword">int</span> arr[maxn];   <span class="hljs-comment">//记录每个城市的援兵数</span><br><span class="hljs-keyword">int</span> dismap[maxn][maxn];    <span class="hljs-comment">//储存X-Y的长度</span><br><span class="hljs-keyword">int</span> path[maxn];    <span class="hljs-comment">//前驱节点</span><br><span class="hljs-keyword">int</span> dis[maxn];     <span class="hljs-comment">//最短路径</span><br><span class="hljs-keyword">int</span> cost[maxn];    <span class="hljs-comment">//最大救援队数量</span><br><span class="hljs-keyword">int</span> vis[maxn];     <span class="hljs-comment">//用来记录该点是否已经是最短路径的点</span><br><span class="hljs-keyword">int</span> num[maxn];     <span class="hljs-comment">//最短路径的条数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(path,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(path));<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dis));<br>    <span class="hljs-built_in">memset</span>(cost,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(cost));<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>    <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num));<br>    dis[s]=<span class="hljs-number">0</span>;<br>    cost[s]=arr[s];   <span class="hljs-comment">//此时救援队数量等于出发点的救援队数量</span><br>    num[s]=<span class="hljs-number">1</span>;         <span class="hljs-comment">//一条最短路径</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> maxt =<span class="hljs-number">0x3f</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;dis[i]&lt;maxt)<br>            &#123;<br>                k=i;<br>                maxt=dis[i];<br>            &#125;<br>        &#125;<br>        vis[k]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;dis[j]&gt;dis[k]+dismap[k][j])&#123;<br>                dis[j]=dis[k]+dismap[k][j];<br>                path[j]=k;<br>                num[j]=num[k];   <span class="hljs-comment">//如果能更新，说明产生了新的最短路径，num[i]变为从s到k的路径条数</span><br>                cost[j] = cost[k]+arr[j];  <span class="hljs-comment">//产生了新的最短路径,人数为cost[k]+arr[j]</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vis[j]&amp;&amp;dis[j]==dis[k]+dismap[k][j])&#123; <span class="hljs-comment">//存在新的最短路径</span><br>                num[j]+=num[k];   <span class="hljs-comment">//最短路径条数更新</span><br>                <span class="hljs-comment">//无论援兵量是否能更新，既然已经有了另一条路与当前最短路长度相同</span><br><span class="hljs-comment">//就说明多了一些最短路条数</span><br>                <span class="hljs-keyword">if</span>(cost[j]&lt;cost[k]+arr[j])   <span class="hljs-comment">//援兵量能更新</span><br>                &#123;<br>                    cost[j]=cost[k]+arr[j];<br>                    path[j]=k;<br><br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">print</span>(path[x]);<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d;<br>    <span class="hljs-built_in">memset</span>(arr,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr));<br>    <span class="hljs-built_in">memset</span>(dismap,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dismap));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n ; ++j) &#123;<br>        cin&gt;&gt;arr[j];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> x,y,z;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-comment">//此题是无向图</span><br>        dismap[x][y]=z;<br>        dismap[y][x]=z;<br>    &#125;<br>    <span class="hljs-built_in">dijk</span>(s);<br>    cout&lt;&lt;num[d]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cost[d]&lt;&lt;endl;<span class="hljs-comment">//打印最短路径条数和最大援兵数</span><br>    <span class="hljs-built_in">print</span>(path[d]);<br>    cout&lt;&lt;d&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目链接："><a href="#相关题目链接：" class="headerlink" title="相关题目链接："></a>相关题目链接：</h2><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://www.luogu.com.cn/problem/P1364">P1364 医院设置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></a>]:     “ 样题一：P1364 医院设置”</p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805073643683840">题目详情 - L2-001 紧急救援 (25 分) (pintia.cn)</a> ：样题三：L2-001 紧急救援 (25 分)</p><p><a href="https://www.freesion.com/article/8556971489/">L2-001 紧急救援 (25 分)&amp;&amp;dijkstra - 灰信网（软件开发博客聚合） (freesion.com)</a>：样题三参考资料</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(五)-环形拓扑上利用MPI进行通信</title>
    <link href="/2022/01/01/mpi005/"/>
    <url>/2022/01/01/mpi005/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI学习-五-环形拓扑上利用MPI进行通信"><a href="#MPI学习-五-环形拓扑上利用MPI进行通信" class="headerlink" title="MPI学习(五)-环形拓扑上利用MPI进行通信"></a>MPI学习(五)-环形拓扑上利用MPI进行通信</h1><p>这里，我们演示了一个简单的MPI程序，它使用阻塞通信原语send和receive来进行广播操作：</p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi/intel/2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpic++ mpi005.cpp -o mpi005</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>srun -p amd_256 -N 1 -n  4   ./mpi005(使用SLURM任务调度系统)</p><p>1个分区，核数为4</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> rank, value, size;<br>MPI_Status status;<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc, &amp;argv);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;rank);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;size);<br><br><span class="hljs-keyword">if</span>(rank == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value );<br><span class="hljs-comment">/*Master node sends out the value*/</span><br><span class="hljs-built_in">MPI_Send</span>(&amp;value, <span class="hljs-number">1</span>, MPI_INT, rank + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD);&#125;<span class="hljs-comment">//</span><br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">/*Slave nodes block on receive the send on the value*/</span><br>        <span class="hljs-comment">//接受上一个进程发送的消息</span><br><span class="hljs-built_in">MPI_Recv</span>(&amp;value, <span class="hljs-number">1</span>, MPI_INT, rank - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,MPI_COMM_WORLD, &amp;status);<br><br><span class="hljs-keyword">if</span>(rank &lt; size<span class="hljs-number">-1</span>)<br>&#123;<br>            <span class="hljs-comment">//向下一个进程发送消息</span><br><span class="hljs-built_in">MPI_Send</span>(&amp;value, <span class="hljs-number">1</span>, MPI_INT, rank + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process %d got %d\n&quot;</span>, rank, value);<br>&#125;<br><span class="hljs-built_in">MPI_Finalize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br><br></code></pre></td></tr></table></figure><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//5 5为读入的value值</span><br>process <span class="hljs-number">1</span> got <span class="hljs-number">5</span><br>process <span class="hljs-number">2</span> got <span class="hljs-number">5</span><br>process <span class="hljs-number">3</span> got <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graph-Data Structure</title>
    <link href="/2021/12/22/algorithm002/"/>
    <url>/2021/12/22/algorithm002/</url>
    
    <content type="html"><![CDATA[<h1 id="Graph-Data-Structure"><a href="#Graph-Data-Structure" class="headerlink" title="Graph-Data Structure"></a>Graph-Data Structure</h1><h2 id="1-邻接表的应用"><a href="#1-邻接表的应用" class="headerlink" title="1.邻接表的应用"></a>1.邻接表的应用</h2><h3 id="样题一：L2-025-分而治之-25-分"><a href="#样题一：L2-025-分而治之-25-分" class="headerlink" title="样题一：L2-025 分而治之 (25 分)"></a>样题一：L2-025 分而治之 (25 分)</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Np v<span class="hljs-selector-attr">[1]</span> v<span class="hljs-selector-attr">[2]</span> ... v<span class="hljs-selector-attr">[Np]</span><br></code></pre></td></tr></table></figure><p>其中 <code>Np</code> 是该方案中计划攻下的城市数量，后面的系列 <code>v[i]</code> 是计划攻下的城市编号。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>对每一套方案，如果可行就输出<code>YES</code>，否则输出<code>NO</code>。</p><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v[<span class="hljs-number">10005</span>]; <span class="hljs-comment">//声明邻接表</span><br>    <span class="hljs-keyword">int</span> n,num;<br>    cin&gt;&gt;n&gt;&gt;num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;num ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> start,end;<br>        cin&gt;&gt;start&gt;&gt;end;<br>        <span class="hljs-comment">//创建邻接表</span><br>        v[start].<span class="hljs-built_in">push_back</span>(end); <br>        v[end].<span class="hljs-built_in">push_back</span>(start);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> k;<br>    cin&gt;&gt;k;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;k ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> np;<br>        cin&gt;&gt;np;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> book[<span class="hljs-number">10005</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//每轮炸毁城市初始化</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=np ; ++i) &#123;<br>            <span class="hljs-keyword">int</span> dead;<br>            cin&gt;&gt;dead;<br>            book[dead]=<span class="hljs-number">1</span>; <span class="hljs-comment">//被炸毁的城市标记为1</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=n ; ++l) &#123;<br>            <br>            <span class="hljs-keyword">if</span>(book[l]==<span class="hljs-number">0</span>)<span class="hljs-comment">//没有被炸毁的城市</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;v[l].<span class="hljs-built_in">size</span>() ; ++i) &#123; <span class="hljs-comment">//遍历该城市的邻接表</span><br>                    <br>                    <span class="hljs-keyword">if</span>(book[v[l][i]]==<span class="hljs-number">0</span>) <span class="hljs-comment">//存在着还连通的城市</span><br>                    &#123;<br>                        flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//说明方案不可行</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="程序输入："><a href="#程序输入：" class="headerlink" title="程序输入："></a>程序输入：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">10</span> <span class="hljs-number">11</span><br><span class="hljs-number">8</span> <span class="hljs-number">7</span><br><span class="hljs-number">6</span> <span class="hljs-number">8</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-number">8</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">9</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">10</span><br><span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span><br><span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">NO<br>YES<br>YES<br>NO<br>NO<br></code></pre></td></tr></table></figure><h2 id="题目相关链接："><a href="#题目相关链接：" class="headerlink" title="题目相关链接："></a>题目相关链接：</h2><p>[<a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]">https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]</a>:     “样例一:L2-025 分而治之 (25 分)”</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS-深度优先搜索</title>
    <link href="/2021/12/21/algorithm001/"/>
    <url>/2021/12/21/algorithm001/</url>
    
    <content type="html"><![CDATA[<h1 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS-深度优先搜索"></a>DFS-深度优先搜索</h1><h2 id="样题1-全排列"><a href="#样题1-全排列" class="headerlink" title="样题1-全排列"></a>样题1-全排列</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>输入一个数n，输出n的全排列</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">int</span> book[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> step)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span>(step==n+<span class="hljs-number">1</span>)  <span class="hljs-comment">//这里表示dfs结束,没有可以排的数字了</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>;  i&lt;=n ; i++) &#123;<br>            cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(book[i]==<span class="hljs-number">0</span>)  <span class="hljs-comment">//说明数字i还没有被使用,可以用来排列</span><br>        &#123;<br>            a[step]=i;<span class="hljs-comment">//排列数字i</span><br>            book[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//标记数字i为已使用</span><br>            <span class="hljs-built_in">dfs</span>(step+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//继续排列没有使用的数字</span><br>            book[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//这里表示dfs调用结束了,意思是数字i已经全部排列完了，但还需要</span><br>            <span class="hljs-comment">//按照顺序将数字i收回，重新排列。</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//dfs函数的开始</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="程序输入："><a href="#程序输入：" class="headerlink" title="程序输入："></a>程序输入：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="样题二-自然数的拆分问题"><a href="#样题二-自然数的拆分问题" class="headerlink" title="样题二-自然数的拆分问题"></a>样题二-自然数的拆分问题</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。现在给你一个自然数n，要求你求出n的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。</p><h3 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100000</span>]=&#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//输出一种拆分方案</span><br><br>            <span class="hljs-keyword">if</span>(i!=t<span class="hljs-number">-1</span>) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;+&quot;</span>;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;a[i];<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=a[t<span class="hljs-number">-1</span>];i&lt;=n;i++) &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;num)<span class="hljs-comment">//当前数i要大于等于前一位数，且不超过n</span><br>        &#123;<br>            a[t]=i;<span class="hljs-comment">//保存当前拆分的数i</span><br>            n-=i;<span class="hljs-comment">//n减去数i，n的值将继续拆分</span><br>            <span class="hljs-built_in">dfs</span>(n,t+<span class="hljs-number">1</span>);<br>            n+=i;<span class="hljs-comment">//回溯：加上拆分的数，以便产生所有可能的拆分</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;num;<br>    <span class="hljs-built_in">dfs</span>(num,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="程序输入：-1"><a href="#程序输入：-1" class="headerlink" title="程序输入："></a>程序输入：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="程序输出：-1"><a href="#程序输出：-1" class="headerlink" title="程序输出："></a>程序输出：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">3</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">4</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">5</span><br><span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">4</span><br><span class="hljs-number">1</span>+<span class="hljs-number">3</span>+<span class="hljs-number">3</span><br><span class="hljs-number">1</span>+<span class="hljs-number">6</span><br><span class="hljs-number">2</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span><br><span class="hljs-number">2</span>+<span class="hljs-number">5</span><br><span class="hljs-number">3</span>+<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="样例三：L2-038-病毒溯源-25-分"><a href="#样例三：L2-038-病毒溯源-25-分" class="headerlink" title="样例三：L2-038 病毒溯源 (25 分)"></a>样例三：<strong>L2-038 病毒溯源 (25 分)</strong></h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>病毒容易发生变异。某种病毒可以通过突变产生若干变异的毒株，而这些变异的病毒又可能被诱发突变产生第二代变异，如此继续不断变化。</p><p>现给定一些病毒之间的变异关系，要求你找出其中最长的一条变异链。</p><p>在此假设给出的变异都是由突变引起的，不考虑复杂的基因重组变异问题 —— 即每一种病毒都是由唯一的一种病毒突变而来，并且不存在循环变异的情况。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出一个正整数 <em>N</em>（≤104），即病毒种类的总数。于是我们将所有病毒从 0 到 <em>N</em>−1 进行编号。</p><p>随后 <em>N</em> 行，每行按以下格式描述一种病毒的变异情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">k</span> 变异株<span class="hljs-number">1</span> …… 变异株k<br></code></pre></td></tr></table></figure><p>其中 <code>k</code> 是该病毒产生的变异毒株的种类数，后面跟着每种变异株的编号。第 <em>i</em> 行对应编号为 <em>i</em> 的病毒（0≤<em>i</em>&lt;<em>N</em>）。题目保证病毒源头有且仅有一个。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先输出从源头开始最长变异链的长度。</p><p>在第二行中输出从源头开始最长的一条变异链，编号间以 1 个空格分隔，行首尾不得有多余空格。如果最长链不唯一，则输出最小序列。</p><p>注：我们称序列 { <em>a</em>1,⋯,<em>a**n</em> } 比序列 { <em>b</em>1,⋯,<em>b**n</em> } “小”，如果存在 1≤<em>k</em>≤<em>n</em> 满足 <em>a**i</em>=<em>b**i</em> 对所有 <em>i</em>&lt;<em>k</em> 成立，且 <em>a**k</em>&lt;<em>b**k</em>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs in">10<br>3 6 4 8<br>0<br>0<br>0<br>2 5 9<br>0<br>1 7<br>1 2<br>0<br>2 3 1结尾无空行<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">4<br>0 4 9 1结尾无空行<br></code></pre></td></tr></table></figure><h3 id="程序源代码：-2"><a href="#程序源代码：-2" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; ans, tmp;<br><span class="hljs-keyword">bool</span> a[<span class="hljs-number">10005</span>][<span class="hljs-number">10005</span>];<br><span class="hljs-keyword">bool</span> book[<span class="hljs-number">10005</span>];<br><span class="hljs-keyword">int</span> maxn;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root,<span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(len&gt;maxn)<br>    &#123;<br>        maxn =len;<br>        ans = tmp;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == maxn &amp;&amp; tmp &lt; ans)<br>    &#123;<br>        ans = tmp;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[root][i]) <span class="hljs-comment">//连通</span><br>        &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(i,len+<span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> root=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;k ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> x;<br>            cin&gt;&gt;x;<br>            book[x]=<span class="hljs-literal">true</span>;    <span class="hljs-comment">//用来判断谁是病毒源头，题目给出病毒源头有且仅有一个</span><br>            a[i][x]=<span class="hljs-literal">true</span>;    <span class="hljs-comment">//使用邻接矩阵来储存图，连通为true，否则为false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(book[root]) root++;  <span class="hljs-comment">//寻找病毒源头</span><br>    tmp.<span class="hljs-built_in">push_back</span>(root);<br>    <span class="hljs-built_in">dfs</span>(root,<span class="hljs-number">1</span>); <span class="hljs-comment">//从病毒源头开始dfs</span><br>    cout&lt;&lt;ans.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//输出格式控制</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); i++)&#123;<br>       <span class="hljs-keyword">if</span>(i!=ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>       &#123;<br>           cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>           cout&lt;&lt;ans[i];<br>       &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="样题四：L2-020-功夫传人-25-分"><a href="#样题四：L2-020-功夫传人-25-分" class="headerlink" title="样题四：L2-020 功夫传人 (25 分)"></a>样题四：<strong>L2-020 功夫传人 (25 分)</strong></h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。</p><p>这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第<code>i</code>代传人只能在第<code>i-1</code>代传人中拜1个师傅。我们假设已知祖师爷的功力值为<code>Z</code>，每向下传承一代，就会减弱<code>r%</code>，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。</p><h3 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出3个正整数，分别是：<em>N</em>（≤105）——整个师门的总人数（于是每个人从0到<em>N</em>−1编号，祖师爷的编号为0）；<em>Z</em>——祖师爷的功力值（不一定是整数，但起码是正数）；<em>r</em> ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有<em>N</em>行，第<em>i</em>行（<em>i</em>=0,⋯,<em>N</em>−1）描述编号为<em>i</em>的人所传的徒弟，格式为：</p><p><em>K**i</em> ID[1] ID[2] ⋯ ID[<em>K**i</em>]</p><p>其中<em>K**i</em>是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。<em>K**i</em>为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。</p><h3 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过1010。</p><h3 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs in">10 18.0 1.00<br>3 2 3 5<br>1 9<br>1 4<br>1 7<br>0 7<br>2 6 1<br>1 8<br>0 9<br>0 4<br>0 3结尾无空行<br></code></pre></td></tr></table></figure><h3 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">404<br>结尾无空行<br></code></pre></td></tr></table></figure><h3 id="程序源代码：-3"><a href="#程序源代码：-3" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; tree[<span class="hljs-number">100000</span>];  <span class="hljs-comment">//用于邻接表建树</span><br><span class="hljs-keyword">int</span> book[<span class="hljs-number">100000</span>];<br><span class="hljs-keyword">double</span> sum;<br><span class="hljs-keyword">double</span> r;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">double</span> power)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(book[index]) <span class="hljs-comment">//是得道者就乘他的倍数 </span><br>    &#123;<br>        sum += power * book[index];<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tree[index].<span class="hljs-built_in">size</span>();i++)  <span class="hljs-comment">//遍历整个树</span><br>    &#123;<br>        <span class="hljs-built_in">dfs</span>(tree[index][i],power*r);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">double</span> z;<br>    cin&gt;&gt;n&gt;&gt;z&gt;&gt;r;<br>    r=(<span class="hljs-number">100</span>-r)/<span class="hljs-number">100.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)   <span class="hljs-comment">//这个弟子是否为得道者</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> power;<br>            cin&gt;&gt;power;<br>            book[i]=power;   <span class="hljs-comment">//记录得道者放大倍数</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k;j++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> id;<br>                cin&gt;&gt;id;<br>                tree[i].<span class="hljs-built_in">push_back</span>(id);      <span class="hljs-comment">//使用邻接表建树</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,z);<br>    cout&lt;&lt;(<span class="hljs-keyword">int</span>)sum&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题目相关链接："><a href="#题目相关链接：" class="headerlink" title="题目相关链接："></a>题目相关链接：</h2><p>[<a href="https://www.luogu.com.cn/problem/P2404">P2404 自然数的拆分问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>]:     “ 样例二-自然数的拆分问题”</p><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652361">题目详情 - L2-038 病毒溯源 (25 分) (pintia.cn)</a></a>]:     “ 样例三-L2-038 病毒溯源 (25 分)”</p><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805059118809088">题目详情 - L2-020 功夫传人 (25 分) (pintia.cn)</a></a>]:     “ 样例四-L2-020 功夫传人 (25 分)”</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning(一) 一个神经元网络-线性函数</title>
    <link href="/2021/12/09/tensorflow001/"/>
    <url>/2021/12/09/tensorflow001/</url>
    
    <content type="html"><![CDATA[<h1 id="一个神经元的网络-线性函数"><a href="#一个神经元的网络-线性函数" class="headerlink" title="一个神经元的网络(线性函数)"></a>一个神经元的网络(线性函数)</h1><p>线性函数 y = 2 * x -1 </p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#构建模型</span><br>model = keras.Sequential([keras.layers.Dense(units=<span class="hljs-number">1</span>,input_shape=[<span class="hljs-number">1</span>])])<br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;sgd&#x27;</span>,loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>)<br><span class="hljs-comment">#准备训练数据</span><br>xs=np.array([-<span class="hljs-number">1.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">4.0</span>], dtype = <span class="hljs-built_in">float</span>)<br>ys=np.array([-<span class="hljs-number">3.0</span>,-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">5.0</span>,<span class="hljs-number">7.0</span>], dtype = <span class="hljs-built_in">float</span>)<br><span class="hljs-comment">#训练模型</span><br>model.fit(xs,ys,epochs=<span class="hljs-number">500</span>)<br></code></pre></td></tr></table></figure><h2 id="训练模型过程-截取"><a href="#训练模型过程-截取" class="headerlink" title="训练模型过程(截取)"></a>训练模型过程(截取)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">Epoch <span class="hljs-number">1</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 388ms/step - loss: <span class="hljs-number">3.4976</span><br>Epoch <span class="hljs-number">2</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">2.9127</span><br>Epoch <span class="hljs-number">3</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">2.4493</span><br>Epoch <span class="hljs-number">4</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">2.0814</span><br>Epoch <span class="hljs-number">5</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.7888</span><br>Epoch <span class="hljs-number">6</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.5555</span><br>Epoch <span class="hljs-number">7</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.3689</span><br>Epoch <span class="hljs-number">8</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.2191</span><br>Epoch <span class="hljs-number">9</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">1.0983</span><br>Epoch <span class="hljs-number">10</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.0005</span><br>Epoch <span class="hljs-number">11</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">0.9207</span><br>Epoch <span class="hljs-number">12</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 2ms/step - loss: <span class="hljs-number">0.8551</span><br>Epoch <span class="hljs-number">13</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 5ms/step - loss: <span class="hljs-number">0.8009</span><br></code></pre></td></tr></table></figure><h2 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用模型(输入)</span><br><span class="hljs-built_in">print</span>(model.predict([<span class="hljs-number">2021</span>]))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#输出</span><br>[[<span class="hljs-number">4036.6035</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#输入</span><br>model.predict([<span class="hljs-number">10.0</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#输出</span><br>array([[<span class="hljs-number">18.984968</span>]], dtype=float32)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tensorflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(四)-广播、散播、收集、归约和全归约的MPI语法</title>
    <link href="/2021/11/27/mpi004/"/>
    <url>/2021/11/27/mpi004/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-广播、散播、收集、归约和全归约的MPI语法"><a href="#MPI-广播、散播、收集、归约和全归约的MPI语法" class="headerlink" title="MPI-广播、散播、收集、归约和全归约的MPI语法"></a>MPI-广播、散播、收集、归约和全归约的MPI语法</h1><h2 id="广播：MPI-Bcast"><a href="#广播：MPI-Bcast" class="headerlink" title="广播：MPI_Bcast"></a>广播：MPI_Bcast</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Bcast</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *buffer, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> root, MPI_Comm comm)</span></span><br><span class="hljs-function"><span class="hljs-comment">//int root 广播数据的根进程的标识号(整型)</span></span><br></code></pre></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi001.png"></p><h2 id="散播：MPI-Scatter"><a href="#散播：MPI-Scatter" class="headerlink" title="散播：MPI_Scatter"></a>散播：MPI_Scatter</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Scatter</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">int</span> sendcount, MPI_Datatype sendtype, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> root, MPI_Comm comm)</span></span><br><span class="hljs-function"><span class="hljs-comment">//void *sendbuf 发送消息缓冲区的起始地址(可选数据类型)</span></span><br><span class="hljs-function"><span class="hljs-comment">//void *recvbuf 接收消息缓冲区的起始地址(可选数据类型)</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi002.png"></p><h2 id="收集：MPI-Gather"><a href="#收集：MPI-Gather" class="headerlink" title="收集：MPI_Gather"></a>收集：MPI_Gather</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Gather</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">int</span> sendcount, MPI_Datatype sendtype, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> recvcount, MPI_Datatype recvtype, <span class="hljs-keyword">int</span> root, MPI_Comm comm)</span></span><br></code></pre></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi003.png"></p><h2 id="归约：MPI-Reduce"><a href="#归约：MPI-Reduce" class="headerlink" title="归约：MPI_Reduce"></a>归约：MPI_Reduce</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Reduce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, MPI_Op op, <span class="hljs-keyword">int</span> root,  MPI_Comm comm)</span></span><br><span class="hljs-function"><span class="hljs-comment">//MPI_Op op  归约操作符(句柄)</span></span><br></code></pre></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi004.png"></p><p><img src="/2021/11/27/mpi004/mpi005.png"></p><h2 id="全归约：MPI-Allreduce"><a href="#全归约：MPI-Allreduce" class="headerlink" title="全归约：MPI_Allreduce"></a>全归约：MPI_Allreduce</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Allreduce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)</span></span><br></code></pre></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi006.png"></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(三)-通过OpenmMP使用MPI</title>
    <link href="/2021/11/26/mpi003/"/>
    <url>/2021/11/26/mpi003/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-通过OpenMP使用MPI"><a href="#MPI-通过OpenMP使用MPI" class="headerlink" title="MPI-通过OpenMP使用MPI"></a>MPI-通过OpenMP使用MPI</h1><p>OpenMP是另一种为基于共享内存的并行编程提供的应用编程接口。当人们想使用多核处理器时，通常使用OpenMP。下面是一个“Hello World”程序，使用了MPI和OpenMP的API。</p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi/intel/2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpic++    -fopenmp  mpi003.cpp -o mpi003</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>srun -p amd_256 -N 2 -n  2   ./mpi003(使用SLURM任务调度系统)</p><p>2个分区，核数为2</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;omp.h&gt;</span>  <span class="hljs-comment">//OpenMP所需要的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> myid, numprocs;<br><span class="hljs-keyword">int</span> namelen;<br><span class="hljs-keyword">int</span> thread_id , nthreads;<br><span class="hljs-keyword">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc, &amp;argv);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;myid);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;numprocs);<br><span class="hljs-built_in">MPI_Get_processor_name</span>(processor_name, &amp;namelen);<br>    <span class="hljs-comment">//构造并行区</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel private(thread_id, nthreads) num_threads(8) <span class="hljs-comment">//设置线程数为8</span></span><br>&#123;<br>thread_id = <span class="hljs-built_in">omp_get_thread_num</span>();  <span class="hljs-comment">//获得当前线程的id</span><br>nthreads = <span class="hljs-built_in">omp_get_num_threads</span>();  <span class="hljs-comment">//获得总的线程数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread number %d (on %d) for the MPI process number %d (on %d) [%s]\n&quot;</span>,<br>thread_id, nthreads, myid, numprocs, processor_name);<br>&#125; <br><span class="hljs-built_in">MPI_Finalize</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">Thread number <span class="hljs-number">0</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">4</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">3</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">5</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">2</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">6</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">0</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">1</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">2</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">5</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">1</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">7</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">3</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">4</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">6</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">7</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(二)-非阻塞通信程序(无缓冲)</title>
    <link href="/2021/11/26/mpi002/"/>
    <url>/2021/11/26/mpi002/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-非阻塞通信程序-无缓冲"><a href="#MPI-非阻塞通信程序-无缓冲" class="headerlink" title="MPI-非阻塞通信程序(无缓冲)"></a>MPI-非阻塞通信程序(无缓冲)</h1><p>非阻塞通信程序(无缓冲)是由MPI中的Isend和Ireceive来表示的，即异步通信。在这种情况下，发送进程发布一条“发送授权请求”(挂起的消息)的消息，并继续其程序的执行。当接收进程发布一个“同意发送”许可指令时，数据传输就启动了。所有的这些机制都是通过操作系统的信号进行内部管理的。当数据传输完成时，检查状态并指示进程是否可以安全地进行读/写数据。                                                                      需要注意的是原语MPI_Wait(&amp;request,&amp;status)等到数据传输完成(或中断后)，使用一个成为status的状态变量来指示数据传输是否已经成功。</p><h2 id="相关的MPI原语"><a href="#相关的MPI原语" class="headerlink" title="相关的MPI原语"></a>相关的MPI原语</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Isend</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> dest, <span class="hljs-keyword">int</span> tag, MPI_comm comm, MPI_Request *req)</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Irecv</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> tag, MPI_Comm comm, MPI_Request *req)</span></span><br></code></pre></td></tr></table></figure><p>MPI_Request结构中经常使用的：当*req操作完成时返回 *flag = 1,否则返回 0。</p><p>原语MPI_Wait一直等到*req所执行的操作完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Wait</span><span class="hljs-params">(MPI_Request *req, MPI_Status *status)</span></span><br></code></pre></td></tr></table></figure><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi/intel/2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpicc  mpi002.cpp -o mpi002</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>mpirun -np 10   ./mpi002(本地提交,采取10个进程)</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> myid, numprocs;<br><span class="hljs-keyword">int</span> tag,source,destination,count;<br><span class="hljs-keyword">int</span> buffer;<br>MPI_Status status;<br>MPI_Request request;<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc,&amp;argv);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;numprocs);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;myid);<br>tag =<span class="hljs-number">2021</span>; <span class="hljs-comment">/* any integer to tag messages */</span><br>source = <span class="hljs-number">0</span>;<br>count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(myid != source )<br>&#123;<br>buffer =<span class="hljs-number">2077</span>;<br><span class="hljs-comment">//其他进程向0号进程发送消息</span><br><span class="hljs-built_in">MPI_Isend</span>(&amp;buffer,count,MPI_INT,source,tag,MPI_COMM_WORLD,&amp;request);<br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor %d send %d to processor %d\n&quot;</span>,myid,buffer,source);<br>&#125;<br><br><span class="hljs-keyword">if</span>(myid == source )<br>&#123;<br><span class="hljs-comment">//0号进程接收来自其他进程的消息</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;numprocs;i++)<br>&#123;<br><span class="hljs-built_in">MPI_Irecv</span>(&amp;buffer,count,MPI_INT,i,tag,MPI_COMM_WORLD,&amp;request);<br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor %d received %d from processor %d \n&quot;</span>,myid,buffer,i);<br>&#125;<br><br>&#125;<br><br><span class="hljs-built_in">MPI_Finalize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">processor <span class="hljs-number">2</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">3</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">5</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">6</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">7</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">8</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">9</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">4</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">1</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">1</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">2</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">3</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">4</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">5</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">6</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">7</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">8</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(三)-if判断的处理</title>
    <link href="/2021/11/24/AVX003/"/>
    <url>/2021/11/24/AVX003/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX-if判断的处理"><a href="#AVX-if判断的处理" class="headerlink" title="AVX-if判断的处理"></a>AVX-if判断的处理</h1><p>使用AVX指令集对if判断进行处理</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)<br></code></pre></td></tr></table></figure><p><strong>Description</strong></p><p>Blend packed double-precision (64-bit) floating-point elements from a and b using mask, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span><br>i := j*<span class="hljs-number">64</span><br>IF mask[i+<span class="hljs-number">63</span>]<br>dst[i+<span class="hljs-number">63</span>:i] := b[i+<span class="hljs-number">63</span>:i]<br>ELSE<br>dst[i+<span class="hljs-number">63</span>:i] := a[i+<span class="hljs-number">63</span>:i]<br>FI<br>ENDFOR<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m256d _mm256_cmp_pd (__m256d a, __m256d b, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> imm8)<br></code></pre></td></tr></table></figure><p><strong>Description</strong></p><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">CASE</span> (imm8[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]) OF<br><span class="hljs-number">0</span>: OP := _CMP_EQ_OQ<br><span class="hljs-number">1</span>: OP := _CMP_LT_OS<br><span class="hljs-number">2</span>: OP := _CMP_LE_OS<br><span class="hljs-number">3</span>: OP := _CMP_UNORD_Q <br><span class="hljs-number">4</span>: OP := _CMP_NEQ_UQ<br><span class="hljs-number">5</span>: OP := _CMP_NLT_US<br><span class="hljs-number">6</span>: OP := _CMP_NLE_US<br><span class="hljs-number">7</span>: OP := _CMP_ORD_Q<br><span class="hljs-number">8</span>: OP := _CMP_EQ_UQ<br><span class="hljs-number">9</span>: OP := _CMP_NGE_US<br><span class="hljs-number">10</span>: OP := _CMP_NGT_US<br><span class="hljs-number">11</span>: OP := _CMP_FALSE_OQ<br><span class="hljs-number">12</span>: OP := _CMP_NEQ_OQ<br><span class="hljs-number">13</span>: OP := _CMP_GE_OS<br><span class="hljs-number">14</span>: OP := _CMP_GT_OS<br><span class="hljs-number">15</span>: OP := _CMP_TRUE_UQ<br><span class="hljs-number">16</span>: OP := _CMP_EQ_OS<br><span class="hljs-number">17</span>: OP := _CMP_LT_OQ<br><span class="hljs-number">18</span>: OP := _CMP_LE_OQ<br><span class="hljs-number">19</span>: OP := _CMP_UNORD_S<br><span class="hljs-number">20</span>: OP := _CMP_NEQ_US<br><span class="hljs-number">21</span>: OP := _CMP_NLT_UQ<br><span class="hljs-number">22</span>: OP := _CMP_NLE_UQ<br><span class="hljs-number">23</span>: OP := _CMP_ORD_S<br><span class="hljs-number">24</span>: OP := _CMP_EQ_US<br><span class="hljs-number">25</span>: OP := _CMP_NGE_UQ <br><span class="hljs-number">26</span>: OP := _CMP_NGT_UQ <br><span class="hljs-number">27</span>: OP := _CMP_FALSE_OS <br><span class="hljs-number">28</span>: OP := _CMP_NEQ_OS <br><span class="hljs-number">29</span>: OP := _CMP_GE_OQ<br><span class="hljs-number">30</span>: OP := _CMP_GT_OQ<br><span class="hljs-number">31</span>: OP := _CMP_TRUE_US<br>ESAC<br>FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span><br>i := j*<span class="hljs-number">64</span><br>dst[i+<span class="hljs-number">63</span>:i] := ( a[i+<span class="hljs-number">63</span>:i] OP b[i+<span class="hljs-number">63</span>:i] ) ? <span class="hljs-number">0xFFFFFFFFFFFFFFFF</span> : <span class="hljs-number">0</span><br>ENDFOR<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span> d[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>&#125;;     <span class="hljs-comment">//记录原始if判断后的值</span><br><span class="hljs-keyword">double</span> e[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>&#125;;     <span class="hljs-comment">//记录AVX-if判断后的值</span><br><br>__m256d v0;<br>__m256d v1;<br>__m256d v2,v3;<br>__m256d v4;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&gt;b[i])<br>&#123;<br>d[i] = a[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>d[i]=b[i];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span><span class="hljs-number">-4</span>;i+=<span class="hljs-number">4</span>)<br>&#123;<br>v0 = _mm256_loadu_pd(a+i);<br>v1 = _mm256_loadu_pd(b+i);<br>v2=_mm256_add_pd(v0,v1);<br>v3 =_mm256_blendv_pd(v0,v1,_mm256_cmp_pd(v0,v1,_CMP_LE_OQ));<br>_mm256_storeu_pd(e+i,v3);<br><br>&#125;<br>    <br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&gt;b[i])<br>&#123;<br>e[i] = a[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>e[i]=b[i];<br>&#125;<br>&#125;<br>    <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is d.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,d[i]);<br>&#125;<br>    <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is e with AVX.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,e[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is d.<br><span class="hljs-number">2.100000</span><br><span class="hljs-number">3.200000</span><br><span class="hljs-number">6.400000</span><br><span class="hljs-number">8.600000</span><br><span class="hljs-number">5.500000</span><br><span class="hljs-number">9.900000</span><br><span class="hljs-number">7.700000</span><br><span class="hljs-number">8.800000</span><br><span class="hljs-number">6.600000</span><br><span class="hljs-keyword">this</span> is e with AVX.<br><span class="hljs-number">2.100000</span><br><span class="hljs-number">3.200000</span><br><span class="hljs-number">6.400000</span><br><span class="hljs-number">8.600000</span><br><span class="hljs-number">5.500000</span><br><span class="hljs-number">9.900000</span><br><span class="hljs-number">7.700000</span><br><span class="hljs-number">8.800000</span><br><span class="hljs-number">6.600000</span><br></code></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>:     “ Intel® Intrinsics Guide”</p><p>[<a href="https://stackoverflow.com/questions/16988199/how-to-choose-avx-compare-predicate-variants">simd - How to choose AVX compare predicate variants - Stack Overflow</a>]:     “Stack Overflow”</p><p>[<a href="https://www.officedaytime.com/simd512e/simdimg/si.php?f=blendvpd">blendvpd (officedaytime.com)</a>]:     “_mm256_Blendv_pd()原理解释”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(一)-简单的发送接收</title>
    <link href="/2021/11/23/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/"/>
    <url>/2021/11/23/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-简单的发送接收"><a href="#MPI-简单的发送接收" class="headerlink" title="MPI-简单的发送接收"></a>MPI-简单的发送接收</h1><p>打印来自进程问候语句的MPI程序</p><h2 id="所使用的MPI原语"><a href="#所使用的MPI原语" class="headerlink" title="所使用的MPI原语"></a>所使用的MPI原语</h2><p><img src="/2021/11/23/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi001.png"></p><p><img src="/2021/11/23/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi002.png"></p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi/intel/2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpicc  3.1.cpp -o 3.1</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>mpirun -np 4 ./3.1(本地提交,采取4个进程)</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span>   <span class="hljs-comment">//头文件</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_STRING = <span class="hljs-number">100</span> ;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> greeting[MAX_STRING];<br><span class="hljs-keyword">int</span> comm_sz;<br><span class="hljs-keyword">int</span> my_rank;<br>MPI_Status status;<br><br><span class="hljs-built_in">MPI_Init</span>(&amp;argc,&amp;argv);<br><br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;comm_sz);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;my_rank);<br><br><span class="hljs-keyword">if</span>(my_rank != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//其他进程向0号进程发消息</span><br><span class="hljs-built_in">sprintf</span>(greeting,<span class="hljs-string">&quot;Greetings from process %d of %d!&quot;</span>,my_rank,comm_sz);<br><span class="hljs-built_in">MPI_Send</span>(greeting,<span class="hljs-built_in">strlen</span>(greeting)+<span class="hljs-number">1</span>,MPI_CHAR,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,MPI_COMM_WORLD); <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Greetings from process %d of %d!\n&quot;</span>,my_rank,comm_sz);<br><span class="hljs-comment">//0号进程接受来自其他进程的消息并输出</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=<span class="hljs-number">1</span>;q&lt;comm_sz;q++)<br>&#123;<br><span class="hljs-built_in">MPI_Recv</span>(greeting,MAX_STRING,MPI_CHAR,q,<span class="hljs-number">0</span>,MPI_COMM_WORLD,&amp;status);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,greeting);<br>&#125;<br>&#125;<br><span class="hljs-built_in">MPI_Finalize</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Greetings from process <span class="hljs-number">0</span> of <span class="hljs-number">4</span>!<br>Greetings from process <span class="hljs-number">1</span> of <span class="hljs-number">4</span>!<br>Greetings from process <span class="hljs-number">2</span> of <span class="hljs-number">4</span>!<br>Greetings from process <span class="hljs-number">3</span> of <span class="hljs-number">4</span>!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(二)-内存对齐的应用</title>
    <link href="/2021/11/15/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2021/11/15/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX指令集的简单操作-内存对齐版"><a href="#AVX指令集的简单操作-内存对齐版" class="headerlink" title="AVX指令集的简单操作(内存对齐版)"></a>AVX指令集的简单操作(内存对齐版)</h1><p>使用AVX指令集进行2个double型的数组相加操作</p><h2 id="常用的内存对齐函数"><a href="#常用的内存对齐函数" class="headerlink" title="常用的内存对齐函数"></a>常用的内存对齐函数</h2><p>因为AVX中要求mem__addr必须在32字节边界上对齐，否则可能会产生通用保护异常。  </p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br></code></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)_mm_malloc(<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>),<span class="hljs-number">32</span>);<br></code></pre></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">aligned_alloc</span>(<span class="hljs-number">32</span>,<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br></code></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__attribute__ ((<span class="hljs-built_in">aligned</span>(<span class="hljs-number">32</span>)))<span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>]  =&#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br></code></pre></td></tr></table></figure><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m256d _mm256_load_pd (<span class="hljs-keyword">double</span> <span class="hljs-keyword">const</span> * mem_addr)<br></code></pre></td></tr></table></figure><p><strong>Description</strong></p><p>Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">dst[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>] := MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr]<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m256 _mm256_add_ps (__m256 a, __m256 b)<br></code></pre></td></tr></table></figure><p><strong>Description</strong></p><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FOR</span> j := <span class="hljs-number">0</span> to <span class="hljs-number">7</span><br><span class="hljs-attribute">i</span> := j*<span class="hljs-number">32</span><br><span class="hljs-attribute">dst</span>[i+<span class="hljs-number">31</span>:i] := a[i+<span class="hljs-number">31</span>:i] + b[i+<span class="hljs-number">31</span>:i]<br><span class="hljs-attribute">ENDFOR</span><br><span class="hljs-attribute">dst</span>[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="3-stream的作用：绕过缓存直接写入内存"><a href="#3-stream的作用：绕过缓存直接写入内存" class="headerlink" title="3.stream的作用：绕过缓存直接写入内存"></a>3.stream的作用：绕过缓存直接写入内存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> _mm256_stream_pd (<span class="hljs-keyword">double</span> * mem_addr, __m256d a)<br></code></pre></td></tr></table></figure><p><strong>Description</strong></p><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr] := a[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="样例程序举例："><a href="#样例程序举例：" class="headerlink" title="样例程序举例："></a>样例程序举例：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br><span class="hljs-keyword">double</span>*b =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">4</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br><span class="hljs-keyword">double</span> af[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125; ;<br><span class="hljs-keyword">double</span> bf[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span>*c =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">4</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>a[i]=af[i];<br>b[i]=bf[i];<br>&#125;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>__m256d v0;<br>__m256d v1;<br>__m256d v2;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span><span class="hljs-number">-4</span>;i+=<span class="hljs-number">4</span>)<br>&#123;<br>v0 = _mm256_load_pd(a+i);<br>v1 = _mm256_load_pd(b+i);<br>v2=_mm256_add_pd(v0,v1);<br> _mm256_stream_pd(c+i,v2);<br><br>&#125;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>c[i]=a[i]+b[i];<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is c.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,c[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure><h2 id="样例程序输出："><a href="#样例程序输出：" class="headerlink" title="样例程序输出："></a>样例程序输出：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is c.<br><span class="hljs-number">3.200000</span><br><span class="hljs-number">5.400000</span><br><span class="hljs-number">9.700000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">9.200000</span><br><span class="hljs-number">16.500000</span><br><span class="hljs-number">12.800000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">8.700000</span><br></code></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>:     “Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐</title>
    <link href="/2021/10/24/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2021/10/24/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><h2 id="CPU读取内存的方式"><a href="#CPU读取内存的方式" class="headerlink" title="CPU读取内存的方式"></a>CPU读取内存的方式</h2><p>CPU读取内存的方式其实非常复杂，为了更进一步的了解相关的原理，需要对计算机组成原理进行深度学习。</p><h3 id="Memory-access-granularity-内存读取粒度"><a href="#Memory-access-granularity-内存读取粒度" class="headerlink" title="Memory access granularity(内存读取粒度)"></a>Memory access granularity(内存读取粒度)</h3><p>However, your computer’s processor does not read from and write to memory in byte-sized chunks. Instead, it accesses memory in two-, four-, eight- 16- or even 32-byte chunks. We’ll call the size in which a processor accesses memory its memory access granularity.</p><p>CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为<em>memory access granularity（粒度）</em> 本人把它翻译为“内存读取粒度” 。</p><p><a href="https://www.cnblogs.com/feng9exe/p/10059543.html">https://www.cnblogs.com/feng9exe/p/10059543.html</a> ”内存对齐“</p><h2 id="内存对齐举例"><a href="#内存对齐举例" class="headerlink" title="内存对齐举例"></a>内存对齐举例</h2><p>假设此计算机的内存读取粒度是4。</p><h3 id="如果内存对齐时"><a href="#如果内存对齐时" class="headerlink" title="如果内存对齐时"></a>如果内存对齐时</h3><p>前提知识：</p><p>1 Byte = 8bit </p><p>1 int8 占用 1 Byte</p><p>1 int16 占用 2 Byte</p><p>1 int32 占用 4 Byte</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//一个结构体的定义如下</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span></span><br><span class="hljs-class">&#123;</span><br>    int8 a;<br>    int32 b;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th align="center">4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>int8 a</td><td></td><td></td><td></td><td align="center">int32 b</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>我们可以发现int8 a储存在0号内存上，占用1个Byte，1-3号内存空下了3个Byte。int32 b储存在了4-7号内存，一共4个Byte。</p><p>由于此计算机的内存读取粒度时是4</p><p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p><p>当需要读取b(4-7号内存时)，计算机会读取4-7号内存，访问次数1次。</p><h3 id="如果内存没有对齐时"><a href="#如果内存没有对齐时" class="headerlink" title="如果内存没有对齐时"></a>如果内存没有对齐时</h3><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>int8 a</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>我们可以发现int8 a储存在0号内存上，占用了1个Byte。int32 b储存在1-4号内存上，一共4个Byte。</p><p>由于此计算机的内存读取粒度时是4</p><p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p><p>当需要读取b(1-4号内存)时，计算机会先读取0-3号一组内存，去掉0号内存，再读取4-7号一组内存，去掉5-7号内存，随后再拼接1-3号内存和4号内存组成完整的b。访问次数2次。</p><h2 id="内存对齐的目的"><a href="#内存对齐的目的" class="headerlink" title="内存对齐的目的"></a>内存对齐的目的</h2><p>合理的内存对齐可以高效的利用硬件性能，减少处理器内存访问次数。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0</a> “内存对齐”</p><p><a href="https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0</a> “内存对齐对程序性能的影响”</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(一)</title>
    <link href="/2021/10/23/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2021/10/23/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX指令集的简单操作"><a href="#AVX指令集的简单操作" class="headerlink" title="AVX指令集的简单操作"></a>AVX指令集的简单操作</h1><p>使用AVX指令集进行2个double型的数组相加操作</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m256 _mm256_loadu_ps (<span class="hljs-keyword">float</span> <span class="hljs-keyword">const</span> * mem_addr)<br></code></pre></td></tr></table></figure><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p><h3 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">dst[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>] := MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr]<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m256d _mm256_add_pd (__m256d a, __m256d b)<br></code></pre></td></tr></table></figure><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p><h3 id="Operation-1"><a href="#Operation-1" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span><br>i := j*<span class="hljs-number">64</span><br>dst[i+<span class="hljs-number">63</span>:i] := a[i+<span class="hljs-number">63</span>:i] + b[i+<span class="hljs-number">63</span>:i]<br>ENDFOR<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> _mm256_storeu_pd (<span class="hljs-keyword">double</span> * mem_addr, __m256d a)<br></code></pre></td></tr></table></figure><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p><h3 id="Operation-2"><a href="#Operation-2" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr] := a[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="未进行AVX向量化的情况"><a href="#未进行AVX向量化的情况" class="headerlink" title="未进行AVX向量化的情况"></a>未进行AVX向量化的情况</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span> c[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>c[i]=a[i]+b[i];<br><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is c.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,c[i]);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is c.<br><span class="hljs-number">3.200000</span><br><span class="hljs-number">5.400000</span><br><span class="hljs-number">9.700000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">9.200000</span><br><span class="hljs-number">16.500000</span><br><span class="hljs-number">12.800000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">8.700000</span><br></code></pre></td></tr></table></figure><h2 id="进行AVX向量化的情况"><a href="#进行AVX向量化的情况" class="headerlink" title="进行AVX向量化的情况"></a>进行AVX向量化的情况</h2><h3 id="程序源代码-1"><a href="#程序源代码-1" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span> c[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>__m256d v0;<br>__m256d v1;<br>__m256d v2;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span><span class="hljs-number">-4</span>;i+=<span class="hljs-number">4</span>)<br>&#123;<br>v0 = _mm256_loadu_pd(a+i);<br>v1 = _mm256_loadu_pd(b+i);<br>v2=_mm256_add_pd(v0,v1);<br> _mm256_storeu_pd(c+i,v2);<br><br>&#125;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>c[i]=a[i]+b[i];<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is c with AVX.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,c[i]);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure><h3 id="程序输出-1"><a href="#程序输出-1" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is c with AVX.<br><span class="hljs-number">3.200000</span><br><span class="hljs-number">5.400000</span><br><span class="hljs-number">9.700000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">9.200000</span><br><span class="hljs-number">16.500000</span><br><span class="hljs-number">12.800000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">8.700000</span><br></code></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>:     “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
