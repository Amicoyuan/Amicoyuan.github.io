<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>论文阅读：面向国产申威 26010 众核处理器的 SpMV 实现与优化</title>
    <link href="/2023/06/09/gemm0008/"/>
    <url>/2023/06/09/gemm0008/</url>
    
    <content type="html"><![CDATA[<h2 id="面向国产申威-26010-众核处理器的-SpMV-实现与优化"><a href="#面向国产申威-26010-众核处理器的-SpMV-实现与优化" class="headerlink" title="面向国产申威 26010 众核处理器的 SpMV 实现与优化"></a>面向国产申威 26010 众核处理器的 SpMV 实现与优化</h2><h2 id="文章链接："><a href="#文章链接：" class="headerlink" title="文章链接："></a>文章链接：</h2><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C44YLTlOAiTRKibYlV5Vjs7iLik5jEcCI09uHa3oBxtWoDjpNvZMhBwTwYhU5_aacU5_o2Scyx5dsHMxE0wqndQa&uniplatform=NZKPT">面向国产申威26010众核处理器的SpMV实现与优化 - 中国知网 (cnki.net)</a></p><h2 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h2><p>存储格式：CSR</p><p>数据名称定义：</p><ul><li>col:非零元的列号</li><li>data:非零元数值，连续存放</li><li>row_off:x数组，每行第一个元素前面的非零元素，最后一个rowoff代表总的非零元素</li><li>vec:计算向量</li><li>y:结果向量</li><li>rows:行号</li><li>srow:为当前申威处理器一个从核的 LDM 可以容纳的最多稀疏行大小</li></ul><h3 id="X动静态buffer"><a href="#X动静态buffer" class="headerlink" title="X动静态buffer"></a>X动静态buffer</h3><p>x静态buffer，初始化后一直不改变。(论文中有两种初始化方法)</p><p>x动态buffer，未命中，则用dma更新x动态buffer</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//slave.c</span><br>LDM-&gt;malloc   x_sbuffer   <span class="hljs-comment">//x静态buffer</span><br>LDM-&gt;malloc   x_dbuffer   <span class="hljs-comment">//x动态buffer</span><br>sstart,send,dstart,<span class="hljs-function">dend</span><br><span class="hljs-function"><span class="hljs-title">dma</span><span class="hljs-params">(vec-&gt;x_sbuffer,sstart,send)</span></span><br><span class="hljs-function"><span class="hljs-title">dma</span><span class="hljs-params">(vec-&gt;x_dbuffer,dstart,dend)</span></span><br><span class="hljs-function"><span class="hljs-keyword">for</span> srow</span><br><span class="hljs-function">    <span class="hljs-keyword">for</span> row</span><br><span class="hljs-function">        <span class="hljs-title">if</span><span class="hljs-params">(in x_sbuffer)</span></span><br><span class="hljs-function">            cal</span><br><span class="hljs-function">        <span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(in x_dbuffer)</span></span><br><span class="hljs-function">            cal</span><br><span class="hljs-function">        <span class="hljs-keyword">else</span></span><br><span class="hljs-function">            <span class="hljs-title">update_dma</span><span class="hljs-params">(vec-&gt;x_dbuffer,dstart,dend)</span></span><br><span class="hljs-function">            cal</span><br><span class="hljs-function">     store</span><br></code></pre></div></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>动静态划分</p><p>第一轮静态：每个从核分配相同的任务量即srow</p><p>后续采用动态：哪个从核先计算完，就先从任务池里面拿新的任务</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//slave.c</span><br>eg:<span class="hljs-number">64</span>个从核<br>task_num <span class="hljs-comment">//任务数</span><br>now_addr <span class="hljs-comment">//当前任务计算到哪里了</span><br><span class="hljs-comment">//第一轮  每个从核执行相同的任务量即srow</span><br>    <br>cal srow<br><br><span class="hljs-comment">//其余任务保存到任务池，用锁保护，实现互斥操作</span><br><br><span class="hljs-comment">//任务池，当task_num为0时计算完毕</span><br>mutex = <span class="hljs-number">1</span><br><span class="hljs-built_in">P</span>(mutex)<br><span class="hljs-comment">//互斥区</span><br>task_num<br>now_addr<br><span class="hljs-built_in">V</span>(mutex)<br><span class="hljs-comment">//取now_addr</span><br>cal  srow<br><span class="hljs-comment">//随后 继续loop，直到task_num为0</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blas</tag>
      
      <tag>spmv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Packing into contiguous memory</title>
    <link href="/2023/06/07/gemm0007/"/>
    <url>/2023/06/07/gemm0007/</url>
    
    <content type="html"><![CDATA[<h2 id="Packing-into-contiguous-memory"><a href="#Packing-into-contiguous-memory" class="headerlink" title="Packing into contiguous memory"></a>Packing into contiguous memory</h2><ul><li>首先，我们打包A块，这样我们就可以连续地穿过它(march through it)。</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_12">Optimization_4x4_12 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_13">Optimization_4x4_13 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li></ul><p>这将带来惊人的性能提升:</p><p><img src="/2023/06/07/gemm0007/compare_MMult0_MMult-4x4-13.png" alt="img"></p><p><img src="/2023/06/07/gemm0007/compare_MMult-4x4-11_MMult-4x4-13.png" alt="img"></p><ul><li>最后，我们打包B块，以便连续地遍历它。</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_14">https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_14</a></li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_14">Optimization_4x4_14 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li></ul><p>我们现在达到了处理器90%的涡轮增压峰值!</p><p><img src="/2023/06/07/gemm0007/compare_MMult0_MMult-4x4-15.png" alt="img"></p><p><img src="/2023/06/07/gemm0007/compare_MMult-4x4-13_MMult-4x4-15.png" alt="img"></p><h2 id="Optimization-4x4-12"><a href="#Optimization-4x4-12" class="headerlink" title="Optimization_4x4_12"></a>Optimization_4x4_12</h2><p>在调用AddDot4x4之前，我们现在打包到4xk的A块。我们看到性能下降。如果检查内部内核，就会注意到每个4xk的A块都被重复打包，每次执行外部循环一次。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Block sizes */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mc 256</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> kc 128</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> min( i, j ) ( (i)&lt;(j) ? (i): (j) )</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixA</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> * )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, p, pb, ib;<br><br>  <span class="hljs-comment">/* This time, we compute a mc x n block of C by a call to the InnerKernel */</span><br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p+=kc )&#123;<br>    pb = <span class="hljs-built_in">min</span>( k-p, kc );<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=mc )&#123;<br>      ib = <span class="hljs-built_in">min</span>( m-i, mc );<br>      <span class="hljs-built_in">InnerKernel</span>( ib, n, pb, &amp;<span class="hljs-built_in">A</span>( i,p ), lda, &amp;<span class="hljs-built_in">B</span>(p, <span class="hljs-number">0</span> ), ldb, &amp;<span class="hljs-built_in">C</span>( i,<span class="hljs-number">0</span> ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InnerKernel</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br>  <span class="hljs-keyword">double</span> <br>    packedA[ m * k ];<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br>      <span class="hljs-built_in">PackMatrixA</span>( k, &amp;<span class="hljs-built_in">A</span>( i, <span class="hljs-number">0</span> ), lda, &amp;packedA[ i*k ] );<br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;packedA[ i*k ], <span class="hljs-number">4</span>, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixA</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, <span class="hljs-keyword">double</span> *a_to )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> j;<br><br>  <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;k; j++)&#123;  <span class="hljs-comment">/* loop over columns of A */</span><br>    <span class="hljs-keyword">double</span> <br>      *a_ij_pntr = &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, j );<br><br>    *a_to++ = *a_ij_pntr;<br>    *a_to++ = *(a_ij_pntr+<span class="hljs-number">1</span>);<br>    *a_to++ = *(a_ij_pntr+<span class="hljs-number">2</span>);<br>    *a_to++ = *(a_ij_pntr+<span class="hljs-number">3</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;xmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE2</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;emmintrin.h&gt;</span>  <span class="hljs-comment">// SSE3</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">&#123;</span><br>  __m128d v;<br>  <span class="hljs-keyword">double</span> d[<span class="hljs-number">2</span>];<br>&#125; <span class="hljs-keyword">v2df_t</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     And now we use vector registers and instructions */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">v2df_t</span><br>    c_00_c_10_vreg,    c_01_c_11_vreg,    c_02_c_12_vreg,    c_03_c_13_vreg,<br>    c_20_c_30_vreg,    c_21_c_31_vreg,    c_22_c_32_vreg,    c_23_c_33_vreg,<br>    a_0p_a_1p_vreg,<br>    a_2p_a_3p_vreg,<br>    b_p0_vreg, b_p1_vreg, b_p2_vreg, b_p3_vreg; <br><br>  <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* Point to the current elements in the four columns of B */</span><br>    *b_p0_pntr, *b_p1_pntr, *b_p2_pntr, *b_p3_pntr; <br>    <br>  b_p0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<br>  b_p1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> );<br>  b_p2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );<br>  b_p3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  c_00_c_10_vreg.v = _mm_setzero_pd();   <br>  c_01_c_11_vreg.v = _mm_setzero_pd();<br>  c_02_c_12_vreg.v = _mm_setzero_pd(); <br>  c_03_c_13_vreg.v = _mm_setzero_pd(); <br>  c_20_c_30_vreg.v = _mm_setzero_pd();   <br>  c_21_c_31_vreg.v = _mm_setzero_pd();  <br>  c_22_c_32_vreg.v = _mm_setzero_pd();   <br>  c_23_c_33_vreg.v = _mm_setzero_pd(); <br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_a_1p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) );<br>    a_2p_a_3p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) );<br><br>    b_p0_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p0_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p1_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p1_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p2_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p2_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p3_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p3_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br><br>    <span class="hljs-comment">/* First row and second rows */</span><br>    c_00_c_10_vreg.v += a_0p_a_1p_vreg.v * b_p0_vreg.v;<br>    c_01_c_11_vreg.v += a_0p_a_1p_vreg.v * b_p1_vreg.v;<br>    c_02_c_12_vreg.v += a_0p_a_1p_vreg.v * b_p2_vreg.v;<br>    c_03_c_13_vreg.v += a_0p_a_1p_vreg.v * b_p3_vreg.v;<br><br>    <span class="hljs-comment">/* Third and fourth rows */</span><br>    c_20_c_30_vreg.v += a_2p_a_3p_vreg.v * b_p0_vreg.v;<br>    c_21_c_31_vreg.v += a_2p_a_3p_vreg.v * b_p1_vreg.v;<br>    c_22_c_32_vreg.v += a_2p_a_3p_vreg.v * b_p2_vreg.v;<br>    c_23_c_33_vreg.v += a_2p_a_3p_vreg.v * b_p3_vreg.v;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">1</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">1</span>]; <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization-4x4-13"><a href="#Optimization-4x4-13" class="headerlink" title="Optimization_4x4_13"></a>Optimization_4x4_13</h2><p>这个版本保存了A的打包块，以便在InnerKernel的外部循环的第一次迭代之后，使用保存的版本。性能的提升是显而易见的!与上一个版本相比，唯一的变化是增加了if (j&#x3D;&#x3D; 0)。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Block sizes */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mc 256</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> kc 128</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> min( i, j ) ( (i)&lt;(j) ? (i): (j) )</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixA</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> * )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, p, pb, ib;<br><br>  <span class="hljs-comment">/* This time, we compute a mc x n block of C by a call to the InnerKernel */</span><br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p+=kc )&#123;<br>    pb = <span class="hljs-built_in">min</span>( k-p, kc );<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=mc )&#123;<br>      ib = <span class="hljs-built_in">min</span>( m-i, mc );<br>      <span class="hljs-built_in">InnerKernel</span>( ib, n, pb, &amp;<span class="hljs-built_in">A</span>( i,p ), lda, &amp;<span class="hljs-built_in">B</span>(p, <span class="hljs-number">0</span> ), ldb, &amp;<span class="hljs-built_in">C</span>( i,<span class="hljs-number">0</span> ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InnerKernel</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br>  <span class="hljs-keyword">double</span> <br>    packedA[ m * k ];<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br>      <span class="hljs-keyword">if</span> ( j == <span class="hljs-number">0</span> ) <span class="hljs-built_in">PackMatrixA</span>( k, &amp;<span class="hljs-built_in">A</span>( i, <span class="hljs-number">0</span> ), lda, &amp;packedA[ i*k ] );<br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;packedA[ i*k ], <span class="hljs-number">4</span>, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixA</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, <span class="hljs-keyword">double</span> *a_to )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> j;<br><br>  <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;k; j++)&#123;  <span class="hljs-comment">/* loop over columns of A */</span><br>    <span class="hljs-keyword">double</span> <br>      *a_ij_pntr = &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, j );<br><br>    *a_to++ = *a_ij_pntr;<br>    *a_to++ = *(a_ij_pntr+<span class="hljs-number">1</span>);<br>    *a_to++ = *(a_ij_pntr+<span class="hljs-number">2</span>);<br>    *a_to++ = *(a_ij_pntr+<span class="hljs-number">3</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;xmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE2</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;emmintrin.h&gt;</span>  <span class="hljs-comment">// SSE3</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">&#123;</span><br>  __m128d v;<br>  <span class="hljs-keyword">double</span> d[<span class="hljs-number">2</span>];<br>&#125; <span class="hljs-keyword">v2df_t</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     And now we use vector registers and instructions */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">v2df_t</span><br>    c_00_c_10_vreg,    c_01_c_11_vreg,    c_02_c_12_vreg,    c_03_c_13_vreg,<br>    c_20_c_30_vreg,    c_21_c_31_vreg,    c_22_c_32_vreg,    c_23_c_33_vreg,<br>    a_0p_a_1p_vreg,<br>    a_2p_a_3p_vreg,<br>    b_p0_vreg, b_p1_vreg, b_p2_vreg, b_p3_vreg; <br><br>  <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* Point to the current elements in the four columns of B */</span><br>    *b_p0_pntr, *b_p1_pntr, *b_p2_pntr, *b_p3_pntr; <br>    <br>  b_p0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<br>  b_p1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> );<br>  b_p2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );<br>  b_p3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  c_00_c_10_vreg.v = _mm_setzero_pd();   <br>  c_01_c_11_vreg.v = _mm_setzero_pd();<br>  c_02_c_12_vreg.v = _mm_setzero_pd(); <br>  c_03_c_13_vreg.v = _mm_setzero_pd(); <br>  c_20_c_30_vreg.v = _mm_setzero_pd();   <br>  c_21_c_31_vreg.v = _mm_setzero_pd();  <br>  c_22_c_32_vreg.v = _mm_setzero_pd();   <br>  c_23_c_33_vreg.v = _mm_setzero_pd(); <br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_a_1p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) a );<br>    a_2p_a_3p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) ( a+<span class="hljs-number">2</span> ) );<br>    a += <span class="hljs-number">4</span>;<br><br>    b_p0_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p0_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p1_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p1_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p2_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p2_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p3_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p3_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br><br>    <span class="hljs-comment">/* First row and second rows */</span><br>    c_00_c_10_vreg.v += a_0p_a_1p_vreg.v * b_p0_vreg.v;<br>    c_01_c_11_vreg.v += a_0p_a_1p_vreg.v * b_p1_vreg.v;<br>    c_02_c_12_vreg.v += a_0p_a_1p_vreg.v * b_p2_vreg.v;<br>    c_03_c_13_vreg.v += a_0p_a_1p_vreg.v * b_p3_vreg.v;<br><br>    <span class="hljs-comment">/* Third and fourth rows */</span><br>    c_20_c_30_vreg.v += a_2p_a_3p_vreg.v * b_p0_vreg.v;<br>    c_21_c_31_vreg.v += a_2p_a_3p_vreg.v * b_p1_vreg.v;<br>    c_22_c_32_vreg.v += a_2p_a_3p_vreg.v * b_p2_vreg.v;<br>    c_23_c_33_vreg.v += a_2p_a_3p_vreg.v * b_p3_vreg.v;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">1</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">1</span>]; <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization-4x4-14"><a href="#Optimization-4x4-14" class="headerlink" title="Optimization_4x4_14"></a>Optimization_4x4_14</h2><p>我们现在打包b的kx4块，注意，在这个版本中，面板是重复打包的，这会对性能产生不利影响。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Block sizes */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mc 256</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> kc 128</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> min( i, j ) ( (i)&lt;(j) ? (i): (j) )</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixA</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> * )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixB</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> * )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InnerKernel</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, p, pb, ib;<br><br>  <span class="hljs-comment">/* This time, we compute a mc x n block of C by a call to the InnerKernel */</span><br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p+=kc )&#123;<br>    pb = <span class="hljs-built_in">min</span>( k-p, kc );<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=mc )&#123;<br>      ib = <span class="hljs-built_in">min</span>( m-i, mc );<br>      <span class="hljs-built_in">InnerKernel</span>( ib, n, pb, &amp;<span class="hljs-built_in">A</span>( i,p ), lda, &amp;<span class="hljs-built_in">B</span>(p, <span class="hljs-number">0</span> ), ldb, &amp;<span class="hljs-built_in">C</span>( i,<span class="hljs-number">0</span> ), ldc, i==<span class="hljs-number">0</span> );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InnerKernel</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc, <span class="hljs-keyword">int</span> first_time )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br>  <span class="hljs-keyword">double</span> <br>    packedA[ m * k ], packedB[ k*n ];<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-built_in">PackMatrixB</span>( k, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, j ), ldb, &amp;packedB[ j*k ] );<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br>      <span class="hljs-keyword">if</span> ( j == <span class="hljs-number">0</span> ) <br><span class="hljs-built_in">PackMatrixA</span>( k, &amp;<span class="hljs-built_in">A</span>( i, <span class="hljs-number">0</span> ), lda, &amp;packedA[ i*k ] );<br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;packedA[ i*k ], <span class="hljs-number">4</span>, &amp;packedB[ j*k ], k, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixA</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, <span class="hljs-keyword">double</span> *a_to )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> j;<br><br>  <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;k; j++)&#123;  <span class="hljs-comment">/* loop over columns of A */</span><br>    <span class="hljs-keyword">double</span> <br>      *a_ij_pntr = &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, j );<br><br>    *a_to     = *a_ij_pntr;<br>    *(a_to+<span class="hljs-number">1</span>) = *(a_ij_pntr+<span class="hljs-number">1</span>);<br>    *(a_to+<span class="hljs-number">2</span>) = *(a_ij_pntr+<span class="hljs-number">2</span>);<br>    *(a_to+<span class="hljs-number">3</span>) = *(a_ij_pntr+<span class="hljs-number">3</span>);<br><br>    a_to += <span class="hljs-number">4</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixB</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *b_to )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">double</span> <br>    *b_i0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), *b_i1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ),<br>    *b_i2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ), *b_i3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;k; i++)&#123;  <span class="hljs-comment">/* loop over rows of B */</span><br>    *b_to++ = *b_i0_pntr++;<br>    *b_to++ = *b_i1_pntr++;<br>    *b_to++ = *b_i2_pntr++;<br>    *b_to++ = *b_i3_pntr++;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;xmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE2</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;emmintrin.h&gt;</span>  <span class="hljs-comment">// SSE3</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">&#123;</span><br>  __m128d v;<br>  <span class="hljs-keyword">double</span> d[<span class="hljs-number">2</span>];<br>&#125; <span class="hljs-keyword">v2df_t</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     And now we use vector registers and instructions */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">v2df_t</span><br>    c_00_c_10_vreg,    c_01_c_11_vreg,    c_02_c_12_vreg,    c_03_c_13_vreg,<br>    c_20_c_30_vreg,    c_21_c_31_vreg,    c_22_c_32_vreg,    c_23_c_33_vreg,<br>    a_0p_a_1p_vreg,<br>    a_2p_a_3p_vreg,<br>    b_p0_vreg, b_p1_vreg, b_p2_vreg, b_p3_vreg; <br><br>  c_00_c_10_vreg.v = _mm_setzero_pd();   <br>  c_01_c_11_vreg.v = _mm_setzero_pd();<br>  c_02_c_12_vreg.v = _mm_setzero_pd(); <br>  c_03_c_13_vreg.v = _mm_setzero_pd(); <br>  c_20_c_30_vreg.v = _mm_setzero_pd();   <br>  c_21_c_31_vreg.v = _mm_setzero_pd();  <br>  c_22_c_32_vreg.v = _mm_setzero_pd();   <br>  c_23_c_33_vreg.v = _mm_setzero_pd(); <br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_a_1p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) a );<br>    a_2p_a_3p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) ( a+<span class="hljs-number">2</span> ) );<br>    a += <span class="hljs-number">4</span>;<br><br>    b_p0_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b );       <span class="hljs-comment">/* load and duplicate */</span><br>    b_p1_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) (b+<span class="hljs-number">1</span>) );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p2_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) (b+<span class="hljs-number">2</span>) );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p3_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) (b+<span class="hljs-number">3</span>) );   <span class="hljs-comment">/* load and duplicate */</span><br><br>    b += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">/* First row and second rows */</span><br>    c_00_c_10_vreg.v += a_0p_a_1p_vreg.v * b_p0_vreg.v;<br>    c_01_c_11_vreg.v += a_0p_a_1p_vreg.v * b_p1_vreg.v;<br>    c_02_c_12_vreg.v += a_0p_a_1p_vreg.v * b_p2_vreg.v;<br>    c_03_c_13_vreg.v += a_0p_a_1p_vreg.v * b_p3_vreg.v;<br><br>    <span class="hljs-comment">/* Third and fourth rows */</span><br>    c_20_c_30_vreg.v += a_2p_a_3p_vreg.v * b_p0_vreg.v;<br>    c_21_c_31_vreg.v += a_2p_a_3p_vreg.v * b_p1_vreg.v;<br>    c_22_c_32_vreg.v += a_2p_a_3p_vreg.v * b_p2_vreg.v;<br>    c_23_c_33_vreg.v += a_2p_a_3p_vreg.v * b_p3_vreg.v;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">1</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">1</span>]; <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization-4x4-15"><a href="#Optimization-4x4-15" class="headerlink" title="Optimization_4x4_15"></a>Optimization_4x4_15</h2><p>并且，我们再次添加了一些代码，这样我们就可以避免重新打包b的kx4块。现在性能令人印象深刻!</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Block sizes */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mc 256</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> kc 128</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> nb 1000</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> min( i, j ) ( (i)&lt;(j) ? (i): (j) )</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixA</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> * )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixB</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> * )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InnerKernel</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, p, pb, ib;<br><br>  <span class="hljs-comment">/* This time, we compute a mc x n block of C by a call to the InnerKernel */</span><br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p+=kc )&#123;<br>    pb = <span class="hljs-built_in">min</span>( k-p, kc );<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=mc )&#123;<br>      ib = <span class="hljs-built_in">min</span>( m-i, mc );<br>      <span class="hljs-built_in">InnerKernel</span>( ib, n, pb, &amp;<span class="hljs-built_in">A</span>( i,p ), lda, &amp;<span class="hljs-built_in">B</span>(p, <span class="hljs-number">0</span> ), ldb, &amp;<span class="hljs-built_in">C</span>( i,<span class="hljs-number">0</span> ), ldc, i==<span class="hljs-number">0</span> );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InnerKernel</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc, <span class="hljs-keyword">int</span> first_time )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br>  <span class="hljs-keyword">double</span> <br>    packedA[ m * k ];<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <br>    packedB[ kc*nb ];    <span class="hljs-comment">/* Note: using a static buffer is not thread safe... */</span><br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">if</span> ( first_time )<br>      <span class="hljs-built_in">PackMatrixB</span>( k, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, j ), ldb, &amp;packedB[ j*k ] );<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br>      <span class="hljs-keyword">if</span> ( j == <span class="hljs-number">0</span> ) <br><span class="hljs-built_in">PackMatrixA</span>( k, &amp;<span class="hljs-built_in">A</span>( i, <span class="hljs-number">0</span> ), lda, &amp;packedA[ i*k ] );<br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;packedA[ i*k ], <span class="hljs-number">4</span>, &amp;packedB[ j*k ], k, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixA</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, <span class="hljs-keyword">double</span> *a_to )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> j;<br><br>  <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;k; j++)&#123;  <span class="hljs-comment">/* loop over columns of A */</span><br>    <span class="hljs-keyword">double</span> <br>      *a_ij_pntr = &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, j );<br><br>    *a_to     = *a_ij_pntr;<br>    *(a_to+<span class="hljs-number">1</span>) = *(a_ij_pntr+<span class="hljs-number">1</span>);<br>    *(a_to+<span class="hljs-number">2</span>) = *(a_ij_pntr+<span class="hljs-number">2</span>);<br>    *(a_to+<span class="hljs-number">3</span>) = *(a_ij_pntr+<span class="hljs-number">3</span>);<br><br>    a_to += <span class="hljs-number">4</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackMatrixB</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *b_to )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  <span class="hljs-keyword">double</span> <br>    *b_i0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), *b_i1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ),<br>    *b_i2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ), *b_i3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;k; i++)&#123;  <span class="hljs-comment">/* loop over rows of B */</span><br>    *b_to++ = *b_i0_pntr++;<br>    *b_to++ = *b_i1_pntr++;<br>    *b_to++ = *b_i2_pntr++;<br>    *b_to++ = *b_i3_pntr++;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;xmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE2</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;emmintrin.h&gt;</span>  <span class="hljs-comment">// SSE3</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">&#123;</span><br>  __m128d v;<br>  <span class="hljs-keyword">double</span> d[<span class="hljs-number">2</span>];<br>&#125; <span class="hljs-keyword">v2df_t</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     And now we use vector registers and instructions */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">v2df_t</span><br>    c_00_c_10_vreg,    c_01_c_11_vreg,    c_02_c_12_vreg,    c_03_c_13_vreg,<br>    c_20_c_30_vreg,    c_21_c_31_vreg,    c_22_c_32_vreg,    c_23_c_33_vreg,<br>    a_0p_a_1p_vreg,<br>    a_2p_a_3p_vreg,<br>    b_p0_vreg, b_p1_vreg, b_p2_vreg, b_p3_vreg; <br><br>  c_00_c_10_vreg.v = _mm_setzero_pd();   <br>  c_01_c_11_vreg.v = _mm_setzero_pd();<br>  c_02_c_12_vreg.v = _mm_setzero_pd(); <br>  c_03_c_13_vreg.v = _mm_setzero_pd(); <br>  c_20_c_30_vreg.v = _mm_setzero_pd();   <br>  c_21_c_31_vreg.v = _mm_setzero_pd();  <br>  c_22_c_32_vreg.v = _mm_setzero_pd();   <br>  c_23_c_33_vreg.v = _mm_setzero_pd(); <br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_a_1p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) a );<br>    a_2p_a_3p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) ( a+<span class="hljs-number">2</span> ) );<br>    a += <span class="hljs-number">4</span>;<br><br>    b_p0_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b );       <span class="hljs-comment">/* load and duplicate */</span><br>    b_p1_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) (b+<span class="hljs-number">1</span>) );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p2_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) (b+<span class="hljs-number">2</span>) );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p3_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) (b+<span class="hljs-number">3</span>) );   <span class="hljs-comment">/* load and duplicate */</span><br><br>    b += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">/* First row and second rows */</span><br>    c_00_c_10_vreg.v += a_0p_a_1p_vreg.v * b_p0_vreg.v;<br>    c_01_c_11_vreg.v += a_0p_a_1p_vreg.v * b_p1_vreg.v;<br>    c_02_c_12_vreg.v += a_0p_a_1p_vreg.v * b_p2_vreg.v;<br>    c_03_c_13_vreg.v += a_0p_a_1p_vreg.v * b_p3_vreg.v;<br><br>    <span class="hljs-comment">/* Third and fourth rows */</span><br>    c_20_c_30_vreg.v += a_2p_a_3p_vreg.v * b_p0_vreg.v;<br>    c_21_c_31_vreg.v += a_2p_a_3p_vreg.v * b_p1_vreg.v;<br>    c_22_c_32_vreg.v += a_2p_a_3p_vreg.v * b_p2_vreg.v;<br>    c_23_c_33_vreg.v += a_2p_a_3p_vreg.v * b_p3_vreg.v;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">1</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">1</span>]; <br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blas</tag>
      
      <tag>gemm</tag>
      
      <tag>gemv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blocking to maintain performance</title>
    <link href="/2023/06/07/gemm0006/"/>
    <url>/2023/06/07/gemm0006/</url>
    
    <content type="html"><![CDATA[<h2 id="Blocking-to-maintain-performance"><a href="#Blocking-to-maintain-performance" class="headerlink" title="Blocking to maintain performance"></a>Blocking to maintain performance</h2><ul><li>为了保持较小问题规模的性能，我们分块矩阵C(以及相应的A和B):</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_11">Optimization_4x4_11 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li></ul><p>现在，性能得到了保持:</p><p><img src="/2023/06/07/gemm0006/compare_MMult0_MMult-4x4-11.png" alt="img"></p><p><img src="/2023/06/07/gemm0006/compare_MMult-4x4-10_MMult-4x4-11.png" alt="img"></p><h2 id="Optimization-4x4-11"><a href="#Optimization-4x4-11" class="headerlink" title="Optimization_4x4_11"></a>Optimization_4x4_11</h2><p>我们注意到，对于迄今为止的所有优化，当涉及的矩阵比L2缓存所能容纳的矩阵大得多时，性能会大幅下降。在这个优化中，我们创建了一个额外的分块级别来克服这个问题。我们现在有一个主例程，它调用GotoBLAS和BLIS使用的内部内核，然后AddDot4x4例程是BLIS使用的微内核。</p><p>这一步主要是为了分块，把原来的MY_MMult变成了InnerKernel，而现在的MY_MMult作用就是为了分块。分块大小通过宏定义给出。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Block sizes */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mc 256</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> kc 128</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> min( i, j ) ( (i)&lt;(j) ? (i): (j) )</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j, p, pb, ib;<br><br>  <span class="hljs-comment">/* This time, we compute a mc x n block of C by a call to the InnerKernel */</span><br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p+=kc )&#123;<br>    pb = <span class="hljs-built_in">min</span>( k-p, kc );<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=mc )&#123;<br>      ib = <span class="hljs-built_in">min</span>( m-i, mc );<br>      <span class="hljs-built_in">InnerKernel</span>( ib, n, pb, &amp;<span class="hljs-built_in">A</span>( i,p ), lda, &amp;<span class="hljs-built_in">B</span>(p, <span class="hljs-number">0</span> ), ldb, &amp;<span class="hljs-built_in">C</span>( i,<span class="hljs-number">0</span> ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InnerKernel</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;xmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE2</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;emmintrin.h&gt;</span>  <span class="hljs-comment">// SSE3</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">&#123;</span><br>  __m128d v;<br>  <span class="hljs-keyword">double</span> d[<span class="hljs-number">2</span>];<br>&#125; <span class="hljs-keyword">v2df_t</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     And now we use vector registers and instructions */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">v2df_t</span><br>    c_00_c_10_vreg,    c_01_c_11_vreg,    c_02_c_12_vreg,    c_03_c_13_vreg,<br>    c_20_c_30_vreg,    c_21_c_31_vreg,    c_22_c_32_vreg,    c_23_c_33_vreg,<br>    a_0p_a_1p_vreg,<br>    a_2p_a_3p_vreg,<br>    b_p0_vreg, b_p1_vreg, b_p2_vreg, b_p3_vreg; <br><br>  <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* Point to the current elements in the four columns of B */</span><br>    *b_p0_pntr, *b_p1_pntr, *b_p2_pntr, *b_p3_pntr; <br>    <br>  b_p0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<br>  b_p1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> );<br>  b_p2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );<br>  b_p3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  c_00_c_10_vreg.v = _mm_setzero_pd();   <br>  c_01_c_11_vreg.v = _mm_setzero_pd();<br>  c_02_c_12_vreg.v = _mm_setzero_pd(); <br>  c_03_c_13_vreg.v = _mm_setzero_pd(); <br>  c_20_c_30_vreg.v = _mm_setzero_pd();   <br>  c_21_c_31_vreg.v = _mm_setzero_pd();  <br>  c_22_c_32_vreg.v = _mm_setzero_pd();   <br>  c_23_c_33_vreg.v = _mm_setzero_pd(); <br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_a_1p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) );<br>    a_2p_a_3p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) );<br><br>    b_p0_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p0_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p1_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p1_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p2_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p2_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p3_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p3_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br><br>    <span class="hljs-comment">/* First row and second rows */</span><br>    c_00_c_10_vreg.v += a_0p_a_1p_vreg.v * b_p0_vreg.v;<br>    c_01_c_11_vreg.v += a_0p_a_1p_vreg.v * b_p1_vreg.v;<br>    c_02_c_12_vreg.v += a_0p_a_1p_vreg.v * b_p2_vreg.v;<br>    c_03_c_13_vreg.v += a_0p_a_1p_vreg.v * b_p3_vreg.v;<br><br>    <span class="hljs-comment">/* Third and fourth rows */</span><br>    c_20_c_30_vreg.v += a_2p_a_3p_vreg.v * b_p0_vreg.v;<br>    c_21_c_31_vreg.v += a_2p_a_3p_vreg.v * b_p1_vreg.v;<br>    c_22_c_32_vreg.v += a_2p_a_3p_vreg.v * b_p2_vreg.v;<br>    c_23_c_33_vreg.v += a_2p_a_3p_vreg.v * b_p3_vreg.v;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">1</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">1</span>]; <br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blas</tag>
      
      <tag>gemm</tag>
      
      <tag>gemv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Further optimizing</title>
    <link href="/2023/06/07/gemm0005/"/>
    <url>/2023/06/07/gemm0005/</url>
    
    <content type="html"><![CDATA[<h2 id="Further-optimizing"><a href="#Further-optimizing" class="headerlink" title="Further optimizing"></a>Further optimizing</h2><p>现在我们开始以不同的方式优化1x4的情况。</p><ul><li>我们在寄存器中存储一行k × 4矩阵B</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_8">https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_8</a></li></ul><p>请注意，我们现在使用的常规寄存器比物理上可用的寄存器多得多……</p><ul><li>我们重新安排计算，以便一次计算两行4x4的C块。</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_9">Optimization_4x4_9 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li>我们使用向量寄存器和向量运算。</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_10">Optimization_4x4_10 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li></ul><p>We notice a considerable performance boost:</p><p><img src="/2023/06/07/gemm0005/compare_MMult0_MMult-4x4-10.png" alt="img"></p><p><img src="/2023/06/07/gemm0005/compare_MMult-1x4-9_MMult-4x4-10.png" alt="img"></p><p>不过，还有很大的改进空间。</p><h2 id="Optimization-4x4-8"><a href="#Optimization-4x4-8" class="headerlink" title="Optimization_4x4_8"></a>Optimization_4x4_8</h2><p>现在我们使用寄存器来存储B当前行的元素。(注意，对于一次计算C四个元素的情况，我们没有这样做。)性能实际上略有下降。但是这个步骤支持进一步的优化。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     In this version, we use registers for elements in the current row</span><br><span class="hljs-comment">     of B as well */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* hold contributions to</span><br><span class="hljs-comment">       C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ) </span><br><span class="hljs-comment">       C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ) </span><br><span class="hljs-comment">       C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ) </span><br><span class="hljs-comment">       C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 )   */</span><br>       c_00_reg,   c_01_reg,   c_02_reg,   c_03_reg,  <br>       c_10_reg,   c_11_reg,   c_12_reg,   c_13_reg,  <br>       c_20_reg,   c_21_reg,   c_22_reg,   c_23_reg,  <br>       c_30_reg,   c_31_reg,   c_32_reg,   c_33_reg,<br>    <span class="hljs-comment">/* hold </span><br><span class="hljs-comment">       A( 0, p ) </span><br><span class="hljs-comment">       A( 1, p ) </span><br><span class="hljs-comment">       A( 2, p ) </span><br><span class="hljs-comment">       A( 3, p ) */</span><br>       a_0p_reg,<br>       a_1p_reg,<br>       a_2p_reg,<br>       a_3p_reg,<br>       b_p0_reg,<br>       b_p1_reg,<br>       b_p2_reg,<br>       b_p3_reg;<br><br>  <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* Point to the current elements in the four columns of B */</span><br>    *b_p0_pntr, *b_p1_pntr, *b_p2_pntr, *b_p3_pntr; <br>    <br>  b_p0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<br>  b_p1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> );<br>  b_p2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );<br>  b_p3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  c_00_reg = <span class="hljs-number">0.0</span>;   c_01_reg = <span class="hljs-number">0.0</span>;   c_02_reg = <span class="hljs-number">0.0</span>;   c_03_reg = <span class="hljs-number">0.0</span>;<br>  c_10_reg = <span class="hljs-number">0.0</span>;   c_11_reg = <span class="hljs-number">0.0</span>;   c_12_reg = <span class="hljs-number">0.0</span>;   c_13_reg = <span class="hljs-number">0.0</span>;<br>  c_20_reg = <span class="hljs-number">0.0</span>;   c_21_reg = <span class="hljs-number">0.0</span>;   c_22_reg = <span class="hljs-number">0.0</span>;   c_23_reg = <span class="hljs-number">0.0</span>;<br>  c_30_reg = <span class="hljs-number">0.0</span>;   c_31_reg = <span class="hljs-number">0.0</span>;   c_32_reg = <span class="hljs-number">0.0</span>;   c_33_reg = <span class="hljs-number">0.0</span>;<br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p );<br>    a_1p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p );<br>    a_2p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p );<br>    a_3p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p );<br><br>    b_p0_reg = *b_p0_pntr++;<br>    b_p1_reg = *b_p1_pntr++;<br>    b_p2_reg = *b_p2_pntr++;<br>    b_p3_reg = *b_p3_pntr++;<br><br>    <span class="hljs-comment">/* First row */</span><br>    c_00_reg += a_0p_reg * b_p0_reg;<br>    c_01_reg += a_0p_reg * b_p1_reg;<br>    c_02_reg += a_0p_reg * b_p2_reg;<br>    c_03_reg += a_0p_reg * b_p3_reg;<br><br>    <span class="hljs-comment">/* Second row */</span><br>    c_10_reg += a_1p_reg * b_p0_reg;<br>    c_11_reg += a_1p_reg * b_p1_reg;<br>    c_12_reg += a_1p_reg * b_p2_reg;<br>    c_13_reg += a_1p_reg * b_p3_reg;<br><br>    <span class="hljs-comment">/* Third row */</span><br>    c_20_reg += a_2p_reg * b_p0_reg;<br>    c_21_reg += a_2p_reg * b_p1_reg;<br>    c_22_reg += a_2p_reg * b_p2_reg;<br>    c_23_reg += a_2p_reg * b_p3_reg;<br><br>    <span class="hljs-comment">/* Four row */</span><br>    c_30_reg += a_3p_reg * b_p0_reg;<br>    c_31_reg += a_3p_reg * b_p1_reg;<br>    c_32_reg += a_3p_reg * b_p2_reg;<br>    c_33_reg += a_3p_reg * b_p3_reg;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += c_10_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += c_11_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += c_12_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += c_13_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += c_20_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += c_21_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += c_22_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += c_23_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += c_30_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += c_31_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += c_32_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += c_33_reg;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization-4x4-9"><a href="#Optimization-4x4-9" class="headerlink" title="Optimization_4x4_9"></a>Optimization_4x4_9</h2><p>从4x4_8到4x4_9是一个微妙的变化:我们不是一次一行地更新4x4块C的行，而是一次计算两行。这为我们使用向量操作做好了准备，我们用向量操作更新对C(0,j)和C(1,j) (j &#x3D;0，…，3)。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     A simple rearrangement to prepare for the use of vector registers */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* hold contributions to</span><br><span class="hljs-comment">       C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ) </span><br><span class="hljs-comment">       C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ) </span><br><span class="hljs-comment">       C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ) </span><br><span class="hljs-comment">       C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 )   */</span><br>       c_00_reg,   c_01_reg,   c_02_reg,   c_03_reg,  <br>       c_10_reg,   c_11_reg,   c_12_reg,   c_13_reg,  <br>       c_20_reg,   c_21_reg,   c_22_reg,   c_23_reg,  <br>       c_30_reg,   c_31_reg,   c_32_reg,   c_33_reg,<br>    <span class="hljs-comment">/* hold </span><br><span class="hljs-comment">       A( 0, p ) </span><br><span class="hljs-comment">       A( 1, p ) </span><br><span class="hljs-comment">       A( 2, p ) </span><br><span class="hljs-comment">       A( 3, p ) */</span><br>       a_0p_reg,<br>       a_1p_reg,<br>       a_2p_reg,<br>       a_3p_reg,<br>       b_p0_reg,<br>       b_p1_reg,<br>       b_p2_reg,<br>       b_p3_reg;<br><br>  <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* Point to the current elements in the four columns of B */</span><br>    *b_p0_pntr, *b_p1_pntr, *b_p2_pntr, *b_p3_pntr; <br>    <br>  b_p0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<br>  b_p1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> );<br>  b_p2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );<br>  b_p3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  c_00_reg = <span class="hljs-number">0.0</span>;   c_01_reg = <span class="hljs-number">0.0</span>;   c_02_reg = <span class="hljs-number">0.0</span>;   c_03_reg = <span class="hljs-number">0.0</span>;<br>  c_10_reg = <span class="hljs-number">0.0</span>;   c_11_reg = <span class="hljs-number">0.0</span>;   c_12_reg = <span class="hljs-number">0.0</span>;   c_13_reg = <span class="hljs-number">0.0</span>;<br>  c_20_reg = <span class="hljs-number">0.0</span>;   c_21_reg = <span class="hljs-number">0.0</span>;   c_22_reg = <span class="hljs-number">0.0</span>;   c_23_reg = <span class="hljs-number">0.0</span>;<br>  c_30_reg = <span class="hljs-number">0.0</span>;   c_31_reg = <span class="hljs-number">0.0</span>;   c_32_reg = <span class="hljs-number">0.0</span>;   c_33_reg = <span class="hljs-number">0.0</span>;<br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p );<br>    a_1p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p );<br>    a_2p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p );<br>    a_3p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p );<br><br>    b_p0_reg = *b_p0_pntr++;<br>    b_p1_reg = *b_p1_pntr++;<br>    b_p2_reg = *b_p2_pntr++;<br>    b_p3_reg = *b_p3_pntr++;<br><br>    <span class="hljs-comment">/* First row and second rows */</span><br>    c_00_reg += a_0p_reg * b_p0_reg;<br>    c_10_reg += a_1p_reg * b_p0_reg;<br><br>    c_01_reg += a_0p_reg * b_p1_reg;<br>    c_11_reg += a_1p_reg * b_p1_reg;<br><br>    c_02_reg += a_0p_reg * b_p2_reg;<br>    c_12_reg += a_1p_reg * b_p2_reg;<br><br>    c_03_reg += a_0p_reg * b_p3_reg;<br>    c_13_reg += a_1p_reg * b_p3_reg;<br><br>    <span class="hljs-comment">/* Third and fourth rows */</span><br>    c_20_reg += a_2p_reg * b_p0_reg;<br>    c_30_reg += a_3p_reg * b_p0_reg;<br><br>    c_21_reg += a_2p_reg * b_p1_reg;<br>    c_31_reg += a_3p_reg * b_p1_reg;<br><br>    c_22_reg += a_2p_reg * b_p2_reg;<br>    c_32_reg += a_3p_reg * b_p2_reg;<br><br>    c_23_reg += a_2p_reg * b_p3_reg;<br>    c_33_reg += a_3p_reg * b_p3_reg;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += c_10_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += c_11_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += c_12_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += c_13_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += c_20_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += c_21_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += c_22_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += c_23_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += c_30_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += c_31_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += c_32_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += c_33_reg;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization-4x4-10"><a href="#Optimization-4x4-10" class="headerlink" title="Optimization_4x4_10"></a>Optimization_4x4_10</h2><p>在这里，我们开始使用向量寄存器和向量操作。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mmintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;xmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pmmintrin.h&gt;</span>  <span class="hljs-comment">// SSE2</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;emmintrin.h&gt;</span>  <span class="hljs-comment">// SSE3</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">&#123;</span><br>  __m128d v;<br>  <span class="hljs-keyword">double</span> d[<span class="hljs-number">2</span>];<br>&#125; <span class="hljs-keyword">v2df_t</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     And now we use vector registers and instructions */</span><br><br>  <span class="hljs-keyword">int</span> p;<br><br>  <span class="hljs-keyword">v2df_t</span><br>    c_00_c_10_vreg,    c_01_c_11_vreg,    c_02_c_12_vreg,    c_03_c_13_vreg,<br>    c_20_c_30_vreg,    c_21_c_31_vreg,    c_22_c_32_vreg,    c_23_c_33_vreg,<br>    a_0p_a_1p_vreg,<br>    a_2p_a_3p_vreg,<br>    b_p0_vreg, b_p1_vreg, b_p2_vreg, b_p3_vreg; <br><br>  <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* Point to the current elements in the four columns of B */</span><br>    *b_p0_pntr, *b_p1_pntr, *b_p2_pntr, *b_p3_pntr; <br>    <br>  b_p0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<br>  b_p1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> );<br>  b_p2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );<br>  b_p3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  c_00_c_10_vreg.v = _mm_setzero_pd();   <br>  c_01_c_11_vreg.v = _mm_setzero_pd();<br>  c_02_c_12_vreg.v = _mm_setzero_pd(); <br>  c_03_c_13_vreg.v = _mm_setzero_pd(); <br>  c_20_c_30_vreg.v = _mm_setzero_pd();   <br>  c_21_c_31_vreg.v = _mm_setzero_pd();  <br>  c_22_c_32_vreg.v = _mm_setzero_pd();   <br>  c_23_c_33_vreg.v = _mm_setzero_pd(); <br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_a_1p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) );<br>    a_2p_a_3p_vreg.v = _mm_load_pd( (<span class="hljs-keyword">double</span> *) &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) );<br><br>    b_p0_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p0_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p1_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p1_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p2_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p2_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br>    b_p3_vreg.v = _mm_loaddup_pd( (<span class="hljs-keyword">double</span> *) b_p3_pntr++ );   <span class="hljs-comment">/* load and duplicate */</span><br><br>    <span class="hljs-comment">/* First row and second rows *  向量化，一次计算两个double/</span><br><span class="hljs-comment">    c_00_c_10_vreg.v += a_0p_a_1p_vreg.v * b_p0_vreg.v;</span><br><span class="hljs-comment">    c_01_c_11_vreg.v += a_0p_a_1p_vreg.v * b_p1_vreg.v;</span><br><span class="hljs-comment">    c_02_c_12_vreg.v += a_0p_a_1p_vreg.v * b_p2_vreg.v;</span><br><span class="hljs-comment">    c_03_c_13_vreg.v += a_0p_a_1p_vreg.v * b_p3_vreg.v;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    /* Third and fourth rows */</span><br>    c_20_c_30_vreg.v += a_2p_a_3p_vreg.v * b_p0_vreg.v;<br>    c_21_c_31_vreg.v += a_2p_a_3p_vreg.v * b_p1_vreg.v;<br>    c_22_c_32_vreg.v += a_2p_a_3p_vreg.v * b_p2_vreg.v;<br>    c_23_c_33_vreg.v += a_2p_a_3p_vreg.v * b_p3_vreg.v;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += c_00_c_10_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += c_01_c_11_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += c_02_c_12_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += c_03_c_13_vreg.d[<span class="hljs-number">1</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">0</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">0</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">0</span>]; <br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += c_20_c_30_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += c_21_c_31_vreg.d[<span class="hljs-number">1</span>];  <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += c_22_c_32_vreg.d[<span class="hljs-number">1</span>];  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += c_23_c_33_vreg.d[<span class="hljs-number">1</span>]; <br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blas</tag>
      
      <tag>gemm</tag>
      
      <tag>gemv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Repeating the same optimizations</title>
    <link href="/2023/05/31/gemm0004/"/>
    <url>/2023/05/31/gemm0004/</url>
    
    <content type="html"><![CDATA[<h2 id="Repeating-the-same-optimizations"><a href="#Repeating-the-same-optimizations" class="headerlink" title="Repeating the same optimizations"></a>Repeating the same optimizations</h2><ul><li>我们在AddDot4x4子程序中一次计算4个C元素，该子程序一次执行16个乘积:</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_3">Optimization_4x4_3 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li>现在我们内联16个独立的内积，并将循环融合为一个，从而在一个循环中同时计算16个乘积:</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_4">Optimization_4x4_4 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_5">Optimization_4x4_5 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li></ul><p>在这一点上，我们再次开始看到一些性能改进:</p><p><img src="/2023/05/31/gemm0004/compare_MMult0_MMult-4x4-5.png" alt="img"></p><p><img src="/2023/05/31/gemm0004/compare_MMult-1x4-5_MMult-4x4-5.png" alt="img"></p><ul><li>我们将C的元素累加到寄存器中，并使用寄存器存储a的元素</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_6">Optimization_4x4_6 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li>我们使用指针来定位B中的元素</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_4x4_7">Optimization_4x4_7 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li></ul><h1 id="Optimization-4x4-3"><a href="#Optimization-4x4-3" class="headerlink" title="Optimization_4x4_3"></a>Optimization_4x4_3</h1><p>对循环变量i进行展开。由原来AddDot1x4变为AddDot4x4，一次计算16个乘积。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">double</span> * )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C */</span> <br><br>  <span class="hljs-comment">/* First row */</span><br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) );<br><br>  <span class="hljs-comment">/* Second row */</span><br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) );<br><br>  <span class="hljs-comment">/* Third row */</span><br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) );<br><br>  <span class="hljs-comment">/* Four row */</span><br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) );<br>&#125;<br><br><br><span class="hljs-comment">/* Create macro to let X( i ) equal the ith element of x */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X(i) x[ (i)*incx ]</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *x, <span class="hljs-keyword">int</span> incx,  <span class="hljs-keyword">double</span> *y, <span class="hljs-keyword">double</span> *gamma )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* compute gamma := x&#x27; * y + gamma with vectors x and y of length n.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Here x starts at location x with increment (stride) incx and y starts at location y and has (implicit) stride of 1.</span><br><span class="hljs-comment">  */</span><br> <br>  <span class="hljs-keyword">int</span> p;<br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    *gamma += <span class="hljs-built_in">X</span>( p ) * y[ p ];     <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Optimization-4x4-4"><a href="#Optimization-4x4-4" class="headerlink" title="Optimization_4x4_4"></a>Optimization_4x4_4</h1><p>把AddDot计算kernel合并到AddDot4x4里面。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">double</span> * )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     In this version, we &quot;inline&quot; AddDot */</span> <br><br>  <span class="hljs-keyword">int</span> p;<br><br>  <span class="hljs-comment">/* First row 第一行*/</span>   <br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 0 ), &amp;C( 0, 0 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 1 ), &amp;C( 0, 1 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 2 ), &amp;C( 0, 2 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 3 ), &amp;C( 0, 3 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br>  &#125;<br><br>  <span class="hljs-comment">/* Second row 第二行*/</span><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 1, 0 ), lda, &amp;B( 0, 0 ), &amp;C( 1, 0 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 1, 0 ), lda, &amp;B( 0, 1 ), &amp;C( 1, 1 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 1, 0 ), lda, &amp;B( 0, 2 ), &amp;C( 1, 2 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 1, 0 ), lda, &amp;B( 0, 3 ), &amp;C( 1, 3 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br>  &#125;<br><br>  <span class="hljs-comment">/* Third row 第三行*/</span><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 2, 0 ), lda, &amp;B( 0, 0 ), &amp;C( 2, 0 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 2, 0 ), lda, &amp;B( 0, 1 ), &amp;C( 2, 1 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 2, 0 ), lda, &amp;B( 0, 2 ), &amp;C( 2, 2 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 2, 0 ), lda, &amp;B( 0, 3 ), &amp;C( 2, 3 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br>  &#125;<br><br>  <span class="hljs-comment">/* Four row 第四行*/</span><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 3, 0 ), lda, &amp;B( 0, 0 ), &amp;C( 3, 0 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 3, 0 ), lda, &amp;B( 0, 1 ), &amp;C( 3, 1 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 3, 0 ), lda, &amp;B( 0, 2 ), &amp;C( 3, 2 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>  &#125;<br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 3, 0 ), lda, &amp;B( 0, 3 ), &amp;C( 3, 3 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Optimization-4x4-5"><a href="#Optimization-4x4-5" class="headerlink" title="Optimization_4x4_5"></a>Optimization_4x4_5</h1><p>合并16个for循环。</p><p>现在，当矩阵变大时，我们看到了性能上的好处，因为数据在被放入寄存器后会得到更多的重用。</p><p>以前是：1x4_5(一次计算C的4个元素)现在是：4x4_5(一次计算C的16个元素)。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">double</span> * )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     In this version, we merge each set of four loops, computing four</span><br><span class="hljs-comment">     inner products simultaneously. */</span><br><br>  <span class="hljs-keyword">int</span> p;<br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-comment">/* First row */</span><br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br><br>    <span class="hljs-comment">/* Second row */</span><br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br><br>    <span class="hljs-comment">/* Third row */</span><br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br><br>    <span class="hljs-comment">/* Fourth row */</span><br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Optimization-4x4-6"><a href="#Optimization-4x4-6" class="headerlink" title="Optimization_4x4_6"></a>Optimization_4x4_6</h1><p>矩阵C和A采用寄存器来存。</p><p>我们为C的4x4块和A的当前4x1列的元素使用(常规)寄存器，这一事实使性能受益。请注意，我们使用的是比实际存在的更多的常规寄存器，所以任何人都可以猜测编译器会用它做什么。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     In this version, we accumulate in registers and put A( 0, p ) in a register */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* hold contributions to</span><br><span class="hljs-comment">       C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ) </span><br><span class="hljs-comment">       C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ) </span><br><span class="hljs-comment">       C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ) </span><br><span class="hljs-comment">       C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 )   */</span><br>       c_00_reg,   c_01_reg,   c_02_reg,   c_03_reg,  <br>       c_10_reg,   c_11_reg,   c_12_reg,   c_13_reg,  <br>       c_20_reg,   c_21_reg,   c_22_reg,   c_23_reg,  <br>       c_30_reg,   c_31_reg,   c_32_reg,   c_33_reg,<br>    <span class="hljs-comment">/* hold </span><br><span class="hljs-comment">       A( 0, p ) </span><br><span class="hljs-comment">       A( 1, p ) </span><br><span class="hljs-comment">       A( 2, p ) </span><br><span class="hljs-comment">       A( 3, p ) */</span><br>       a_0p_reg,<br>       a_1p_reg,<br>       a_2p_reg,<br>       a_3p_reg;<br><br>  c_00_reg = <span class="hljs-number">0.0</span>;   c_01_reg = <span class="hljs-number">0.0</span>;   c_02_reg = <span class="hljs-number">0.0</span>;   c_03_reg = <span class="hljs-number">0.0</span>;<br>  c_10_reg = <span class="hljs-number">0.0</span>;   c_11_reg = <span class="hljs-number">0.0</span>;   c_12_reg = <span class="hljs-number">0.0</span>;   c_13_reg = <span class="hljs-number">0.0</span>;<br>  c_20_reg = <span class="hljs-number">0.0</span>;   c_21_reg = <span class="hljs-number">0.0</span>;   c_22_reg = <span class="hljs-number">0.0</span>;   c_23_reg = <span class="hljs-number">0.0</span>;<br>  c_30_reg = <span class="hljs-number">0.0</span>;   c_31_reg = <span class="hljs-number">0.0</span>;   c_32_reg = <span class="hljs-number">0.0</span>;   c_33_reg = <span class="hljs-number">0.0</span>;<br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p );<br>    a_1p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p );<br>    a_2p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p );<br>    a_3p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p );<br><br>    <span class="hljs-comment">/* First row */</span><br>    c_00_reg += a_0p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>    c_01_reg += a_0p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>    c_02_reg += a_0p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>    c_03_reg += a_0p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br><br>    <span class="hljs-comment">/* Second row */</span><br>    c_10_reg += a_1p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>    c_11_reg += a_1p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>    c_12_reg += a_1p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>    c_13_reg += a_1p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br><br>    <span class="hljs-comment">/* Third row */</span><br>    c_20_reg += a_2p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>    c_21_reg += a_2p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>    c_22_reg += a_2p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>    c_23_reg += a_2p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br><br>    <span class="hljs-comment">/* Four row */</span><br>    c_30_reg += a_3p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>    c_31_reg += a_3p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>    c_32_reg += a_3p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>    c_33_reg += a_3p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += c_10_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += c_11_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += c_12_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += c_13_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += c_20_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += c_21_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += c_22_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += c_23_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += c_30_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += c_31_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += c_32_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += c_33_reg;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="Optimization-4x4-7"><a href="#Optimization-4x4-7" class="headerlink" title="Optimization_4x4_7"></a>Optimization_4x4_7</h1><p>这里我们改为使用指针来跟踪B的当前4x1块。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot4x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot4x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes a 4x4 block of matrix A</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment">           C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ).  </span><br><span class="hljs-comment">           C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ).  </span><br><span class="hljs-comment">           C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i  , j ), C( i  , j+1 ), C( i  , j+2 ), C( i  , j+3 ) </span><br><span class="hljs-comment">           C( i+1, j ), C( i+1, j+1 ), C( i+1, j+2 ), C( i+1, j+3 ) </span><br><span class="hljs-comment">           C( i+2, j ), C( i+2, j+1 ), C( i+2, j+2 ), C( i+2, j+3 ) </span><br><span class="hljs-comment">           C( i+3, j ), C( i+3, j+1 ), C( i+3, j+2 ), C( i+3, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     In this version, we use pointer to track where in four columns of B we are */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* hold contributions to</span><br><span class="hljs-comment">       C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ) </span><br><span class="hljs-comment">       C( 1, 0 ), C( 1, 1 ), C( 1, 2 ), C( 1, 3 ) </span><br><span class="hljs-comment">       C( 2, 0 ), C( 2, 1 ), C( 2, 2 ), C( 2, 3 ) </span><br><span class="hljs-comment">       C( 3, 0 ), C( 3, 1 ), C( 3, 2 ), C( 3, 3 )   */</span><br>       c_00_reg,   c_01_reg,   c_02_reg,   c_03_reg,  <br>       c_10_reg,   c_11_reg,   c_12_reg,   c_13_reg,  <br>       c_20_reg,   c_21_reg,   c_22_reg,   c_23_reg,  <br>       c_30_reg,   c_31_reg,   c_32_reg,   c_33_reg,<br>    <span class="hljs-comment">/* hold </span><br><span class="hljs-comment">       A( 0, p ) </span><br><span class="hljs-comment">       A( 1, p ) </span><br><span class="hljs-comment">       A( 2, p ) </span><br><span class="hljs-comment">       A( 3, p ) */</span><br>       a_0p_reg,<br>       a_1p_reg,<br>       a_2p_reg,<br>       a_3p_reg;<br>  <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* Point to the current elements in the four columns of B */</span><br>    *b_p0_pntr, *b_p1_pntr, *b_p2_pntr, *b_p3_pntr; <br><br>  c_00_reg = <span class="hljs-number">0.0</span>;   c_01_reg = <span class="hljs-number">0.0</span>;   c_02_reg = <span class="hljs-number">0.0</span>;   c_03_reg = <span class="hljs-number">0.0</span>;<br>  c_10_reg = <span class="hljs-number">0.0</span>;   c_11_reg = <span class="hljs-number">0.0</span>;   c_12_reg = <span class="hljs-number">0.0</span>;   c_13_reg = <span class="hljs-number">0.0</span>;<br>  c_20_reg = <span class="hljs-number">0.0</span>;   c_21_reg = <span class="hljs-number">0.0</span>;   c_22_reg = <span class="hljs-number">0.0</span>;   c_23_reg = <span class="hljs-number">0.0</span>;<br>  c_30_reg = <span class="hljs-number">0.0</span>;   c_31_reg = <span class="hljs-number">0.0</span>;   c_32_reg = <span class="hljs-number">0.0</span>;   c_33_reg = <span class="hljs-number">0.0</span>;<br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p );<br>    a_1p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p );<br>    a_2p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">2</span>, p );<br>    a_3p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">3</span>, p );<br>  <br>    b_p0_pntr = &amp;<span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );<br>    b_p1_pntr = &amp;<span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );<br>    b_p2_pntr = &amp;<span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );<br>    b_p3_pntr = &amp;<span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );  <br><br>    <span class="hljs-comment">/* First row */</span><br>    c_00_reg += a_0p_reg * *b_p0_pntr;     <br>    c_01_reg += a_0p_reg * *b_p1_pntr;     <br>    c_02_reg += a_0p_reg * *b_p2_pntr;     <br>    c_03_reg += a_0p_reg * *b_p3_pntr;     <br><br>    <span class="hljs-comment">/* Second row */</span><br>    c_10_reg += a_1p_reg * *b_p0_pntr;     <br>    c_11_reg += a_1p_reg * *b_p1_pntr;     <br>    c_12_reg += a_1p_reg * *b_p2_pntr;     <br>    c_13_reg += a_1p_reg * *b_p3_pntr;     <br><br>    <span class="hljs-comment">/* Third row */</span><br>    c_20_reg += a_2p_reg * *b_p0_pntr;     <br>    c_21_reg += a_2p_reg * *b_p1_pntr;     <br>    c_22_reg += a_2p_reg * *b_p2_pntr;     <br>    c_23_reg += a_2p_reg * *b_p3_pntr;     <br><br>    <span class="hljs-comment">/* Four row */</span><br>    c_30_reg += a_3p_reg * *b_p0_pntr++;     <br>    c_31_reg += a_3p_reg * *b_p1_pntr++;     <br>    c_32_reg += a_3p_reg * *b_p2_pntr++;     <br>    c_33_reg += a_3p_reg * *b_p3_pntr++;     <br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ) += c_10_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ) += c_11_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ) += c_12_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">1</span>, <span class="hljs-number">3</span> ) += c_13_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">0</span> ) += c_20_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ) += c_21_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ) += c_22_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ) += c_23_reg;<br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">0</span> ) += c_30_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ) += c_31_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ) += c_32_reg;   <span class="hljs-built_in">C</span>( <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ) += c_33_reg;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blas</tag>
      
      <tag>gemm</tag>
      
      <tag>gemv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Further optimizing</title>
    <link href="/2023/05/26/gemm0003/"/>
    <url>/2023/05/26/gemm0003/</url>
    
    <content type="html"><![CDATA[<h2 id="Further-optimizing"><a href="#Further-optimizing" class="headerlink" title="Further optimizing"></a>Further optimizing</h2><ul><li>我们将C的元素累加到寄存器中，并使用寄存器存储a的元素</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_1x4_6">Optimization_1x4_6 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li>我们使用指针来定位B中的元素</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_1x4_7">Optimization_1x4_7 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li>我们将循环展开4次(展开因子的选择相对任意)</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_1x4_8">Optimization_1x4_8 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li>我们使用间接寻址来减少需要更新指针的次数</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_1x4_9">Optimization_1x4_9 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li></ul><p>对于问题大小适合L2缓存(至少部分地)有相当大的改进。不过，还有很大的改进空间。</p><p><img src="/2023/05/26/gemm0003/compare_MMult0_MMult-1x4-9.png" alt="img"></p><h2 id="Optimization-1x4-6"><a href="#Optimization-1x4-6" class="headerlink" title="Optimization_1x4_6"></a>Optimization_1x4_6</h2><p>我们在寄存器中对当前1x4行C的更新累积，并将元素A(p, 0)放在寄存器中，以减少缓存(cache)和寄存器(reg)之间的流量(traffic)。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>,  <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">1</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot1x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes four elements of C: </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i, j ), C( i, j+1 ), C( i, j+2 ), C( i, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     In this version, we accumulate in registers and put A( 0, p ) in a register */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>    <br>    <br>  <span class="hljs-comment">//C的累加在寄存器中，同时A也放在寄存器中</span><br>  <span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* hold contributions to</span><br><span class="hljs-comment">       C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ) */</span><br>       c_00_reg,   c_01_reg,   c_02_reg,   c_03_reg,  <br>    <span class="hljs-comment">/* holds A( 0, p ) */</span><br>       a_0p_reg;<br>    <br>  c_00_reg = <span class="hljs-number">0.0</span>; <br>  c_01_reg = <span class="hljs-number">0.0</span>; <br>  c_02_reg = <span class="hljs-number">0.0</span>; <br>  c_03_reg = <span class="hljs-number">0.0</span>;<br> <br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p );<br><br>    c_00_reg += a_0p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>    c_01_reg += a_0p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>    c_02_reg += a_0p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>    c_03_reg += a_0p_reg * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br>  &#125;<br>  <span class="hljs-comment">//计算完成后，再通过寄存器写回C</span><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_reg;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization-1x4-7"><a href="#Optimization-1x4-7" class="headerlink" title="Optimization_1x4_7"></a>Optimization_1x4_7</h2><p>现在使用bp0_pntr、bp1_pntr、bp2_pntr和bp3_pntr四个指针来访问元素B(p, 0)、B(p, 1)、B(p, 2)、B(p, 3)。这减少了索引开销。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>,  <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">1</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot1x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes four elements of C: </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i, j ), C( i, j+1 ), C( i, j+2 ), C( i, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     In this version, we use pointer to track where in four columns of B we are */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* hold contributions to</span><br><span class="hljs-comment">       C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ) */</span><br>       c_00_reg,   c_01_reg,   c_02_reg,   c_03_reg,  <br>    <span class="hljs-comment">/* holds A( 0, p ) */</span><br>       a_0p_reg;<br>  <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* Point to the current elements in the four columns of B */</span><br>    *bp0_pntr, *bp1_pntr, *bp2_pntr, *bp3_pntr; <br>  <span class="hljs-comment">//由于使用了宏定义，每次B(i,j)都会计算B中元素的位置</span><br>  <span class="hljs-comment">//使用指针后，后续访问不需要再额外计算B中元素位置，只需在当前指针向后移动一位即可</span><br>  bp0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<br>  bp1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> );<br>  bp2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );<br>  bp3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  c_00_reg = <span class="hljs-number">0.0</span>; <br>  c_01_reg = <span class="hljs-number">0.0</span>; <br>  c_02_reg = <span class="hljs-number">0.0</span>; <br>  c_03_reg = <span class="hljs-number">0.0</span>;<br> <br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p );<br><br>    c_00_reg += a_0p_reg * *bp0_pntr++;<br>    c_01_reg += a_0p_reg * *bp1_pntr++;<br>    c_02_reg += a_0p_reg * *bp2_pntr++;<br>    c_03_reg += a_0p_reg * *bp3_pntr++;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_reg;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization-1x4-8"><a href="#Optimization-1x4-8" class="headerlink" title="Optimization_1x4_8"></a>Optimization_1x4_8</h2><p>我们现在展开了4个循环。有趣的是，这会略微降低性能。这可能意味着，通过添加优化，我们混淆了编译器，因此它不能做以前做的优化。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>,  <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">1</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot1x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes four elements of C: </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i, j ), C( i, j+1 ), C( i, j+2 ), C( i, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     We now unroll the loop */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* hold contributions to</span><br><span class="hljs-comment">       C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ) */</span><br>       c_00_reg,   c_01_reg,   c_02_reg,   c_03_reg,  <br>    <span class="hljs-comment">/* holds A( 0, p ) */</span><br>       a_0p_reg;<br>  <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* Point to the current elements in the four columns of B */</span><br>    *bp0_pntr, *bp1_pntr, *bp2_pntr, *bp3_pntr; <br>    <br>  bp0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<br>  bp1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> );<br>  bp2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );<br>  bp3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  c_00_reg = <span class="hljs-number">0.0</span>; <br>  c_01_reg = <span class="hljs-number">0.0</span>; <br>  c_02_reg = <span class="hljs-number">0.0</span>; <br>  c_03_reg = <span class="hljs-number">0.0</span>;<br>  <span class="hljs-comment">//这里对循环变量p进行了展开，注意这里计算是顺序的</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p+=<span class="hljs-number">4</span> )&#123;<br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p );<br><br>    c_00_reg += a_0p_reg * *bp0_pntr++;<br>    c_01_reg += a_0p_reg * *bp1_pntr++;<br>    c_02_reg += a_0p_reg * *bp2_pntr++;<br>    c_03_reg += a_0p_reg * *bp3_pntr++;<br><br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p+<span class="hljs-number">1</span> );<br><br>    c_00_reg += a_0p_reg * *bp0_pntr++;<br>    c_01_reg += a_0p_reg * *bp1_pntr++;<br>    c_02_reg += a_0p_reg * *bp2_pntr++;<br>    c_03_reg += a_0p_reg * *bp3_pntr++;<br><br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p+<span class="hljs-number">2</span> );<br><br>    c_00_reg += a_0p_reg * *bp0_pntr++;<br>    c_01_reg += a_0p_reg * *bp1_pntr++;<br>    c_02_reg += a_0p_reg * *bp2_pntr++;<br>    c_03_reg += a_0p_reg * *bp3_pntr++;<br><br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p+<span class="hljs-number">3</span> );<br><br>    c_00_reg += a_0p_reg * *bp0_pntr++;<br>    c_01_reg += a_0p_reg * *bp1_pntr++;<br>    c_02_reg += a_0p_reg * *bp2_pntr++;<br>    c_03_reg += a_0p_reg * *bp3_pntr++;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_reg;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization-1x4-9"><a href="#Optimization-1x4-9" class="headerlink" title="Optimization_1x4_9"></a>Optimization_1x4_9</h2><p>在这里，*a0p_reg保存元素A(0, p+1)。</p><ul><li><p>我们希望bp0_pntr指向元素B（p，0）。因此，bp0_pntr+1寻址元素B（p+1，0）。有一条特殊的机器指令可以访问bp0_pntr+1处的元素，该指令不需要更新指针。</p></li><li><p>因此，指向B列中元素的指针只需要在循环的第四次迭代中更新一次。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>,  <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">1</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot1x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes four elements of C: </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i, j ), C( i, j+1 ), C( i, j+2 ), C( i, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     We next use indirect addressing */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* hold contributions to</span><br><span class="hljs-comment">       C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ) */</span><br>       c_00_reg,   c_01_reg,   c_02_reg,   c_03_reg,  <br>    <span class="hljs-comment">/* holds A( 0, p ) */</span><br>       a_0p_reg;<br>  <span class="hljs-keyword">double</span> <br>    <span class="hljs-comment">/* Point to the current elements in the four columns of B */</span><br>    *bp0_pntr, *bp1_pntr, *bp2_pntr, *bp3_pntr; <br>    <br>  bp0_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );<br>  bp1_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> );<br>  bp2_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> );<br>  bp3_pntr = &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> );<br><br>  c_00_reg = <span class="hljs-number">0.0</span>; <br>  c_01_reg = <span class="hljs-number">0.0</span>; <br>  c_02_reg = <span class="hljs-number">0.0</span>; <br>  c_03_reg = <span class="hljs-number">0.0</span>;<br> <br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p+=<span class="hljs-number">4</span> )&#123;<br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p );<br><br>    c_00_reg += a_0p_reg * *bp0_pntr;<br>    c_01_reg += a_0p_reg * *bp1_pntr;<br>    c_02_reg += a_0p_reg * *bp2_pntr;<br>    c_03_reg += a_0p_reg * *bp3_pntr;<br><br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p+<span class="hljs-number">1</span> );<br><br>    <span class="hljs-comment">//现在我们使用间接寻址，&#x27;indirect addressing&#x27;</span><br>    c_00_reg += a_0p_reg * *(bp0_pntr+<span class="hljs-number">1</span>);<br>    c_01_reg += a_0p_reg * *(bp1_pntr+<span class="hljs-number">1</span>);<br>    c_02_reg += a_0p_reg * *(bp2_pntr+<span class="hljs-number">1</span>);<br>    c_03_reg += a_0p_reg * *(bp3_pntr+<span class="hljs-number">1</span>);<br><br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p+<span class="hljs-number">2</span> );<br><br>    c_00_reg += a_0p_reg * *(bp0_pntr+<span class="hljs-number">2</span>);<br>    c_01_reg += a_0p_reg * *(bp1_pntr+<span class="hljs-number">2</span>);<br>    c_02_reg += a_0p_reg * *(bp2_pntr+<span class="hljs-number">2</span>);<br>    c_03_reg += a_0p_reg * *(bp3_pntr+<span class="hljs-number">2</span>);<br><br>    a_0p_reg = <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p+<span class="hljs-number">3</span> );<br><br>    c_00_reg += a_0p_reg * *(bp0_pntr+<span class="hljs-number">3</span>);<br>    c_01_reg += a_0p_reg * *(bp1_pntr+<span class="hljs-number">3</span>);<br>    c_02_reg += a_0p_reg * *(bp2_pntr+<span class="hljs-number">3</span>);<br>    c_03_reg += a_0p_reg * *(bp3_pntr+<span class="hljs-number">3</span>);<br><br>      <br>    <span class="hljs-comment">//更新指针，4次迭代中仅更新一次</span><br>    bp0_pntr+=<span class="hljs-number">4</span>;<br>    bp1_pntr+=<span class="hljs-number">4</span>;<br>    bp2_pntr+=<span class="hljs-number">4</span>;<br>    bp3_pntr+=<span class="hljs-number">4</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += c_00_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += c_01_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += c_02_reg; <br>  <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += c_03_reg;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blas</tag>
      
      <tag>gemm</tag>
      
      <tag>gemv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computing four elements at a time</title>
    <link href="/2023/05/26/gemm0002/"/>
    <url>/2023/05/26/gemm0002/</url>
    
    <content type="html"><![CDATA[<h2 id="Computing-four-elements-at-a-time"><a href="#Computing-four-elements-at-a-time" class="headerlink" title="Computing four elements at a time"></a>Computing four elements at a time</h2><ul><li>我们在子程序AddDot1x4中一次计算4个元素，该子程序一次执行4个内部乘积</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_1x4_3">Optimization_1x4_3 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li>现在我们内联(inline)四个独立的内积，并将循环融合为一个，从而在一个循环中同时计算四个内积:</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_1x4_4">Optimization_1x4_4 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization_1x4_5">Optimization_1x4_5 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li></ul><p>在这一点上，我们开始看到一些性能改进:</p><p><img src="/2023/05/26/gemm0002/compare_MMult0_MMult-1x4-5.png" alt="img"></p><h2 id="Optimization-1x4-3"><a href="#Optimization-1x4-3" class="headerlink" title="Optimization_1x4_3"></a>Optimization_1x4_3</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">double</span> * )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>,  <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">1</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br>  <span class="hljs-comment">//相交于上个版本，把4个AddDot合并成了一个AddDot1x4</span><br>      <span class="hljs-built_in">AddDot1x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes four elements of C: </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i, j ), C( i, j+1 ), C( i, j+2 ), C( i, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C */</span> <br>  <span class="hljs-comment">//一次AddDot1x4完成四次AddDot运算</span><br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) );<br>  <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ), &amp;<span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) );<br>&#125;<br><br><br><span class="hljs-comment">/* Create macro to let X( i ) equal the ith element of x */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X(i) x[ (i)*incx ]</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *x, <span class="hljs-keyword">int</span> incx,  <span class="hljs-keyword">double</span> *y, <span class="hljs-keyword">double</span> *gamma )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* compute gamma := x&#x27; * y + gamma with vectors x and y of length n.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Here x starts at location x with increment (stride) incx and y starts at location y and has (implicit) stride of 1.</span><br><span class="hljs-comment">  */</span><br> <br>  <span class="hljs-keyword">int</span> p;<br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    *gamma += <span class="hljs-built_in">X</span>( p ) * y[ p ];     <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization-1x4-4"><a href="#Optimization-1x4-4" class="headerlink" title="Optimization_1x4_4"></a>Optimization_1x4_4</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>,  <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">1</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot1x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes four elements of C: </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i, j ), C( i, j+1 ), C( i, j+2 ), C( i, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     In this version, we &quot;inline&quot; AddDot */</span> <br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-comment">//在这里我们把AddDot中的运算，全部集成到了AddDot1x4中，即4段for执行4个内部乘积</span><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 0 ), &amp;C( 0, 0 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <br>  &#125;<br><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 1 ), &amp;C( 0, 1 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>  &#125;<br><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 2 ), &amp;C( 0, 2 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>  &#125;<br><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 3 ), &amp;C( 0, 3 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization-1x4-5"><a href="#Optimization-1x4-5" class="headerlink" title="Optimization_1x4_5"></a>Optimization_1x4_5</h2><p>在这个版本，我们开始看到性能上的好处。原因是四个循环已经融合，因此四个内部乘积运算现在正在同时进行。这有以下好处:</p><ul><li>索引p只需要每8次浮点操作更新一次(4次乘法4次加法)。</li><li>元素A(0, p)只需要从内存中取出一次，而不是四次。(只有当矩阵不再适合二级缓存时，这才有好处)</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>,  <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span> )</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">1</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update C( i,j ), C( i,j+1 ), C( i,j+2 ), and C( i,j+3 ) in</span><br><span class="hljs-comment"> one routine (four inner products) */</span><br><br>      <span class="hljs-built_in">AddDot1x4</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), ldb, &amp;<span class="hljs-built_in">C</span>( i,j ), ldc );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot1x4</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda,  <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* So, this routine computes four elements of C: </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( 0, 0 ), C( 0, 1 ), C( 0, 2 ), C( 0, 3 ).  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Notice that this routine is called with c = C( i, j ) in the</span><br><span class="hljs-comment">     previous routine, so these are actually the elements </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">           C( i, j ), C( i, j+1 ), C( i, j+2 ), C( i, j+3 ) </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">     in the original matrix C.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     In this version, we merge the four loops, computing four inner</span><br><span class="hljs-comment">     products simultaneously. */</span><br><br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-comment">//在这个版本中，我们合并了4个for循环，使得可以同时计算4个乘积运算</span><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 0 ), &amp;C( 0, 0 ) );</span><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 1 ), &amp;C( 0, 1 ) );</span><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 2 ), &amp;C( 0, 2 ) );</span><br>  <span class="hljs-comment">//  AddDot( k, &amp;A( 0, 0 ), lda, &amp;B( 0, 3 ), &amp;C( 0, 3 ) );</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span> );     <span class="hljs-comment">//第一次取A( 0, p )</span><br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">2</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">2</span> );     <br>    <span class="hljs-built_in">C</span>( <span class="hljs-number">0</span>, <span class="hljs-number">3</span> ) += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p ) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">3</span> );     <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blas</tag>
      
      <tag>gemm</tag>
      
      <tag>gemv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hiding computation in a subroutine</title>
    <link href="/2023/05/26/gemm0001/"/>
    <url>/2023/05/26/gemm0001/</url>
    
    <content type="html"><![CDATA[<h2 id="Hiding-computation-in-a-subroutine"><a href="#Hiding-computation-in-a-subroutine" class="headerlink" title="Hiding computation in a subroutine"></a>Hiding computation in a subroutine</h2><ul><li>我们首先重写基本实现，将内部循环隐藏在子程序AddDot中:</li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization1">Optimization1 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li><li><a href="https://github.com/flame/how-to-optimize-gemm/wiki/Optimization2">Optimization2 · flame&#x2F;how-to-optimize-gemm Wiki (github.com)</a></li></ul><p>这一步不会产生任何性能提升：</p><p><img src="https://github.com/flame/how-to-optimize-gemm/raw/master/figures/compare_MMult0_MMult2.png" alt="img"></p><p>它其实是为我们下一步做好准备。</p><h2 id="Optimization1"><a href="#Optimization1" class="headerlink" title="Optimization1"></a>Optimization1</h2><p>这里最原始的矩阵乘代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-comment">//创建宏，使矩阵是列主序</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j, p;<br>  <span class="hljs-comment">//loop i j p</span><br>  <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i++ )&#123;        <span class="hljs-comment">/* Loop over the rows of C 遍历C的行 */</span>   <br>    <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j++ )&#123;        <span class="hljs-comment">/* Loop over the columns of C 遍历C的列 */</span><br>      <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;        <span class="hljs-comment">/* Update C( i,j ) with the inner</span><br><span class="hljs-comment">       product of the ith row of A and</span><br><span class="hljs-comment">       the jth column of B */</span><br>    <span class="hljs-comment">//A的一行B的一列更新C(i,j)</span><br><span class="hljs-built_in">C</span>( i,j ) = <span class="hljs-built_in">C</span>( i,j ) +  <span class="hljs-built_in">A</span>( i,p ) * <span class="hljs-built_in">B</span>( p,j );<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>拆分内部循环，把乘加运算放在子程序AddDot中:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">double</span> * )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br><br>   <span class="hljs-comment">//loop j i p   在这里更改了循环变量的顺序</span><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">1</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">1</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update the C( i,j ) with the inner product of the ith row of A</span><br><span class="hljs-comment"> and the jth column of B */</span><br>  <span class="hljs-comment">//拆分内部循环(循环变量p)，把乘加运算放在子程序AddDot中:</span><br>      <span class="hljs-comment">//A的第i行，B的第j列</span><br>      <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), &amp;<span class="hljs-built_in">C</span>( i,j ) );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">/* Create macro to let X( i ) equal the ith element of x */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X(i) x[ (i)*incx ]</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *x, <span class="hljs-keyword">int</span> incx,  <span class="hljs-keyword">double</span> *y, <span class="hljs-keyword">double</span> *gamma )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* compute gamma := x&#x27; * y + gamma with vectors x and y of length n.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Here x starts at location x with increment (stride) incx and y starts at location y and has (implicit) stride of 1.</span><br><span class="hljs-comment">  */</span><br> <br>  <span class="hljs-keyword">int</span> p;<br>  <span class="hljs-comment">//列主序，同行访问带跨步，同列访问无需跨步。跨步大小lda</span><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    *gamma += <span class="hljs-built_in">X</span>( p ) * y[ p ];     <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Optimization2"><a href="#Optimization2" class="headerlink" title="Optimization2"></a>Optimization2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* Create macros so that the matrices are stored in column-major order */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> A(i,j) a[ (j)*lda + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> B(i,j) b[ (j)*ldb + (i) ]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C(i,j) c[ (j)*ldc + (i) ]</span><br><br><span class="hljs-comment">/* Routine for computing C = A * B + C */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot</span><span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">double</span> * )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_MMult</span><span class="hljs-params">( <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *a, <span class="hljs-keyword">int</span> lda, </span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *b, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">double</span> *c, <span class="hljs-keyword">int</span> ldc )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br>  <span class="hljs-comment">//在这里对C的列进行了循环展开，展开数为4。列主序</span><br>  <span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>; j&lt;n; j+=<span class="hljs-number">4</span> )&#123;        <span class="hljs-comment">/* Loop over the columns of C, unrolled by 4 */</span><br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;m; i+=<span class="hljs-number">1</span> )&#123;        <span class="hljs-comment">/* Loop over the rows of C */</span><br>      <span class="hljs-comment">/* Update the C( i,j ) with the inner product of the ith row of A</span><br><span class="hljs-comment"> and the jth column of B */</span><br><br>      <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j ), &amp;<span class="hljs-built_in">C</span>( i,j ) );<br><br>      <span class="hljs-comment">/* Update the C( i,j+1 ) with the inner product of the ith row of A</span><br><span class="hljs-comment"> and the (j+1)th column of B */</span><br><br>      <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j+<span class="hljs-number">1</span> ), &amp;<span class="hljs-built_in">C</span>( i,j+<span class="hljs-number">1</span> ) );<br><br>      <span class="hljs-comment">/* Update the C( i,j+2 ) with the inner product of the ith row of A</span><br><span class="hljs-comment"> and the (j+2)th column of B */</span><br><br>      <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j+<span class="hljs-number">2</span> ), &amp;<span class="hljs-built_in">C</span>( i,j+<span class="hljs-number">2</span> ) );<br><br>      <span class="hljs-comment">/* Update the C( i,j+3 ) with the inner product of the ith row of A</span><br><span class="hljs-comment"> and the (j+1)th column of B */</span><br><br>      <span class="hljs-built_in">AddDot</span>( k, &amp;<span class="hljs-built_in">A</span>( i,<span class="hljs-number">0</span> ), lda, &amp;<span class="hljs-built_in">B</span>( <span class="hljs-number">0</span>,j+<span class="hljs-number">3</span> ), &amp;<span class="hljs-built_in">C</span>( i,j+<span class="hljs-number">3</span> ) );<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">/* Create macro to let X( i ) equal the ith element of x */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X(i) x[ (i)*incx ]</span><br><br><span class="hljs-comment">//内层核心相较于上次来说，并没有修改</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDot</span><span class="hljs-params">( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *x, <span class="hljs-keyword">int</span> incx,  <span class="hljs-keyword">double</span> *y, <span class="hljs-keyword">double</span> *gamma )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* compute gamma := x&#x27; * y + gamma with vectors x and y of length n.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     Here x starts at location x with increment (stride) incx and y starts at location y and has (implicit) stride of 1.</span><br><span class="hljs-comment">  */</span><br> <br>  <span class="hljs-keyword">int</span> p;<br><br>  <span class="hljs-keyword">for</span> ( p=<span class="hljs-number">0</span>; p&lt;k; p++ )&#123;<br>    *gamma += <span class="hljs-built_in">X</span>( p ) * y[ p ];     <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blas</tag>
      
      <tag>gemm</tag>
      
      <tag>gemv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLAS（Basic Linear Algebra Subprograms）-基础线性代数子程序库</title>
    <link href="/2023/05/22/blas/"/>
    <url>/2023/05/22/blas/</url>
    
    <content type="html"><![CDATA[<h2 id="how-to-optimize-gemm"><a href="#how-to-optimize-gemm" class="headerlink" title="how-to-optimize-gemm"></a>how-to-optimize-gemm</h2><p><strong>项目地址：</strong><a href="https://github.com/flame/how-to-optimize-gemm">flame&#x2F;how-to-optimize-gemm (github.com)</a></p><h3 id="Computing-four-elements-of-C-at-a-time"><a href="#Computing-four-elements-of-C-at-a-time" class="headerlink" title="Computing four elements of C at a time"></a>Computing four elements of C at a time</h3><p><a href="https://xingyuanjie.top/2023/05/26/gemm0001/">Hiding computation in a subroutine - Amicoyuan (xingyuanjie.top)</a></p><p><a href="https://xingyuanjie.top/2023/05/26/gemm0002/">Computing four elements at a time - Amicoyuan (xingyuanjie.top)</a></p><p><a href="https://xingyuanjie.top/2023/05/26/gemm0003/">Further optimizing - Amicoyuan (xingyuanjie.top)</a></p><h3 id="Computing-a-4-x-4-block-of-C-at-a-time"><a href="#Computing-a-4-x-4-block-of-C-at-a-time" class="headerlink" title="Computing a 4 x 4 block of C at a time"></a>Computing a 4 x 4 block of C at a time</h3><p>为了有效地使用向量指令和向量寄存器，我们现在一次计算一个4 x 4的C代码块。其思想如下:作为SSE3指令集的一部分，有一些特殊的指令允许每个时钟周期执行两次“乘法累加”操作(两次乘法和两次加法)，每个时钟周期总共执行四个浮点操作。要使用这些，必须将数据放入“向量寄存器”中。有16个这样的向量寄存器，每个向量寄存器可以容纳两个双精度数。因此，我们可以在寄存器中保存32个双精度数。我们将使用其中的16个来保存C的元素，一个4 x 4的块。</p><p><a href="https://xingyuanjie.top/2023/05/31/gemm0004/">Repeating the same optimizations - Amicoyuan (xingyuanjie.top)</a></p><p><a href="https://xingyuanjie.top/2023/06/07/gemm0005/">Further optimizing - Amicoyuan (xingyuanjie.top)</a></p><p><a href="https://xingyuanjie.top/2023/06/07/gemm0006/">Blocking to maintain performance - Amicoyuan (xingyuanjie.top)</a></p><p><a href="https://xingyuanjie.top/2023/06/07/gemm0007/">Packing into contiguous memory - Amicoyuan (xingyuanjie.top)</a></p><h3 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h3><p>This material was partially sponsored by grants from the National Science Foundation (Awards ACI-1148125&#x2F;1340293).</p><p><em>Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation (NSF).</em></p><h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h2><p><a href="https://xingyuanjie.top/2023/06/09/gemm0008/">论文阅读：面向国产申威 26010 众核处理器的 SpMV 实现与优化 - Amicoyuan (xingyuanjie.top)</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="博客"><a href="#博客" class="headerlink" title="博客:"></a>博客:</h3><p><a href="https://www.jianshu.com/p/e01024892afb">矩阵相乘在GPU上的终极优化：深度解析Maxas汇编器工作原理 - 简书 (jianshu.com)</a></p><p><a href="https://www.leiphone.com/category/yanxishe/Puevv3ZWxn0heoEv.html">OpenBLAS项目与矩阵乘法优化 | AI 研习社 | 雷峰网 (leiphone.com)</a></p><p><a href="https://jcf94.com/2021/08/28/2021-08-28-simd/">矩阵乘法与 SIMD | Chenfan Blog (jcf94.com)</a></p><p><a href="https://zhenhuaw.me/blog/2019/gemm-optimization.html">通用矩阵乘（GEMM）优化算法 | 黎明灰烬 博客 (zhenhuaw.me)</a></p><p><a href="https://zhuanlan.zhihu.com/p/383115932">大佬是怎么优雅实现矩阵乘法的？ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/65436463">OpenBLAS gemm从零入门 - 知乎 (zhihu.com)</a></p><p><a href="https://harleyszhang.github.io/cv_note/">Introduction · cv算法工程师成长之路 (harleyszhang.github.io)</a></p><p><a href="https://zhuanlan.zhihu.com/p/435908830">深入浅出GPU优化系列：GEMM优化（一） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/410278370">CUDA 矩阵乘法终极优化指南 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/368870275">矩阵乘法的并行优化（1）：OPENMP、CUDA实现 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/617296073">并行计算入门 UIUC ECE408 Lecture 7&amp;8 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/143328317">移动端arm cpu优化学习笔记第4弹–内联汇编入门 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/348372132">C语言的内嵌汇编 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/105616727">内嵌汇编学习 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/unbutun/article/details/6123472">(88条消息) #define barrier() <strong>asm</strong> <strong>volatile</strong>(“”: : :”memory”) 中的memory是gcc的东西_unbutun的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_38669561/article/details/105192200?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control">(88条消息) MIPS指令集：内嵌汇编asm语法介绍_daddu指令_无色云的博客-CSDN博客</a></p><h3 id="论文："><a href="#论文：" class="headerlink" title="论文："></a>论文：</h3><p><a href="https://www.cs.utexas.edu/users/flame/FLAMEPublications.html">Publications Related to the FLAME Project (utexas.edu)</a></p><p><a href="https://dl.acm.org/doi/10.1145/1356052.1356053">Anatomy of high-performance matrix multiplication | ACM Transactions on Mathematical Software</a></p><p><a href="https://dl.acm.org/doi/10.1145/3018743.3018755">Understanding the GPU Microarchitecture to Achieve Bare-Metal Performance Tuning | Proceedings of the 22nd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</a></p><p>[<a href="https://arxiv.org/abs/1804.06826">1804.06826] Dissecting the NVIDIA Volta GPU Architecture via Microbenchmarking (arxiv.org)</a></p><p><a href="https://ieeexplore.ieee.org/document/6114452">Fast implementation of DGEMM on Fermi GPU | IEEE Conference Publication | IEEE Xplore</a></p><p><a href="https://dl.acm.org/doi/abs/10.1145/3369583.3393611">High Performance is All about Minimizing Data Movement | Proceedings of the 29th International Symposium on High-Performance Parallel and Distributed Computing (acm.org)</a></p><h3 id="社区-x2F-论坛"><a href="#社区-x2F-论坛" class="headerlink" title="社区&#x2F;论坛:"></a>社区&#x2F;论坛:</h3><p><a href="http://tvm.d2l.ai/chapter_gpu_schedules/vector_add.html#cuda-programming">2. Vector Add — Dive into Deep Learning Compiler 0.1 documentation (d2l.ai)</a></p><p><a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">Intel® Intrinsics Guide</a></p><p><a href="https://github.com/pytorch/QNNPACK">https://github.com/pytorch/QNNPACK</a></p><p><a href="https://github.com/flame/blis">https://github.com/flame/blis</a></p><p><a href="https://www.mathematik.uni-ulm.de/~lehn/apfel/ulmBLAS/">ulmBLAS (index) (uni-ulm.de)</a></p><p><a href="https://www.mathematik.uni-ulm.de/~lehn/apfel/sghpc/gemm/index.html">work&#x2F;sghpc (index) (uni-ulm.de)</a></p><p><a href="https://shpc.oden.utexas.edu/">The Science of High-Performance Computing Group (utexas.edu)</a></p><p><a href="https://github.com/BBuf/how-to-optimize-gemm">GitHub - BBuf&#x2F;how-to-optimize-gemm</a></p><p><a href="https://github.com/Liu-xiandong/How_to_optimize_in_GPU">GitHub - Liu-xiandong&#x2F;How_to_optimize_in_GPU: This is a series of GPU optimization topics. Here we will introduce how to optimize the CUDA kernel in detail. I will introduce several basic kernel optimizations, including: elementwise, reduce, sgemv, sgemm, etc. The performance of these kernels is basically at or near the theoretical limit.</a></p><p><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#">CUDA C++ Programming Guide (nvidia.com)</a></p><p><a href="https://github.com/NervanaSystems/maxas/wiki/SGEMM">SGEMM · NervanaSystems&#x2F;maxas Wiki · GitHub</a></p><p><a href="https://github.com/Cjkkkk/CUDA_gemm">GitHub - Cjkkkk&#x2F;CUDA_gemm: A simple high performance CUDA GEMM implementation.</a></p><p><a href="https://github.com/yzhaiustc/Optimizing-SGEMM-on-NVIDIA-Turing-GPUs">GitHub - yzhaiustc&#x2F;Optimizing-SGEMM-on-NVIDIA-Turing-GPUs: Optimizing SGEMM kernel functions on NVIDIA GPUs to a close-to-cuBLAS performance.</a></p><p><a href="https://developer.nvidia.com/blog/cutlass-linear-algebra-cuda/">https://developer.nvidia.com/blog/cutlass-linear-algebra-cuda/</a></p><p><a href="https://wiki.illinois.edu/wiki/display/ECE408/Class+Schedule">Class Schedule - ECE408 - Illinois Wiki</a></p><p><a href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#toc2">GCC-Inline-Assembly-HOWTO (ibiblio.org)</a></p><p><a href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blas</tag>
      
      <tag>gemm</tag>
      
      <tag>gemv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++枚举类型 enum</title>
    <link href="/2023/04/30/enum/"/>
    <url>/2023/04/30/enum/</url>
    
    <content type="html"><![CDATA[<h2 id="C-x2F-C-枚举类型-enum"><a href="#C-x2F-C-枚举类型-enum" class="headerlink" title="C&#x2F;C++枚举类型 enum"></a>C&#x2F;C++枚举类型 enum</h2><p><strong>枚举类型的定义：</strong>枚举类型(enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p><p>定义格式：枚举类型的定义格式为：</p><figure class="highlight bnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bnf">enum <span class="hljs-attribute">&lt;类型名&gt;</span> &#123;<span class="hljs-attribute">&lt;枚举常量表&gt;</span>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>格式说明：</strong></p><ul><li>关键字enum——指明其后的标识符是一个枚举类型的名字。</li><li>枚举常量表——由枚举常量构成。”枚举常量”或称”枚举成员”，是以标识符形式表示的整型量，表示枚举类型的取值。枚举常量表列出枚举类型的所有取值，各枚举常量之间以”，”间隔，且必须各不相同。取值类型与条件表达式相同。</li></ul><p><strong>应用举例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color_set1</span> &#123;</span>RED, BLUE, WHITE, BLACK&#125;; <span class="hljs-comment">// 定义枚举类型color_set1</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">week</span> &#123;</span>Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; <span class="hljs-comment">// 定义枚举类型week</span><br></code></pre></div></td></tr></table></figure><p><strong>重要提示：</strong></p><p>枚举常量代表该枚举类型的变量可能取的值，编译系统为每个枚举常量指定一个整数值，默认状态下，这个整数就是所列举元素的序号，序号从0开始。 可以在定义枚举类型时为部分或全部枚举常量指定整数值，在指定值之前的枚举常量仍按默认方式取值，而指定值之后的枚举常量按依次加1的原则取值。 各枚举常量的值可以重复。例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fruit_set</span> &#123;</span>apple, orange, banana=<span class="hljs-number">1</span>, peach, grape&#125;<br><span class="hljs-comment">//枚举常量apple=0,orange=1, banana=1,peach=2,grape=3。</span><br><span class="hljs-keyword">enum</span> week &#123;Sun=<span class="hljs-number">7</span>, Mon=<span class="hljs-number">1</span>, Tue, Wed, Thu, Fri, Sat&#125;;<br><span class="hljs-comment">//枚举常量Sun,Mon,Tue,Wed,Thu,Fri,Sat的值分别为7、1、2、3、4、5、6。</span><br></code></pre></div></td></tr></table></figure><p>枚举常量只能以标识符形式表示，而不能是整型、字符型等文字常量。例如，以下定义非法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">letter_set</span> &#123;</span><span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;T&#x27;</span>&#125;; <span class="hljs-comment">//枚举常量不能是字符常量</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">year_set</span>&#123;</span><span class="hljs-number">2000</span>,<span class="hljs-number">2001</span>,<span class="hljs-number">2002</span>,<span class="hljs-number">2003</span>,<span class="hljs-number">2004</span>,<span class="hljs-number">2005</span>&#125;; <span class="hljs-comment">//枚举常量不能是整型常量</span><br></code></pre></div></td></tr></table></figure><p>可改为以下形式则定义合法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">letter_set</span> &#123;</span>a, d, F, s, T&#125;;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">year_set</span>&#123;</span>y2000, y2001, y2002, y2003, y2004, y2005&#125;;<br></code></pre></div></td></tr></table></figure><hr><h2 id="枚举变量的使用"><a href="#枚举变量的使用" class="headerlink" title="枚举变量的使用"></a>枚举变量的使用</h2><p>定义枚举类型的主要目的是：增加程序的可读性。枚举类型最常见也最有意义的用处之一就是用来描述状态量，这点将在第9章 输入输出流类看到。</p><p>定义格式：定义枚举类型之后，就可以定义该枚举类型的变量，如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">color_set1 color1, color2;<br></code></pre></div></td></tr></table></figure><p>亦可类型与变量同时定义（甚至类型名可省），格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>Sun,Mon,Tue,Wed,Thu,Fri,Sat&#125; weekday1, weekday2;<br></code></pre></div></td></tr></table></figure><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><p>枚举变量的值只能取枚举常量表中所列的值，就是整型数的一个子集。</p><p>枚举变量占用内存的大小与整型数相同。</p><p>枚举变量只能参与赋值和关系运算以及输出操作，参与运算时用其本身的整数值。例如，设有定义：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color_set1</span> &#123;</span>RED, BLUE, WHITE, BLACK&#125; color1, color2;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color_set2</span> &#123;</span> GREEN, RED, YELLOW, WHITE&#125; color3, color4;<br></code></pre></div></td></tr></table></figure><p>则允许的赋值操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">color3=RED;           <span class="hljs-comment">//将枚举常量值赋给枚举变量</span><br>color4=color3;        <span class="hljs-comment">//相同类型的枚举变量赋值，color4的值为RED</span><br><span class="hljs-keyword">int</span>  i=color3;        <span class="hljs-comment">//将枚举变量赋给整型变量，i的值为1</span><br><span class="hljs-keyword">int</span>  j=GREEN;         <span class="hljs-comment">//将枚举常量赋给整型变量，j的值为0</span><br></code></pre></div></td></tr></table></figure><p>允许的关系运算有：&#x3D;&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;等，例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//比较同类型枚举变量color3，color4是否相等</span><br><span class="hljs-keyword">if</span> (color3==color4) cout&lt;&lt;<span class="hljs-string">&quot;相等&quot;</span>；<br><span class="hljs-comment">//输出的是变量color3与WHITE的比较结果，结果为1</span><br>cout&lt;&lt; color3&lt;WHITE;<br></code></pre></div></td></tr></table></figure><p>枚举变量可以直接输出，输出的是变量的整数值。例如：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cout</span>&lt;&lt; color<span class="hljs-number">3</span>;         //输出的是color<span class="hljs-number">3</span>的整数值，即RED的整数值<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h3 id="重要提示"><a href="#重要提示" class="headerlink" title="重要提示"></a>重要提示</h3><ul><li>枚举变量可以直接输出，但不能直接输入。如：cout &gt;&gt; color3;  &#x2F;&#x2F;非法</li><li>不能直接将常量赋给枚举变量。如： color1&#x3D;1; &#x2F;&#x2F;非法</li><li>不同类型的枚举变量之间不能相互赋值。如： color1&#x3D;color3; &#x2F;&#x2F;非法</li><li>枚举变量的输入输出一般都采用switch语句将其转换为字符或字符串；枚举类型数据的其他处理也往往应用switch语句，以保证程序的合法性和可读性。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/w3cnote/cpp-enum-intro.html">C++ 枚举类型详解 | 菜鸟教程 (runoob.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++ volatile关键字</title>
    <link href="/2023/04/30/violate/"/>
    <url>/2023/04/30/violate/</url>
    
    <content type="html"><![CDATA[<h2 id="C-x2F-C-volatile关键字"><a href="#C-x2F-C-volatile关键字" class="headerlink" title="C&#x2F;C++ volatile关键字"></a>C&#x2F;C++ volatile关键字</h2><p><strong>volatile后面的变量，是常变量，会直接访问地址，如果没有这个关键字，就可能会暂时使用寄存器的值，而不是读取地址。</strong></p><p>C&#x2F;C++ 中的 volatile 关键字和 const 对应，用来修饰变量。volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;<br></code></pre></div></td></tr></table></figure><p>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p><p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。</p><p><strong>volatile关键字的实现：如在并行环境下，进行同步操作，用volatile修饰回答字地址，即可实现并行环境下的同步。这种方法一般使用在非阻塞通信中。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/ijn842/article/details/81273232">浅谈C语言的volatile关键字_琼琼的博客的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/GreatTang/article/details/90454011">C++ volatile_c++ violate_来日梦多长的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/jerry_wuhao/article/details/113247800">C&#x2F;C++ 中 volatile 关键字_c++ violate关键字_王俊洁、�的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU 15-213 Lecture 01:Course Overview</title>
    <link href="/2023/03/13/CMU15-213001/"/>
    <url>/2023/03/13/CMU15-213001/</url>
    
    <content type="html"><![CDATA[<h2 id="2015-CMU-15-213-CSAPP-深入理解计算机系统-Lecture-01-Course-Overview"><a href="#2015-CMU-15-213-CSAPP-深入理解计算机系统-Lecture-01-Course-Overview" class="headerlink" title="2015 CMU 15-213 CSAPP 深入理解计算机系统 Lecture 01: Course Overview"></a>2015 CMU 15-213 CSAPP 深入理解计算机系统 Lecture 01: Course Overview</h2><h3 id="例子一："><a href="#例子一：" class="headerlink" title="例子一："></a>例子一：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">double</span> d;<br>&#125;<span class="hljs-keyword">struct_t</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">struct_t</span> s;   <span class="hljs-comment">//volatile关键字</span><br>    s.d = <span class="hljs-number">3.14</span>;<br>    s.a[i] = <span class="hljs-number">1073741824</span>;   <span class="hljs-comment">/*Possibly out of bounds*/</span><br>    <span class="hljs-keyword">return</span> s.d;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">fun(0)   -&gt;   3.14<br>fun(1)   -&gt;   3.14<br>fun(2)   -&gt;   3.1399998664856<br>fun(3)   -&gt;   2.00000061035156<br>fun(4)   -&gt;   3.14<br>fun(6)   -&gt;   Segmentation falut<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/13/CMU15-213001/image-20230313201550219.png" alt="image-20230313201550219"></p><p>【图中假设memory line大小为4B】根据结构体可知我们拥有一个int型的数组大小为2，一个double型的变量。因为int数组的大小为2，当fun(0),fun(1)时，s.a[i]访问是正确的，所以fun(0),fun(1)返回正确值s.d及3.14。而当fun(i):i&gt;1时，就会返回奇怪的结果，这是因为数组大小为2，我们越界了，实际上s.a[i]写的是double的内存空间，如图中的2，3。而6代表程序状态，我们去修改它就会造成程序状态的改变，导致Segmentation fault。这里提醒我们在写C代码的时候一定要注意边界处理。【这里需要清楚C语言中堆区和栈区存的是什么】</p><h3 id="例子二："><a href="#例子二：" class="headerlink" title="例子二："></a>例子二：</h3><p><img src="/2023/03/13/CMU15-213001/image-20230313202535864.png" alt="image-20230313202535864"></p><p>【src和dst是大小2048*2048的二维数组】上面的图片，我们可以十分清楚代码的逻辑。他想把src数组的值拷贝到dst。而左右代码的功能完全一样，仅仅是for循环顺序不一样，但是却会有这么大的性能差距，这是什么原因呢？总的来说就是左边代码cache命中率高，右边cache命中率的。cache命中和cache miss的速度差距很大甚至是数量级别的差距，这是导致两者差距巨大的原因。【注意这里还可以更细致的分析，但是会有很多其他因素会影响】</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/index.html">15-213: Introduction to Computer Systems (cmu.edu)</a></p>]]></content>
    
    
    <categories>
      
      <category>Computer Organization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2015 CMU 15-213 CSAPP 深入理解计算机系统</title>
    <link href="/2023/03/13/CMU15-213/"/>
    <url>/2023/03/13/CMU15-213/</url>
    
    <content type="html"><![CDATA[<h1 id="2015-CMU-15-213-CSAPP-深入理解计算机系统"><a href="#2015-CMU-15-213-CSAPP-深入理解计算机系统" class="headerlink" title="2015 CMU 15-213 CSAPP 深入理解计算机系统"></a>2015 CMU 15-213 CSAPP 深入理解计算机系统</h1><p><strong>项目地址：</strong><a href="https://github.com/EugeneLiu/translationCSAPP">EugeneLiu&#x2F;translationCSAPP: 为 CSAPP 视频课程提供字幕，翻译 PPT，Lab。 (github.com)</a></p><p><strong>bilibili翻译：</strong><a href="https://www.bilibili.com/video/av31289365/">【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频_哔哩哔哩_bilibili</a></p><h2 id="CSAPP-3e-官方链接"><a href="#CSAPP-3e-官方链接" class="headerlink" title="CSAPP:3e 官方链接"></a>CSAPP:3e 官方链接</h2><ul><li><a href="http://csapp.cs.cmu.edu/">课程主页</a></li><li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html">课件下载链接</a></li><li><a href="http://csapp.cs.cmu.edu/3e/labs.html">课程 Lab 页面</a></li><li><a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22b96d90ae-9871-4fae-91e2-b1627b43e25e%22&sortColumn=0&sortAscending=true">课程视频地址</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Organization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归的梯度下降</title>
    <link href="/2023/03/13/ML003/"/>
    <url>/2023/03/13/ML003/</url>
    
    <content type="html"><![CDATA[<h2 id="线性回归的梯度下降"><a href="#线性回归的梯度下降" class="headerlink" title="线性回归的梯度下降"></a>线性回归的梯度下降</h2><p><img src="/2023/03/13/ML003/image-20230313145346118.png" alt="image-20230313145346118"></p><h2 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h2><p>在本实验中，您将:</p><ul><li>使用梯度下降自动优化w和b的过程</li></ul><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p>在本实验中，我们将使用:</p><ul><li>NumPy，一个用于科学计算的流行库</li><li>Matplotlib，用于绘制数据的流行库</li><li>在本地目录的lab_utils.py文件中绘制例程</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math, copy<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.style.use(<span class="hljs-string">&#x27;./deeplearning.mplstyle&#x27;</span>)<br><span class="hljs-keyword">from</span> lab_utils_uni <span class="hljs-keyword">import</span> plt_house_x, plt_contour_wgrad, plt_divergence, plt_gradients<br></code></pre></div></td></tr></table></figure><h2 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h2><p>让我们使用与之前相同的两个数据点——1000平方英尺的房子以30万美元的价格出售，2000平方英尺的房子以50万美元的价格出售。</p><table><thead><tr><th>Size(1000 sqft)</th><th>Price(1000s of dollars)</th></tr></thead><tbody><tr><td>1</td><td>300</td></tr><tr><td>2</td><td>500</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#Load our data set</span><br>x_train = np.array([<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>])<span class="hljs-comment">#features</span><br>y_train = np.array([<span class="hljs-number">300.0</span>,<span class="hljs-number">500.0</span>])<span class="hljs-comment">#target value</span><br></code></pre></div></td></tr></table></figure><h2 id="Compute-Cost"><a href="#Compute-Cost" class="headerlink" title="Compute_Cost"></a>Compute_Cost</h2><p>这是上一个实验室开发的。我们在这里还会用到它。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pyhton">#Function to calculate the cost<br>def compute_cost(x, y, w, b,):<br><br>m = x.shape[0]<br>cost = 0<br><br>for i in range(m):<br>f_wb = w * x[i] + b<br>cost = cost + (f_wb - y[i])**2<br>total_cost = 1 / (2 * m)*cost<br><br>return total_cost<br></code></pre></div></td></tr></table></figure><h2 id="Gradient-descent-summary"><a href="#Gradient-descent-summary" class="headerlink" title="Gradient descent summary"></a>Gradient descent summary</h2><p>到目前为止，在这门课程中，你已经建立了一个线性模型来预测f_w,b(x^i):</p><p><img src="/2023/03/13/ML003/image-20230313150848463.png" alt="image-20230313150848463"></p><p>在线性回归中，您使用输入训练数据来拟合参数𝑤,𝑏;来最小化我们的预测之间的误差测量f_𝑤，𝑏(𝑥^(𝑖))和实际数据𝑦(𝑖)。这种测量成为代价，J（w,b）。在训练中，你可以衡量我们所有训练样本的成本𝑥(𝑖)，𝑦(𝑖)。</p><p><img src="/2023/03/13/ML003/image-20230313151251919.png" alt="image-20230313151251919"></p><p>在课堂上，梯度下降被描述为:</p><p><img src="/2023/03/13/ML003/image-20230313151329621.png" alt="image-20230313151329621"></p><p>其中参数𝑤,𝑏同时更新。</p><p><img src="/2023/03/13/ML003/image-20230313151450500.png" alt="image-20230313151450500"></p><p>这里同时意味着在更新任何参数之前计算所有参数的偏导数。</p><h2 id="Implement-Gradient-Descent"><a href="#Implement-Gradient-Descent" class="headerlink" title="Implement Gradient Descent"></a>Implement Gradient Descent</h2><p>你将为一个特征实现梯度下降算法。你需要三个函数。</p><ul><li>compute_gradient实现上述式(4)和(5)</li><li>上面的compute_cost实现方程(2)(代码来自以前的实验室)</li><li>gradient_descent，使用compute_gradient和compute_cost</li></ul><p>Conventions:</p><p><img src="/2023/03/13/ML003/image-20230313151857315.png" alt="image-20230313151857315"></p><h2 id="compute-gradient"><a href="#compute-gradient" class="headerlink" title="compute_gradient"></a>compute_gradient</h2><p><img src="/2023/03/13/ML003/image-20230313151947363.png" alt="image-20230313151947363"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_gradient</span>(<span class="hljs-params">x, y, w, b</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Computes the gradient for linear regression</span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">    x (ndarray (m,)): Data, m examples</span><br><span class="hljs-string">    y (ndarray (m,)): target values</span><br><span class="hljs-string">    w,b (scalar): model parameters</span><br><span class="hljs-string">    Returns</span><br><span class="hljs-string">    dj_dw (scalar): The gradient of the cost w.r.t. the parameters w</span><br><span class="hljs-string">    dj_db (scalar): The gradient of the cost w.r.t. the parameter b </span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br>    <span class="hljs-comment">#Number of training examples</span><br>    m = x.shape[<span class="hljs-number">0</span>]<br>    dj_de = <span class="hljs-number">0</span><br>    dj_db = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        f_wb = w * x[i] + b;<br>        dj_dw_i = (f_wb - y[i]) * x[i]<br>        dj_db_i = f_wb - y[i]<br>        dj_db += dj_db_i<br>        dj_dw += dj_dw_i<br>    dj_dw = dj_dw / m<br>    dj_db = dj_db / m<br>    <br>    <span class="hljs-keyword">return</span> dj_dw, dj_db<br></code></pre></div></td></tr></table></figure><p>课程描述了梯度下降如何利用在某一点上对参数代价的偏导数来更新该参数。</p><p>让我们使用compute_gradient函数来查找并绘制代价函数相对于其中一个参数𝑤0的偏导数。</p><p><img src="/2023/03/13/ML003/image-20230313154012173.png" alt="image-20230313154012173"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">plt_gradients(x_train,y_train, compute_cost, compute_gradient)<br>plt.show()<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/13/ML003/image-20230313154210478.png" alt="image-20230313154210478"></p><p><img src="/2023/03/13/ML003/image-20230313154333429.png" alt="image-20230313154333429"></p><h2 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h2><p>现在可以计算梯度，上面公式(3)中描述的梯度下降可以在下面的gradient_descent中实现。注释中描述了实现的细节。下面，您将利用这个函数在训练数据上找到w和b的最佳值。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gradient_descent</span>(<span class="hljs-params">x, y, w_in, b_in, alpha, num_iters, cost_function, gradient_function</span>):</span> <br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Performs gradient descent to fit w,b. Updates w,b by taking </span><br><span class="hljs-string">    num_iters gradient steps with learning rate alpha</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">      x (ndarray (m,))  : Data, m examples </span><br><span class="hljs-string">      y (ndarray (m,))  : target values</span><br><span class="hljs-string">      w_in,b_in (scalar): initial values of model parameters  </span><br><span class="hljs-string">      alpha (float):     Learning rate</span><br><span class="hljs-string">      num_iters (int):   number of iterations to run gradient descent</span><br><span class="hljs-string">      cost_function:     function to call to produce cost</span><br><span class="hljs-string">      gradient_function: function to call to produce gradient</span><br><span class="hljs-string">      </span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">      w (scalar): Updated value of parameter after running gradient descent</span><br><span class="hljs-string">      b (scalar): Updated value of parameter after running gradient descent</span><br><span class="hljs-string">      J_history (List): History of cost values</span><br><span class="hljs-string">      p_history (list): History of parameters [w,b] </span><br><span class="hljs-string">      &quot;&quot;&quot;</span><br>    <br>    w = copy.deepcopy(w_in) <span class="hljs-comment"># avoid modifying global w_in</span><br>    <span class="hljs-comment"># An array to store cost J and w&#x27;s at each iteration primarily for graphing later</span><br>    J_history = []<br>    p_history = []<br>    b = b_in<br>    w = w_in<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_iters):<br>        <span class="hljs-comment"># Calculate the gradient and update the parameters using gradient_function</span><br>        dj_dw, dj_db = gradient_function(x, y, w , b)     <br><br>        <span class="hljs-comment"># Update Parameters using equation (3) above</span><br>        b = b - alpha * dj_db                            <br>        w = w - alpha * dj_dw                            <br><br>        <span class="hljs-comment"># Save cost J at each iteration</span><br>        <span class="hljs-keyword">if</span> i&lt;<span class="hljs-number">100000</span>:      <span class="hljs-comment"># prevent resource exhaustion </span><br>            J_history.append( cost_function(x, y, w , b))<br>            p_history.append([w,b])<br>        <span class="hljs-comment"># Print cost every at intervals 10 times or as many iterations if &lt; 10</span><br>        <span class="hljs-keyword">if</span> i% math.ceil(num_iters/<span class="hljs-number">10</span>) == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Iteration <span class="hljs-subst">&#123;i:<span class="hljs-number">4</span>&#125;</span>: Cost <span class="hljs-subst">&#123;J_history[-<span class="hljs-number">1</span>]:<span class="hljs-number">0.2</span>e&#125;</span> &quot;</span>,<br>                  <span class="hljs-string">f&quot;dj_dw: <span class="hljs-subst">&#123;dj_dw: <span class="hljs-number">0.3</span>e&#125;</span>, dj_db: <span class="hljs-subst">&#123;dj_db: <span class="hljs-number">0.3</span>e&#125;</span>  &quot;</span>,<br>                  <span class="hljs-string">f&quot;w: <span class="hljs-subst">&#123;w: <span class="hljs-number">0.3</span>e&#125;</span>, b:<span class="hljs-subst">&#123;b: <span class="hljs-number">0.5</span>e&#125;</span>&quot;</span>)<br> <br>    <span class="hljs-keyword">return</span> w, b, J_history, p_history <span class="hljs-comment">#return w and J,w history for graphing</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">Iteration    <span class="hljs-number">0</span>: Cost <span class="hljs-number">7.93e+04</span>  dj_dw: -<span class="hljs-number">6.500e+02</span>, dj_db: -<span class="hljs-number">4.000e+02</span>   w:  <span class="hljs-number">6.500e+00</span>, b: <span class="hljs-number">4.00000e+00</span><br>Iteration <span class="hljs-number">1000</span>: Cost <span class="hljs-number">3.41e+00</span>  dj_dw: -<span class="hljs-number">3.712e-01</span>, dj_db:  <span class="hljs-number">6.007e-01</span>   w:  <span class="hljs-number">1.949e+02</span>, b: <span class="hljs-number">1.08228e+02</span><br>Iteration <span class="hljs-number">2000</span>: Cost <span class="hljs-number">7.93e-01</span>  dj_dw: -<span class="hljs-number">1.789e-01</span>, dj_db:  <span class="hljs-number">2.895e-01</span>   w:  <span class="hljs-number">1.975e+02</span>, b: <span class="hljs-number">1.03966e+02</span><br>Iteration <span class="hljs-number">3000</span>: Cost <span class="hljs-number">1.84e-01</span>  dj_dw: -<span class="hljs-number">8.625e-02</span>, dj_db:  <span class="hljs-number">1.396e-01</span>   w:  <span class="hljs-number">1.988e+02</span>, b: <span class="hljs-number">1.01912e+02</span><br>Iteration <span class="hljs-number">4000</span>: Cost <span class="hljs-number">4.28e-02</span>  dj_dw: -<span class="hljs-number">4.158e-02</span>, dj_db:  <span class="hljs-number">6.727e-02</span>   w:  <span class="hljs-number">1.994e+02</span>, b: <span class="hljs-number">1.00922e+02</span><br>Iteration <span class="hljs-number">5000</span>: Cost <span class="hljs-number">9.95e-03</span>  dj_dw: -<span class="hljs-number">2.004e-02</span>, dj_db:  <span class="hljs-number">3.243e-02</span>   w:  <span class="hljs-number">1.997e+02</span>, b: <span class="hljs-number">1.00444e+02</span><br>Iteration <span class="hljs-number">6000</span>: Cost <span class="hljs-number">2.31e-03</span>  dj_dw: -<span class="hljs-number">9.660e-03</span>, dj_db:  <span class="hljs-number">1.563e-02</span>   w:  <span class="hljs-number">1.999e+02</span>, b: <span class="hljs-number">1.00214e+02</span><br>Iteration <span class="hljs-number">7000</span>: Cost <span class="hljs-number">5.37e-04</span>  dj_dw: -<span class="hljs-number">4.657e-03</span>, dj_db:  <span class="hljs-number">7.535e-03</span>   w:  <span class="hljs-number">1.999e+02</span>, b: <span class="hljs-number">1.00103e+02</span><br>Iteration <span class="hljs-number">8000</span>: Cost <span class="hljs-number">1.25e-04</span>  dj_dw: -<span class="hljs-number">2.245e-03</span>, dj_db:  <span class="hljs-number">3.632e-03</span>   w:  <span class="hljs-number">2.000e+02</span>, b: <span class="hljs-number">1.00050e+02</span><br>Iteration <span class="hljs-number">9000</span>: Cost <span class="hljs-number">2.90e-05</span>  dj_dw: -<span class="hljs-number">1.082e-03</span>, dj_db:  <span class="hljs-number">1.751e-03</span>   w:  <span class="hljs-number">2.000e+02</span>, b: <span class="hljs-number">1.00024e+02</span><br>(w,b) found by gradient descent: (<span class="hljs-number">199.9929</span>,<span class="hljs-number">100.0116</span>)<br></code></pre></div></td></tr></table></figure><p>花点时间，注意上面打印的梯度下降过程的一些特征。</p><ul><li>正如课堂上的幻灯片所描述的，成本开始很大，然后迅速下降。</li><li>偏导数dj_dw和dj_db也变小了，起初很快，然后变慢。正如课堂上的图表所示，随着过程接近“碗底”，由于在这一点上的导数值较小，进程会变慢。</li><li>尽管学习率alpha保持不变，但进程会减慢</li></ul><p><img src="/2023/03/13/ML003/image-20230313155614815.png" alt="image-20230313155614815"></p><h2 id="Cost-versus-iterations-of-gradient-descent"><a href="#Cost-versus-iterations-of-gradient-descent" class="headerlink" title="Cost versus iterations of gradient descent"></a>Cost versus iterations of gradient descent</h2><p>成本与迭代的关系图是衡量梯度下降技术进展的有用方法。在成功的运行中，成本总是会降低。最初成本的变化如此之快，用不同于最终下降的尺度来描绘最初的上升是有用的。</p><p>在下面的图表中，请注意轴上的成本规模和迭代步骤。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># plot cost versus iteration  </span><br>fig, (ax1, ax2) = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, constrained_layout=<span class="hljs-literal">True</span>, figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))<br>ax1.plot(J_hist[:<span class="hljs-number">100</span>])<br>ax2.plot(<span class="hljs-number">1000</span> + np.arange(<span class="hljs-built_in">len</span>(J_hist[<span class="hljs-number">1000</span>:])), J_hist[<span class="hljs-number">1000</span>:])<br>ax1.set_title(<span class="hljs-string">&quot;Cost vs. iteration(start)&quot;</span>);  ax2.set_title(<span class="hljs-string">&quot;Cost vs. iteration (end)&quot;</span>)<br>ax1.set_ylabel(<span class="hljs-string">&#x27;Cost&#x27;</span>)            ;  ax2.set_ylabel(<span class="hljs-string">&#x27;Cost&#x27;</span>) <br>ax1.set_xlabel(<span class="hljs-string">&#x27;iteration step&#x27;</span>)  ;  ax2.set_xlabel(<span class="hljs-string">&#x27;iteration step&#x27;</span>) <br>plt.show()<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/13/ML003/image-20230313160112122.png" alt="image-20230313160112122"></p><h2 id="Predictions"><a href="#Predictions" class="headerlink" title="Predictions"></a>Predictions</h2><p>现在您已经发现了参数𝑤的最佳值和𝑏，您现在可以使用该模型根据我们学习的参数来预测房屋价值。正如预期的那样，在相同的住房条件下，预测值与训练值几乎相同。进一步，不在预测中的值与期望值一致。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;1000 sqft house prediction <span class="hljs-subst">&#123;w_final*<span class="hljs-number">1.0</span> + b_final:<span class="hljs-number">0.1</span>f&#125;</span> Thousand dollars&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;1200 sqft house prediction <span class="hljs-subst">&#123;w_final*<span class="hljs-number">1.2</span> + b_final:<span class="hljs-number">0.1</span>f&#125;</span> Thousand dollars&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;2000 sqft house prediction <span class="hljs-subst">&#123;w_final*<span class="hljs-number">2.0</span> + b_final:<span class="hljs-number">0.1</span>f&#125;</span> Thousand dollars&quot;</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-number">1000</span> sqft house prediction <span class="hljs-number">300.0</span> Thousand dollars<br><span class="hljs-number">1200</span> sqft house prediction <span class="hljs-number">340.0</span> Thousand dollars<br><span class="hljs-number">2000</span> sqft house prediction <span class="hljs-number">500.0</span> Thousand dollars<br></code></pre></div></td></tr></table></figure><h2 id="Plotting"><a href="#Plotting" class="headerlink" title="Plotting"></a>Plotting</h2><p>您可以通过在代价(w,b)的等高线图上绘制迭代的代价来显示梯度下降在执行过程中的进度。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">fig, ax = plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<br>plt_contour_wgrad(x_train, y_train, p_hist, ax)<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/13/ML003/image-20230313160446994.png" alt="image-20230313160446994"></p><p>上面的等高线图显示了𝑤和𝑏范围内的𝑐𝑜𝑠𝑡(𝑤，𝑏)。成本水平由圆环表示。用红色箭头覆盖的是梯度下降的路径。这里有一些需要注意的事情:</p><ul><li>这条路径朝着它的目标稳步(单调)前进。</li><li>最初的步骤比接近目标的步骤要大得多。</li></ul><p>放大，我们可以看到梯度下降的最后步骤。注意，阶梯之间的距离随着梯度趋近于零而缩小。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">fig, ax = plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">4</span>))<br>plt_contour_wgrad(x_train, y_train, p_hist, ax, w_range=[<span class="hljs-number">180</span>, <span class="hljs-number">220</span>, <span class="hljs-number">0.5</span>], b_range=[<span class="hljs-number">80</span>, <span class="hljs-number">120</span>, <span class="hljs-number">0.5</span>],<br>            contours=[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>],resolution=<span class="hljs-number">0.5</span>)<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/13/ML003/image-20230313160944244.png" alt="image-20230313160944244"></p><h2 id="Increased-Learning-Rate"><a href="#Increased-Learning-Rate" class="headerlink" title="Increased Learning Rate"></a>Increased Learning Rate</h2><p>在这节课中，在式(3)中有一个关于学习率的合适值𝛼的讨论。𝛼越大，梯度下降收敛到解的速度就越快。但是，如果它太大，梯度下降就会发散。上面有一个很好收敛的解的例子。让我们试着增加𝛼的值看看会发生什么:</p><p><img src="/2023/03/13/ML003/image-20230313161516209.png" alt="image-20230313161516209"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># initialize parameters</span><br>w_init = <span class="hljs-number">0</span><br>b_init = <span class="hljs-number">0</span><br><span class="hljs-comment"># set alpha to a large value</span><br>iterations = <span class="hljs-number">10</span><br>tmp_alpha = <span class="hljs-number">8.0e-1</span><br><span class="hljs-comment"># run gradient descent</span><br>w_final, b_final, J_hist, p_hist = gradient_descent(x_train ,y_train, w_init, b_init, tmp_alpha, <br>                                                    iterations, compute_cost, compute_gradient)<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pyhton">Iteration    0: Cost 2.58e+05  dj_dw: -6.500e+02, dj_db: -4.000e+02   w:  5.200e+02, b: 3.20000e+02<br>Iteration    1: Cost 7.82e+05  dj_dw:  1.130e+03, dj_db:  7.000e+02   w: -3.840e+02, b:-2.40000e+02<br>Iteration    2: Cost 2.37e+06  dj_dw: -1.970e+03, dj_db: -1.216e+03   w:  1.192e+03, b: 7.32800e+02<br>Iteration    3: Cost 7.19e+06  dj_dw:  3.429e+03, dj_db:  2.121e+03   w: -1.551e+03, b:-9.63840e+02<br>Iteration    4: Cost 2.18e+07  dj_dw: -5.974e+03, dj_db: -3.691e+03   w:  3.228e+03, b: 1.98886e+03<br>Iteration    5: Cost 6.62e+07  dj_dw:  1.040e+04, dj_db:  6.431e+03   w: -5.095e+03, b:-3.15579e+03<br>Iteration    6: Cost 2.01e+08  dj_dw: -1.812e+04, dj_db: -1.120e+04   w:  9.402e+03, b: 5.80237e+03<br>Iteration    7: Cost 6.09e+08  dj_dw:  3.156e+04, dj_db:  1.950e+04   w: -1.584e+04, b:-9.80139e+03<br>Iteration    8: Cost 1.85e+09  dj_dw: -5.496e+04, dj_db: -3.397e+04   w:  2.813e+04, b: 1.73730e+04<br>Iteration    9: Cost 5.60e+09  dj_dw:  9.572e+04, dj_db:  5.916e+04   w: -4.845e+04, b:-2.99567e+04<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/13/ML003/image-20230313161636772.png" alt="image-20230313161636772"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">plt_divergence(p_hist, J_hist,x_train, y_train)<br>plt.show()<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/13/ML003/image-20230313161959222.png" alt="image-20230313161959222"></p><p>上图中，左图显示了𝑤在梯度下降的前几个步骤中的进展。𝑤从正振荡到负，成本迅速增长。梯度下降同时在𝑤和𝑏上运行，所以需要右边的3d图才能看到完整的图片。</p><h2 id="Congratulations"><a href="#Congratulations" class="headerlink" title="Congratulations!"></a>Congratulations!</h2><p>在这个实验室里，你:</p><ul><li>深入研究单个变量的梯度下降的细节。</li><li>开发了一个计算梯度的程序</li><li>看看梯度是什么</li><li>完成一个梯度下降程序</li><li>利用梯度下降法寻找参数</li><li>检查了学习率大小的影响</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1Pa411X76s?p=5&amp;vd_source=3ae32e36058f58c5b85935fca9b77797">https://www.bilibili.com/video/BV1Pa411X76s?p=5&amp;vd_source=3ae32e36058f58c5b85935fca9b77797</a></p><p><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization">kaieye&#x2F;2022-Machine-Learning-Specialization (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tensorflow</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代价函数</title>
    <link href="/2023/03/12/ML002/"/>
    <url>/2023/03/12/ML002/</url>
    
    <content type="html"><![CDATA[<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><img src="/2023/03/12/ML002/image-20230312164306128.png" alt="image-20230312164306128"></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在本实验中，你将:</p><ul><li>你将实现和探索成本函数的线性回归伴随一个变量。</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>在本实验室中，我们将使用:</p><ul><li>NumPy，一个用于科学计算的流行库</li><li>Matplotlib，用于绘制数据的流行库</li><li>本地目录的lab_utils_uni.py文件中的本地绘图例程</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> nunpy <span class="hljs-keyword">as</span> np<br>%matplotlib widget<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> lab_utils_uni <span class="hljs-keyword">import</span> plt_intuition, plt_stationary, plt_updata_onclick, soup_bowl<br>plt.style.use(<span class="hljs-string">&#x27;./deeplearning.mplstyle&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h2 id="问题意境"><a href="#问题意境" class="headerlink" title="问题意境"></a>问题意境</h2><p>你想要一个模型，它可以根据房子的大小预测房价。让我们使用与上一个实验室之前相同的两个数据点——一个1000平方英尺的房子卖了30万美元，一个2000平方英尺的房子卖了50万美元。</p><table><thead><tr><th>Size(1000 sqft)</th><th>Price(1000s of dollars)</th></tr></thead><tbody><tr><td>1</td><td>300</td></tr><tr><td>2</td><td>500</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x_train = np.array([<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>])   <span class="hljs-comment">#(size in 1000 square feet)</span><br>y_train = np.zrray([<span class="hljs-number">300.0</span>, <span class="hljs-number">500.0</span>])<span class="hljs-comment">#(price in 1000s of dollars)</span><br></code></pre></div></td></tr></table></figure><h2 id="计算代价"><a href="#计算代价" class="headerlink" title="计算代价"></a>计算代价</h2><p>这个作业中的术语“成本”可能会让人有点困惑，因为数据是住房成本。在这里，成本是衡量我们的模型预测房子目标价格的好坏。“价格”一词指的是住房数据。</p><p>含一个变量的成本方程为:</p><p><img src="/2023/03/12/ML002/image-20230312165434160.png" alt="image-20230312165434160"></p><p>在这里</p><p><img src="/2023/03/12/ML002/image-20230312165503613.png" alt="image-20230312165503613"></p><ul><li>f_w,b(x^i)是我们使用参数w,b来预测例子i。</li><li>（f_w,b(x^i) - y^i）^2  是目标值与预测值之间的差的平方</li><li>这些差异被加在所有m例子上，再除以2m，得到代价函数 <strong>J（w,b）</strong></li></ul><p>注意，在讲座中，总和的范围通常是从1到m，而代码将从0到m-1。</p><p>下面的代码通过遍历每个示例来计算成本。在每个循环中:</p><ul><li>f_wb，计算一个预测</li><li>目标和预测之间的差值被计算和平方。</li><li>这被加到总成本中。</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_cost</span>(<span class="hljs-params">x, y, w, b</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Computes the cost function for linear regression</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">    x (ndarray (m,)):Data, m examples</span><br><span class="hljs-string">    y (ndarray (m,)):target values</span><br><span class="hljs-string">    w,b (scalar):model parameters</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Returns</span><br><span class="hljs-string">    total_cost (float):The cost of using w,b as the parameters for linear regression to fit the data points in x and y</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment">#number of training examples</span><br>    m = x.shape[<span class="hljs-number">0</span>]<br>    <br>    cost_sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        f_wb = w * x[i] + b<br>        cost = (f_wb - y[i])**<span class="hljs-number">2</span><br>        cost_sum = cost_sum + cost<br>    total_cost = (<span class="hljs-number">1</span>/(<span class="hljs-number">2</span>*m)) * cost_sum<br>    <br>    <span class="hljs-keyword">return</span> total_cost<br></code></pre></div></td></tr></table></figure><h2 id="Cost-Function-Intuition"><a href="#Cost-Function-Intuition" class="headerlink" title="Cost Function Intuition"></a>Cost Function Intuition</h2><p><img src="/2023/03/12/ML002/image-20230312172325465.png" alt="image-20230312172325465"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">plt_intuition(x_train, y_train)<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/12/ML002/image-20230313144221393.png" alt="image-20230313144221393"></p><p>情节中有几点值得一提。</p><ul><li>当𝑤&#x3D;200时，成本最小化，这与之前实验室的结果相吻合。</li><li>因为在成本方程中，目标和预测之间的差异是平方，当𝑤时，成本迅速增加不是太大就是太小。</li><li>使用通过最小化成本选择的w和b，可以得到与数据完美匹配的直线。</li></ul><h2 id="Cost-Function-Visualiztion-3D"><a href="#Cost-Function-Visualiztion-3D" class="headerlink" title="Cost Function Visualiztion-3D"></a>Cost Function Visualiztion-3D</h2><p>你可以通过三维绘图或等高线图看到成本是如何随w和b变化的。</p><p>值得注意的是，这门课的一些情节会变得相当复杂。本文提供了绘图例程，虽然通读代码以熟悉这些方法是有指导意义的，但要成功完成课程并不需要这样做。例程在本地目录lab_utils_uni.py中。</p><h2 id="Larger-Data-Set"><a href="#Larger-Data-Set" class="headerlink" title="Larger Data Set"></a>Larger Data Set</h2><p>较大的数据集用更多的数据点来观察一个场景是很有指导意义的。该数据集包括不在同一线上的数据点。这对成本方程意味着什么?我们能找到𝑤、𝑏那样使得代价是0?</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x_train = np.array([<span class="hljs-number">1.0</span>,<span class="hljs-number">1.7</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">2.5</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">3.2</span>])<br>y_train = np.array([<span class="hljs-number">250</span>,<span class="hljs-number">300</span>,<span class="hljs-number">480</span>,<span class="hljs-number">430</span>,<span class="hljs-number">630</span>,<span class="hljs-number">730</span>])<br></code></pre></div></td></tr></table></figure><p>在等高线图中，点击一个点，选择w和b，以达到最低的成本。使用轮廓来指导你的选择。注意，更新图形可能需要几秒钟的时间。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">plt.close(<span class="hljs-string">&#x27;all&#x27;</span>)<br>fig, ax ,dyn_items = plt_stationary(x_train, y_train)<br>updater = plt_update_onclick(fig, ax, x_train,y_train,dyn_items)<br></code></pre></div></td></tr></table></figure><p>上面，注意左边图中的虚线。这些代表了你的训练集中每个例子所贡献的代价的部分。在本例中，值约为𝑤&#x3D;209和𝑏&#x3D; 2.4提供低代价。请注意，因为我们的训练示例不在一条线上，所以最小代价不为零。</p><h2 id="Convex-Cost-surface"><a href="#Convex-Cost-surface" class="headerlink" title="Convex Cost surface"></a>Convex Cost surface</h2><p>成本函数平方损失的事实确保了“误差曲面”像汤碗一样凸出。它总是有一个最小值，可以通过在所有维度上跟随梯度来达到。在前面的图中，因为𝑤和𝑏尺寸比例不同，这是不容易识别的。下图，其中𝑤和𝑏都是对称的，在讲座中展示过:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">soup_bowl()<br></code></pre></div></td></tr></table></figure><h2 id="Congratulations"><a href="#Congratulations" class="headerlink" title="Congratulations!"></a>Congratulations!</h2><p>您已经学习了以下内容:</p><ul><li>成本方程提供了一种衡量预测与训练数据匹配程度的方法。</li><li>最小化成本可以提供𝑤和b的最优值。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1Pa411X76s?p=5&amp;vd_source=3ae32e36058f58c5b85935fca9b77797">https://www.bilibili.com/video/BV1Pa411X76s?p=5&amp;vd_source=3ae32e36058f58c5b85935fca9b77797</a></p><p><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization">kaieye&#x2F;2022-Machine-Learning-Specialization (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tensorflow</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用AVX和AVX2处理数据(个人翻译)</title>
    <link href="/2023/03/10/avx006/"/>
    <url>/2023/03/10/avx006/</url>
    
    <content type="html"><![CDATA[<h2 id="1-文章来源"><a href="#1-文章来源" class="headerlink" title="1.文章来源"></a>1.文章来源</h2><p><strong>Matt Scarpino（USA）</strong></p><p><a href="https://www.codeproject.com/Articles/874396/Crunching-Numbers-with-AVX-and-AVX">Crunching Numbers with AVX and AVX2 - CodeProject</a></p><h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h2><p>在2003年，<a href="https://www.codeproject.com/script/Membership/View.aspx?mid=22834">Alex Fr</a>写了一篇优秀的<a href="https://www.codeproject.com/Articles/4522/Introduction-to-SSE-Programming">文章</a>[该文章现在已经被原作者删除]，解释了如何使用Intel的流式SIMD扩展(SSE)执行SIMD(单指令，多数据)处理。SSE是英特尔处理器支持的一组指令，可对大量数据执行高速运算。</p><p>2008年，英特尔推出了一套新的高性能指令，称为高级向量扩展(AVX)。AVX执行许多与SSE指令相同的操作，但以更快的速度对更大的数据块进行操作。最近，英特尔在AVX2和AVX512系列中发布了额外的指令。本文的重点是通过称为intrinsic funtions的特殊C函数访问AVX和AVX2指令。</p><p>本文不介绍整个AVX&#x2F;AVX2 intrinsics，而是侧重于数学计算。特别地，目标是复数相乘。要使用AVX&#x2F;AVX2执行此操作，需要三种类型的intrinsic:</p><ol><li>Initialization intrinscis</li><li>Arithmetic intrinsics</li><li>Permute&#x2F;shuffle intrinsics</li></ol><p></p><p>本文讨论每个类别中的intrinsics，并解释如何在代码中使用它们。本文的最后将展示如何用这些intrinsic进行乘法复数运算。</p><p>理解处理器指令和intrinsic function之间的区别是很重要的。AVX指令是执行不可分割操作的汇编命令。例如，AVX指令vaddps添加了两个操作数，并将结果放在第三个操作数中。</p><p>要在C&#x2F;C++中执行操作，the intrinsic funtion _mm256_add_ps()直接映射到vaddps，将汇编的性能与高级函数的便利性结合起来。An intrinsic funtion不一定映射到单个指令，但与其他C&#x2F; C++函数相比，AVX&#x2F;AVX2 intrinsics提供了可靠的高性能。</p><h2 id="3-基本要求"><a href="#3-基本要求" class="headerlink" title="3.基本要求"></a>3.基本要求</h2><p>要理解本文的内容，您需要基本熟悉C语言和SIMD处理。要执行代码，您需要一个支持AVX或AVX&#x2F;AVX2的CPU。以下是支持AVX的cpu:</p><ul><li>Intel’s Sandy Bridge&#x2F;Sandy Bridge E&#x2F;Ivy Bridge&#x2F;Ivy Bridge E</li><li>Intel’s Haswell&#x2F;Haswell E&#x2F;Broadwell&#x2F;Broadwell E</li><li>AMD’s Bulldozer&#x2F;Piledriver&#x2F;Steamroller&#x2F;Excavator</li></ul><p>支持AVX2的CPU也支持AVX。以下是这些设备:</p><ul><li>Intel’s Haswell&#x2F;Haswell E&#x2F;Broadwell&#x2F;Broadwell E</li><li>AMD’s Excavator</li></ul><p>本文中讨论的大多数函数都是由AVX提供的。但也有一些是AVX2特有的。为了区分它们，在本文的表中，我在AVX2 intrinsic的名称前面加上(2)。</p><p>[个人补充]</p><p>判断自己电脑CPU是否支持AVX和AVX2，最简单的就是在命令行执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">lscpu<br></code></pre></div></td></tr></table></figure><p>你会得到以下结果：</p><p><img src="/2023/03/10/avx006/image-20230129153048825.png" alt="image-20230129153048825"></p><p>在Flags里面你可以清楚的看到你的电脑是否支持AVX以及AVX2。</p><h2 id="4-向量化概述"><a href="#4-向量化概述" class="headerlink" title="4.向量化概述"></a>4.向量化概述</h2><p>AVX指令通过同时处理大块值而不是单独处理值来提高应用程序的性能。这些值大块称为向量，AVX向量最多可以包含256位数据。</p><p>常见的AVX向量包含4个double (4 x 64位&#x3D; 256)，8个float (8 x 32位&#x3D; 256)或8个int (8 x 32位&#x3D; 256)。[double 8B, flout 4B, int 4B]</p><p>一个示例将演示AVX&#x2F;AVX2处理的强大功能。假设一个函数需要将一个数组的8个浮点数乘以第二个数组的8个浮点数，并将结果添加到第三个数组。如果没有向量化，函数可能是这样的:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">multiply_and_add</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>* a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>* b, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>* c, <span class="hljs-keyword">float</span>* d) &#123;  <br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++) &#123;<br>    d[i] = a[i] * b[i];<br>    d[i] = d[i] + c[i];<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>下面是使用AVX2函数的例子:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__m256 <span class="hljs-title">multiply_and_add</span><span class="hljs-params">(__m256 a, __m256 b, __m256 c)</span> </span>&#123;<br><br>  <span class="hljs-keyword">return</span> _mm256_fmadd_ps(a, b, c);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>This AVX2 intrinsic funtion <strong>_mm256_fmadd_ps</strong>处理24个floats，但它不映射到单个指令。相反，它执行三个指令:<strong>vfmadd132ps</strong>、<strong>vfmadd213ps</strong>和<strong>vfmadd231ps</strong>。尽管如此，它执行得很快，比遍历单个元素快得多。</p><p>尽管英特尔的intrinsics功能强大，但它们还是让许多程序员感到紧张。这通常有两个原因。首先，数据类型有奇怪的名字，比如**__m256<strong>。其次，函数有奇怪的名称，如</strong>_mm256_fmadd_ps**。因此，在详细讨论intrinsic funtions之前，我想先讨论一下Intel的数据类型和命名约定。</p><h2 id="5-AVX编程基础"><a href="#5-AVX编程基础" class="headerlink" title="5.AVX编程基础"></a>5.AVX编程基础</h2><p>本文主要关注AVX和AVX2提供的与数学相关的intrinsic functions。但在看函数之前，有三点很重要:</p><ul><li>Data types</li><li>Function naming conventions</li><li>Compiling AVX applications</li></ul><p>本节涉及这些要点，并提供一个简单的应用程序，用于一个向量减去另一个向量。</p><h3 id="5-1数据类型"><a href="#5-1数据类型" class="headerlink" title="5.1数据类型"></a>5.1数据类型</h3><p>少数intrinsic接受传统的数据类型，如<strong>int</strong>或<strong>float</strong>，但大多数intrinsic操作有特定的AVX和AVX2的数据类型。有六种主要的向量类型，表1列出了它们。</p><p><strong>Table 1:AVX&#x2F;AVX2 Data Types</strong></p><table><thead><tr><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td><code>__m128</code></td><td>128-bit vector containing 4 <code>float</code>s</td></tr><tr><td><code>__m128d</code></td><td>128-bit vector containing 2 <code>double</code>s</td></tr><tr><td><code>__m128i</code></td><td>128-bit vector containing integers</td></tr><tr><td><code>__m256</code></td><td>256-bit vector containing 8 <code>float</code>s</td></tr><tr><td><code>__m256d</code></td><td>256-bit vector containing 4 <code>double</code>s</td></tr><tr><td><code>__m256i</code></td><td>256-bit vector containing integers</td></tr></tbody></table><p>每种类型都以两个下划线、一个m和向量的宽度(以位为单位)开始。AVX512支持以_m512开头的512位向量类型，但AVX&#x2F;AVX2向量不超过256位。如果向量类型以d结尾，则代表double，如果没有后缀，则代表float。看起来_m128i和_m256i向量必须包含int型，但事实并非如此。整数向量类型可以包含任何类型的整数，from chars to shorts to unsigned long longs.That is, an _m256i may contain 32 chars, 16 shorts, 8 ints, or 4 longs.  These integers can be signed or unsigned.</p><h3 id="5-3函数命名约定"><a href="#5-3函数命名约定" class="headerlink" title="5.3函数命名约定"></a>5.3函数命名约定</h3><p>AVX&#x2F;AVX2 intrinsics的名称一开始可能令人困惑，但命名约定确是非常直白的。一旦你理解了它，你就可以通过看它的名字来大致判断一个函数是做什么的。AVX&#x2F;AVX2 intrinsics的一般形式如下:</p><p>_mm<bit_width>_<name>_<data_type></data_type></name></bit_width></p><p>该格式的各部分如下所示:</p><ol><li><code>&lt;bit_width&gt;</code> identifies the size of the vector returned by the function. For 128-bit vectors, this is empty. For 256-bit vectors, this is set to <code>256</code>.</li><li><code>&lt;name&gt;</code> describes the operation performed by the intrinsic</li><li><code>&lt;data_type&gt;</code> identifies the data type of the function’s primary arguments</li></ol><p>最后一部分<data_type>有点复杂。它标识输入值的内容，可以设置为以下任何值:</data_type></p><ul><li><code>ps</code> - vectors contain <code>float</code>s (<code>ps</code> stands for packed single-precision)</li><li><code>pd</code> - vectors contain <code>double</code>s (<code>pd</code> stands for packed double-precision)</li><li><code>epi8/epi16/epi32/epi64</code> - vectors contain 8-bit&#x2F;16-bit&#x2F;32-bit&#x2F;64-bit signed integers</li><li><code>epu8/epu16/epu32/epu64</code> - vectors contain 8-bit&#x2F;16-bit&#x2F;32-bit&#x2F;64-bit unsigned integers</li><li><code>si128</code>&#x2F;<code>si256</code> - unspecified 128-bit vector or 256-bit vector</li><li><code>m128/m128i/m128d/m256/m256i/m256d</code> - identifies input vector types when they’re different than the type of the returned vector</li></ul><p>例如，考虑_mm256_srlv_epi64。即使您不知道srlv是什么意思，_mm256前缀告诉您该函数返回一个256位向量，_epi64告诉您参数包含64位有符号整数。</p><p>作为第二个示例，考虑_mm_testnzc_ps。_mm表示函数返回一个128位的向量。末尾的_ps表示参数向量包含浮点数。</p><p>AVX数据类型以两个下划线和一个m开头。函数以一个下划线和两个m开头。我很容易搞混这一点，所以我想出了一种方法来记住它们的区别:数据类型代表内存（<strong>m</strong>emory），函数代表多媒体操作（<strong>m</strong>ulti<strong>m</strong>edia）。这是我能做的最好的了。</p><h3 id="5-4构建AVX应用程序"><a href="#5-4构建AVX应用程序" class="headerlink" title="5.4构建AVX应用程序"></a>5.4构建AVX应用程序</h3><p>要构建使用AVX intrinsic的应用程序，不需要链接任何库。但是您需要包含<strong>imminrin .h</strong>头文件。此头文件包括将AVX&#x2F;AVX2函数映射到指令的其他头文件。</p><p>hello_avx.c中的代码显示了一个基本的AVX应用程序的样子:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>  <span class="hljs-comment">/* Initialize the two argument vectors */</span><span class="hljs-comment">//初始化</span><br>  __m256 evens = _mm256_set_ps(<span class="hljs-number">2.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">8.0</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">12.0</span>, <span class="hljs-number">14.0</span>, <span class="hljs-number">16.0</span>);<br>  __m256 odds = _mm256_set_ps(<span class="hljs-number">1.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">9.0</span>, <span class="hljs-number">11.0</span>, <span class="hljs-number">13.0</span>, <span class="hljs-number">15.0</span>);<br><br>  <span class="hljs-comment">/* Compute the difference between the two vectors */</span><br>  __m256 result = _mm256_sub_ps(evens, odds);<span class="hljs-comment">//减法</span><br><br>  <span class="hljs-comment">/* Display the elements of the result vector */</span><br>  <span class="hljs-keyword">float</span>* f = (<span class="hljs-keyword">float</span>*)&amp;result;<span class="hljs-comment">//类型转换</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f %f %f %f %f %f %f %f\n&quot;</span>,<br>    f[<span class="hljs-number">0</span>], f[<span class="hljs-number">1</span>], f[<span class="hljs-number">2</span>], f[<span class="hljs-number">3</span>], f[<span class="hljs-number">4</span>], f[<span class="hljs-number">5</span>], f[<span class="hljs-number">6</span>], f[<span class="hljs-number">7</span>]);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>要构建应用程序，需要告诉编译器该体系结构支持AVX。这个标志取决于编译器，gcc需要-mavx标志。因此，可以使用以下命令编译hello_avx.c源文件:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gcc -mavx -o hello_avx hello_avx.c<br></code></pre></div></td></tr></table></figure><p>在本例中，所有函数都以_mm256开始，以_ps结束，因此我希望所有操作都清楚地涉及包含floats的256位向量。我还希望结果向量中的每个元素都等于1.0。如果运行应用程序，您将看到情况就是这样。</p><p>[这就是一个简单的向量减法例子，大家可以对应数据看一下]</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000<br></code></pre></div></td></tr></table></figure><h3 id="5-5初始化intrinsics"><a href="#5-5初始化intrinsics" class="headerlink" title="5.5初始化intrinsics"></a>5.5初始化intrinsics</h3><p>在对AVX向量进行操作之前，需要用数据填充向量。因此，本文讨论的第一组intrinsics用数据初始化向量。有两种方法:用标量值初始化向量和用从内存加载的数据初始化向量。</p><h4 id="5-5-1使用标量值初始化"><a href="#5-5-1使用标量值初始化" class="headerlink" title="5.5.1使用标量值初始化"></a>5.5.1使用标量值初始化</h4><p>AVX提供了将一个或多个值组合成256位向量的intrinsics funtions。表2列出了它们的名称，并提供了每个名称的描述。也有类似的intrinsics初始化128位向量，但它们是由SSE提供的，而不是AVX。函数名的唯一区别是_mm256_被替换为_mm_。</p><p><strong>Table 2: Initialization Intrinsics</strong></p><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>_mm256_setzero_ps/pd</code></td><td>Returns a floating-point vector filled with zeros</td></tr><tr><td><code>_mm256_setzero_si256</code></td><td>Returns an integer vector whose bytes are set to zero</td></tr><tr><td><code>_mm256_set1_ps/pd</code></td><td>Fill a vector with a floating-point value</td></tr><tr><td><code>_mm256_set1_epi8/epi16</code> <code>_mm256_set1_epi32/epi64</code></td><td>Fill a vector with an integer</td></tr><tr><td><code>_mm256_set_ps/pd</code></td><td>Initialize a vector with eight floats (ps) or four doubles (pd)</td></tr><tr><td><code>_mm256_set_epi8/epi16</code> <code>_mm256_set_epi32/epi64</code></td><td>Initialize a vector with integers</td></tr><tr><td><code>_mm256_set_m128/m128d/</code> <code>_mm256_set_m128i</code></td><td>Initialize a 256-bit vector with two 128-bit vectors</td></tr><tr><td><code>_mm256_setr_ps/pd</code></td><td>Initialize a vector with eight floats (ps) or four doubles (pd) in reverse order</td></tr><tr><td><code>_mm256_setr_epi8/epi16</code> <code>_mm256_setr_epi32/epi64</code></td><td>Initialize a vector with integers in reverse order</td></tr></tbody></table><p>表中的第一个函数是最容易理解的。_m256_setzero_ps返回一个__m256向量，包含8个设置为0的浮点数。类似地，_m256_setzero_si256返回一个__m256i向量，其字节被设置为0。例如，下面这行代码创建了一个256位的向量，其中包含4个设为0的double:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">_m256d dbl_vector = _m256_setzero_pd();<br></code></pre></div></td></tr></table></figure><p>名称中包含set1的函数接受一个值，并在整个向量中重复该值。例如，下面这行代码创建了一个__m256i，它的16个short value被设置为47:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">_m256i short_vector = _m256_set1_pd();<br></code></pre></div></td></tr></table></figure><p>表2中的其他函数包含_set_或_setr_。这些函数接受一系列值，每个向量的元素对应一个值。这些值被放置在返回的向量中，理解顺序很重要。下面的函数调用返回一个包含8个整数的向量，其值范围为1到8:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">_m256i int_vector = _m256_set_epi32(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br></code></pre></div></td></tr></table></figure><p>您可能希望值按照给定的顺序存储。但英特尔的架构是<strong>小端</strong>存储类型的[这里很重要]，所以最低有效值(8)先存储，最高有效值(1)最后存储。您可以通过将int_vector转换为int指针并打印存储的值来验证这一点。如下代码所示:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256i int_vector = _mm256_set_epi32(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br><span class="hljs-keyword">int</span> *ptr = (<span class="hljs-keyword">int</span>*)&amp;int_vector;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d %d %d %d %d\n&quot;</span>, ptr[<span class="hljs-number">0</span>], ptr[<span class="hljs-number">1</span>], ptr[<span class="hljs-number">2</span>], ptr[<span class="hljs-number">3</span>], ptr[<span class="hljs-number">4</span>], ptr[<span class="hljs-number">5</span>], ptr[<span class="hljs-number">6</span>], ptr[<span class="hljs-number">7</span>]);<br>--&gt; <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>如果希望值按给定顺序存储，可以使用_setr_函数之一创建向量，其中r可能代表reverse。下面的代码展示了它是如何工作的:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256i int_vector = _mm256_setr_epi32(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br><span class="hljs-keyword">int</span> *ptr = (<span class="hljs-keyword">int</span>*)&amp;int_vector;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d %d %d %d %d\n&quot;</span>, ptr[<span class="hljs-number">0</span>], ptr[<span class="hljs-number">1</span>], ptr[<span class="hljs-number">2</span>], ptr[<span class="hljs-number">3</span>], ptr[<span class="hljs-number">4</span>], ptr[<span class="hljs-number">5</span>], ptr[<span class="hljs-number">6</span>], ptr[<span class="hljs-number">7</span>]);<br>--&gt; <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure><p>有趣的是，AVX和AVX2都没有提供用无符号整数初始化向量的intrinsic。但是，它们提供了对带无符号整数的向量进行操作的函数。</p><h4 id="5-5-2从内存加载数据"><a href="#5-5-2从内存加载数据" class="headerlink" title="5.5.2从内存加载数据"></a>5.5.2从内存加载数据</h4><p>AVX&#x2F;AVX2的一个常见用法是将数据从内存加载到向量中，对向量进行处理，并将结果存储回内存。第一步是使用表3中列出的intrinsic funtions完成的。最后两个函数前面有(2)，因为它们是由AVX2而不是AVX提供的。</p><p><strong>Table 3: Vector Load Intrinsics</strong></p><table><thead><tr><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td><code>_mm256_load_ps/pd</code></td><td>Loads a floating-point vector from an  aligned memory address</td></tr><tr><td><code>_mm256_load_si256</code></td><td>Loads an integer vector from an aligned memory address</td></tr><tr><td><code>_mm256_loadu_ps/pd</code></td><td>Loads a floating-point vector from an  unaligned memory address</td></tr><tr><td><code>_mm256_loadu_si256</code></td><td>Loads an integer vector from an unaligned memory address</td></tr><tr><td><code>_mm_maskload_ps/pd</code> <code>_mm256_maskload_ps/pd</code></td><td>Load portions of a 128-bit&#x2F;256-bit floating-point vector according to a mask</td></tr><tr><td><code>(2)_mm_maskload_epi32/64</code> <code>(2)_mm256_maskload_epi32/64</code></td><td>Load portions of a 128-bit&#x2F;256-bit integer vector according to a mask</td></tr></tbody></table><p>当将数据加载到向量中时，内存对齐变得特别重要。每个<strong>_mm256_load_</strong>* intrinsic接受一个必须在32字节边界上对齐的内存地址。即地址必须能被32整除。下面的代码展示了如何在实践中使用它:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">float</span>* aligned_floats = (<span class="hljs-keyword">float</span>*)<span class="hljs-built_in">aligned_alloc</span>(<span class="hljs-number">32</span>, <span class="hljs-number">64</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>));<span class="hljs-comment">//这里使用了内存对齐</span><br>... Initialize data ...<br>__m256 vec = _mm256_load_ps(aligned_floats);<br></code></pre></div></td></tr></table></figure><p>【个人补充】关于内存对齐以及相关函数</p><p><a href="https://xingyuanjie.top/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">内存对齐 - Amicoyuan (xingyuanjie.top)</a></p><p><a href="https://xingyuanjie.top/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/">AVX向量化学习(二)-内存对齐的应用 - Amicoyuan (xingyuanjie.top)</a></p><p>任何使用_m256_load_*加载未对齐数据的尝试都会造成<strong>segmentation fault</strong>。如果数据不是以32位边界对齐，则应该使用_m256_loadu_*函数。如下代码所示:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">float</span>* unaligned_floats = (<span class="hljs-keyword">float</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>));<span class="hljs-comment">//未使用内存对齐</span><br>... Initialize data ...<br>__m256 vec = _mm256_loadu_ps(unaligned_floats);<br></code></pre></div></td></tr></table></figure><p>假设你想用AVX向量处理一个浮点数组(float)，但是数组的长度是11，不能被8整除。在这种情况下，第二个__m256向量的最后五个浮点数需要设置为0[或者使用非向量计算手段]，这样它们就不会影响计算。这种选择性加载可以用表3底部的**_maskload_**函数来完成。</p><p>每个_maskload_函数接受两个参数:一个内存地址和一个与返回向量元素数量相同的整数向量。对于整数向量中最高位为1的每个元素，将从内存中读取返回向量中相应的元素。如果整数向量中的最高位为零，则返回向量中的相应元素被设置为零。</p><p>一个示例将说明如何使用这些函数。mask_load.c中的代码将8个整型读入一个向量，最后3个应该设置为0。要使用的函数是_mm256_maskload_epi32，它的第二个参数应该是__m256i掩码向量。这个掩码向量包含5个最高位为1的整数和3个最高位为0的整数。下面是代码的样子:</p><p>【int型在计算机的存储是补码，正数的补码最高位为0，所以这里返回0，负数的补码最高位为1，所以这里返回的是内存中相应的元素】</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>  <span class="hljs-keyword">int</span> i;<br>  <br>  <span class="hljs-keyword">int</span> int_array[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>, <span class="hljs-number">600</span>, <span class="hljs-number">700</span>, <span class="hljs-number">800</span>&#125;;<br>  <br>  <span class="hljs-comment">/* Initialize the mask vector */</span><br>  __m256i mask = _mm256_setr_epi32(<span class="hljs-number">-20</span>, <span class="hljs-number">-72</span>, <span class="hljs-number">-48</span>, <span class="hljs-number">-9</span>, <span class="hljs-number">-100</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>);<span class="hljs-comment">//这里需要充分理解计算机组成原理中的补码</span><br><br>  <span class="hljs-comment">/* Selectively load data into the vector */</span><br>  __m256i result = _mm256_maskload_epi32(int_array, mask);<br>  <br>  <span class="hljs-comment">/* Display the elements of the result vector */</span><br>  <span class="hljs-keyword">int</span>* res = (<span class="hljs-keyword">int</span>*)&amp;result;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d %d %d %d %d\n&quot;</span>, <br>    res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>], res[<span class="hljs-number">2</span>], res[<span class="hljs-number">3</span>], res[<span class="hljs-number">4</span>], res[<span class="hljs-number">5</span>], res[<span class="hljs-number">6</span>], res[<span class="hljs-number">7</span>]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果您在支持AVX2的系统上运行此应用程序，它将打印以下结果:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">100</span> <span class="hljs-number">200</span> <span class="hljs-number">300</span> <span class="hljs-number">400</span> <span class="hljs-number">500</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>有三点是需要注意的：</p><ol><li>代码使用_setr_函数而不是_set_来设置掩码向量的内容，因为它在将向量元素传递给函数时对它们进行排序。</li><li>负整数的最高位总是1。这就是掩码向量包含五个负数和三个正数的原因。</li><li>_mm256_maskload_epi32函数由AVX2提供，而不是AVX。因此，要用gcc编译这段代码，必须使用-mavx2标志而不是-mavx。</li></ol><p>除了表3中列出的函数之外，AVX2还提供了从内存加载索引数据的集合函数。</p><h2 id="6-Arithmetic-Intrinsics"><a href="#6-Arithmetic-Intrinsics" class="headerlink" title="6.Arithmetic Intrinsics"></a>6.Arithmetic Intrinsics</h2><p>数学是AVX存在的主要原因，基本操作是加、减、乘和除。本节将介绍执行这些操作的intrinsic funtions，还将介绍AVX2提供的新的融合乘法和加法函数。</p><h3 id="6-1加法和减法"><a href="#6-1加法和减法" class="headerlink" title="6.1加法和减法"></a>6.1加法和减法</h3><p>表4列出了执行加法和减法的AVX&#x2F;AVX2 intrinsic。由于考虑到饱和度，它们大多数都作用于包含整数的向量。</p><p><strong>Table 4: Addition and Subtraction Intrinsics</strong></p><table><thead><tr><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td><code>_mm256_add_ps/pd</code></td><td>Add two floating-point vectors</td></tr><tr><td><code>_mm256_sub_ps/pd</code></td><td>Subtract two floating-point vectors</td></tr><tr><td><code>(2)_mm256_add_epi8/16/32/64 </code></td><td>Add two integer vectors</td></tr><tr><td><code>(2)_mm236_sub_epi8/16/32/64</code></td><td>Subtract two integer vectors</td></tr><tr><td><code>(2)_mm256_adds_epi8/16</code> <code>(2)_mm256_adds_epu8/16 </code></td><td>Add two integer vectors with saturation</td></tr><tr><td><code>(2)_mm256_subs_epi8/16</code> <code>(2)_mm256_subs_epu8/16</code></td><td>Subtract two integer vectors with saturation</td></tr><tr><td><code>_mm256_hadd_ps/pd</code></td><td>Add two floating-point vectors horizontally</td></tr><tr><td><code>_mm256_hsub_ps/pd</code></td><td>Subtract two floating-point vectors horizontally</td></tr><tr><td><code>(2)_mm256_hadd_epi16/32</code></td><td>Add two integer vectors horizontally</td></tr><tr><td><code>(2)_mm256_hsub_epi16/32</code></td><td>Subtract two integer vectors horizontally</td></tr><tr><td><code>(2)_mm256_hadds_epi16</code></td><td>Add two vectors containing shorts horizontally with saturation</td></tr><tr><td><code>(2)_mm256_hsubs_epi16</code></td><td>Subtract two vectors containing shorts horizontally with saturation</td></tr><tr><td><code>_mm256_addsub_ps/pd</code></td><td>Add and subtract two floating-point vectors</td></tr></tbody></table><p>加法和减法整数向量时，重要的是要查看_add_&#x2F;_sub_函数和_adds_&#x2F;_subs_函数之间的区别。额外的s代表饱和，当结果需要的内存超过向量可以存储的内存时，就会产生饱和。Functions that take saturation into account clamp the result to the minimum&#x2F;maximum value that can be stored.没有饱和的函数在发生饱和时忽略内存问题。</p><p>例如，假设一个向量包含有符号字节，那么每个元素的最大值是127 (0x7F)。如果一个运算将98加到85，数学和是183 (0xB7)。</p><ul><li>如果使用_mm256_add_epi8添加这些值，饱和度将被忽略，存储的结果将是-73 (0xB7)。</li><li>如果使用_mm256_adds_epi8添加这些值，结果将被固定为最大值127 (0x7F)。</li></ul><p>作为另一个例子，考虑两个包含有符号短整数的向量。最小值为-32,768。如果计算-18,000 - 19,000，数学结果是-37,000 (0xFFFF6F78作为32位整数)。</p><ul><li>如果用_mm256_sub_epi16减去这些值，饱和度将被忽略，存储的结果将是28,536 (0x6F78)。</li><li>如果用_mm256_subs_epi16减去这些值，结果将被压缩到最小值-32,768 (0x8000)。</li></ul><p>_hadd_&#x2F;_hsub_函数水平执行加法和减法。也就是说，它们不是添加或减去不同向量的元素，而是在每个向量中添加或减去<strong>相邻</strong>的元素。结果以交错的方式存储。图1显示了_mm256_hadd_pd的工作原理，它水平地添加了两个向量A和B:</p><p><img src="/2023/03/10/avx006/Fig1.jpg" alt="Image 1"></p><p><strong>Figure 1: Horizontal Addition of Two Vectors</strong></p><p>水平加减元素看起来可能很奇怪，但这些操作在复数相乘时很有用。本文稍后将对此进行解释。表4中的最后一个函数_mm256_addsub_ps&#x2F;pd交替减法和加法两个浮点向量的元素。也就是说，偶数元素被减去，奇数元素被加上。例如，如果vec_a包含(0.1,0.2,0.3,0.4)，vec_b包含(0.5,0.6,0.7,0.8)，则_mm256_addsub_pd(vec_a, vec_b)等于(-0.4,0.8，-0.4,1.2)【需要注意数组下标从0开始】。</p><h3 id="6-2乘法和除法"><a href="#6-2乘法和除法" class="headerlink" title="6.2乘法和除法"></a>6.2乘法和除法</h3><p>表5列出了执行乘法和除法的AVX&#x2F;AVX2 intrinsic。与加法和减法一样，对整数进行运算也有一些特殊的特性。</p><p><strong>Table 5: Multiplication and Division Intrinsics</strong></p><table><thead><tr><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td><code>_mm256_mul_ps/pd</code></td><td>Multiply two floating-point vectors</td></tr><tr><td><code>(2)_mm256_mul_epi32/</code> <code>(2)_mm256_mul_epu32 </code></td><td>Multiply the lowest four elements of vectors containing 32-bit integers</td></tr><tr><td><code>(2)_mm256_mullo_epi16/32</code></td><td>Multiply integers and store low halves</td></tr><tr><td><code>(2)_mm256_mulhi_epi16/</code> <code>(2)_mm256_mulhi_epu16</code></td><td>Multiply integers and store high halves</td></tr><tr><td><code>(2)_mm256_mulhrs_epi16</code></td><td>Multiply 16-bit elements to form 32-bit elements</td></tr><tr><td><code>_mm256_div_ps/pd</code></td><td>Divide two floating-point vectors</td></tr></tbody></table><p>如果两个N位的数字在计算机上相乘，结果可以占用2N位【这里你需要熟悉计算机组成原理中的乘法原理，同时思考会不会在某些函数出现精度损失的情况】。因此，只有_mm256_mul_epi32和_mm256_mul_epu32的四个低元素被乘在一起，结果是一个包含四个长整数的向量。</p><p><strong>___m256i _mm256_mul_epi32 (m256i a, __m256i b)</strong></p><p><strong>Description</strong></p><p>Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst.</p><p><strong>Operation</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">FOR</span> j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span> <br><span class="hljs-attribute">i</span> := j*<span class="hljs-number">64</span> <br><span class="hljs-attribute">dst</span>[i+<span class="hljs-number">63</span>:i] := SignExtend<span class="hljs-number">64</span>(a[i+<span class="hljs-number">31</span>:i]) * SignExtend<span class="hljs-number">64</span>(b[i+<span class="hljs-number">31</span>:i]) <br><span class="hljs-attribute">ENDFOR</span> <br><span class="hljs-attribute">dst</span>[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>图2:整数向量的低元素相乘</strong></p><p>_mullo_函数类似于整数_mul_函数，但它们不是乘低元素，而是乘两个向量的每个元素，只存储每个乘积的低一半。</p><p><strong>Synopsis</strong></p><p><strong>m256i _mm256_mullo_epi32 (m256i a, __m256i b)</strong><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmulld ymm, ymm, ymm<br>CPUID Flags: AVX2</p><p><strong>Description</strong></p><p>Multiply the packed signed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst.</p><p><strong>Operation</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">FOR</span> j := <span class="hljs-number">0</span> to <span class="hljs-number">7</span> <br><span class="hljs-attribute">i</span> := j*<span class="hljs-number">32</span> <br><span class="hljs-attribute">tmp</span>[<span class="hljs-number">63</span>:<span class="hljs-number">0</span>] := a[i+<span class="hljs-number">31</span>:i] * b[i+<span class="hljs-number">31</span>:i] <br><span class="hljs-attribute">dst</span>[i+<span class="hljs-number">31</span>:i] := tmp[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] <br><span class="hljs-attribute">ENDFOR</span> <br><span class="hljs-attribute">dst</span>[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>图3:整数相乘和存储低二分之一</strong></p><p>_mm256_mulhi_epi16和_mm256_mulhi_epu16 intrinsics类似，但是它们存储整数积的高一半。</p><p><strong>Synopsis</strong></p><p><strong>m256i _mm256_mulhi_epi16 (m256i a, __m256i b)</strong><br>#include &lt;immintrin.h&gt;<br>Instruction: vpmulhw ymm, ymm, ymm<br>CPUID Flags: AVX2</p><p><strong>Description</strong></p><p>Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst.</p><p><strong>Operation</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">FOR</span> j := <span class="hljs-number">0</span> to <span class="hljs-number">15</span> <br><span class="hljs-attribute">i</span> := j*<span class="hljs-number">16</span> <br><span class="hljs-attribute">tmp</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] := SignExtend<span class="hljs-number">32</span>(a[i+<span class="hljs-number">15</span>:i]) * SignExtend<span class="hljs-number">32</span>(b[i+<span class="hljs-number">15</span>:i])       dst[i+<span class="hljs-number">15</span>:i] := tmp[<span class="hljs-number">31</span>:<span class="hljs-number">16</span>] <br><span class="hljs-attribute">ENDFOR</span> <br><span class="hljs-attribute">dst</span>[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="6-3Fused-Multiply-and-Add-FMA"><a href="#6-3Fused-Multiply-and-Add-FMA" class="headerlink" title="6.3Fused Multiply and Add (FMA)"></a>6.3Fused Multiply and Add (FMA)</h3><p>如前所述，两个N位数字相乘的结果可以占用2N位。因此，当您将两个浮点值a和b相乘时，结果实际上是四舍五入(a * b)，其中四舍五入(x)返回最接近x的浮点值。随着进一步操作的执行，这种精度损失会增加。【这里需要注意分部乘加，先乘法后加法和使用FMA两者的计算精度】</p><p>AVX2提供了将乘法和加法融合在一起的指令。也就是说，它们不是返回整数(整数(a * b) + c)，而是返回整数(a * b + c)。因此，这些指令比分别执行乘法和加法提供了更高的速度和准确性【这里正是FMA的特点】。</p><p>表6列出了AVX2提供的FMA intrinsic，并包括对每个函数的描述。表中的每条指令都接受三个输入向量，我把它们分别称为a、b和c。</p><p><strong>Table 6: FMA Intrinsics</strong></p><table><thead><tr><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td><code>(2)_mm_fmadd_ps/pd/</code> <code>(2)_mm256_fmadd_ps/pd</code></td><td>Multiply two vectors and add the product to a third (res &#x3D; a * b + c)</td></tr><tr><td><code>(2)_mm_fmsub_ps/pd/</code> <code>(2)_mm256_fmsub_ps/pd</code></td><td>Multiply two vectors and subtract a vector from the product (res &#x3D; a * b - c)</td></tr><tr><td><code>(2)_mm_fmadd_ss/sd </code></td><td>Multiply and add the lowest element in the vectors (res[0] &#x3D; a[0] * b[0] + c[0])</td></tr><tr><td><code>(2)_mm_fmsub_ss/sd</code></td><td>Multiply and subtract the lowest element in the vectors (res[0] &#x3D; a[0] * b[0] - c[0])</td></tr><tr><td><code>(2)_mm_fnmadd_ps/pd</code> <code>(2)_mm256_fnmadd_ps/pd </code></td><td>Multiply two vectors and add the negated product to a third (res &#x3D; -(a * b) + c)</td></tr><tr><td><code>(2)_mm_fnmsub_ps/pd/</code> <code>(2)_mm256_fnmsub_ps/pd</code></td><td>Multiply two vectors and add the negated product to a third (res &#x3D; -(a * b) - c)</td></tr><tr><td><code>(2)_mm_fnmadd_ss/sd</code></td><td>Multiply the two lowest elements and add the negated product to the lowest element of the third vector (res[0] &#x3D; -(a[0] * b[0]) + c[0])</td></tr><tr><td><code>(2)_mm_fnmsub_ss/sd</code></td><td>Multiply the lowest elements and subtract the lowest element of the third vector from the negated product (res[0] &#x3D; -(a[0] * b[0]) - c[0])</td></tr><tr><td><code>(2)_mm_fmaddsub_ps/pd/</code> <code>(2)_mm256_fmaddsub_ps/pd</code></td><td>Multiply two vectors and alternately add and subtract from the product (res &#x3D; a * b - c)</td></tr><tr><td><code>(2)_mm_fmsubadd_ps/pd/</code> <code>(2)_mmf256_fmsubadd_ps/pd </code></td><td>Multiply two vectors and alternately subtract and add from the product (res &#x3D; a * b - c)</td></tr></tbody></table><p>如果一个内征的名称以_ps或_pd结尾，则输入向量的每个元素都包含在运算中。如果intrinsic的名称以_ss或_sd结尾，则只包括最低的元素。输出向量中的其余元素被设置为与第一个输入向量中的元素相等。例如,假设vec_a &#x3D; (1.0, 2.0)， vec_b &#x3D; (5.0, 10.0)， vec_c &#x3D;(7.0, 14.0)。在本例中，_mm_fmadd_sd(vec_a, vec_b, vec_c)返回(12.0,2.0)，因为(1.0 * 5.0)+ 7.0 &#x3D; 12.0,2.0是vec_a的第二个元素。</p><p>了解_fmadd_&#x2F;_fmsub_和_fnmadd_&#x2F;_fnmsub_ intrinsic之间的区别很重要。后一种函数在加上或减去第三个输入向量之前，对前两个输入向量的乘积求反。</p><p><strong>Synopsis</strong></p><p><strong>__m256d _mm256_fnmadd_pd (m256d a, m256d b, m256d c)</strong><br>#include &lt;immintrin.h&gt;<br>Instruction: vfnmadd132pd ymm, ymm, ymm<br>       vfnmadd213pd ymm, ymm, ymm<br>       vfnmadd231pd ymm, ymm, ymm<br>CPUID Flags: FMA</p><p><strong>Description</strong></p><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">FOR</span> j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span> <br><span class="hljs-attribute">i</span> := j*<span class="hljs-number">64</span> <br><span class="hljs-attribute">dst</span>[i+<span class="hljs-number">63</span>:i] := -(a[i+<span class="hljs-number">63</span>:i] * b[i+<span class="hljs-number">63</span>:i]) + c[i+<span class="hljs-number">63</span>:i] <br><span class="hljs-attribute">ENDFOR</span> <br><span class="hljs-attribute">dst</span>[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>_fmaddsub_和_fmsubadd_内在函数在第三个向量的加法和减法元素之间交替使用。_fmaddsub_ intrinsic奇数元素做加法而偶数元素做减法。_fmsubadd_ intrinsic奇数元素做减法而偶数元素做加法。fmatest.c中的代码展示了如何在实践中使用_mm256_fmaddsub_pd intrinsic。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>  __m256d veca = _mm256_setr_pd(<span class="hljs-number">6.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">6.0</span>);<br><br>  __m256d vecb = _mm256_setr_pd(<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>);<br>  <br>  __m256d vecc = _mm256_setr_pd(<span class="hljs-number">7.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">7.0</span>);<br>  <br>  <span class="hljs-comment">/* Alternately subtract and add the third vector</span><br><span class="hljs-comment">     from the product of the first and second vectors */</span><br>  __m256d result = _mm256_fmaddsub_pd(veca, vecb, vecc);<br>  <br>  <span class="hljs-comment">/* Display the elements of the result vector */</span><br>  <span class="hljs-keyword">double</span>* res = (<span class="hljs-keyword">double</span>*)&amp;result;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf %lf %lf %lf\n&quot;</span>, res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>], res[<span class="hljs-number">2</span>], res[<span class="hljs-number">3</span>]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当这段代码在支持AVX2的处理器上编译和执行时，打印的结果如下:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5.000000</span> <span class="hljs-number">19.000000</span> <span class="hljs-number">5.000000</span> <span class="hljs-number">19.000000</span><br></code></pre></div></td></tr></table></figure><p>FMA指令是由AVX2提供的，因此您可能认为使用gcc构建应用程序需要使用-mavx2标志。但是我发现-mfma标志是<strong>必需</strong>的。否则，我会得到奇怪的编译错误。</p><h2 id="7-Permuting-and-Shuffling"><a href="#7-Permuting-and-Shuffling" class="headerlink" title="7.Permuting and Shuffling"></a>7.Permuting and Shuffling</h2><p>许多应用程序必须重新排列向量元素，以确保正确执行操作。</p><p>AVX&#x2F;AVX2为此目的提供了许多intrinsic funtion，其中两大类是_permute_函数和_shuffle_函数。本节介绍这两种类型的intrinsic。</p><h3 id="7-1Permuting"><a href="#7-1Permuting" class="headerlink" title="7.1Permuting"></a>7.1Permuting</h3><p>AVX提供了返回一个向量的函数，该向量包含一个向量的重新排列的元素。表7列出了这些排列函数，并提供了对每个函数的描述。</p><p><strong>Table 7: Permute Intrinsics</strong></p><table><thead><tr><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td><code>_mm_permute_ps/pd/</code> <code>_mm256_permute_ps/pd</code></td><td>Select elements from the input vector based on an 8-bit control value</td></tr><tr><td><code>(2)_mm256_permute4x64_pd/</code> <code>(2)_mm256_permute4x64_epi64</code></td><td>Select 64-bit elements from the input vector based on an 8-bit control value</td></tr><tr><td><code>_mm256_permute2f128_ps/pd</code></td><td>Select 128-bit chunks from two input vectors based on an 8-bit control value</td></tr><tr><td><code>_mm256_permute2f128_si256 </code></td><td>Select 128-bit chunks from two input vectors based on an 8-bit control value</td></tr><tr><td><code>_mm_permutevar_ps/pd</code> <code>_mm256_permutevar_ps/pd </code></td><td>Select elements from the input vector based on bits in an integer vector</td></tr><tr><td><code>(2)_mm256_permutevar8x32_ps</code>&#x2F; <code>(2)_mm256_permutevar8x32_epi32</code></td><td>Select 32-bit elements (<code>float</code>s and <code>int</code>s) using indices in an integer vector</td></tr></tbody></table><p>_permute_ intrinsic接受两个参数:一个输入向量和一个8位控制值。控制值的位决定输入向量的哪个元素插入到输出中。</p><p>对于_mm256_permute_ps，每对控制位通过选择输入向量中的一个上或下元素来确定一个上或下输出元素。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>  __m128 v1 = _mm_setr_ps(<span class="hljs-number">2.3</span>, <span class="hljs-number">4.1</span>, <span class="hljs-number">6.2</span>, <span class="hljs-number">8.4</span>);<br>  <span class="hljs-keyword">float</span> * a =(<span class="hljs-keyword">float</span>*)&amp;v1;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">4</span> ;i++)<br>   &#123;<br>    cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>   &#125;<br>   cout&lt;&lt;endl;<br>   __m128 v2 = _mm_permute_ps (v1, <span class="hljs-number">3</span>);<br>   <span class="hljs-keyword">float</span> * b =(<span class="hljs-keyword">float</span>*)&amp;v2;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">4</span> ;i++)<br>   &#123;<br>    cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>   &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">3</span> <span class="hljs-number">4</span>.<span class="hljs-number">1</span> <span class="hljs-number">6</span>.<span class="hljs-number">2</span> <span class="hljs-number">8</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">8</span>.<span class="hljs-number">4</span> <span class="hljs-number">2</span>.<span class="hljs-number">3</span> <span class="hljs-number">2</span>.<span class="hljs-number">3</span> <span class="hljs-number">2</span>.<span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p><strong>Figure 4: Operation of the Permute Intrinsic Function</strong></p><p>如图所示，输入向量的值可以在输出中重复多次。其他输入值可能根本不被选择。</p><p>在_mm256_permute_pd中，控制值的低四位在相邻的双精度数对之间进行选择。_mm256_permute4x4_pd类似，但使用所有控制位来选择将哪个64位元素放在输出中。在_permute2f128_ intrinsic中，控制值从两个输入向量中选择128位块，而不是从一个输入向量中选择元素。</p><p>_permutevar_ intrinsic执行与_permute_ intrinsic相同的操作。但是它们不是使用8位控制值来选择元素，而是依赖于与输入向量大小相同的整数向量。例如，_mm256_permute_ps的输入向量是_mm256，因此整数向量是_mm256i。整数向量的高位执行选择的方式与_permute_ intrinsic的8位控制值的位相同。</p><h3 id="7-2Shuffling"><a href="#7-2Shuffling" class="headerlink" title="7.2Shuffling"></a>7.2Shuffling</h3><p>像_permute_ intrinsic一样，_shuffle_ intrinsic从一个或两个输入向量中选择元素，并将它们放在输出向量中。表8列出了这些功能，并提供了每个功能的描述。</p><p><strong>Table 8: Shuffle Intrinsics</strong></p><table><thead><tr><th>Data Type</th><th>Description</th></tr></thead><tbody><tr><td><code>_mm256_shuffle_ps/pd</code></td><td>Select floating-point elements according to an 8-bit value</td></tr><tr><td><code>_mm256_shuffle_epi8/</code> <code>_mm256_shuffle_epi32</code></td><td>Select integer elements according to an 8-bit value</td></tr><tr><td><code>(2)_mm256_shufflelo_epi16/ </code> <code>(2)_mm256_shufflehi_epi16</code></td><td>Select 128-bit chunks from two input vectors based on an 8-bit control value</td></tr></tbody></table><p>所有的shuffle_ intrinsic运算于256位向量。在每种情况下，最后一个参数是一个8位的值，它决定哪些输入元素应该放在输出向量中。</p><p>对于_mm256_shuffle_ps，只使用控件值的高四位。如果输入向量包含整型或浮点数，则使用所有控制位。对于_mm256_shuffle_ps，前两对位选择第一个向量中的元素，后两对位选择第二个向量中的元素。</p><p><strong>Synopsis</strong></p><p><strong>m256 _mm256_shuffle_ps (m256 a, __m256 b, const int imm8)</strong><br>#include &lt;immintrin.h&gt;<br>Instruction: vshufps ymm, ymm, ymm, imm8<br>CPUID Flags: AVX</p><p><strong>Description</strong></p><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">DEFINE SELECT4(<span class="hljs-attribute">src</span>, control) &#123; <br>CASE(control<span class="hljs-selector-attr">[1:0]</span>) OF <br><span class="hljs-number">0</span>:tmp<span class="hljs-selector-attr">[31:0]</span> := <span class="hljs-attribute">src</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] <br><span class="hljs-number">1</span>:tmp<span class="hljs-selector-attr">[31:0]</span> := <span class="hljs-attribute">src</span>[<span class="hljs-number">63</span>:<span class="hljs-number">32</span>] <br><span class="hljs-number">2</span>:tmp<span class="hljs-selector-attr">[31:0]</span> := <span class="hljs-attribute">src</span>[<span class="hljs-number">95</span>:<span class="hljs-number">64</span>] <br><span class="hljs-number">3</span>:tmp<span class="hljs-selector-attr">[31:0]</span> := <span class="hljs-attribute">src</span>[<span class="hljs-number">127</span>:<span class="hljs-number">96</span>] <br>ESAC <br>RETURN tmp<span class="hljs-selector-attr">[31:0]</span> <br>&#125; <br>dst<span class="hljs-selector-attr">[31:0]</span> := SELECT4(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[127:0]</span>, imm8<span class="hljs-selector-attr">[1:0]</span>) <br>dst<span class="hljs-selector-attr">[63:32]</span> := SELECT4(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[127:0]</span>, imm8<span class="hljs-selector-attr">[3:2]</span>) <br>dst<span class="hljs-selector-attr">[95:64]</span> := SELECT4(<span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[127:0]</span>, imm8<span class="hljs-selector-attr">[5:4]</span>) <br>dst<span class="hljs-selector-attr">[127:96]</span> := SELECT4(<span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[127:0]</span>, imm8<span class="hljs-selector-attr">[7:6]</span>) <br>dst<span class="hljs-selector-attr">[159:128]</span> := SELECT4(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[255:128]</span>, imm8<span class="hljs-selector-attr">[1:0]</span>) <br>dst<span class="hljs-selector-attr">[191:160]</span> := SELECT4(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[255:128]</span>, imm8<span class="hljs-selector-attr">[3:2]</span>) <br>dst<span class="hljs-selector-attr">[223:192]</span> := SELECT4(<span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[255:128]</span>, imm8<span class="hljs-selector-attr">[5:4]</span>) <br>dst<span class="hljs-selector-attr">[255:224]</span> := SELECT4(<span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[255:128]</span>, imm8<span class="hljs-selector-attr">[7:6]</span>) <br>dst<span class="hljs-selector-attr">[MAX:256]</span> := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>为了shuffle16位值，AVX2提供了_mm256_shufflelo_epi16和_mm256_shufflehi_epi16。与_mm256_shuffle_ps一样，控制值被分成四对从八个元素中选择的位。但是对于_mm256_shufflelo_epi16, 8个元素是从8个低的16位值中取出的。对于_mm256_shufflehi_epi16, 8个元素取自8个高的16位值。</p><h2 id="8-Complex-Multiplication"><a href="#8-Complex-Multiplication" class="headerlink" title="8.Complex Multiplication"></a>8.Complex Multiplication</h2><p>在信号处理应用中，复数乘法是一项必须反复执行的耗时操作。我不会深入讨论这个理论，但每个复数都可以表示为a + bi，其中a和b是浮点值，i是-1的平方根。A是实部，b是虚部。如果(a + bi)和(c + di)相乘，乘积等于(ac - bd) + (ad + bc)i。</p><p>复数可以以交错的方式存储，这意味着每个实数部分后面跟着虚数部分。假设vec1是一个__m256d，存储两个复数(a + bi)和(x + yi)， vec2是一个__m256d，存储(c + di)和(z + wi)。图6说明了如何存储这些值。如图所示，prod向量存储了两个产物:(ac - bd) + (ad + bc)i和(xz - yw) + (xw + yz)i。</p><p>【图片丢失】</p><p><strong>Figure 6: Complex Multiplication Using Vectors</strong></p><p>我不知道用AVX&#x2F;AVX2计算复杂乘积的最快方法。但我想出了一个方法，效果很好。它包括五个步骤:</p><ol><li>将vec1和vec2相乘，并将结果存储在vec3中。</li><li>切换vec2的实&#x2F;虚值。</li><li>求vec2的虚数的负数。</li><li>将vec1和vec2相乘，并将结果存储在vec4中。</li><li>对vec3和vec4进行水平相减，得到vec1中的答案。</li></ol><p>complex_multi .c中的代码展示了如何使用AVX intrinsic执行此操作:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>  __m256d vec1 = _mm256_setr_pd(<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">13.0</span>, <span class="hljs-number">6.0</span>);<br>  __m256d vec2 = _mm256_setr_pd(<span class="hljs-number">9.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>);<br>  __m256d neg = _mm256_setr_pd(<span class="hljs-number">1.0</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">-1.0</span>);<br>  <br>  <span class="hljs-comment">/* Step 1: Multiply vec1 and vec2 */</span><br>  __m256d vec3 = _mm256_mul_pd(vec1, vec2);<br><br>  <span class="hljs-comment">/* Step 2: Switch the real and imaginary elements of vec2 */</span><br>  vec2 = _mm256_permute_pd(vec2, <span class="hljs-number">0x5</span>);<br>  <br>  <span class="hljs-comment">/* Step 3: Negate the imaginary elements of vec2 */</span><br>  vec2 = _mm256_mul_pd(vec2, neg);  <br>  <br>  <span class="hljs-comment">/* Step 4: Multiply vec1 and the modified vec2 */</span><br>  __m256d vec4 = _mm256_mul_pd(vec1, vec2);<br><br>  <span class="hljs-comment">/* Horizontally subtract the elements in vec3 and vec4 */</span><br>  vec1 = _mm256_hsub_pd(vec3, vec4);<br>  <br>  <span class="hljs-comment">/* Display the elements of the result vector */</span><br>  <span class="hljs-keyword">double</span>* res = (<span class="hljs-keyword">double</span>*)&amp;vec1;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf %lf %lf %lf\n&quot;</span>, res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>], res[<span class="hljs-number">2</span>], res[<span class="hljs-number">3</span>]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">21</span>.<span class="hljs-number">000000</span> <span class="hljs-number">57</span>.<span class="hljs-number">000000</span> <span class="hljs-number">36</span>.<span class="hljs-number">000000</span> <span class="hljs-number">127</span>.<span class="hljs-number">000000</span><br></code></pre></div></td></tr></table></figure><p>这段代码作用于双向量，但是可以很容易地扩展该方法以支持浮点向量。</p><h2 id="9-Points-of-Interest"><a href="#9-Points-of-Interest" class="headerlink" title="9.Points of Interest"></a>9.Points of Interest</h2><p>许多开发人员可能会避免学习AVX&#x2F;AVX2，希望编译器能够执行自动向量化。自动向量化是一个很好的特性，但是如果您了解本质，就可以重新安排算法以更好地利用SIMD处理。通过插入AVX&#x2F;AVX2 intrinsic，我极大地提高了信号处理应用程序的处理速度。</p><h2 id="10-History"><a href="#10-History" class="headerlink" title="10.History"></a>10.History</h2><p>2&#x2F;20 - Fixed formatting and image links</p><p>4&#x2F;2 - Fixed a couple typographical errors</p><h2 id="11-License"><a href="#11-License" class="headerlink" title="11.License"></a>11.License</h2><p>This article, along with any associated source code and files, is licensed under <a href="http://www.codeproject.com/info/cpol10.aspx">The Code Project Open License (CPOL)</a></p><p>Written By</p><p><strong><a href="https://www.codeproject.com/Members/mattscar">Matt Scarpino</a></strong></p><p><img src="/2023/03/10/avx006/US.gif" alt="United States"> United States</p><p>I’ve been a programmer and engineer for over 20 years. I’m a certified Azure Developer Associate and an Azure IoT Developer Specialist.</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
      <tag>AVX2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA使用二维网格和二位块对矩阵求和</title>
    <link href="/2023/03/09/cuda015/"/>
    <url>/2023/03/09/cuda015/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA使用二维网格和二位块对矩阵求和"><a href="#CUDA使用二维网格和二位块对矩阵求和" class="headerlink" title="CUDA使用二维网格和二位块对矩阵求和"></a>CUDA使用二维网格和二位块对矩阵求和</h2><p>在本节中，我们将使用一个二维网格和二位块来编写一个矩阵加法核函数。首先，应该编写一个校验主函数以验证矩阵加法核函数是否能得出正确的结果：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sumMatrixOnhost</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, <span class="hljs-keyword">float</span> *C, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> nx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ny)</span></span>&#123;<br>    <span class="hljs-keyword">float</span> *ia = A;<br>    <span class="hljs-keyword">float</span> *ib = B;<br>    <span class="hljs-keyword">float</span> *ic = C;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> iy=<span class="hljs-number">0</span>;iy&lt;ny;iy++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> ix=<span class="hljs-number">0</span>;ix&lt;nx;ix++)&#123;<br>            ic[ix]=ia[ix]+ib[ix];<br>        &#125;<br>        ia += nx;<br>        ib += nx;<br>        ic += nx;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后，创建一个新的核函数，目的是采用一个二维线程块来进行矩阵求和：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">sumMatrixOnGPU2D</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *MatA, <span class="hljs-keyword">float</span> *MatB, <span class="hljs-keyword">float</span> *MatC, <span class="hljs-keyword">int</span> nx, <span class="hljs-keyword">int</span> ny)</span></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ix = threadIdx.x + blockIdx.x * blockDim.x;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> iy = threadIdx.y + blockIdx.y * blockDim.y;<br>    ubsigned <span class="hljs-keyword">int</span> idx = iy*nx + ix;<br>    <br>    <span class="hljs-keyword">if</span>(ix &lt; nx &amp;&amp; iy &lt;ny)<br>        MatC[idx] = MatA[idx] + MatB[idx];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个核函数的关键步骤是将每个线程从它的线程索引映射到全局线性内存索引中，如图2-12所示。</p><p>接下来，每个维度下的矩阵大小可以按如下方法设置为16384个元素：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> nx = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>;<br><span class="hljs-keyword">int</span> ny = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>;<br></code></pre></div></td></tr></table></figure><p>然后，使用一个二维网格和二维块按如下方法设置核函数的执行配置：</p><p><img src="/2023/03/09/cuda015/image-20230309125059653.png" alt="image-20230309125059653"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> dimx = <span class="hljs-number">32</span>;<br><span class="hljs-keyword">int</span> dimy = <span class="hljs-number">32</span>;<br><span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(dimx, dimy)</span></span>;<br><span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">((nx + block.x - <span class="hljs-number">1</span>)/block.x, (ny + block.y - <span class="hljs-number">1</span>)/block.y)</span></span>;<br></code></pre></div></td></tr></table></figure><p>把所有的代码整合到名为sumMatrixOnGPU-2D-grid-2D-block.cu的文件中。主函数代码如代码清单2-7所示。</p><p>代码清单2-7 使用一个二维网格和二维块的矩阵加法(sumMatrixOnGPU-2D-grid-2D-block.cu)</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s Starting...\n&quot;</span>,zrgv[<span class="hljs-number">0</span>]);<br>    <br>    <span class="hljs-comment">//set up device</span><br>    <span class="hljs-keyword">int</span> dev = <span class="hljs-number">0</span>;<br>    cudaDeviceProp deviceProp;<br>    <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">cudaGetDeviceProperties</span>(&amp;deviceProp, dev));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Using Device %d: %s\n&quot;</span>,dev, deviceProp.name);<br>    <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">cudaSetDevice</span>(dev));<br>    <br>    <span class="hljs-comment">//set up data size of matrix</span><br>    <span class="hljs-keyword">int</span> nx = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">int</span> ny = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>;<br>    <br>    <span class="hljs-keyword">int</span> nxy = nx*ny;<br>    <span class="hljs-keyword">int</span> nBytes = nxy *<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Matrix size: nx %d ny %d\n&quot;</span>,nx,ny);<br>    <br>    <span class="hljs-comment">//malloc host memory</span><br>    <span class="hljs-keyword">float</span> *h_A, *h_B, *hostRef, *gpuRef;<br>    h_A = (<span class="hljs-keyword">float</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    h_B = (<span class="hljs-keyword">float</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    hostRef = (<span class="hljs-keyword">float</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    gpuRef = (<span class="hljs-keyword">float</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    <br>    <span class="hljs-comment">//initialize data at host side</span><br>    <span class="hljs-keyword">double</span> iStart = <span class="hljs-built_in">cpuSecond</span>();<br>    <span class="hljs-built_in">initialData</span> (h_A, nxy);<br>    <span class="hljs-built_in">initialData</span> (h_B, nxy);<br>    <span class="hljs-keyword">double</span> iElaps = <span class="hljs-built_in">cpuSecond</span>() - iStart;<br>    <br>    <span class="hljs-built_in">memset</span>(hostRef, <span class="hljs-number">0</span>, nBytes);<br>    <span class="hljs-built_in">memset</span>(gpuRef, <span class="hljs-number">0</span>, nBytes);<br>    <br>    <span class="hljs-comment">//add matrix at host side for result checks</span><br>    iStart = <span class="hljs-built_in">cpuSecond</span>();<br>    <span class="hljs-built_in">sumMatrixOnHost</span> (h_A, h_B, hostRef, nx,ny);<br>    iElaps = <span class="hljs-built_in">cpuSecond</span>() - iStart;<br>    <br>    <span class="hljs-comment">//malloc device global memory</span><br>    <span class="hljs-keyword">float</span> *d_MatA, *d_MatB, *d_MatC;<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">void</span> **)&amp;d_MatA,nBytes);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">void</span> **)&amp;d_MatB,nBytes);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">void</span> **)&amp;d_MatC,nBytes);<br>    <br>    <span class="hljs-comment">//transfer data from host to device</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(d_MatA, h_A, nBytes, cudaMemcpyHostToDevice);<br>    <span class="hljs-built_in">cudaMemcpy</span>(d_MatB, h_B, nBytes, cudaMemcpyHostToDevice);<br>    <br>    <span class="hljs-comment">//invoke kernel at host side</span><br>    <span class="hljs-keyword">int</span> dimx = <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">int</span> dimy = <span class="hljs-number">32</span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(dimx,dimy)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">((nx+block.x<span class="hljs-number">-1</span>)/block.x,(ny+block.y<span class="hljs-number">-1</span>)/block.y)</span></span>;<br>    <br>    iStart = <span class="hljs-built_in">cpuSecond</span>();<br>    sumMatrixOnGPU2D&lt;&lt;&lt;grid,block&gt;&gt;&gt;(d_MatA, d_MatB, d_MatC, nx,ny);<br>    <span class="hljs-built_in">cudaDeviceSynchronize</span>();<br>    iElaps = <span class="hljs-built_in">cpuSecond</span>() - iStart;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sumMatrixOnGPU2D&lt;&lt;&lt;(%d,%d),(%d,%d)&gt;&gt;&gt; elapsed %f sec\n&quot;</span>,grid.x, grid.y, block.x,block.y,iElaps);<br>    <br>    <span class="hljs-comment">//copy kernel result back to host side</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(gpuRef, d_MatC, nBytes, cudaMemcpyDeviceToHost);<br>    <br>    <span class="hljs-comment">//check device results</span><br>    <span class="hljs-built_in">checkResult</span>(hostRef, gpuRef,nxy);<br>    <br>    <span class="hljs-comment">//free device global memory</span><br>    <span class="hljs-built_in">cudaFree</span>(d_MatA);<br>    <span class="hljs-built_in">cudaFree</span>(d_MatB);<br>    <span class="hljs-built_in">cudaFree</span>(d_MatC);<br>    <br>    <span class="hljs-comment">//free host memory</span><br>    <span class="hljs-built_in">free</span>(h_A);<br>    <span class="hljs-built_in">free</span>(h_B);<br>    <span class="hljs-built_in">free</span>(hostRef);<br>    <span class="hljs-built_in">free</span>(gpuRef);<br>    <br>    <span class="hljs-comment">//reset device</span><br>    <span class="hljs-built_in">cudaDeviceReset</span>();<br>    <br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125; <br></code></pre></div></td></tr></table></figure><p>用以下命令编译并运行该代码：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc -arch=sm_20 sumMatrixOnGPU-2D-grid-2D-block.cu -o matrix2D<br>./matrix2D<br></code></pre></div></td></tr></table></figure><p>在Tesla M2070上运行的结果：</p><p><img src="/2023/03/09/cuda015/image-20230309224513603.png" alt="image-20230309224513603"></p><p>接下来，调整块的尺寸为32×16并重新编译和运行该代码。核函数的执行速度几乎快了两倍：</p><p><img src="/2023/03/09/cuda015/image-20230309224626772.png" alt="image-20230309224626772"></p><p>你可能好奇为什么只是改变了执行配置，内核性能就几乎翻了一倍。直观地说，你可能会觉得这是因为第二次配置的线程块数是第一次配置块数的两倍，所以并行性也是两倍。你的直觉是正确的，但是，如果进一步减小块的大小变为16×16，相比第一次配置你已经将块的数量翻了四倍。如下所示，这种配置比第一个结果好但是不如第二个。</p><p><img src="/2023/03/09/cuda015/image-20230309224912499.png" alt="image-20230309224912499"></p><p>表2-3总结了不同执行配置的性能。结果显示，增加块的数量不一定能提升内核性能。</p><p><img src="/2023/03/09/cuda015/image-20230309225004531.png" alt="image-20230309225004531"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA使用块和线程建立矩阵索引</title>
    <link href="/2023/03/09/cuda014/"/>
    <url>/2023/03/09/cuda014/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA使用块和线程建立矩阵索引"><a href="#CUDA使用块和线程建立矩阵索引" class="headerlink" title="CUDA使用块和线程建立矩阵索引"></a>CUDA使用块和线程建立矩阵索引</h2><p>通常情况下，一个矩阵用行优先的方法在全局内存中进行线性存储。图2-9所示的是一个8×6矩阵的小例子。</p><p>在一个矩阵加法核函数中，一个线程通常被分配一个数据元素来处理。首先要完成的任务是使用块和线程索引从全局内存中访问指定的数据。通常情况下，对一个二维示例来说，需要管理3种索引。</p><p><img src="/2023/03/09/cuda014/image-20230309113733674.png" alt="image-20230309113733674"></p><ul><li>线程和块索引</li><li>矩阵中给定点的坐标</li><li>全局线性内存中的偏移量</li></ul><p>对于一个给定的线程，首先可以通过把线程和块索引映射到矩阵坐标上来获取线程块和线程索引的全局内存偏移量，然后将这些矩阵坐标映射到全局内存的存储单元中。</p><p>第一步，可以用以下公式把线程和块索引映射到矩阵坐标上：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">ix = threadIdx.x + blockIdx.x * blockDim.x;<br>iy = threadIdx.y + blockIdx.y * blockDim.y;<br></code></pre></div></td></tr></table></figure><p>第二步，可以用以下公式把矩阵坐标映射到全局内存中的索引&#x2F;存储单元上:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">idx = iy * nx + ix<br></code></pre></div></td></tr></table></figure><p>图2-10说明了块和线程索引，矩阵坐标以及线性全局内存索引之间的对应关系。</p><p><img src="/2023/03/09/cuda014/image-20230309114815497.png" alt="image-20230309114815497"></p><p>printThreadInfo函数被用于输出关于每个线程的以下信息：</p><ul><li>线程索引</li><li>块索引</li><li>矩阵坐标</li><li>线性全局内存偏移量</li><li>相应元素的值</li></ul><p>用以下命令编译并运行该程序：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc -arch=sm_20 checkThreadIndex.cu -o checkIndex<br>./checkIndex<br></code></pre></div></td></tr></table></figure><p>对于每个线程，你可以获取以下信息：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">thread_id</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<span class="hljs-built_in">block_id</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<span class="hljs-built_in">coordinate</span>(<span class="hljs-number">6</span>,<span class="hljs-number">1</span>)global index <span class="hljs-number">14</span> ival <span class="hljs-number">14</span><br></code></pre></div></td></tr></table></figure><p>图2-11说明了这三项索引之间的关系。</p><p><img src="/2023/03/09/cuda014/image-20230309115229368.png" alt="image-20230309115229368"></p><p>代码清单2-6 检查块和线程索引（checkT和readIndex.cu）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#inclde <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHECK(call)</span><br>&#123;<br>    <span class="hljs-keyword">const</span> cudaError_t error = call;<br>    <span class="hljs-keyword">if</span>(error != cudaSuccess)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: %s:%d, &quot;</span>,__FILE__, __LINE__);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;code:%d, reason: %s\n&quot;</span>,error, <span class="hljs-built_in">cudaGetErrorString</span>(error));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-10</span>*error);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p, <span class="hljs-keyword">int</span> size)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        ip[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMateix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *C,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> nx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ny)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> *ic = C;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nMatrix:(%d.%d)\n&quot;</span>.nx,ny);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> iy=<span class="hljs-number">0</span>;iy&lt;ny;iy++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> ix=<span class="hljs-number">0</span>; ix&lt;nx;ix++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3d&quot;</span>,ic[ix]);<br>        &#125;<br>        ic += nx;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">printThreadIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *A, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> nx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ny)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ix = threadIdx.x + blockIdx.x * blockDim.x;<br>    <span class="hljs-keyword">int</span> iy = threadIdx.y + blockIdx.y * blockDim.y;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> idx = iy*nx + ix;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_id (%d,%d) block_id (%d,%d) coordinate (%d,%d) global index %2d ival %2d\n&quot;</span>, threadIdx.x, threadIdx.y, blockIdx.x,blockIdx.y,ix,iy,idx,A[idx]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s Starting...\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>    <br>    <span class="hljs-comment">//get device information</span><br>    <span class="hljs-keyword">int</span> dev = <span class="hljs-number">0</span>;<br>    cudaDeviceProp deviceProp;<br>    <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">cudaGetDeviceProperties</span>(&amp;deviceProp, dev));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Using Device %d: %s\n&quot;</span>, dev, deviceProp.name);<br>    <br>    <span class="hljs-comment">//set matrix dimension</span><br>    <span class="hljs-keyword">int</span> nx = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">int</span> ny = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">int</span> nxy = nx*ny;<br>    <span class="hljs-keyword">int</span> nBytes = nxy * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>);<br>    <br>    <span class="hljs-comment">//malloc host memory</span><br>    <span class="hljs-keyword">int</span> *h_A;<br>    h_A = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    <br>    <span class="hljs-comment">//initialize host matrix with interger</span><br>    <span class="hljs-built_in">initialInt</span>(h_A, nxy);<br>    <span class="hljs-built_in">printMatrix</span>(h_A, nx, ny);<br>    <br>    <span class="hljs-comment">//malloc device memory</span><br>    <span class="hljs-keyword">int</span> *d_MatA;<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">void</span>**)&amp;d_MatA, nBytes);<br>    <br>    <span class="hljs-comment">//transfer data from host to device</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(d_MatA, h_A, nBytes, cudaMemcpyHostToDevice);<br>    <br>    <span class="hljs-comment">//set up execution configuration</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">((nx+block.x<span class="hljs-number">-1</span>)/block.x,(ny+block.y<span class="hljs-number">-1</span>)/block.y)</span></span>;<br>    <br>    <span class="hljs-comment">//invoke the kernel</span><br>    printThreadIndex&lt;&lt;&lt;grid,block&gt;&gt;&gt;(d_MatA,nx,ny);<br>    <span class="hljs-built_in">cudaDeviceSynchronize</span>();<br>    <br>    <span class="hljs-comment">//free host and device memory</span><br>    <span class="hljs-built_in">cudaFree</span>(d_MatA);<br>    <span class="hljs-built_in">free</span>(h_A);<br>    <br>    <span class="hljs-comment">//reset device</span><br>    <span class="hljs-built_in">cudaDeviceReset</span>();<br>    <br>    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA组织并行编程</title>
    <link href="/2023/03/08/cuda013/"/>
    <url>/2023/03/08/cuda013/</url>
    
    <content type="html"><![CDATA[<h2 id="组织并行编程"><a href="#组织并行编程" class="headerlink" title="组织并行编程"></a>组织并行编程</h2><p>从前面的例子可以看出，如果使用了合适的网格和块大小来正确地组织线程，那么可以对内核性能产生很大的影响。在向量加法的例子中，为了实现最佳性能我们调整了块的大小，并基于块大小和向量数据大小计算出了网格大小。</p><p>现在通过一个矩阵加法的例子说明这一点。对于矩阵运算，传统的方法是在内核中使用一个包含二维网格与二位块的布局来组织线程。但是，这种传统的方法无法获得最佳性能。在矩阵加法中使用以下布局将有助于了解更多关于网格和块的启发性的用法：</p><ol><li>有二维线程块构成的二维网格</li><li>由一维线程块构成的一维网格</li><li>由一维线程块构成的二维网格</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA给核函数计时</title>
    <link href="/2023/03/07/CUDA012/"/>
    <url>/2023/03/07/CUDA012/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA给核函数计时"><a href="#CUDA给核函数计时" class="headerlink" title="CUDA给核函数计时"></a>CUDA给核函数计时</h2><p>在内核的性能转换过程中，了解核函数的执行需要多长时间是很有帮助并且十分关键的。衡量核函数性能的方法有很多。最简单的方法是在主机端使用一个CPU或GPU计时器来计算内核的执行时间。在本节，你需要设置一个CPU计时器，并使用NVIDIA分析工具来计算执行时间。</p><h3 id="用CPU计时器计时"><a href="#用CPU计时器计时" class="headerlink" title="用CPU计时器计时"></a>用CPU计时器计时</h3><p>可以使用gettimeofday系统调用来创建一个CPU计时器，以获取系统的时钟时间，它将返回自1970年1月1日零点以来，到现在的秒数。程序中需要添加sys&#x2F;time.h头文件，如代码清单2-5所示。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cpuSecond</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tp</span>;</span><br>    <span class="hljs-built_in">gettimeofday</span>(&amp;tp,<span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">double</span>)tp.tv_sec + (<span class="hljs-keyword">double</span>)tp.tv_usec*<span class="hljs-number">1.e-6</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>你可以用cpuSecond函数来测试你的核函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> iStart = <span class="hljs-built_in">cpuSecond</span>();<br>kernel_name&lt;&lt;&lt;grid,block&gt;&gt;&gt;(argument list);<br><span class="hljs-built_in">cudaDeviceSynchronize</span>();<br><span class="hljs-keyword">double</span> iElaps = <span class="hljs-built_in">cpuSecond</span>() - iStart;<br></code></pre></div></td></tr></table></figure><p>由于核函数调用与主机端程序是异步的，你需要用cudaDeviceSynchronize函数来等待所有的GPU线程运行结束。变量iElaps表示程序运行的时间，就像你用手表记录的核函数的执行时间（用秒计算）。</p><p>现在，通过设置数据集大小来对一个有16M个元素的大向量进行测试：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> nElem = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">24</span>;<br></code></pre></div></td></tr></table></figure><p>由于GPU的可扩展性，你需要借助块和线程的索引来计算一个按行优先的数组索引 i ，并对核函数进行修改，添加限定条件（i &lt; N）来检验索引值是否越界，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">sumArraysOnGPU</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, <span class="hljs-keyword">float</span> *C, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-keyword">if</span>( n &lt; N) C[i] = A[i] + B[i];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>有了这些更改，可以使用不同的执行配置来衡量核函数。为了解决创建的线程总数大于向量元素总数的情况，你需要限制内核不能非法访问全局内存，如图2-7所示。</p><p><img src="/2023/03/07/CUDA012/image-20230307120643741.png" alt="image-20230307120643741"></p><p>代码清单2-5展示了如何在主函数中用CPU计时器测试向量加法的核函数。</p><p>代码清单2-5测试向量加法的核函数（sumArraysOnGPU-timer.cu）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s Starting...\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>    <br>    <span class="hljs-comment">//set up device</span><br>    <span class="hljs-keyword">int</span> dev = <span class="hljs-number">0</span>;<br>    cudaDeviceProp deviceProp;<br>    <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">cudaGetDeviceProperties</span>(&amp;deviceProp, dev));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Using Device %d: %s\n&quot;</span>, dev, deviceProp.name);<br>    <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">cudaSetDevice</span>(dev));<br>    <br>    <span class="hljs-comment">//set up data size of vectors</span><br>    <span class="hljs-keyword">int</span> nElem = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">24</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Vector size %d\n&quot;</span>,nElem);<br>    <br>    <span class="hljs-comment">//malloc host memory</span><br>    <span class="hljs-keyword">size_t</span> nBytes = nElem * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>);<br>    <br>    <span class="hljs-keyword">float</span> *h_A, *h_B, *hostRef, *gpuRef;<br>    h_A = (<span class="hljs-keyword">float</span>*)<span class="hljs-built_in">malloc</span>(nBytes);<br>    h_B = (<span class="hljs-keyword">float</span>*)<span class="hljs-built_in">malloc</span>(nBytes);<br>    hostRef = (<span class="hljs-keyword">float</span>*)<span class="hljs-built_in">malloc</span>(nBytes);<br>    gpuRef = (<span class="hljs-keyword">float</span>*)<span class="hljs-built_in">malloc</span>(nBytes);<br>    <br>    <span class="hljs-keyword">double</span> iStart,iElaps;<br>    <br>    <span class="hljs-comment">//initialize data at host side</span><br>    iStart = <span class="hljs-built_in">cpuSecond</span>();<br>    <span class="hljs-built_in">initialData</span>(h_A, nElem);<br>    <span class="hljs-built_in">initialData</span>(h_B, nElem);<br>    iElaps = <span class="hljs-built_in">cpuSecond</span>() - iStart;<br>    <br>    <span class="hljs-built_in">memset</span>(hostRef, <span class="hljs-number">0</span> ,nBytes);<br>    <span class="hljs-built_in">memset</span>(gpuRef, <span class="hljs-number">0</span> ,nBytes);<br>    <br>    <span class="hljs-comment">//add vector at host side for result checks</span><br>    iStart = <span class="hljs-built_in">cpuSecond</span>();<br>    <span class="hljs-built_in">sumArraysOnHost</span>(h_A, h_B, hostRef, nElem);<br>    iElaps = <span class="hljs-built_in">cpuSecond</span>() - iStart;<br>    <br>    <span class="hljs-comment">//malloc device global memory</span><br>    <span class="hljs-keyword">float</span> *d_A, *d_B, *d_C;<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_A, nBytes);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_B, nBytes);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_C, nBytes);<br>    <br>    <span class="hljs-comment">//transfer data from host to device</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(d_A, h_A, nBytes, cudaMemcpyHostTodevice);<br>    <span class="hljs-built_in">cudaMemcpy</span>(d_B, h_B, nBytes, cudaMemcpyHostTodevice);<br>    <br>    <span class="hljs-comment">//invoke kernel at host side</span><br>    <span class="hljs-keyword">int</span> iLen = <span class="hljs-number">1024</span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(iLen)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">((nElem+block.x<span class="hljs-number">-1</span>))</span>/block.x)</span>;<br>    <br>    iStart = <span class="hljs-built_in">cpuSecond</span>();<br>    sumArraysOnGPU&lt;&lt;&lt;grid,block&gt;&gt;&gt;(d_A, d_B, d_C,nElem);<br>    <span class="hljs-built_in">cudaDeviceSynchronize</span>();<br>    iElaps = <span class="hljs-built_in">cpuSecond</span>() - iStart;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sumArraysOnGPU&lt;&lt;&lt;%d,%d&gt;&gt;&gt; Time elapsed %f sec\n&quot;</span>,grid.x, block.x, iElaps);<br>    <br>    <span class="hljs-comment">//copy kernel result back to host side</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost);<br>    <br>    <span class="hljs-comment">//check device results</span><br>    <span class="hljs-built_in">checkResult</span>(hostRef, gpuRef, nElem);<br>    <br>    <span class="hljs-comment">//free device global memory</span><br>    <span class="hljs-built_in">cudaFree</span>(d_A);<br>    <span class="hljs-built_in">cudaFree</span>(d_B);<br>    <span class="hljs-built_in">cudaFree</span>(d_C);<br>    <br>    <span class="hljs-comment">//free host memory</span><br>    <span class="hljs-built_in">free</span>(h_A);<br>    <span class="hljs-built_in">free</span>(h_B);<br>    <span class="hljs-built_in">free</span>(hostRef);<br>    <span class="hljs-built_in">free</span>(gpuRef);<br>    <br>    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>默认的执行配置被设置为一个包含16384个块的一维网格，每个块包含1024个线程。用以下命令编译并运行程序：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc sumArraysOnGPU-timer.cu -o sumArraysOnGPU-timer<br>./sumArraysOnGPU-timer<br></code></pre></div></td></tr></table></figure><p>在基于英特尔Sandy Bridge架构的系统上进行测试，从代码清单2-5的示例中可以看出，在GPU上进行的向量加法的运算速度是在CPU上运行向量加法的3.86倍。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./sumArraysOnGPU-timer Starting...<br>Using Device 0:Tesia M2070<br>Vector size 16777216<br>sumArraysOnGPU&lt;&lt;&lt;16384, 1024&gt;&gt;&gt;Time elapsed 0.002456 sec<br>Arrays match.<br></code></pre></div></td></tr></table></figure><p>把块的维度减少到512可以创建32768个块。在这个新的配置下，内核的性能提升了1.19倍。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sumArraysOnGPU&lt;&lt;&lt;32768, 512&gt;&gt;&gt;Time elapsed 0.002058 sec<br></code></pre></div></td></tr></table></figure><p>如果进一步将块的维度降低到256，系统将提示以下错误信息，信息表示块的总数超过一维网格的限制。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./sumArraysOnGPU-timer Starting...<br>Using Device 0:Tesla M2070<br>Vector size 16777216<br>sumArraysOnGPU&lt;&lt;&lt;65536, 256&gt;&gt;&gt;  Time elapsed 0.000183 sec<br>Error: sumArraysOnGPU-timer.cu:153, code:9, reason: invalid configuration argument<br></code></pre></div></td></tr></table></figure><h3 id="了解自身局限性"><a href="#了解自身局限性" class="headerlink" title="了解自身局限性"></a>了解自身局限性</h3><p>在调整执行配置时需要了解的一个关键点是对网格和块维度的限制。线程层次结构中每个层次的最大尺寸取决于设备。</p><p>CUDA提供了通过查询GPU来了解这些限制的能力。</p><p>对于Fermi设备，每个块的最大线程数是1024，且网格的x,y,z三个方向上的维度最大值是65535</p><h3 id="用nvprof工具计时"><a href="#用nvprof工具计时" class="headerlink" title="用nvprof工具计时"></a>用nvprof工具计时</h3><p>自CUDA 5.0以来，NVIDIA提供了一个名为nvprof的命令行分析工具，可以帮助从应用程序的CPU和GPU活动情况中获取时间线信息，其包括内核执行，内存传输以及CUDA API的调用。其用法如下。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvprof [nvprof_args] &lt;application&gt;  [application_args]<br></code></pre></div></td></tr></table></figure><p>可以使用以下命令获取更多关于nvprof的帮助信息：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvprof --help<br></code></pre></div></td></tr></table></figure><p>你可以用如下命令去测试内核：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvprof  ./sumArraysOnGPU-timer<br></code></pre></div></td></tr></table></figure><p>nvprof的输出结果会因为你使用的GPU类型不同而有所差异。以下结果是从Tesla GPU中得到的：</p><p><img src="/2023/03/07/CUDA012/image-20230307142027522.png" alt="image-20230307142027522"></p><p>以上结果的前半部分来自于程序的输出，后半部分来自于nvprof的输出。可以注意到，CPU计时器显示消耗的内核时间为3.26ms，而nvprof显示消耗的内核时间为2.90ms。在这个例子中，nvprof的结果更为精确，因为CPU计时器测量的时间中包含了来自nvprof附加的时间。</p><p>nvprof是一个能帮助你理解在执行应用程序时所花费的时间主要用在何处的强大工具。可以注意到，在这个例子中，主机和设备之间的数据传输需要的时间比内核执行的时间要多。图2-8所描绘的时间线（未按比例绘制），显示了在CPU上消耗的时间，数据传输所用的时间以及在GPU上计算所用的时间。</p><p><img src="/2023/03/07/CUDA012/image-20230307145539161.png" alt="image-20230307145539161"></p><p>对于HPC工作负载，理解程序中通信比的计算是非常重要的。如果你的应用程序用于计算的时间大于数据传输所用的时间，那么或许可以压缩这些操作，并完全隐藏与传输数据有关的延迟。如果你的应用程序用于计算的时间少于数据传输所用的时间，那么需要尽量减少主机和设备之间的传输。</p><h3 id="比较应用程序的性能将理论界限最大化"><a href="#比较应用程序的性能将理论界限最大化" class="headerlink" title="比较应用程序的性能将理论界限最大化"></a>比较应用程序的性能将理论界限最大化</h3><p>在进行程序优化时，如何将应用程序和理论界限进行比较是很重要的。由nvprof得到的计数器可以帮助你获取应用程序的指令和内存吞吐量。如果将应用程序的测量值与理论峰值进行比较，可以判定你的应用程序的性能是受限于算法还是受限于内存带宽的。以Tesla K10为例，可以得到理论上的比率：</p><p>Tesla K10单精度峰值浮点运算次数</p><p>745 MHz核心频率*2 GPU&#x2F;芯片*  （8个多处理器<em>192个浮点单元</em>32核心&#x2F;多处理器）*2OPS&#x2F;周期 &#x3D; 4.58 TFLOPS （FLOPS表示每秒浮点运算次数）</p><p>Tesla K10内存带宽峰值</p><p>2 GPU&#x2F;芯片<em>256位</em>2500 MHz内存时钟*2 DDR&#x2F;8位&#x2F;字节 &#x3D; 320 GB&#x2F;s</p><p>指令比：字节</p><p>4.58 TFLOPS&#x2F;320 GB&#x2F;s,也就是13.6个指令：1个字节</p><p>对于Tesla K10而言，如果你的应用程序每访问一个字节所产生的指令数多于13.6，那么你的应用程序受算法性能限制。大多数HPC工作负载受内存带宽的限制。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归模型</title>
    <link href="/2023/03/06/ML001/"/>
    <url>/2023/03/06/ML001/</url>
    
    <content type="html"><![CDATA[<h2 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h2><h3 id="MOdel-Representation"><a href="#MOdel-Representation" class="headerlink" title="MOdel Representation"></a>MOdel Representation</h3><p><img src="/2023/03/06/ML001/image-20230306195956356.png" alt="image-20230306195956356"></p><h3 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h3><p>In this lab you will:</p><ul><li>learn to implement the model f_{w,b} for linear regression with one variable</li></ul><h3 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h3><p>Here is a summary of some of the notation you will encounter.</p><p><img src="/2023/03/06/ML001/image-20230306200250050.png" alt="image-20230306200250050"></p><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p>In this lab you will make use of:</p><ul><li><p>NumPy,a popular library for scientific computing</p></li><li><p>Matplotlib,a popular library for plotting data</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.style.use(<span class="hljs-string">&#x27;./deeplearning.mpstyle&#x27;</span>)<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p><img src="/2023/03/06/ML001/image-20230306200642937.png" alt="image-20230306200642937"></p><p>As in the lecture,you will use the motivating example of housing price prediction. This lab will use a simple data set with only two data points - a house with 1000 square feet(sqft) sold for $300,000 and a house with 2000 square feet sold for $500,000.These two points will constitute our data or training set. In this lab, the units of size are 1000 sqft and the units of price are 1000s of dollars.</p><table><thead><tr><th>Size (1000 sqft)</th><th>Price (1000s of dollars)</th></tr></thead><tbody><tr><td>1.0</td><td>300</td></tr><tr><td>2.0</td><td>500</td></tr></tbody></table><p>You would like to fit a linear regression model(shown above as the blue straight line)through these two points, so you can then predict price for other houses - say, a house with 1200 sqft.</p><p>Please run the following code cell to create your x_train and y_train variables. The data is stored in one-dimensional NumPy arrays.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#x_train is the input variable (size in 1000 square feet)</span><br><span class="hljs-comment">#y_train is the target (price in 1000s of dollars)</span><br>x_train = np.array([<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>])<br>y_train = np.array([<span class="hljs-number">300.0</span>,<span class="hljs-number">500.0</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;x_train = <span class="hljs-subst">&#123;x_train&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;y_train = <span class="hljs-subst">&#123;y_train&#125;</span>&quot;</span>)<br></code></pre></div></td></tr></table></figure><h3 id="Number-of-training-examples-m"><a href="#Number-of-training-examples-m" class="headerlink" title="Number of training examples m"></a>Number of training examples m</h3><p>you will use m to denote the number of training examples. Numpy arrays have a .shape parameter. x_train.shape return a python tuple with an entry for each dimension. x_train.shape[0] is the length of the array and number of examples as shown below.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># m is the number of training examples</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;x_train.shape: <span class="hljs-subst">&#123;x_train.shape&#125;</span>&quot;</span>)<br>m = x_train.shape[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Number of training example is: <span class="hljs-subst">&#123;m&#125;</span>&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>x.train.shape: (2,)</p><p>Number of training examples is: 2</p><p><strong>One can also use the Python len() function as shown below.</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># m is the number of training examples</span><br>m = <span class="hljs-built_in">len</span>(x_train)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Number of training example is: <span class="hljs-subst">&#123;m&#125;</span>&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>Number of training examples  is:2</p><h3 id="Training-example-x-i-y-i"><a href="#Training-example-x-i-y-i" class="headerlink" title="Training example x_i, y_i"></a>Training example x_i, y_i</h3><p>You will use (x(𝑖), y(𝑖)) to denote the 𝑖(th) training example. Since Python is zero indexed, (x(0), y(0) is (1.0, 300.0) and (x(1), y(1) is (2.0, 500.0).</p><p>To access a value in a Numpy array, one indexes the array with the desired offset. For example the syntax to access location zero of x_train is x_train[0]. Run the next code block below to get the i(th) training example.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">i = <span class="hljs-number">0</span> <span class="hljs-comment">#Change this to 1 to see (x^1,y^1)</span><br><br>x_i = x_train[i]<br>y_i = y_train[i]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(x^(<span class="hljs-subst">&#123;i&#125;</span>), y^(<span class="hljs-subst">&#123;i&#125;</span>)) = (<span class="hljs-subst">&#123;x_i&#125;</span>, <span class="hljs-subst">&#123;y_i&#125;</span>)&quot;</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">(x^(<span class="hljs-number">0</span>), y^(<span class="hljs-number">0</span>)) = (<span class="hljs-number">1.0</span>, <span class="hljs-number">300.0</span>)<br></code></pre></div></td></tr></table></figure><h3 id="Plotting-the-data"><a href="#Plotting-the-data" class="headerlink" title="Plotting the data"></a>Plotting the data</h3><p>You can plot these two points using the scatter() function is the matplotlib library,as shown in the cell below.</p><ul><li>The function arguments marker and c show the points as red crosses(the default is blue dots.)</li></ul><p>You can use other functions in the matplotlib library to set title and labels to display.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#Plot the data points</span><br>plt.scatter(x_train, y_train, marker=<span class="hljs-string">&#x27;x&#x27;</span> c=<span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-comment">#Set the title</span><br>plt.title(<span class="hljs-string">&quot;Housing Prices&quot;</span>)<br><span class="hljs-comment">#Set the y-axis label</span><br>plt.ylabel(<span class="hljs-string">&#x27;Price (in 1000s of dollars)&#x27;</span>)<br><span class="hljs-comment">#Set the x-axis lbel</span><br>plt.xlabel(<span class="hljs-string">&#x27;Size (1000 sqft)&#x27;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/06/ML001/image-20230306204822102.png" alt="image-20230306204822102"></p><h3 id="Model-function"><a href="#Model-function" class="headerlink" title="Model function"></a>Model function</h3><p><img src="/2023/03/06/ML001/image-20230306204918585.png" alt="image-20230306204918585"></p><p>As described in lecture, the model function for linear regression (which is a function that maps from x to y)is represented as</p><p><img src="/2023/03/06/ML001/image-20230306205107527.png" alt="image-20230306205107527"></p><p>The formula above is how you can represent straight lines - different values of w and b give you different straight lines on the plot.</p><p>Let’s try to get a better intuition for this through the code blocks below. Let’s start with w &#x3D; 100 and b &#x3D;100.</p><p>Note: You can come back to this cell to adjust the model’s w and b parameters.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">w = <span class="hljs-number">100</span><br>b = <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;w: <span class="hljs-subst">&#123;w&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;b: <span class="hljs-subst">&#123;b&#125;</span>&quot;</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">w:<span class="hljs-number">100</span><br>b:<span class="hljs-number">100</span><br></code></pre></div></td></tr></table></figure><p>Now,let’s compute the value of f_{w,b}(x^i) for your two data points. You can explicitly write this out for each data poins as -</p><p>for x(0),f_wb &#x3D; w * x[0] + b</p><p>for x(1),f_wb &#x3D; w * x[1] + b</p><p>For a large number of data points, this can get unwieldy and repetitive. So instead, you can calculate the function output in a for loop as shown in the compute_model_output function below.</p><p>Note:The argument description (ndarray (m,)) describes a Numpy n-dimensional array of shape (m,). (scalar) describes an argument without dimensions, just a magnitude.</p><p>Note: np.zero(n) will return a one-dimensional numpy array with n entries</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_model_output</span>(<span class="hljs-params">x, w, b</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Computes the prediction of a linear model</span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">    x (ndarray (m,)):Data, m examples</span><br><span class="hljs-string">    w,b (scalar):model parameters</span><br><span class="hljs-string">    Returns</span><br><span class="hljs-string">    y (ndarray (m,)):target values</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br>    m = x.shape[<span class="hljs-number">0</span>]<br>    f_wb = np.zeros(m)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)<br>    f_wb[i] = w * x[i] + b<br>    <br>    <span class="hljs-keyword">return</span> f_wb<br></code></pre></div></td></tr></table></figure><p>Now let’s call the compute_model_output function and plot the output.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">tmp_f_wb = compute_model_output(x_train, w, b,)<br><br><span class="hljs-comment">#Plot our model prediction</span><br>plt.plot(x_train, tmp_f_wb, c=<span class="hljs-string">&#x27;b&#x27;</span>,label=<span class="hljs-string">&#x27;Our Prediction&#x27;</span>)<br><br><span class="hljs-comment">#Plot the data points</span><br>plt.scatter(x_train, y_train, marker=<span class="hljs-string">&#x27;x&#x27;</span>, c=<span class="hljs-string">&#x27;r&#x27;</span>,label=<span class="hljs-string">&#x27;Actual Values&#x27;</span>)<br><br><span class="hljs-comment">#Set the title</span><br>plt.title(<span class="hljs-string">&quot;Housing Prices&quot;</span>)<br><span class="hljs-comment">#Set the y-axis label</span><br>plt.ylabel(<span class="hljs-string">&#x27;Price (in 1000s of dollars)&#x27;</span>)<br><span class="hljs-comment">#Set the x-axis label</span><br>plt.xlabel(<span class="hljs-string">&#x27;Size (1000 sqft)&#x27;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/06/ML001/image-20230306211337338.png" alt="image-20230306211337338"></p><p>As you can see, setting w &#x3D; 100 and b &#x3D; 100 does not result in a line that fits our data.</p><h3 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h3><p>Try experimenting with different values of w and b. What should the values be for a line that fits our data?</p><p><strong>Tips:</strong></p><p>You can use  your mouse to click on the triangle to the left of the green “Hints” below to reveal some hints for choosing b and w.</p><p><strong>Hints</strong></p><h3 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h3><p>Now that we have a model, we can use it to make our original prediction. Let’s predict the price of a house with 1200 sqft. Since the units of x are in 1000’s of sqft, x is 1.2.</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">w = <span class="hljs-number">200</span><br>b = <span class="hljs-number">100</span><br>x_i = <span class="hljs-number">1.2</span><br>cost_1200sqft = w * x_i + b<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;$<span class="hljs-subst">&#123;cost_1200sqft:<span class="hljs-number">.0</span>f&#125;</span> thousand dollars&quot;</span> )<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">$<span class="hljs-number">340</span> thousand dollars<br></code></pre></div></td></tr></table></figure><h3 id="Congratulations"><a href="#Congratulations" class="headerlink" title="Congratulations!"></a>Congratulations!</h3><p>In this lab you have learned:</p><ul><li>Linear regression bulids a model which establishes a relationship between features and targets</li><li>In the example above, the feature was house size and the target was house price</li><li>for simple linear regression, the model has two parameters w and b whose calue are ‘fit’ using training data.</li><li>once a model’s parameters have been determined, the model can be used to make predictions on novel data.</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1Pa411X76s?p=5&amp;vd_source=3ae32e36058f58c5b85935fca9b77797">https://www.bilibili.com/video/BV1Pa411X76s?p=5&amp;vd_source=3ae32e36058f58c5b85935fca9b77797</a></p><p><a href="https://github.com/kaieye/2022-Machine-Learning-Specialization">kaieye&#x2F;2022-Machine-Learning-Specialization (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tensorflow</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA编译与执行</title>
    <link href="/2023/03/06/cuda011/"/>
    <url>/2023/03/06/cuda011/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA编译与执行"><a href="#CUDA编译与执行" class="headerlink" title="CUDA编译与执行"></a>CUDA编译与执行</h2><p>现在把所有的代码放在一个文件名为sumArraysOnGPU-small-case.cu的文件中，如代码清单2-4所示。</p><p><strong>代码清单2-4基于GPU的向量加法（sumArraysOnGPU-small-case.cu）</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#define CHECK(call)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    const cudaError_t error = call;</span><br><span class="hljs-comment">    if(error != cudaSuccess)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        printf(&quot;Error:%s:%d, &quot;, __FILE__, __LINE__);</span><br><span class="hljs-comment">        printf(&quot;code:%d, reason: %s\n&quot;, error, cudaGetErrorString(error));</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkResult</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *hostRef, <span class="hljs-keyword">float</span> *gpuRef, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N)</span></span>&#123;<br>    <span class="hljs-keyword">double</span> epsilon = <span class="hljs-number">1.0E-8</span>;<br>    <span class="hljs-keyword">int</span> match = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i &lt; N; i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(hostRef[i] - gpuRef[i]) &gt; epsilon)&#123;<br>            match = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Arrays do not match!\n&quot;</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;host %5.2f gpu %5.2f at current %d\n&quot;</span>,hostRef[i],gpuRef[i],i);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(match) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Arrays match.\n\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialData</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *ip,<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>    <span class="hljs-comment">//generate different seed for random number</span><br>    <span class="hljs-keyword">time_t</span> t;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>) <span class="hljs-built_in">time</span>(&amp;t));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;size;i++)&#123;<br>        ip[i] = (<span class="hljs-keyword">float</span>)(<span class="hljs-built_in">rand</span>() &amp; <span class="hljs-number">0xFF</span>) /<span class="hljs-number">10.0f</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sumArraysOnHost</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A,<span class="hljs-keyword">float</span> *B, <span class="hljs-keyword">float</span> *C)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = threadIdx.x;<br>    C[i] = A[i] + B[i];<br>&#125;<br><br><span class="hljs-function">__gloal__ <span class="hljs-keyword">void</span> <span class="hljs-title">sumArraysOnGPU</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, <span class="hljs-keyword">float</span> *C)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = threadIdx.x;<br>    C[i] = A[i] + B[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s Starting...\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>    <br>    <span class="hljs-comment">//set up device</span><br>    <span class="hljs-keyword">int</span> dev = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">cudaSetDevice</span>(dev);<br>    <br>    <span class="hljs-comment">//set up data size of vectors</span><br>    <span class="hljs-keyword">int</span> nElem = <span class="hljs-number">32</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Vector size %d\n&quot;</span>,nElem);<br>    <br>    <span class="hljs-comment">//malloc host memory</span><br>    <span class="hljs-keyword">size_t</span> nBytes = nElem * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>);<br>    <br>    <span class="hljs-keyword">float</span> *h_A, *h_B, *hostRef, *gpuRef;<br>    h_A = (<span class="hljs-keyword">float</span>*)<span class="hljs-built_in">malloc</span>(nBytes);<br>    h_B = (<span class="hljs-keyword">float</span>*)<span class="hljs-built_in">malloc</span>(nBytes);<br>    hostRef = (<span class="hljs-keyword">float</span>*)<span class="hljs-built_in">malloc</span>(nBytes);<br>    gpuRef = (<span class="hljs-keyword">float</span>*)<span class="hljs-built_in">malloc</span>(nBytes);<br>    <br>    <span class="hljs-comment">//initialize data at host side</span><br>    <span class="hljs-built_in">initialData</span>(h_A, nElem);<br>    <span class="hljs-built_in">initialData</span>(h_B, nElem);<br>    <br>    <span class="hljs-built_in">memset</span>(hostRef, <span class="hljs-number">0</span> ,nBytes);<br>    <span class="hljs-built_in">memset</span>(gpuRef, <span class="hljs-number">0</span> ,nBytes);<br>    <br>    <span class="hljs-comment">//malloc device global memory</span><br>    <span class="hljs-keyword">float</span> *d_A, *d_B, *d_C;<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_A, nBytes);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_B, nBytes);<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_C, nBytes);<br>    <br>    <span class="hljs-comment">//transfer data from host to device</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(d_A, h_A, nBytes, cudaMemcpyHostTodevice);<br>    <span class="hljs-built_in">cudaMemcpy</span>(d_B, h_B, nBytes, cudaMemcpyHostTodevice);<br>    <br>    <span class="hljs-comment">//invoke kernel at host side</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(nElem)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(nElem/block.x)</span></span>;<br>    <br>    sumArraysOnGPU&lt;&lt;&lt;grid,block&gt;&gt;&gt;(d_A, d_B, d_C);<br>    <span class="hljs-built_in">pritnf</span>(<span class="hljs-string">&quot;Execution configuration &lt;&lt;&lt;%d, %d&gt;&gt;&gt;\n&quot;</span>,grid.x,block.x);<br>    <br>    <span class="hljs-comment">//copy kernel result back to host side</span><br>    <span class="hljs-built_in">cudaMemcpy</span>(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost);<br>    <br>    <span class="hljs-comment">//add vector at host side for result checks</span><br>    <span class="hljs-built_in">sumArraysOnHost</span>(h_A, h_B, hostRef, nElem);<br>    <br>    <span class="hljs-comment">//check device results</span><br>    <span class="hljs-built_in">checkResult</span>(hostRef, gpuRef, nElem);<br>    <br>    <span class="hljs-comment">//free device global memory</span><br>    <span class="hljs-built_in">cudaFree</span>(d_A);<br>    <span class="hljs-built_in">cudaFree</span>(d_B);<br>    <span class="hljs-built_in">cudaFree</span>(d_C);<br>    <br>    <span class="hljs-comment">//free host memory</span><br>    <span class="hljs-built_in">free</span>(h_A);<br>    <span class="hljs-built_in">free</span>(h_B);<br>    <span class="hljs-built_in">free</span>(hostRef);<br>    <span class="hljs-built_in">free</span>(gpuRef);<br>    <br>    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这段代码中，向量大小被设置为32，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> nElem = <span class="hljs-number">32</span>;<br></code></pre></div></td></tr></table></figure><p>执行配置被放入一个块内，其中包含32个元素：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(nElem)</span></span>;<br><span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(nElem/block.x)</span></span>;<br></code></pre></div></td></tr></table></figure><p>使用以下命令编译和执行该带啊吗：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc sumArraysOnGPU-small-case.cu -o addvector<br>./addvector<br></code></pre></div></td></tr></table></figure><p>系统报告如下：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./addvector Starting...<br>Vector size 32<br>Execution configuration &lt;&lt;&lt;1,32&gt;&gt;&gt;<br>Arrays match.<br></code></pre></div></td></tr></table></figure><p>如果你将执行配置重新定义为32个块，每个块只有一个元素，如下所示；</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(nElem)</span></span>;<br></code></pre></div></td></tr></table></figure><p>那么就需要在代码清单2-4中对核函数sumArraysOnGPU进行修改：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">用<span class="hljs-keyword">int</span> i = threadIdx.x;    替换<span class="hljs-keyword">int</span> i = blockIdx.x;<br></code></pre></div></td></tr></table></figure><p>一般情况下，可以基于给定的一维网格和块的信息来计算全局数据访问的唯一索引：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__gloal__ <span class="hljs-keyword">void</span> <span class="hljs-title">sumArraysOnGPU</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, <span class="hljs-keyword">float</span> *C)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = blockIdx.x * blockDim.x * threadIdx.x;<br>    C[i] = A[i] + B[i];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>你需要确保一般情况下进行更改所产生结果的正确性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA处理错误</title>
    <link href="/2023/03/06/cuda010/"/>
    <url>/2023/03/06/cuda010/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA处理错误"><a href="#CUDA处理错误" class="headerlink" title="CUDA处理错误"></a>CUDA处理错误</h2><p>由于许多CUDA调用是异步的，所以有时可能很难确定某个错误是由哪一步程序引起的。定义一个错误处理宏封装所有的CUDA API调用，这简化了错误检查过程：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHECK(call)</span><br>&#123;<br>    <span class="hljs-keyword">const</span> cudaError_t error = call;<br>    <span class="hljs-keyword">if</span>(error != cudaSuccess)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error:%s:%d, &quot;</span>, __FILE__, __LINE__);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;code:%d, reason: %s\n&quot;</span>, error, <span class="hljs-built_in">cudaGetErrorString</span>(error));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>例如，你可以在以下代码中使用宏：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">CHECK(<span class="hljs-params">cudaMemcpy</span>(<span class="hljs-params">d_C</span>, <span class="hljs-params">gpuRef</span>, <span class="hljs-params">nBytes</span>, <span class="hljs-params">cudaMemcpyHostToDevice</span>)</span>);<br></code></pre></div></td></tr></table></figure><p>如果内存拷贝或之前的异步操作产生了错误，这个宏会报告错误代码，并输出一个可读信息，然后停止程序。也可以用下述方法，在核函数调用后检查核函数错误：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">kernel_function&lt;&lt;&lt;grid,block&gt;&gt;&gt;(argument list);<br><span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">cudaDeviceSynchronize</span>());<br></code></pre></div></td></tr></table></figure><p>CHECK(cudaDeviceSynchronize())会阻塞主机端线程的运行直到设备端所有的请求任务都结束，并确保最后的核函数启动部分不会出错。以上仅是以调试为目的的，因为在核函数启动后添加这个检查点会阻塞主机端线程，使该检查点成为全局屏障。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA验证核函数</title>
    <link href="/2023/03/06/cuda009/"/>
    <url>/2023/03/06/cuda009/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA验证核函数"><a href="#CUDA验证核函数" class="headerlink" title="CUDA验证核函数"></a>CUDA验证核函数</h2><p>既然你已经编写了核函数，你如何能知道它是否正确运行？你需要一个主机函数来验证核函数的结果。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkResult</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *hostRef, <span class="hljs-keyword">float</span> *gpuRef, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N)</span></span>&#123;<br>    <span class="hljs-keyword">double</span> epsilon = <span class="hljs-number">1.0E-8</span>;<br>    <span class="hljs-keyword">int</span> match = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i &lt; N; i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(hostRef[i] - gpuRef[i]) &gt; epsilon)&#123;<br>            match = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Arrays do not match!\n&quot;</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;host %5.2f gpu %5.2f at current %d\n&quot;</span>,hostRef[i],gpuRef[i],i);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(match) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Arrays match.\n\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="验证核函数代码"><a href="#验证核函数代码" class="headerlink" title="验证核函数代码"></a>验证核函数代码</h3><p>除了许多可用的调试工具外，还有两个非常简单实用的方法可以验证核函数。</p><p>首先，你可以在Fermi及更高版本的设备端的核函数中使用printf函数。</p><p>其次，可以将执行参数设置为&lt;&lt;&lt;1,1&gt;&gt;&gt;，因此强制用一个块和一个线程执行核函数，这模拟了串行执行程序。这对于调试和验证结果是否正确是非常有用的，而且，如果你遇到了运算次序的问题，这有助于你对比验证数值结果是否是按位精确的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA编写核函数</title>
    <link href="/2023/03/06/cuda008/"/>
    <url>/2023/03/06/cuda008/</url>
    
    <content type="html"><![CDATA[<h2 id="编写核函数"><a href="#编写核函数" class="headerlink" title="编写核函数"></a>编写核函数</h2><p>核函数是在设备端执行的代码。在核函数中，需要为一个线程规定要进行的计算以及要进行的数据访问。当核函数被调用时，许多不同的CUDA线程并行执行同一个计算任务。以下是用_<em>global</em>_</p><p>声明定义核函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">__global__  void kernel<span class="hljs-constructor">_name(<span class="hljs-params">argument</span> <span class="hljs-params">list</span>)</span>;<br></code></pre></div></td></tr></table></figure><p>核函数必须有一个void返回类型。</p><p>表2-2总结了CUDA C程序中的函数类型限定符。函数类型限定符指定一个函数在主机上执行还是在设备上执行，以及可被主机调用还是被设备调用。</p><p><img src="/2023/03/06/cuda008/image-20230306155126122.png" alt="image-20230306155126122"></p><p>_<em>device</em>_   和 __host__限定符可以一齐使用，这样函数可以同时在主机和设备端进行编译。</p><h3 id="CUDA核函数的限制"><a href="#CUDA核函数的限制" class="headerlink" title="CUDA核函数的限制"></a>CUDA核函数的限制</h3><p>以下限制适用于所有核函数：</p><ul><li>只能访问设备内存</li><li>必须具有void返回类型</li><li>不支持可变数量的参数</li><li>不支持静态变量</li><li>显示异步行为</li></ul><p>考虑一个简单的例子：将两个大小为N的向量A和B相加，主机端的向量加法C代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sumArrayOnHost</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, <span class="hljs-keyword">float</span> *C, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; N; i++)<br>        C[i] = A[i] + B[i];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这是一个迭代N次的串行程序，循环结束后将产生以下核函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">sumArrayOnHost</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, <span class="hljs-keyword">float</span> *C)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = threadIdx.x;<br>        C[i] = A[i] + B[i];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>C函数和核函数之间有什么不同？你可能已经注意到循环体消失了，内置的线程坐标变量替换了数组索引，由于N是被隐式定义用来启动N个线程的，所以N没有什么参考价值。</p><p>假设有一个长度为32个元素的向量，你可以按以下方法用32个线程来调用核函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sumArraysOnGPU&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">32</span>&gt;&gt;&gt;(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, <span class="hljs-keyword">float</span> *C);<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>启动一个CUDA核函数</title>
    <link href="/2023/03/06/cuda007/"/>
    <url>/2023/03/06/cuda007/</url>
    
    <content type="html"><![CDATA[<h2 id="启动一个CUDA核函数"><a href="#启动一个CUDA核函数" class="headerlink" title="启动一个CUDA核函数"></a>启动一个CUDA核函数</h2><p>你应该对下列C语言函数调用语句很熟悉：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">function_name</span> (argument list);<br></code></pre></div></td></tr></table></figure><p>CUDA内核调用是对C语言函数调用语句的延申，&lt;&lt;&lt;&gt;&gt;&gt;运算符内是核函数的执行配置。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">kerbel_name&lt;&lt;&lt;grid,block&gt;&gt;&gt;(srgument list);<br></code></pre></div></td></tr></table></figure><p>正如上一节所述，CUDA编程模型揭示了线程层次结构。利用执行配置可以指定线程在GPU上调度运行的方式。执行配置的第一个值是网格维度，也就是启动块的数目。第二个值是块维度，也就是每个块中线程的数目。通过指定网格和块的维度，你可以进行一下配置：</p><ul><li>内核中线程的数目</li><li>内核中使用的线程布局</li></ul><p>同一个块中的线程之间可以相互协作，不同块内的线程不能协作。对于一个给定的问题，可以使用不同的网格和块布局来组织你的线程。例如，假设你有32个数据元素用于计算，每8个元素一个块，需要启动4个块：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">kernel_name&lt;&lt;&lt;<span class="hljs-number">4</span>,<span class="hljs-number">8</span>&gt;&gt;&gt;(argument list);<br></code></pre></div></td></tr></table></figure><p><img src="/2023/03/06/cuda007/image-20230306140924311.png" alt="image-20230306140924311"></p><p>由于数据在全局内存中是线性存储的，因此可以用变量blockIdx.x和threadIdx.x来进行以下操作。</p><ul><li>在网格中标识一个唯一的线程</li><li>建立线程和数据元素之间的映射关系</li></ul><p>如果把32个元素放到一个块里，那么只会得到一个块：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">kernel_name&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">32</span>&gt;&gt;&gt;(argument list);<br></code></pre></div></td></tr></table></figure><p>如果每个块只含一个元素，那么会有32个块：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">kernel_name&lt;&lt;&lt;<span class="hljs-number">32</span>,<span class="hljs-number">1</span>&gt;&gt;&gt;(argument list);<br></code></pre></div></td></tr></table></figure><p>核函数的调用与主机线程是异步的。核函数调用结束后，控制权立刻返回给主机端。你可以调用以下函数来强制主机端程序等待所有的核函数执行结束：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">cudaError_t <span class="hljs-title">cudaDeviceSynchronize</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></div></td></tr></table></figure><p>一些CUDA运行时API在主机和设备之间是隐式同步的。当使用cudaMemcpy函数在主机和设备之间拷贝数据时，主机端隐式同步，即主机端程序必须等待数据拷贝完成后才能继续执行程序。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">cudaError_t <span class="hljs-title">cudaMemcpy</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* src, <span class="hljs-keyword">size_t</span> count, cudaMemcpyKind kind)</span></span>;<br></code></pre></div></td></tr></table></figure><p>之前所有的核函数调用完成后开始拷贝数据。当拷贝完成后，控制权立刻返回给主机端。</p><h3 id="异步行为"><a href="#异步行为" class="headerlink" title="异步行为"></a>异步行为</h3><p>不同于C语言的函数调用，所有的CUDA核函数的启动都是异步的。CUDA内核调用完成后，控制权立刻返回给CPU。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>205.同构字符串</title>
    <link href="/2023/03/02/leetcode205/"/>
    <url>/2023/03/02/leetcode205/</url>
    
    <content type="html"><![CDATA[<h2 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205.同构字符串"></a>205.同构字符串</h2><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/isomorphic-strings/">205. 同构字符串 - 力扣（LeetCode）</a></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        string ss;<br>        string st;<br>        <span class="hljs-keyword">int</span> hash[<span class="hljs-number">255</span>];<br>        <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(hash, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(hash));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash[<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(s[i])]==<span class="hljs-number">0</span>)<br>            &#123;<br>                index++;<br>                hash[<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(s[i])]=index;<br>                ss.<span class="hljs-built_in">push_back</span>(index+<span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ss.<span class="hljs-built_in">push_back</span>(hash[<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(s[i])]+<span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>        &#125;<br>        index=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(hash, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(hash));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;t.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash[<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(t[i])]==<span class="hljs-number">0</span>)<br>            &#123;<br>                index++;<br>                hash[<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(t[i])]=index;<br>                st.<span class="hljs-built_in">push_back</span>(index+<span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-built_in">push_back</span>(hash[<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(t[i])]+<span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = ss.<span class="hljs-built_in">compare</span>(st);<br>        <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="/2023/03/02/leetcode205/image-20230302204605581.png" alt="image-20230302204605581"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">char</span>&gt; s2t;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">char</span>&gt; t2s;<br>        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-keyword">char</span> x = s[i], y = t[i];<br>            <span class="hljs-keyword">if</span> ((s2t.<span class="hljs-built_in">count</span>(x) &amp;&amp; s2t[x] != y) || (t2s.<span class="hljs-built_in">count</span>(y) &amp;&amp; t2s[y] != x)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            s2t[x] = y;<br>            t2s[y] = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode.cn/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/">同构字符串 - 同构字符串 - 力扣（LeetCode）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>189.轮转数组</title>
    <link href="/2023/03/02/leetcode189/"/>
    <url>/2023/03/02/leetcode189/</url>
    
    <content type="html"><![CDATA[<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189.轮转数组"></a>189.轮转数组</h2><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组 - 力扣（LeetCode）</a></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><img src="/2023/03/02/leetcode189/image-20230302200538871.png" alt="image-20230302200538871"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(begin&lt;end)&#123;<br>            <span class="hljs-built_in">swap</span>(nums[begin], nums[end]);<br>            begin++;<br>            end--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//数组翻转</span><br>        <span class="hljs-keyword">int</span> p = k%nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums,<span class="hljs-number">0</span>,p<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums,p,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode.cn/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/">旋转数组 - 轮转数组 - 力扣（LeetCode）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>LeetCode</tag>
      
      <tag>数组翻转</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>724.寻找数组的中心下标</title>
    <link href="/2023/03/01/leetcode724/"/>
    <url>/2023/03/01/leetcode724/</url>
    
    <content type="html"><![CDATA[<h1 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724.寻找数组的中心下标"></a>724.寻找数组的中心下标</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/find-pivot-index/">724. 寻找数组的中心下标 - 力扣（LeetCode）</a></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><img src="/2023/03/01/leetcode724/image-20230301173931031.png" alt="image-20230301173931031"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> total=<span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<span class="hljs-comment">//第三个形参是累加的初始值</span><br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*sum+nums[i] == total)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            sum+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode.cn/problems/find-pivot-index/solution/xun-zhao-shu-zu-de-zhong-xin-suo-yin-by-gzjle/">寻找数组的中心索引 - 寻找数组的中心下标 - 力扣（LeetCode）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>LeetCode</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector&lt;bool&gt;与vector&lt;T&gt;</title>
    <link href="/2023/02/28/vectorbool/"/>
    <url>/2023/02/28/vectorbool/</url>
    
    <content type="html"><![CDATA[<h1 id="vector-lt-bool-gt-与vector-lt-T-gt"><a href="#vector-lt-bool-gt-与vector-lt-T-gt" class="headerlink" title="vector&lt;bool&gt;与vector&lt;T&gt;"></a>vector&lt;bool&gt;与vector&lt;T&gt;</h1><p>vector&lt;bool&gt; 不像其他容器一样按Byte存储的，它是按bit存储的，也就是说一个正常的bool类型的空间可以存放vector&lt;bool&gt;中的8个，空间上确实优化了很多，然而，c++是不能直接取对bit操作的（因为C++的最小可寻址值通常以byte为单位），对其使用operator[]其实返回的不是bool的引用而是一个”proxy reference”是”std::vector&lt; bool&gt;:reference”类型的对象。</p><p>正因为如此，vector&lt;bool&gt;通过代理对象进行存取访问时需要执行逐位处理，访问通常比int之类的普通类型操作要慢很多。</p><p>因此，对vecotr&lt;bool&gt;的使用需慎重考虑以下几点：<br>(1)是否需要牺牲速度来获取空间上的优化<br>(2)算法中会否有对vecotr地址进行解引用操作的可能。</p><p>如果不满足以上条件，建议使用deque&lt;bool&gt;来取代vector&lt;bool&gt;，功能基本相同，但deque&lt;bool&gt;未对其进行特殊处理。</p><p>下面是vector&lt;bool&gt;与vector&lt;T&gt;简单的对比例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>vector&lt;<span class="hljs-keyword">char</span>&gt; ch;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; in;<br>vector&lt;<span class="hljs-keyword">bool</span>&gt; bo;<br> <br><span class="hljs-keyword">int</span> m = <span class="hljs-number">1e6</span>;<br><span class="hljs-keyword">clock_t</span> t1, t2, t3;<br> <br>t1 = <span class="hljs-built_in">clock</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>ch.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>t1 = <span class="hljs-built_in">clock</span>() - t1;<br> <br>t2 = <span class="hljs-built_in">clock</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>in.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>&#125;<br>t2 = <span class="hljs-built_in">clock</span>() - t2;<br> <br>t3 = <span class="hljs-built_in">clock</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>bo.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>&#125;<br>t3 = <span class="hljs-built_in">clock</span>() - t3;<br> <br>cout &lt;&lt;<span class="hljs-string">&quot;vector&lt;char&gt; &quot;</span>&lt;&lt; t1 &lt;&lt; <span class="hljs-string">&quot;\n vector&lt;int&gt; &quot;</span> &lt;&lt; t2 &lt;&lt; <span class="hljs-string">&quot;\nvector&lt;bool&gt; &quot;</span> &lt;&lt; t3 &lt;&lt; endl;<br>cout &lt;&lt; endl;<br> <br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-number">216</span><br>vextor&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-number">229</span><br>vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-number">16535</span><br></code></pre></div></td></tr></table></figure><p>这里发现vector&lt;bool&gt;相较于其他vector&lt;T&gt;速度要慢的多！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_52134928/article/details/121066304?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121066304-blog-86603050.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121066304-blog-86603050.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1">(65条消息) 【C++】vector＜bool＞的特别之处_小陶同学_的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/u013249689/article/details/25297657">(65条消息) 不使用vector的原因和替代方法_jackycmu的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>Vector</tag>
      
      <tag>C/C++</tag>
      
      <tag>bool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++关键字之restrict</title>
    <link href="/2023/02/28/Linux004/"/>
    <url>/2023/02/28/Linux004/</url>
    
    <content type="html"><![CDATA[<h1 id="C-x2F-C-关键字之restrict"><a href="#C-x2F-C-关键字之restrict" class="headerlink" title="C&#x2F;C++关键字之restrict"></a>C&#x2F;C++关键字之restrict</h1><p>在C语言中，restrict关键字用于修饰指针（C99标准）。通过加上restrict关键字，程序员可提示编译器：在该指针的生命周期内，其指向的对象不会被别的指针所引用。</p><p>需要注意的是，在C++中，并无明确统一的标准支持restrict关键字。但是很多编译器实现了功能相同的关键字，例如gcc和clang中的__restrict关键字。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*a, <span class="hljs-keyword">int</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br>    *a = <span class="hljs-number">10</span>;<br>    *b = <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">return</span> *a + *b;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>add1函数的返回值会永远是10 + 12 &#x3D; 22吗？</p><p>答案是不一定。在指针a和b的地址不同时，返回22没有问题。但是当指针a与b指向的是同一个int对象时，该对象先被赋值为10，后被赋值为12，因此a和b都返回12，因此add1函数最终返回24。</p><p>下面是一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br>    *a = <span class="hljs-number">10</span>;<br>    *b = <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">return</span> *a + *b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span>* c;<br>    <span class="hljs-keyword">int</span>* d;<br>    d=(<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>)*<span class="hljs-number">1</span>);<br>    c=(<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>)*<span class="hljs-number">1</span>);<br>    *c=<span class="hljs-number">10</span>;<br>    *d=<span class="hljs-number">12</span>;<br>    *d=<span class="hljs-number">12</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;c:&quot;</span>&lt;&lt;*c&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;d:&quot;</span>&lt;&lt;*d&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;When Pointers a and b have different addresses&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">add1</span>(c,d)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;When Pointers a and b have the same address&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">add1</span>(c,c)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>程序输出：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">c:<span class="hljs-number">10</span><br>d:<span class="hljs-number">12</span><br>When Pointers a <span class="hljs-keyword">and</span> b have different addresses<br><span class="hljs-number">22</span><br>When Pointers a <span class="hljs-keyword">and</span> b have the same address<br><span class="hljs-number">24</span><br></code></pre></div></td></tr></table></figure><p>开启-O3优化，add1对应的汇编代码如下:</p><p>为了得到<code>*a</code>的值访问了1次内存，而不管在何种条件下(<code>a == b</code> or <code>a != b</code>)，<code>*b</code>的值都是12。因此编译器将<code>*a</code>的值载入<code>eax</code>寄存器后，直接加上立即数12，而无需再访问内存获取<code>*b</code>的值。在无法确定指针a和b是否相同的情况下，编译器只能帮你优化到这里了。</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-number">0000000000400</span>a10 &lt;_Z4add1PiS_&gt;:<br>  <span class="hljs-number">400</span>a10:   c7 <span class="hljs-number">07</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       movl   $<span class="hljs-number">0</span>xa,(%rdi) ; *a = <span class="hljs-number">10</span><br>  <span class="hljs-number">400</span>a16:   c7 <span class="hljs-number">06</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       movl   $<span class="hljs-number">0</span>xc,(%rsi) ; *b = <span class="hljs-number">10</span><br>  <span class="hljs-number">400</span>a1c:   <span class="hljs-number">8</span>b <span class="hljs-number">07</span>                   mov    (%rdi),%eax ; 结果 = *a<br>  <span class="hljs-number">400</span>a1e:   <span class="hljs-number">83</span> c0 <span class="hljs-number">0</span>c                add    $<span class="hljs-number">0</span>xc,%eax   ; 结果 += <span class="hljs-number">12</span> <br>  <span class="hljs-number">400</span>a21:   c3                      retq<br></code></pre></div></td></tr></table></figure><p>加上了restrict关键字过后，同样开启-O3优化，add1对应的汇编代码如下：</p><p>加上关键字restrict后，编译器能够确认指针a和b不可能指向同一个内存地址，因此在求*a + *b时，无虚访问内存，因为*a必然等于立即数10，*b必然等于立即数12。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* __restrict  a, <span class="hljs-keyword">int</span>* __restrict b)</span> </span><br><span class="hljs-function"></span>&#123;<br>    *a = <span class="hljs-number">10</span>;<br>    *b = <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">return</span> *a + *b ;<br>&#125;<br><span class="hljs-number">0000000000400</span>a30 &lt;_Z4add2PiS_&gt;:<br>  <span class="hljs-number">400</span>a30:   c7 <span class="hljs-number">07</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       movl   $<span class="hljs-number">0xa</span>,(%rdi) ; *a = <span class="hljs-number">10</span><br>  <span class="hljs-number">400</span>a36:   b8 <span class="hljs-number">16</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    $<span class="hljs-number">0x16</span>,%eax  ; 结果 = <span class="hljs-number">22</span><br>  <span class="hljs-number">400</span>a3b:   c7 <span class="hljs-number">06</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       movl   $<span class="hljs-number">0xc</span>,(%rsi) ; *b = <span class="hljs-number">12</span><br>  <span class="hljs-number">400</span>a41:   c3  <br></code></pre></div></td></tr></table></figure><p>有无restrict关键字的两种情况下的汇编指令可看到，后者比前者少访问一次内存，且少执行一条指令。就是因为没加restruct关键字时，编译器不能确定别的地方是不是会修改此值，所以会去相应的地址查看。</p><p><strong>这样当我们明确知道两个指针不可能指向同一个地址时，我们就可以通过使用restrict关键字来进行性能优化。</strong></p><p>注意使用restrict的时候，程序员必须确保不会出现<strong>pointer aliasing</strong>，即同一块内存无法通过两个或以上的指针变量名访问。不满足这个条件强行指定restrict，将会出现<strong>underfined behavior</strong>。</p><p>通常编写代码时会忽略pointer aliasing的问题。更常见是在性能分析时，通过反汇编看到很多冗余的读取指令，才会想到加入restrict关键字来提升性能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/349726808">C&#x2F;C++关键字之restrict - 知乎 (zhihu.com)</a></p><p><a href="https://github.com/ClickHouse/ClickHouse/pull/19946">Improve performance of aggregate functions by alexey-milovidov · Pull Request #19946 · ClickHouse&#x2F;ClickHouse (github.com)</a></p><p><a href="https://en.cppreference.com/w/c/language/restrict">restrict type qualifier - cppreference.com</a></p><p><a href="https://www.zhihu.com/question/41653775/answer/2535730128">如何理解C语言关键字restrict？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/qq_41822235/article/details/83479562">(65条消息) 关键字_restrict___restrict_楚楚可薇的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_41950508/article/details/126619881?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-126619881-blog-102577325.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-126619881-blog-102577325.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1">(65条消息) 【C++】关键字restrict的作用_restrict关键字的作用_不知所措的渣渣辉的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unroll_and_jam/nounroll_and_jam</title>
    <link href="/2023/02/26/intel001/"/>
    <url>/2023/02/26/intel001/</url>
    
    <content type="html"><![CDATA[<h1 id="unroll-and-jam-x2F-nounroll-and-jam"><a href="#unroll-and-jam-x2F-nounroll-and-jam" class="headerlink" title="unroll_and_jam&#x2F;nounroll_and_jam"></a>unroll_and_jam&#x2F;nounroll_and_jam</h1><p>启用或禁用循环展开和阻塞。这些指令只能应用于迭代for循环。</p><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><p>#pragma unroll_and_jam#pragma unroll_and_jam (n)#pragma nounroll_and_jam</p><h2 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h2><p>展开因子，表示展开循环的次数;必须是0到255之间的整数常数</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>unroll_and_jam指令部分展开套中比最内层循环更高的一个或多个循环，并将结果循环融合&#x2F;阻塞回一起。这种转换允许在循环中进行更多的重用。</p><p>此pragma对最内层循环无效。确保紧随其后的循环不是编译器发起的交换完成后的最内层循环。</p><p>指定此pragma是向编译器提示展开和阻塞序列是合法且有利可图的。编译器会在任何可能的情况下启用这种转换。</p><p>对于它影响的每个for循环，unroll_and_jam指令必须在for语句之前。如果指定了n，优化器将展开循环n次。如果n被省略或超出允许的范围，优化器将分配展开循环的次数。编译器通过比较n和循环计数生成正确的代码。</p><p>只有在设置了编译器选项O3时，才支持此pragma。unroll_and_jam指令将覆盖从命令行展开循环的任何设置。</p><p>当展开循环会增加寄存器压力和代码大小时，可能需要防止展开嵌套循环或不完美的嵌套循环。在这种情况下，使用nounroll_and_jam编译指令。nounroll_and_jam pragma提示编译器不要展开指定的循环。</p><p><strong>Examples</strong></p><p><strong>Use the unroll_and_jam pragma:</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]; <br><span class="hljs-keyword">int</span> b[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]; <br><span class="hljs-keyword">int</span> c[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]; <br><span class="hljs-keyword">int</span> d[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]; <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unroll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,k;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> unroll_and_jam (6)</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>       <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> unroll_and_jam (6)</span><br>       <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>          <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; n; k++)&#123;<br>            a[i][j] += b[i][k]*c[k][j];<br>            &#125;<br>       &#125;<br>    &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/pragmas/intel-specific-pragma-reference/unroll-and-jam-nounroll-and-jam.html">unroll_and_jam nounroll_and_jam (intel.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Intel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache Blocking Techniques【个人翻译】</title>
    <link href="/2023/02/26/cache001/"/>
    <url>/2023/02/26/cache001/</url>
    
    <content type="html"><![CDATA[<h2 id="Cache-Blocking-Techniques"><a href="#Cache-Blocking-Techniques" class="headerlink" title="Cache Blocking Techniques"></a>Cache Blocking Techniques</h2><p><strong>文章来源：</strong><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/cache-blocking-techniques.html">Cache Blocking Techniques (intel.cn)</a></p><p><strong>文章作者：</strong><a href="https://community.intel.com/cipcp26785/plugins/custom/intel/intel/custom.userprofile?id=3UpJu61CDTyShonSVJNwDw==&iv=8843887237217530">Amanda K Sharp</a></p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>一类重要的算法更改涉及分块数据结构以适应缓存。通过组织数据内存访问，可以用一个大得多的数据集的一个小子集加载缓存。接下来的想法是在缓存中处理这个数据块。通过在缓存中使用&#x2F;重用这些数据，我们减少了访问内存的需要(减少内存带宽压力)。</p><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>分块是一种著名的优化技术，可以帮助避免许多应用程序中的内存带宽瓶颈。分块背后的关键思想是利用应用程序中固有的数据重用，确保数据在多个用途之间保持在缓存中。分块可以在1-D、2-D或3-D空间数据结构上执行。一些迭代应用程序可以进一步受益于多次迭代的分块(通常称为时间分块)，以进一步缓解带宽瓶颈。就代码更改而言，分块通常涉及循环分割和交换的组合。在大多数应用程序代码中，通过对分块因子进行一些参数化，对源进行正确的更改，用户可以最好地执行分块。</p><h3 id="Original-Source"><a href="#Original-Source" class="headerlink" title="Original Source"></a>Original Source</h3><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran">for (body1 = <span class="hljs-number">0</span>; body1 &lt; NBODIES; body1 ++) &#123;<br>   for (body2=<span class="hljs-number">0</span>; body2 &lt; NBODIES; body2++) &#123;<br>     <span class="hljs-keyword">OUT</span>[body1] += compute(body1, body2);<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在本例中，数据(body2)来自内存。假设NBODIES很大，我们将无法在缓存中重用。此应用程序受内存带宽限制。应用程序将以内存到CPU的速度运行，而不是最佳速度。</p><p><strong>Modified Source (with 1-D blocking):</strong></p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran">for (body2 = <span class="hljs-number">0</span>; body2 &lt; NBODIES; body2 += <span class="hljs-keyword">BLOCK</span>) &#123;<br>   for (body1=<span class="hljs-number">0</span>; body1 &lt; NBODIES; body1 ++) &#123;<br>      for (body22=<span class="hljs-number">0</span>; body22 &lt; <span class="hljs-keyword">BLOCK</span>; body22 ++) &#123;<br>         <span class="hljs-keyword">OUT</span>[body1] += compute(body1, body2 + body22);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在修改后的代码中，数据(body22)在缓存中被保留和重用，从而获得更好的性能。</p><p>例如，上面的代码片段显示了一个分块NBody代码的示例。有两个循环(body1和body2)遍历所有主体。顶部的原始代码流经内部循环中的整个主体集，并且必须在每次迭代中从内存中加载body2值。底部的分块代码是通过将body2循环分解为一个迭代多个BLOCK中的body的外部循环和一个迭代BLOCK中的元素的内部body22循环，并交织body1和body2循环来获得的。这段代码在body1循环的多次迭代中重用了一组BLOCK body2值。如果BLOCK被选中，使得这组值适合缓存，内存流量就会降低一个BLOCK的因子。</p><p>以下是来自OpenMP*版本的NBody基准测试的相关代码片段(使用CHUNK_SIZE因子进行分块应用)。</p><p>在这种情况下，循环展开-阻塞转换被表示为一个pragma，并由编译器完成。在这种情况下，研究-opt-report的输出可以确认编译器确实为你的循环执行了展开阻塞优化。</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran">#define CHUNK_SIZE <span class="hljs-number">8192</span><br><br>#pragma omp parallel <span class="hljs-keyword">private</span>(body_start_index)<br>  for(body_start_index = <span class="hljs-number">0</span>; body_start_index &lt; global_number_of_bodies; body_start_index += CHUNK_SIZE) &#123;<br>    <span class="hljs-built_in">int</span> i;<br>    <span class="hljs-built_in">int</span> body_end_index = body_start_index + CHUNK_SIZE;<br><br>    #pragma omp for <span class="hljs-keyword">private</span>(i) schedule(guided)<br>    #pragma unroll_and_jam (<span class="hljs-number">4</span>)<br>    for(i=starting_index; i&lt;ending_index; i++) &#123;<br>      <span class="hljs-built_in">int</span> j;<br>      <span class="hljs-keyword">TYPE</span> acc_x_0 = <span class="hljs-number">0</span>, acc_y_0 = <span class="hljs-number">0</span>, acc_z_0 = <span class="hljs-number">0</span>;<br>      for(j=body_start_index; j&lt;body_end_index; j+=<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">TYPE</span> delta_x_0 = Input_Position_X[(j+<span class="hljs-number">0</span>)] - Input_Position_X[i];<br>        <span class="hljs-keyword">TYPE</span> delta_y_0 = Input_Position_Y[(j+<span class="hljs-number">0</span>)] - Input_Position_Y[i];<br>        <span class="hljs-keyword">TYPE</span> delta_z_0 = Input_Position_Z[(j+<span class="hljs-number">0</span>)] - Input_Position_Z[i];<br><br>        <span class="hljs-keyword">TYPE</span> gamma_0 = delta_x_0*delta_x_0 + delta_y_0*delta_y_0 + delta_z_0*delta_z_0 + epsilon_sqr;<br>        <span class="hljs-keyword">TYPE</span> s_0 = Mass[j+<span class="hljs-number">0</span>]/(gamma_0 * <span class="hljs-built_in">SQRT</span>(gamma_0));<br>        acc_x_0 += s_0*delta_x_0;<br>        acc_y_0 += s_0*delta_y_0;<br>        acc_z_0 += s_0*delta_z_0;<br>      &#125;<br>      Output_Acceleration[<span class="hljs-number">3</span>*(i+<span class="hljs-number">0</span>)+<span class="hljs-number">0</span>] += acc_x_0;<br>      Output_Acceleration[<span class="hljs-number">3</span>*(i+<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>] += acc_y_0;<br>      Output_Acceleration[<span class="hljs-number">3</span>*(i+<span class="hljs-number">0</span>)+<span class="hljs-number">2</span>] += acc_z_0;<br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>下面是Fortran中的一个矩阵乘法代码示例，其中用户执行高级块展开-分块转换(在修改版本中)，涉及本地复制数组以获得最佳性能。</p><p><strong>Fortran Source Example:</strong></p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">do</span> j=<span class="hljs-number">1</span>,N<br>  <span class="hljs-keyword">do</span> k = <span class="hljs-number">1</span>,N<br>    <span class="hljs-keyword">do</span> i = <span class="hljs-number">1</span>,N<br>      c(i,j) = c(i,j) + a(i,k) * b(k,j)<br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br><span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br></code></pre></div></td></tr></table></figure><p><strong>Modified Fortran Source:</strong></p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">do</span> JJ = <span class="hljs-number">1</span>, N, TJ<br><br>       <span class="hljs-keyword">do</span> KK = <span class="hljs-number">1</span>, N, TK<br>         <span class="hljs-keyword">do</span> jjj = <span class="hljs-number">1</span>,<span class="hljs-built_in">min</span>(tj,N-jj+<span class="hljs-number">1</span>)                     <span class="hljs-comment">! BCOPY - no transpose</span><br>           <span class="hljs-keyword">do</span> kkk = <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(tk,N-kk+<span class="hljs-number">1</span>)<br>             p(kkk,jjj-<span class="hljs-number">1</span>+<span class="hljs-number">1</span>) = B(kk+kkk-<span class="hljs-number">1</span>, jj+jjj-<span class="hljs-number">1</span>)<br>           <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>         <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>         <span class="hljs-keyword">do</span> II = <span class="hljs-number">1</span>, N, TI<br>           <span class="hljs-keyword">do</span> iii = <span class="hljs-number">1</span>,<br>             <span class="hljs-built_in">min</span>(ti,N-ii+<span class="hljs-number">1</span>)                   <span class="hljs-comment">!ACOPY - transpose</span><br>             <span class="hljs-keyword">do</span> kkk = <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(tk,N-kk+<span class="hljs-number">1</span>)<br>                Q(kkk,iii) = A(ii+iii-<span class="hljs-number">1</span>, kk+kkk-<span class="hljs-number">1</span>)<br>             <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>           <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>           <span class="hljs-keyword">do</span> J = <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(tj,N-jj+<span class="hljs-number">1</span>), <span class="hljs-number">4</span><br>             <span class="hljs-keyword">do</span> I = <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(ti,N-ii+<span class="hljs-number">1</span>), <span class="hljs-number">2</span><br>                t1 = <span class="hljs-number">0</span> ; t2 = <span class="hljs-number">0</span> ; t5 = <span class="hljs-number">0</span> ; t6 = <span class="hljs-number">0</span> ; t9 = <span class="hljs-number">0</span> ; t10 = <span class="hljs-number">0</span> ; t13 =<span class="hljs-number">0</span> ; t14 = <span class="hljs-number">0</span><br>                <span class="hljs-comment">!DIR$ vector aligned                      !DIR$ unroll(2)</span><br>                <span class="hljs-keyword">do</span> K = <span class="hljs-number">1</span>,<span class="hljs-built_in">min</span>(TK,N-kk+<span class="hljs-number">1</span>)      <span class="hljs-comment">! Innermost loop, vectorized and unrolled by 2 after that</span><br>                   qi = Q(K,I)           ;    qi1 = Q(K,I+<span class="hljs-number">1</span>)  <br>                   t1 = t1+qi*P(K,J)     ;    t2 = t2+ qi1*P(K,J)<br>                   t5 = t5+ qi*P(K,J+<span class="hljs-number">1</span>)  ;    t6 = t6+ qi1*P(K,J+<span class="hljs-number">1</span>)<br>                   t9 = t9+ qi*P(K,J+<span class="hljs-number">2</span>)  ;    t10 = t10+ qi1*P(K,J+<span class="hljs-number">2</span>)<br>                   t13 = t13+ qi*P(K,J+<span class="hljs-number">3</span>);    t14 = t14+qi1*P(K,J+<span class="hljs-number">3</span>)<br>                <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>               c(i+ii-<span class="hljs-number">1</span>,j+jj-<span class="hljs-number">1</span>) = c(i+ii-<span class="hljs-number">1</span>,j+jj-<span class="hljs-number">1</span>) +t1          ; c(i+<span class="hljs-number">1</span>+ii-<span class="hljs-number">1</span>,j+jj-<span class="hljs-number">1</span>) = c(i+<span class="hljs-number">1</span>+ii-<span class="hljs-number">1</span>,j+jj-<span class="hljs-number">1</span>) + t2<br>               c(i+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>+jj-<span class="hljs-number">1</span>) = c(i+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>+jj-<span class="hljs-number">1</span>) + t5     ; c(i+<span class="hljs-number">1</span>+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>+jj-<span class="hljs-number">1</span>) = c(i+<span class="hljs-number">1</span>+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>+jj-<span class="hljs-number">1</span>) + t6<br>               c(i+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">2</span>+jj-<span class="hljs-number">1</span>) = c(i+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">2</span>+jj-<span class="hljs-number">1</span>) + t9     ; c(i+<span class="hljs-number">1</span>+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">2</span>+jj-<span class="hljs-number">1</span>) = c(i+<span class="hljs-number">1</span>+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">2</span>+jj-<span class="hljs-number">1</span>) + t10<br>               c(i+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">3</span>+jj-<span class="hljs-number">1</span>) = c(i+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">3</span>+jj-<span class="hljs-number">1</span>) + t13    ; c(i+<span class="hljs-number">1</span>+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">3</span>+jj-<span class="hljs-number">1</span>) = c(i+<span class="hljs-number">1</span>+ii-<span class="hljs-number">1</span>,j+<span class="hljs-number">3</span>+jj-<span class="hljs-number">1</span>) + t14<br>             <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>           <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>         <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>       <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>     <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br></code></pre></div></td></tr></table></figure><h3 id="Take-Aways"><a href="#Take-Aways" class="headerlink" title="Take Aways"></a>Take Aways</h3><p>缓存分块是一种重新安排数据访问的技术，将数据子集(块)拉入缓存，并对这个块进行操作，以避免不得不重复从主存中获取数据。正如上面的示例所示，可以以这种方式手动分块循环数据以重用缓存。</p><p>对于性能关键的循环，其中性能分析表明内存带宽限制，而-opt-report显示编译器没有以最佳方式分块循环，您可以考虑手动展开循环，以便更好地分块数据以实现缓存重用。</p><h3 id="NEXT-STEPS"><a href="#NEXT-STEPS" class="headerlink" title="NEXT STEPS"></a>NEXT STEPS</h3><p>您必须从头到尾阅读本指南，使用内置的超链接来指导您在Intel®Xeon处理器上成功地移植和调优应用程序。本指南中提供的路径反映了获得最佳应用程序性能所需的步骤。</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
      <tag>Blocking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP:Internal Control Variables</title>
    <link href="/2023/02/26/openmp008/"/>
    <url>/2023/02/26/openmp008/</url>
    
    <content type="html"><![CDATA[<h2 id="2-5-Internal-Control-Variables"><a href="#2-5-Internal-Control-Variables" class="headerlink" title="2.5 Internal Control Variables"></a>2.5 Internal Control Variables</h2><p>OpenMP实现必须像内部控制变量(icv)一样控制OpenMP程序的行为。这些icv存储的信息包括用于未来并行区域的线程数、用于工作共享循环的调度以及是否启用嵌套并行。在程序执行期间，icv在不同的时间被赋予值(如下所述)。它们是由实现本身初始化的，并且可以通过OpenMP环境变量和调用OpenMP API例程来赋值。程序只能通过OpenMP API例程检索这些icv的值。</p><p>出于说明的目的，本文档使用特定的名称来引用icv，但是实现不需要使用这些名称，也不需要提供访问变量的任何方法，除非通过第<a href="https://www.openmp.org/spec-html/5.0/openmpsu31.html#x50-680002.5.2">189</a>页第<a href="https://www.openmp.org/spec-html/5.0/openmpsu31.html#x50-680002.5.2">2.5.2节</a>所示的方法。</p><p>2.5.1 <a href="https://www.openmp.org/spec-html/5.0/openmpsu30.html#x49-670002.5.1">ICV Descriptions</a></p><p>2.5.2 <a href="https://www.openmp.org/spec-html/5.0/openmpsu31.html#x50-680002.5.2">ICV Initialization</a></p><p>2.5.3 <a href="https://www.openmp.org/spec-html/5.0/openmpsu32.html#x51-710002.5.3">Modifying and Retrieving ICV Values</a></p><p>2.5.4 <a href="https://www.openmp.org/spec-html/5.0/openmpsu33.html#x52-740002.5.4">How ICVs are Scoped</a></p><p>​ 2.5.4.1 <a href="https://www.openmp.org/spec-html/5.0/openmpsu33.html#x52-760002.5.4.1">How the Per-Data Environment ICVs Work</a></p><p>2.5.5 <a href="https://www.openmp.org/spec-html/5.0/openmpsu34.html#x53-770002.5.5">ICV Override Relationships</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.openmp.org/spec-html/5.0/openmpse13.html#x48-660002.5">Internal Control Variables (openmp.org)</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP线程绑定【未完结】</title>
    <link href="/2023/02/26/openmp007/"/>
    <url>/2023/02/26/openmp007/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenMP线程绑定"><a href="#OpenMP线程绑定" class="headerlink" title="OpenMP线程绑定"></a>OpenMP线程绑定</h2><h3 id="OpenMP相关环境变量与指令"><a href="#OpenMP相关环境变量与指令" class="headerlink" title="OpenMP相关环境变量与指令"></a>OpenMP相关环境变量与指令</h3><h4 id="OMP-PROC-BIND"><a href="#OMP-PROC-BIND" class="headerlink" title="OMP_PROC_BIND"></a>OMP_PROC_BIND</h4><p>OMP_PROC_BIND环境变量设置bind-var ICV的初始值。这个环境变量的值可以是true、false，或者用逗号分隔的master、close或spread列表。列表的值设置了对应嵌套级别的并行区域要使用的线程亲和策略。</p><p>如果环境变量设置为false，则执行环境可能会在OpenMP位置之间移动OpenMP线程，线程相关性将被禁用，并行构造上的proc_bind子句将被忽略。</p><p>否则，执行环境不应该在OpenMP位置之间移动OpenMP线程，线程亲和性被启用，并且初始线程被绑定到OpenMP位置列表中的第一个位置，先于第一个活动并行区域。</p><p>如果OMP_PROC_BIND环境变量中的值不是true、false或master、close或spread的逗号分隔列表，则程序的行为是实现定义的。如果初始线程不能绑定到OpenMP位置列表中的第一个位置，则该行为也是实现定义的。</p><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">setenv OMP_PROC_BIND false<br>setenv OMP_PROC_BIND &quot;spread,spread, close&quot;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://harrychen.xyz/2022/05/08/numa-processor-and-cpu-binding/">NUMA 处理器与进程绑定 - Harry Chen’s Blog</a></p><p><a href="https://www.openmp.org/spec-html/5.0/openmpse52.html">OMP_PROC_BIND (openmp.org)</a></p><p><a href="https://www.openmp.org/spec-html/5.0/openmpsu36.html#x56-900002.6.2">Controlling OpenMP Thread Affinity</a></p><p><a href="https://www.openmp.org/spec-html/5.0/openmpse53.html">OMP_PLACES (openmp.org)</a></p><p><a href="https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/optimization-and-programming/openmp-support/openmp-library-support/thread-affinity-interface.html">Thread Affinity Interface (intel.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于GDB的程序调试</title>
    <link href="/2023/02/24/Linux003/"/>
    <url>/2023/02/24/Linux003/</url>
    
    <content type="html"><![CDATA[<h2 id="基于GDB的程序调试"><a href="#基于GDB的程序调试" class="headerlink" title="基于GDB的程序调试"></a>基于GDB的程序调试</h2><h3 id="程序调试工具GDB"><a href="#程序调试工具GDB" class="headerlink" title="程序调试工具GDB"></a>程序调试工具GDB</h3><p>编译器GCC，项目构建工具Make（又称gmake），以及GDB。</p><p><img src="/2023/02/24/Linux003/image-20230224165344672.png" alt="image-20230224165344672"></p><p><strong>GDB是什么？</strong></p><p>GDB：GNU symbolic debugger是Linux下常用的程序调试器</p><p><strong>GDB可以做什么？</strong></p><p><img src="/2023/02/24/Linux003/image-20230224165606636.png" alt="image-20230224165606636"></p><p><strong>GDB官网：</strong><a href="https://www.sourceware.org/gdb/">GDB: The GNU Project Debugger (sourceware.org)</a></p><h3 id="调试案例一"><a href="#调试案例一" class="headerlink" title="调试案例一"></a>调试案例一</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> n,sum;<br>    n = <span class="hljs-number">1</span>;<br>    sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>( n &lt;= <span class="hljs-number">100</span>)<br>    &#123;<br>        sum = sum + n;<br>        n = n + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在编译程序的时候，需要加调试选项： -g</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gcc gdb001.c -g -o ex1<br></code></pre></div></td></tr></table></figure><p>使用gdb启动程序：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gdb ./ex1<br></code></pre></div></td></tr></table></figure><p><strong>进入gdb调试环境</strong>：</p><p><img src="/2023/02/24/Linux003/image-20230224170419171.png" alt="image-20230224170419171"></p><p><strong>在调试环境中：使用l选项会显示带行号的源代码</strong></p><p><img src="/2023/02/24/Linux003/image-20230224170620617.png" alt="image-20230224170620617"></p><p><strong>但是默认情况下，l选项只显示10行源代码，如果查看后续代码，在调试界面Enter回车即可</strong></p><p><img src="/2023/02/24/Linux003/image-20230224170804048.png" alt="image-20230224170804048"></p><p><strong>在第7行源代码处打断点：</strong></p><p><img src="/2023/02/24/Linux003/image-20230224171858691.png" alt="image-20230224171858691"></p><p><strong>运行程序，遇到断点停止：</strong></p><p><img src="/2023/02/24/Linux003/image-20230224172105514.png" alt="image-20230224172105514"></p><p><strong>查看代码中变量n的值</strong></p><p><img src="/2023/02/24/Linux003/image-20230224172200662.png" alt="image-20230224172200662"></p><p>当前n的值为1，$1表示该变量所在存储区的名称</p><p><strong>在程序第12行处打断点</strong></p><p><img src="/2023/02/24/Linux003/image-20230224172321002.png" alt="image-20230224172321002"></p><p><strong>继续执行程序</strong></p><p><img src="/2023/02/24/Linux003/image-20230224172356622.png" alt="image-20230224172356622"></p><p><strong>查看当前n变量的值</strong></p><p><img src="/2023/02/24/Linux003/image-20230224172422998.png" alt="image-20230224172422998"></p><p>当前n的值为101</p><p><strong>退出调试</strong></p><p><img src="/2023/02/24/Linux003/image-20230224172456626.png" alt="image-20230224172456626"></p><p><strong>查看调试环境所有断点：</strong></p><p><img src="/2023/02/24/Linux003/image-20230224172650422.png" alt="image-20230224172650422"></p><p><strong>删除第7行的断点：</strong></p><p><img src="/2023/02/24/Linux003/image-20230224172745323.png" alt="image-20230224172745323"></p><p><strong>禁用编号为2的断点：</strong></p><p><img src="/2023/02/24/Linux003/image-20230224172832507.png" alt="image-20230224172832507"></p><p>注意断点状态Enb(enable)由y变成n，代表禁用</p><p><strong>恢复编号为2的断点：</strong></p><p><img src="/2023/02/24/Linux003/image-20230224173006975.png" alt="image-20230224173006975"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>GDB有三种调试模式：</p><p><strong>调试执行程序：</strong>（前面的案例），注意编译加调试信息(-g)</p><p><strong>调试core文件   ：</strong>需要对系统设置的core文件大小作调整（ulimit - c unlimlited），否则可能无法  产生core文件</p><p><strong>调试正在执行的程序（gdb attach） ：</strong>Top找到进程编号pid，Gdb attach pid</p><p><strong>GDB结构组成：</strong></p><p><img src="/2023/02/24/Linux003/image-20230224173613247.png" alt="image-20230224173613247"></p><h3 id="常用调试指令："><a href="#常用调试指令：" class="headerlink" title="常用调试指令："></a>常用调试指令：</h3><h4 id="启动指令"><a href="#启动指令" class="headerlink" title="启动指令"></a>启动指令</h4><p>调试程序：gdb program</p><p>根据core文件调试程序：gdb program corefile</p><p>跟踪调试进程：gdb attach pid</p><h4 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h4><p>run，该命令会运行至程序结束，除非遇到断点或报错</p><h4 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h4><p>步进执行不进栈？next</p><p>步进执行，进栈step</p><h4 id="代码查看"><a href="#代码查看" class="headerlink" title="代码查看"></a>代码查看</h4><p>列出断点附近或程序所有代码list</p><p>设置现实代码的行数 set listsize &lt;n&gt;</p><h4 id="退出调试"><a href="#退出调试" class="headerlink" title="退出调试"></a>退出调试</h4><p>quit</p><h4 id="查看栈信息"><a href="#查看栈信息" class="headerlink" title="查看栈信息"></a>查看栈信息</h4><p>bt打印当前的函数调用栈的所有信息</p><p>bt &lt;n&gt;n是一个正整数，表示只打印栈顶上n层的栈信息</p><p>bt &lt;-n&gt;表示只打印栈底下n层的栈信息</p><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><p><strong>代码断点：</strong></p><ul><li>break lineNumber | functionName</li><li>break lineNumber | functionName if condition</li><li>tbreak lineNumber | functionName  临时断点，仅能使用一次</li></ul><p><strong>内存断点（观察点）：</strong></p><ul><li>监控内存值改变 watch expr [if condition]</li><li>监控内存值被读取 rwatch expr [if condition]</li><li>监控内存值被读取和写入 awatch wxpr [if condition]</li></ul><p><strong>事件断点：</strong></p><ul><li>C++ exception，使用catch exception [name]</li><li>Ada exception，使用catch handlers [name]</li><li>exec事件，使用catch exec</li><li>fork事件，使用catch fork 或者 catch vfork</li><li>加载和卸载动态so事件，使用catch load|unload [regexp]</li><li>监听系统信号，使用catch signal [signal]</li><li>监听系统调用，使用catch syscall[name|number|group:groupname|g:groupname]…</li></ul><p><strong>打印变量：</strong></p><ul><li>Print [file | func]::variable 查看局部变量或全局变量</li><li>Print *array@len  数组首地址@查看长度</li><li>x&#x2F;[n | u] &lt;addr&gt;x命令查看内存地址钟的值，n：表示显示内存的长度，u：表示从当前地址往后请求的字节数</li></ul><p><strong>打印寄存器：</strong></p><p>info register查看寄存器（除了浮点寄存器）</p><p>all-registers查看所有寄存器</p><p>info registers &lt;reg_name …&gt;查看所指定寄存器</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><strong>来源培训PPT 作者：Relax  邮箱：<a href="mailto:&#119;&#97;&#110;&#x67;&#119;&#49;&#49;&#x31;&#x40;&#105;&#99;&#108;&#111;&#x75;&#x64;&#46;&#x63;&#111;&#109;">&#119;&#97;&#110;&#x67;&#119;&#49;&#49;&#x31;&#x40;&#105;&#99;&#108;&#111;&#x75;&#x64;&#46;&#x63;&#111;&#109;</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵乘法计算拆分展示</title>
    <link href="/2023/02/19/Matrix002/"/>
    <url>/2023/02/19/Matrix002/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵乘法计算拆分展示"><a href="#矩阵乘法计算拆分展示" class="headerlink" title="矩阵乘法计算拆分展示"></a>矩阵乘法计算拆分展示</h2><h3 id="通用矩阵乘概念"><a href="#通用矩阵乘概念" class="headerlink" title="通用矩阵乘概念"></a>通用矩阵乘概念</h3><p><img src="/2023/02/19/Matrix002/image-20230219171156738.png" alt="image-20230219171156738"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<span class="hljs-comment">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<span class="hljs-comment">//遍历C矩阵i行j列</span><br>        c[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; k; p++)&#123;<span class="hljs-comment">//用p循环累加和计算C[i][j] </span><br>            <span class="hljs-comment">//计算区域</span><br>           C[i][j] += A[i][p] * B[p][j];<span class="hljs-comment">//遍历A矩阵各行与B矩阵各列</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="计算拆分展示"><a href="#计算拆分展示" class="headerlink" title="计算拆分展示"></a>计算拆分展示</h3><p>图四将输出计算拆分为 <strong>1 × 4</strong> 的小块，即将 <strong>N</strong> 维度拆分为两部分。计算该块输出时，需要使用 <strong>A</strong> 矩阵的1行，和 <strong>B</strong> 矩阵的4列 。</p><p><img src="/2023/02/19/Matrix002/image-20230219171904249.png" alt="image-20230219171904249"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<span class="hljs-comment">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j +=<span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//遍历C矩阵j-j+3列</span><br>        c[i][j + <span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        c[i][j + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        c[i][j + <span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>        c[i][j + <span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; k; p++)&#123;<span class="hljs-comment">//用p循环累加和计算C[i][j] </span><br>            <span class="hljs-comment">//计算区域</span><br>            <span class="hljs-comment">//遍历A矩阵各行与B矩阵各列</span><br>           C[i][j + <span class="hljs-number">0</span>] += A[i][p] * B[p][j + <span class="hljs-number">0</span>];    <br>           C[i][j + <span class="hljs-number">1</span>] += A[i][p] * B[p][j + <span class="hljs-number">1</span>];<br>           C[i][j + <span class="hljs-number">2</span>] += A[i][p] * B[p][j + <span class="hljs-number">2</span>];<br>           C[i][j + <span class="hljs-number">3</span>] += A[i][p] * B[p][j + <span class="hljs-number">3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最内侧计算使用的矩阵<strong>A</strong>的元素是一致的。因此可以将**A[i][p]**读取到寄存器中，从而实现4次数据复用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> temp = A[i][p];<br></code></pre></div></td></tr></table></figure><p>一般将最内侧循环称作计算核(micro kernel)</p><p>类似地，我们可以继续拆分输出<strong>M</strong>维度，从而在内测循环中计算 <strong>4 × 4</strong> 输出，如图五。</p><p><img src="/2023/02/19/Matrix002/image-20230219174355047.png" alt="image-20230219174355047"></p><p>同样的，将计算核心展开，可以得到下面的伪代码。这里我们将 <strong>1 × 4</strong> 中展示过的N维度的计算简化表示。这种拆分可看成是<strong>4 × 1 × 4</strong>，这样A和B的访存均可复用四次。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i+=<span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//遍历C矩阵i-i+3行，其行数与A的行数相等 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j +=<span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//遍历C矩阵第j-j+3列</span><br>        c[i + <span class="hljs-number">0</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] = <span class="hljs-number">0</span>;<br>        c[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] = <span class="hljs-number">0</span>;<br>        c[i + <span class="hljs-number">2</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] = <span class="hljs-number">0</span>;<br>        c[i + <span class="hljs-number">3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; k; p++)&#123;<span class="hljs-comment">//用p循环累加和计算C[i][j] </span><br>            <span class="hljs-comment">//计算区域</span><br>            <span class="hljs-comment">//遍历A矩阵各行与B矩阵各列</span><br>           C[i + <span class="hljs-number">0</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] += A[i + <span class="hljs-number">0</span>][p] * B[p][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>];    <br>           C[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] += A[i + <span class="hljs-number">1</span>][p] * B[p][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>];<br>           C[i + <span class="hljs-number">2</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] += A[i + <span class="hljs-number">2</span>][p] * B[p][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>];<br>           C[i + <span class="hljs-number">3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] += A[i + <span class="hljs-number">3</span>][p] * B[p][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>到目前为止。我们都是在输出的两个维度上展开，而整个计算还包含一个规约(Reduction)维度K。图六展示了在计算<strong>4 × 4</strong>输出时，将维度K拆分，从而每次最内侧循环计算出输出矩阵C的<strong>4&#x2F;K</strong>的部分和。</p><p><img src="/2023/02/19/Matrix002/image-20230219180147184.png" alt="image-20230219180147184"></p><p>下面展示的是这部分计算的展开伪代码，其中维度M和N已经被简写。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i+=<span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//遍历C矩阵i-i+3行，其行数与A的行数相等 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j +=<span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//遍历C矩阵第j-j+3列</span><br>        c[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] = <span class="hljs-number">0</span>;<br>        c[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] = <span class="hljs-number">0</span>;<br>        c[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] = <span class="hljs-number">0</span>;<br>        c[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; k; p+=<span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//用p循环累加和计算C[i][j] </span><br>            <span class="hljs-comment">//计算区域</span><br>           C[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] += A[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][p + <span class="hljs-number">0</span>] * B[p + <span class="hljs-number">0</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>];    <br>           C[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] += A[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][p + <span class="hljs-number">1</span>] * B[p + <span class="hljs-number">1</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>];<br>           C[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] += A[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][p + <span class="hljs-number">2</span>] * B[p + <span class="hljs-number">2</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>];<br>           C[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>] += A[i + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>][p + <span class="hljs-number">3</span>] * B[p + <span class="hljs-number">3</span>][j + <span class="hljs-number">0.</span><span class="hljs-number">.3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在对M和N展开式，我们可以分别复用B和A的数据；在对K展开时，其局部使用的C的内存是一致的，那么K迭代时可以将部分和累加在寄存器中——最内层循环整个迭代一次写到C的内存中。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhenhuaw.me/blog/2019/gemm-optimization.html">通用矩阵乘（GEMM）优化算法 | 黎明灰烬 博客 (zhenhuaw.me)</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matrix</tag>
      
      <tag>GEMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. 盛最多水的容器</title>
    <link href="/2023/02/18/leetcode11/"/>
    <url>/2023/02/18/leetcode11/</url>
    
    <content type="html"><![CDATA[<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><h4 id="11-盛最多水的容器-1"><a href="#11-盛最多水的容器-1" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-comment">//双指针；</span><br>        <span class="hljs-keyword">int</span> ans =<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right=height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">int</span> temp=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(height[left]&lt;=height[right])&#123;<br>                temp = height[left]*(right-left);<br>                ans = std::<span class="hljs-built_in">max</span>(ans,temp);<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                temp = height[right]*(right-left);<br>                ans = std::<span class="hljs-built_in">max</span>(ans,temp);<br>                right--;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/">盛最多水的容器 - 盛最多水的容器 - 力扣（LeetCode）</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146.LRU cache</title>
    <link href="/2023/02/17/leetcode001/"/>
    <url>/2023/02/17/leetcode001/</url>
    
    <content type="html"><![CDATA[<h2 id="146-LRU-cache"><a href="#146-LRU-cache" class="headerlink" title="146.LRU cache"></a>146.LRU cache</h2><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存 - 力扣（LeetCode）</a></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> cap=<span class="hljs-number">0</span>;<br>    list&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; lru;   <span class="hljs-comment">//真正的cache</span><br>    unordered_map&lt;<span class="hljs-keyword">int</span>,list&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;::iterator&gt; mp;   <span class="hljs-comment">//主要用处就是查找</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> capacity) &#123;<br>        cap = capacity;<span class="hljs-comment">//容量</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<span class="hljs-comment">//作为就是把最近访问的放在表头</span><br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(key)!=mp.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//有这个元素</span><br>            lru.<span class="hljs-built_in">splice</span>(lru.<span class="hljs-built_in">begin</span>(),lru,mp[key]);<span class="hljs-comment">//将一个 list 容器中的元素插入到另一个容器的指定位置</span><br>            <span class="hljs-keyword">return</span> lru.<span class="hljs-built_in">begin</span>()-&gt;second;<span class="hljs-comment">//返回元素</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//没有这个元素</span><br>        &#125;<br>    &#125;<br><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(key)!=<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//cache中有key，调用get后自动插入到表头【key存在】</span><br>            lru.<span class="hljs-built_in">begin</span>()-&gt;second = value;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//【key不存在】</span><br>            <span class="hljs-keyword">if</span>(lru.<span class="hljs-built_in">size</span>()==cap)&#123;<span class="hljs-comment">//如果容量满了</span><br>                <span class="hljs-keyword">int</span> delkey = lru.<span class="hljs-built_in">back</span>().first; <span class="hljs-comment">//记录最久未访问的key</span><br>                lru.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//pop掉，置换</span><br>                mp.<span class="hljs-built_in">erase</span>(delkey); <span class="hljs-comment">//查找表中也删除</span><br>            &#125;<br>            lru.<span class="hljs-built_in">emplace_front</span>(key,value);<span class="hljs-comment">//头部生成一个元素</span><br>            mp[key]=lru.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//加入查找表</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/bbea4b2410e6">C++实现LRU缓存——LeetCode146 - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLISlab中C矩阵初始化速度测试</title>
    <link href="/2023/02/15/blislab003/"/>
    <url>/2023/02/15/blislab003/</url>
    
    <content type="html"><![CDATA[<h2 id="BLISlab中C矩阵初始化速度测试"><a href="#BLISlab中C矩阵初始化速度测试" class="headerlink" title="BLISlab中C矩阵初始化速度测试"></a>BLISlab中C矩阵初始化速度测试</h2><p><strong>假设我们想把C中的所有元素都设为0。</strong></p><p><strong>统一编译命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">g++  xxx.cpp -O0 -std=c++11 -o xxx<br></code></pre></div></td></tr></table></figure><h3 id="版本一："><a href="#版本一：" class="headerlink" title="版本一："></a>版本一：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i,j,m,n;<br>m=<span class="hljs-number">20000</span>;<br>n=<span class="hljs-number">20000</span>;<br><span class="hljs-keyword">int</span> ldc=m;<br><span class="hljs-keyword">double</span>*C =(<span class="hljs-keyword">double</span>*)_mm_malloc(m*n*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>),<span class="hljs-number">32</span>);<br>std::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>    <span class="hljs-keyword">for</span>( j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123; <br>        <span class="hljs-built_in">C</span>(i,j) = <span class="hljs-number">0.0</span>;<br>    &#125;<br>&#125;<br>std::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>std::chrono::duration&lt;<span class="hljs-keyword">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="实测结果："><a href="#实测结果：" class="headerlink" title="实测结果："></a>实测结果：</h3><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>被计时代码耗时：<span class="hljs-number">10776901341</span> 纳秒<br><span class="hljs-symbol">2 </span>被计时代码耗时：<span class="hljs-number">10776901</span> 微妙<br><span class="hljs-symbol">3 </span>被计时代码耗时：<span class="hljs-number">10776</span> 毫秒<br><span class="hljs-symbol">4 </span>被计时代码耗时：<span class="hljs-number">10</span> 秒钟<br></code></pre></div></td></tr></table></figure><h3 id="版本二："><a href="#版本二：" class="headerlink" title="版本二："></a>版本二：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i,j,m,n;<br>m=<span class="hljs-number">20000</span>;<br>n=<span class="hljs-number">20000</span>;<br><span class="hljs-keyword">int</span> ldc=m;<br><span class="hljs-keyword">double</span>*C =(<span class="hljs-keyword">double</span>*)_mm_malloc(m*n*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>),<span class="hljs-number">32</span>);<br><span class="hljs-keyword">double</span> *cp;<br>std::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-keyword">for</span>( j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j*ldc ];<span class="hljs-comment">//point cp to top of ith column</span><br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        *cp++ = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//set element that cp points to to zero and</span><br>    &#125;<span class="hljs-comment">//advance the pointer</span><br>&#125;<br>std::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>std::chrono::duration&lt;<span class="hljs-keyword">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="实测结果：-1"><a href="#实测结果：-1" class="headerlink" title="实测结果："></a>实测结果：</h3><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>被计时代码耗时：<span class="hljs-number">3455968000</span> 纳秒<br><span class="hljs-symbol">2 </span>被计时代码耗时：<span class="hljs-number">3455968</span> 微妙<br><span class="hljs-symbol">3 </span>被计时代码耗时：<span class="hljs-number">3455</span> 毫秒<br><span class="hljs-symbol">4 </span>被计时代码耗时：<span class="hljs-number">3</span> 秒钟<br></code></pre></div></td></tr></table></figure><h3 id="版本三："><a href="#版本三：" class="headerlink" title="版本三："></a>版本三：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i,j,m,n;<br>m=<span class="hljs-number">20000</span>;<br>n=<span class="hljs-number">20000</span>;<br><span class="hljs-keyword">int</span> ldc=m;<br><span class="hljs-keyword">double</span>*C =(<span class="hljs-keyword">double</span>*)_mm_malloc(m*n*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>),<span class="hljs-number">32</span>);<br><span class="hljs-keyword">double</span> *cp;<br>std::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-keyword">for</span>( j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j * ldc ];<br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; m; i+=<span class="hljs-number">4</span>)&#123;<br>       *(cp+<span class="hljs-number">0</span>) = <span class="hljs-number">0.0</span>;<br>        *(cp+<span class="hljs-number">1</span>) = <span class="hljs-number">0.0</span>;<br>        *(cp+<span class="hljs-number">2</span>) = <span class="hljs-number">0.0</span>;<br>        *(cp+<span class="hljs-number">3</span>) = <span class="hljs-number">0.0</span>;<br>        cp+=<span class="hljs-number">4</span>;<br>   &#125;<br>&#125;<br>std::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>std::chrono::duration&lt;<span class="hljs-keyword">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="实测结果：-2"><a href="#实测结果：-2" class="headerlink" title="实测结果："></a>实测结果：</h3><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>被计时代码耗时：<span class="hljs-number">2581347801</span> 纳秒<br><span class="hljs-symbol">2 </span>被计时代码耗时：<span class="hljs-number">2581347</span> 微妙<br><span class="hljs-symbol">3 </span>被计时代码耗时：<span class="hljs-number">2581</span> 毫秒<br><span class="hljs-symbol">4 </span>被计时代码耗时：<span class="hljs-number">2</span> 秒钟<br></code></pre></div></td></tr></table></figure><h3 id="版本四："><a href="#版本四：" class="headerlink" title="版本四："></a>版本四：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i,j,m,n;<br>m=<span class="hljs-number">20000</span>;<br>n=<span class="hljs-number">20000</span>;<br><span class="hljs-keyword">int</span> ldc=m;<br><span class="hljs-keyword">double</span>*C =(<span class="hljs-keyword">double</span>*)_mm_malloc(m*n*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>),<span class="hljs-number">32</span>);<br><span class="hljs-keyword">double</span> *cp;<br>std::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> c0 =<span class="hljs-number">0.0</span>,c1=<span class="hljs-number">0.0</span>,c2=<span class="hljs-number">0.0</span>,c3=<span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>( j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j * ldc ];<br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; m; i+=<span class="hljs-number">4</span>)&#123;<br>        *(cp+<span class="hljs-number">0</span>) = c0;<br>        *(cp+<span class="hljs-number">1</span>) = c1;<br>        *(cp+<span class="hljs-number">2</span>) = c2;<br>        *(cp+<span class="hljs-number">3</span>) = c3;<br>        cp+=<span class="hljs-number">4</span>;<br>    &#125;<br>&#125;<br>std::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>std::chrono::duration&lt;<span class="hljs-keyword">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="实测结果：-3"><a href="#实测结果：-3" class="headerlink" title="实测结果："></a>实测结果：</h3><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>被计时代码耗时：<span class="hljs-number">2269606428</span> 纳秒<br><span class="hljs-symbol">2 </span>被计时代码耗时：<span class="hljs-number">2269606</span> 微妙<br><span class="hljs-symbol">3 </span>被计时代码耗时：<span class="hljs-number">2269</span> 毫秒<br><span class="hljs-symbol">4 </span>被计时代码耗时：<span class="hljs-number">2</span> 秒钟<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://gukaifeng.cn/posts/c-11-chrono-gao-jing-du-ji-shi-fang-fa/">C++11 chrono 高精度计时方法 | GuKaifeng’s Blog</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>dgemm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLISlab tutoril阅读</title>
    <link href="/2023/02/12/blislib002/"/>
    <url>/2023/02/12/blislib002/</url>
    
    <content type="html"><![CDATA[<h1 id="BLISlab-tutoril阅读"><a href="#BLISlab-tutoril阅读" class="headerlink" title="BLISlab tutoril阅读"></a>BLISlab tutoril阅读</h1><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><strong>Git地址：</strong><a href="https://github.com/flame/blislab">https://github.com/flame/blislab</a> 【代码包包含tutoril.pdf】</p><h2 id="BLISlab-A-Sandbox-for-Optimizing-GEMM"><a href="#BLISlab-A-Sandbox-for-Optimizing-GEMM" class="headerlink" title="BLISlab: A Sandbox for Optimizing GEMM"></a>BLISlab: A Sandbox for Optimizing GEMM</h2><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>矩阵-矩阵乘法是科学计算中非常重要的基本运算，机器学习也越来越重要。这是一个非常简单的概念，可以在典型的高中代数课程中引入，但在实践中又非常重要，它在计算机上的实现仍然是一个活跃的研究主题。本笔记描述了一组使用该操作的练习，如何在具有分层内存(多个缓存)的现代cpu上获得高性能。它是基于blas类库实例化软件(BLIS)框架下的见解，通过公开一个模仿BLIS实现的简化“沙盒”来实现的。因此，它也成为BLIS优化的“众包”工具。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><p>矩阵-矩阵乘法(Gemm)经常被用作一个简单的例子，以提高如何在现代处理器上优化代码的意识。原因是该操作描述简单，很难完全优化，而且具有实际意义。在本文档中，我们将带领读者了解目前CPU架构中最快实现的技术。</p><h3 id="1-1-Basic-Linear-Algebra-Subprograms-BLAS"><a href="#1-1-Basic-Linear-Algebra-Subprograms-BLAS" class="headerlink" title="1.1 Basic Linear Algebra Subprograms (BLAS)"></a>1.1 Basic Linear Algebra Subprograms (BLAS)</h3><p>基本线性代数子程序(BLAS)[10,5,4,14]为一组线性代数操作形成了一个接口，在此基础上构建了更高级别的线性代数库，如LAPACK[2]和libflame[19]。其思想是，如果有人针对给定的体系结构优化BLAS，那么所有以调用BLAS的方式编写的应用程序和库都将受益于这种优化。</p><p>BLAS被分为三组:一级BLAS(矢量-矢量操作)、二级BLAS(矩阵-矢量操作)和三级BLAS(矩阵-矩阵操作)。最后一组得益于这样一个事实:如果所有矩阵操作数的大小都是n × n，则O(n3)浮点运算对O(n)个数据执行，因此在内存层(主存、缓存和寄存器)之间移动数据的成本可以在很多次计算中平摊。因此，如果仔细执行这些操作，原则上可以实现高性能。</p><h3 id="1-2-Matrix-matrix-multiplication"><a href="#1-2-Matrix-matrix-multiplication" class="headerlink" title="1.2 Matrix-matrix multiplication"></a>1.2 Matrix-matrix multiplication</h3><p>特别地，BLAS通过(Fortran)调用支持具有双精度浮点数的Gemm:</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran">dgemm( transa, transb, m, n, k alpha, A,lda, B, ldb, beta, C, ldc)<br></code></pre></div></td></tr></table></figure><p>通过适当地选择转置a和转置b来计算:</p><p><img src="/2023/02/12/blislib002/image-20230212215656711.png" alt="image-20230212215656711"></p><p>这里C是m × n, k是“第三维”。参数dla, dlb和dlc将在本文档后面进行解释。</p><p>在我们的练习中，我们考虑Gemm的简化版本:</p><p><img src="/2023/02/12/blislib002/image-20230212215836596.png" alt="image-20230212215836596"></p><p>其中C是m × n, A是m × k, B是k × n。如果了解如何优化dgemm的这种特殊情况，那么可以很容易地将此知识扩展到所有3级BLAS功能。</p><h3 id="1-3-High-performance-implementation"><a href="#1-3-High-performance-implementation" class="headerlink" title="1.3 High-performance implementation"></a>1.3 High-performance implementation</h3><p>高性能实现的复杂性使得BLAS(尤其是Gemm)的实现通常都是由默默无闻的专家来完成的，这些专家为硬件供应商开发数字库，例如IBM的ESSL、Intel的MKL、Cray的LibSci和AMD的ACML库。这些库通常是用汇编代码编写的(至少是部分)，并且针对特定的处理器高度专门化。</p><p>一篇关键论文[1]展示了“算法和体系结构”方法如何携手设计ar体系结构、编译器和算法，使BLAS能够用高级语言(Fortan)为IBM Power体系结构编写，并解释了在这些处理器上实现高性能的复杂性。便携式高性能ANSI C (PHiPAC)[3]项目随后提供了用C编写高性能代码的指南，并建议如何自动生成和优化以这种方式编写的Gemm。Au tomatatically tuning Linear Algebra Software (ATLAS)[17,18]建立在这些见解的基础上，使BLAS库的自动调优和自动生成成为主流。</p><p>在本文档的一部分中，我们讨论了有关该主题的最新论文，包括引入了实施Gemm[6]的Goto方法和该方法[16]的BLIS重构的论文，以及其他更直接相关的论文。</p><h3 id="1-4-Other-similar-exercises"><a href="#1-4-Other-similar-exercises" class="headerlink" title="1.4 Other similar exercises"></a>1.4 Other similar exercises</h3><p>还有一些人基于Gemm组合了练习。与本文相关的最新成果有:乌尔姆大学Michael Lehn所作的“优化微内核:从纯C到SSE”，以及我们自己整理的关于“优化微内核”的维基。</p><h3 id="1-5-We-need-you"><a href="#1-5-We-need-you" class="headerlink" title="1.5 We need you!"></a>1.5 We need you!</h3><p>本文的目的是指导您实现Gemm的高性能实现。我们的别有用心是，用于实现BLAS的BLIS框架需要针对各种cpu高度优化的所谓微内核。在教你基本技巧的过程中，我们希望找到“那个人”将贡献最好的微内核。就把它当做我们版的高性能计算机达人秀吧。虽然我们在描述中关注的是Intel Haswell架构的优化，但是设置可以很容易地修改，从而帮助您(和我们)优化其他cpu。事实上，BLIS本身支持的体系结构包括AMD和Intel的x86处理器，IBM的Power处理器，ARM处理器和德州仪器的DSP处理器[15,12,8]。</p><h2 id="2-Step-1-The-Basics"><a href="#2-Step-1-The-Basics" class="headerlink" title="2 Step 1: The Basics"></a>2 Step 1: The Basics</h2><h3 id="2-1-Simple-matrix-matrix-multiplication"><a href="#2-1-Simple-matrix-matrix-multiplication" class="headerlink" title="2.1 Simple matrix-matrix multiplication"></a>2.1 Simple matrix-matrix multiplication</h3><p>在我们的讨论中，我们将考虑计算：</p><p><img src="/2023/02/12/blislib002/image-20230213165803939.png" alt="image-20230213165803939"></p><p><img src="/2023/02/12/blislib002/image-20230213165826084.png" alt="image-20230213165826084"></p><p>其中，A、B、C分别为m × k、k × n、m × n矩阵。</p><p><img src="/2023/02/12/blislib002/image-20230213165920897.png" alt="image-20230213165920897"></p><p>如果A、B和C存储在二维数组A、B和C中，下面的伪代码计算C:&#x3D;<br>AB + C:</p><p><img src="/2023/02/12/blislib002/image-20230213170125083.png" alt="image-20230213170125083"></p><p>分别计算乘法和加法，计算需要2mnk个浮点运算(flop)。</p><h3 id="2-2-Setup"><a href="#2-2-Setup" class="headerlink" title="2.2 Setup"></a>2.2 Setup</h3><p>为了让您高效地学习如何高效地进行计算，您可以在启动项目时准备好大部分基础设施。我们已经构造了子目录step1，有点像实现真正库might的项目。对于我们的目的来说，这可能是多余的，但是如何构建软件项目是一项值得学习的有用技能。</p><p><img src="/2023/02/12/blislib002/image-20230214173819349.png" alt="image-20230214173819349"></p><p>考虑图4，它演示了子目录step1的目录结构:</p><p><strong>README</strong>是一个描述目录内容以及如何编译和执行代码的文件。</p><p><strong>source .sh</strong>配置环境变量的文件。在那个文件中</p><p><strong>BLISLAB USE INTEL</strong>设置是否使用INTEL编译器(true)或GNU编译器(false)。</p><p><strong>BLISLAB USE BLAS</strong>指示您的参考dgemm是否使用外部BLAS库实现(如果您的机器上安装了这样的BLAS库，则为true)，还是简单的三重循环实现(false)。</p><p><strong>COMPILER OPT LEVEL</strong>设置GNU或Intel编译器的优化级别(O0, O1, O2, O3)。<br>(请注意，例如，O3由大写字母“O”和数字“3”组成。)</p><p><strong>OMP NUM THREADS</strong> and <strong>BLISLAB IC NT</strong>设置用于并行版本的线程数<br>代码。对于第1步，将它们都设置为1。</p><p><strong>dgemm</strong>是实现dgemm的例程存在的子目录。在其中</p><p><strong>bl_dgemm_ref.c</strong>包含例程<strong>dgemm ref</strong>，它是dgemm的一个简单实现，如果<strong>BLISLAB_use_BLAS &#x3D; false</strong>，您将使用它来检查实现的正确性。</p><p><strong>my_dgemm.c</strong>包含例程<strong>dgemm</strong>，它最初是dgemm的一个简单实现，您将优化它作为掌握如何优化gemm的第一步的一部分。</p><p><strong>Bl_dgemm_util.c</strong>包含稍后会派上用场的实用程序例程</p><p><strong>include</strong>这个目录包含包含各种宏定义和其他头信息的文件。</p><p><strong>lib</strong>此目录将保存由您实现的源文件(libblislab. lib)生成的库。libblislab.a)您还可以在此目录中安装参考库(例如OpenBLAS)以比较性能。</p><p><strong>test</strong> 这个目录包含“测试驱动程序”和各种实现的正确性&#x2F;性能检查脚本。</p><p><strong>test_bl_demm .c</strong>包含测试例程bl_demm的“测试驱动程序”。</p><p><strong>test_bl_dgemm.x</strong>是<strong>test_bl_dgemm.c</strong>的可执行文件。</p><p><strong>Run_bl_dgemm.sh</strong>包含一个bash脚本，用于收集性能结果。</p><p><strong>tacc_run_bl_dgemm.sh</strong> contains a <strong>SLURM</strong> script for you to (optionally) submit the job to the Texas Advanced Computing Center (TACC) machines if you have an account there.</p><h3 id="2-3-Getting-started"><a href="#2-3-Getting-started" class="headerlink" title="2.3 Getting started"></a>2.3 Getting started</h3><p>我们希望您从my_dgemm.c中的实现开始，并通过应用各种标准优化技术对其进行优化。该文件中的初始实现是具有图2中给出的三个循环的简单实现。首先要注意的是二维数组如何以所谓的列-主序映射到内存。这种选择的原因是最初的BLAS假定数组的列主存储，因为该接口首先是为Fortran用户提供的。检查</p><p><img src="/2023/02/12/blislib002/image-20230214185803699.png" alt="image-20230214185803699"></p><p>我们注意到，每个操作数都是一个宏。考虑文件的早期</p><p><img src="/2023/02/12/blislib002/image-20230214185849594.png" alt="image-20230214185849594"></p><p>地址C处的线性数组用于存储元素Ci,j，因此i,j元素被映射到位置j * ldc + i。查看它的方法是C的每一列都是连续存储的。但是，可以把矩阵C看作是嵌入在一个更大的数组中，该数组有ldc行，因此访问一行就意味着跨ldc遍历数组C。二维数组C的前维数通常是指这个较大数组的行维数，因此变量ldc (C的前维数)。下图说明了这三个矩阵:</p><p><img src="/2023/02/12/blislib002/image-20230214190409172.png" alt="image-20230214190409172"></p><p>其中箭头表示列是连续存储的。</p><h4 id="2-3-1-Configure-the-default-implementation"><a href="#2-3-1-Configure-the-default-implementation" class="headerlink" title="2.3.1 Configure the default implementation"></a>2.3.1 Configure the default implementation</h4><p>默认情况下，练习编译并链接到Intel的icc编译器，该编译器将对代码应用编译器优化(O3级)。您需要通过以下命令设置环境变量:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">source sourceme.sh<br></code></pre></div></td></tr></table></figure><p>在终端中，您将看到输出:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">BLISLAB_USE_INTEL = TRUE<br>COMPILER_OPT_LEVEL = O3<br></code></pre></div></td></tr></table></figure><h4 id="2-3-2-Compile-execute-and-collect-results"><a href="#2-3-2-Compile-execute-and-collect-results" class="headerlink" title="2.3.2 Compile, execute and collect results"></a>2.3.2 Compile, execute and collect results</h4><p>如果您无法访问Intel的编译器(icc)，请阅读第2.3.2小节和2.3.3小节，并继续阅读第2.3.5小节。</p><p>您可以编译、执行代码并通过执行收集性能结果</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">make clean<br>make<br>cd test<br>./run_bl_dgemm.sh<br></code></pre></div></td></tr></table></figure><p>在子目录step1中。您将看到性能结果输出:</p><p><img src="/2023/02/12/blislib002/image-20230214231134260.png" alt="image-20230214231134260"></p><p><img src="/2023/02/12/blislib002/image-20230214231142311.png" alt="image-20230214231142311"></p><p>您可以在run_bl_dgemm.sh中更改采样块大小。请注意，如果代码中有错误，这些错误将被报告为，例如，</p><p><img src="/2023/02/12/blislib002/image-20230214231406465.png" alt="image-20230214231406465"></p><h4 id="2-3-3-Draw-the-performance-graph"><a href="#2-3-3-Draw-the-performance-graph" class="headerlink" title="2.3.3 Draw the performance graph"></a>2.3.3 Draw the performance graph</h4><p>最后，您可以使用<strong>MATLAB</strong>用我们的脚本绘制性能图。在<strong>test</strong>子目录下，执行后</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">./collect_result_step1<br></code></pre></div></td></tr></table></figure><p>你会得到一个MATLAB文件“step1_result.m”，具有性能结果。然后你可以执行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">bl_dgemm_plot.m<br></code></pre></div></td></tr></table></figure><p>在MATLAB中，然后生成性能图。</p><h4 id="2-3-4-Change-to-the-GNU-compiler"><a href="#2-3-4-Change-to-the-GNU-compiler" class="headerlink" title="2.3.4 Change to the GNU compiler"></a>2.3.4 Change to the GNU compiler</h4><p>由于我们希望您明确地了解什么样的技巧可以带来高性能，并且由于有些人可能无法访问Intel编译器，因此接下来应该改为使用GNU C编译器。为此，你必须编辑<strong>sourceme.sh</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">BLISLAB_USE_INTEL=false<br></code></pre></div></td></tr></table></figure><p>然后，类似于默认设置，您需要通过执行以下命令来设置环境变量:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">source sourceme.sh<br></code></pre></div></td></tr></table></figure><p>在终端，你会观察到:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">BLISLAB_USE_INTEL = false<br>COMILER_OPT_LEVEL = O3<br></code></pre></div></td></tr></table></figure><h4 id="2-3-5-Turn-off-optimization"><a href="#2-3-5-Turn-off-optimization" class="headerlink" title="2.3.5 Turn off optimization"></a>2.3.5 Turn off optimization</h4><p>接下来，我们希望您关闭编译器执行的优化。这有三个目的:首先，这意味着您将必须显式地执行优化，这将允许您了解架构和算法如何交互。其次，优化编译器很可能会试图“撤销”您显式试图完成的任务。第三，在代码中构建的技巧越多，编译器就越难找出优化的方法。</p><p>你需要先编辑<strong>sourceme.sh:</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">COMILER_OPT_LEVEL = O0<br></code></pre></div></td></tr></table></figure><p>然后，类似于默认设置，您需要通过执行以下命令来设置环境变量:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">source sourceme.sh<br></code></pre></div></td></tr></table></figure><p>在终端中，您将看到输出:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">BLISLAB_USE_INTEL = false<br>COMILER_OPT_LEVEL =O0<br></code></pre></div></td></tr></table></figure><h4 id="2-3-6-Optional-Use-optimized-BLAS-library-as-reference-implementation"><a href="#2-3-6-Optional-Use-optimized-BLAS-library-as-reference-implementation" class="headerlink" title="2.3.6 (Optional) Use optimized BLAS library as reference implementation"></a>2.3.6 (Optional) Use optimized BLAS library as reference implementation</h4><p>默认情况下，您的参考Gemm实现是一个非常缓慢的三循环实现。如果你在测试机器上安装了BLAS库，你可以通过设置该库中的dgemm作为你的参考实现:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">BLISLAB_USE_BLAS=true<br></code></pre></div></td></tr></table></figure><p>在sourceme.sh。如果使用Intel编译器，则不需要显式指定MKL的路径。但是，如果使用GNU编译器，则需要指定BLAS库的路径。例如，您可能希望从<a href="https://github.com/flame/blis%E5%AE%89%E8%A3%85%E6%88%91%E4%BB%AC%E7%9A%84BLIS%E5%BA%93%E5%88%B0/home/lib/blis%E7%9B%AE%E5%BD%95%E5%90%8C%E6%97%B6%E5%9C%A8sourceme">https://github.com/flame/blis安装我们的BLIS库到/home/lib/blis目录同时在sourceme</a> .sh中设置</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">BLAS_DIR=/home/lib/blis<br></code></pre></div></td></tr></table></figure><p>执行**$ source sourceme .sh**后，你会看到:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">BLISLAB_USE_BLAS = true<br>BLAS_DIR = /home/lib/blis<br></code></pre></div></td></tr></table></figure><p>现在，您的实现的性能和准确性将与这个优化的库例程进行比较。</p><h3 id="2-4-Basic-techniques"><a href="#2-4-Basic-techniques" class="headerlink" title="2.4 Basic techniques"></a>2.4 Basic techniques</h3><p>在本小节中，我们将介绍一些基本的交易技巧。</p><h4 id="2-4-1-Using-pointers"><a href="#2-4-1-Using-pointers" class="headerlink" title="2.4.1 Using pointers"></a>2.4.1 Using pointers</h4><p>既然优化被关闭了，那么矩阵元素所在地址的计算将显式地公开。(优化编译器可以消除这种开销。)您要做的是更改my_gemm.c中的实现，以便它使用指针。在这样做之前，您可能需要备份原始的my_gemm.c，以防需要从头开始重新启动。实际上，在每个步骤中，您可能都希望在单独的文件中备份前面的实现</p><p>这是基本的想法。假设我们想把C中的所有元素都设为0。一个基本的循环，按照在my_gemm.c中找到的内容来设计</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>    <span class="hljs-keyword">for</span>( j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        <span class="hljs-built_in">C</span>(i,j) =<span class="hljs-number">0.0</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Using pointers, we might implement this as</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> *cp;<br><span class="hljs-keyword">for</span>( j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j*ldc ];<span class="hljs-comment">//point cp to top of ith column</span><br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        *cp++ = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//set element that cp points to to zero and</span><br>    &#125;<span class="hljs-comment">//advance the pointer</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意，我们有意地交换了循环的顺序，以便向前移动指针将我们带到C的列中。</p><h4 id="2-4-2-Loop-unrolling"><a href="#2-4-2-Loop-unrolling" class="headerlink" title="2.4.2 Loop unrolling"></a>2.4.2 Loop unrolling</h4><p>每次通过内部循环更新循环索引i和指针cp都会产生相当大的开销。</p><p>因此，编译器将执行循环展开。使用展开因子4，我们将C设置为0的简单循环变成</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> *cp;<br><br><span class="hljs-keyword">for</span>( j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j * ldc ];<br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; m; i+=<span class="hljs-number">4</span>)&#123;<br>        *(cp+<span class="hljs-number">0</span>) = <span class="hljs-number">0.0</span>;<br>        *(cp+<span class="hljs-number">1</span>) = <span class="hljs-number">0.0</span>;<br>        *(cp+<span class="hljs-number">2</span>) = <span class="hljs-number">0.0</span>;<br>        *(cp+<span class="hljs-number">3</span>) = <span class="hljs-number">0.0</span>;<br>        cp+=<span class="hljs-number">4</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>重要的</p><ul><li>i和cp现在每四次迭代才更新一次。</li><li><em>(cp+0)使用称为间接寻址的机器指令，这比使用</em>(cp+k)计算更有效，其中k是变量。</li><li>当它从内存中输入数据到缓存中时，每次输入一条64字节的缓存线。这意味着以64字节的块访问连续数据可以减少内存层之间的内存移动成本。</li></ul><p>请注意，在展开时，如果m不是4的倍数，则可能必须处理“边缘”。</p><p>为了这个练习，你不需要担心这个边缘，只要你明智地选择你的采样块大小，就像第2.5节重申的那样。</p><h4 id="2-4-3-Register-variables"><a href="#2-4-3-Register-variables" class="headerlink" title="2.4.3 Register variables"></a>2.4.3 Register variables</h4><p>注意，只有当数据存储在寄存器中时，计算才会发生。编译器将自动转换代码，以便插入将某些数据放入寄存器的中间步骤。可以给编译器一个提示，将某些数据保存在寄存器中是很好的，如下面的例子所示:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> *cp;<br><br><span class="hljs-keyword">for</span>( j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j * ldc ];<br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; m; i+=<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> c0 =<span class="hljs-number">0.0</span>,c1=<span class="hljs-number">0.0</span>,c2=<span class="hljs-number">0.0</span>,c3=<span class="hljs-number">0.0</span>;<br>        *(cp+<span class="hljs-number">0</span>) = c0;<br>        *(cp+<span class="hljs-number">1</span>) = c1;<br>        *(cp+<span class="hljs-number">2</span>) = c2;<br>        *(cp+<span class="hljs-number">3</span>) = c3;<br>        cp+=<span class="hljs-number">4</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-5-A-modest-first-goal"><a href="#2-5-A-modest-first-goal" class="headerlink" title="2.5 A modest first goal"></a>2.5 A modest first goal</h4><p>现在我们要求您使用上面讨论的技术来优化my_dgemm.c。现在，只需要考虑如何为较小的矩阵获得更好的性能。具体来说，请看下面这张图:</p><p><img src="/2023/02/12/blislib002/image-20230215110352304.png" alt="image-20230215110352304"></p><p>我们想让你做的是编写你的代码，使C的mR × nR块保存在寄存器中。你可以选择mR和nR，但是你需要用这些选项更新文件<strong>include&#x2F;bl_config.h</strong>。这确保了测试驱动程序只尝试这些块大小的倍数的问题大小，所以您不必担心“边缘”。</p><p>您将注意到，即使对于可以放入某个缓存内存中的较小的矩阵，您的实现(比您可能已安装的MKL或其他优化的BLAS库的实现差得多)。原因是编译器没有为浮点运算使用最快的指令。可以通过使用向量intrinsic funtions函数(允许您从C显式地利用它们)或通过在汇编代码中编码来访问这些函数。现在，我们还没到那一步。我们将<br>在步骤3中讨论更多。</p><h2 id="3-Step-2-Blocking"><a href="#3-Step-2-Blocking" class="headerlink" title="3 Step 2: Blocking"></a>3 Step 2: Blocking</h2><h3 id="3-1-Poorman’s-BLAS"><a href="#3-1-Poorman’s-BLAS" class="headerlink" title="3.1 Poorman’s BLAS"></a>3.1 Poorman’s BLAS</h3><p>本练习的第1步使您认识到，随着基于缓存的体系结构的出现，Gemm的高性能实现需要仔细注意数据在内存层之间移动的成本和对该数据的计算的摊薄。为了保持这种可管理性，认识到只有使用相对较小的矩阵执行矩阵-矩阵乘法的“内核”需要高度优化，这是有帮助的，因为使用较大的矩阵的计算可以被分块，然后使用这样的内核而不会对整体性能产生不利影响。这一见解在[9]中得到了明确的提倡。</p><p>这有时被称为“穷人的BLAS”，因为如果一个人只能负担得起优化矩阵-矩阵乘法(使用子矩阵)，那么就可以构建Gemm，以及其他重要的矩阵-矩阵运算，即三级BLAS。我们稍后将看到的是，从模块化和性能的角度来看，这实际上是一个好主意。</p><p>在上一节中，您已经看到了分块的示例。</p><h3 id="3-2-Blocked-matrix-matrix-multiplication"><a href="#3-2-Blocked-matrix-matrix-multiplication" class="headerlink" title="3.2 Blocked matrix-matrix multiplication"></a>3.2 Blocked matrix-matrix multiplication</h3><p>分块Gemm以利用处理器的分层内存的关键是理解当这些矩阵被分块时如何计算C:&#x3D; AB + C。分块</p><p><img src="/2023/02/12/blislib002/image-20230216130352894.png" alt="image-20230216130352894"></p><h3 id="3-3-Your-mission-if-you-choose-to-accept-it"><a href="#3-3-Your-mission-if-you-choose-to-accept-it" class="headerlink" title="3.3 Your mission, if you choose to accept it"></a>3.3 Your mission, if you choose to accept it</h3><p>我们现在要求您在my_dgemm中实现分块矩阵-矩阵乘法。具体来说，对于小矩阵，您可以获得比大矩阵更好的性能，因为小矩阵适合缓存。将矩阵划分为能够获得更高性能的子矩阵，您将看到，即使对于更大的矩阵，所得到的实现也能保持更好的性能</p><h2 id="4-Step-3-Blocking-for-Multiple-Levels-of-Cache"><a href="#4-Step-3-Blocking-for-Multiple-Levels-of-Cache" class="headerlink" title="4 Step 3: Blocking for Multiple Levels of Cache"></a>4 Step 3: Blocking for Multiple Levels of Cache</h2><h3 id="4-1-The-Goto-Approach-to-Implementing-gemm"><a href="#4-1-The-Goto-Approach-to-Implementing-gemm" class="headerlink" title="4.1 The Goto Approach to Implementing gemm"></a>4.1 The Goto Approach to Implementing gemm</h3><p>2000年左右，Kazushige Goto用他的技术彻底改变了Gemm在当前cpu上的实现方式，该技术首次发表在论文[6]上。</p><p>最近在[16]中描述了这种方法的进一步“重构”。</p><p>BLIS框架的优点是它将必须高度优化的内核(可能使用向量intrinsic或在汇编代码中)减少为微内核。在本节中，我们将简要描述该方法的重点。然而，我们强烈建议读者熟悉以上两篇论文本身。</p><p>图3(左)说明了Goto方法为三层缓存(L1、L2和L3)构建分块的方式。在BLIS框架中，实现就是这样结构的，因此只有底层的微内核需要针对给定的体系结构进行高度优化和定制。在最初的GotoBLAS实现(现在维护为OpenBLAS[11])中，从围绕微内核的第二个循环开始的操作是定制的。为了获得最佳性能，所有数据都是连续访问的，这就是为什么在到达微内核之前的某个时刻，数据是按照箭头所示的顺序打包的:</p><p><img src="/2023/02/12/blislib002/image-20230216131649371.png" alt="image-20230216131649371"></p><p>现在，注意上图中A块的每一列都乘以B块对应行中的每个元素(我们称这些A块和B块为微面板)。这意味着L2缓存的延迟(从缓存中引入A微面板元素所需的时间)可以平摊到2nR flop上。</p><p><img src="/2023/02/12/blislib002/image-20230216131916807.png" alt="image-20230216131916807"></p><p>出于这个原因，我们可以组织计算，使A的微面板通常驻留在L2缓存中。实际上，我们可以做得更好:当A和B的微面板的一列发生排名1的更新时，A的微面板的下一列可以被带入寄存器，这样计算就可以掩盖数据移动的成本。事实上，我们希望将B的微面板保留在L1缓存中(因为它将被A的许多微面板重用)，这限制了分块参数kC。</p><p><img src="/2023/02/12/blislib002/image-20230216132839380.png" alt="image-20230216132839380"></p><p>有人可能会问，上述方案是否是最优方案。在[7]中给出了一个理论，表明在一个理想化的模型下，上述是局部最优的(在某种意义上，假设数据在层次结构中的某个内存层中，在该级别上提出的阻塞最优地与下一个内存层平摊数据移动的成本)。[13]给出了指导各种分块参数选择的理论。</p><p><img src="/2023/02/12/blislib002/image-20230216133142749.png" alt="image-20230216133142749"></p><h3 id="4-2-Setup"><a href="#4-2-Setup" class="headerlink" title="4.2 Setup"></a>4.2 Setup</h3><p>图4说明了子目录step3的目录结构。与步骤1相比，我们对以下目录&#x2F;文件进行了修改&#x2F;添加:</p><p><strong>kernels</strong> 这个目录包含各种架构的微内核实现</p><p><strong>bd_gemm_ukr.c</strong>给出了一个原生的C实现</p><p><strong>bl_dgemm_int_kernel.c</strong> gives an <strong>AVX&#x2F;AVX2</strong> intrinsics micro-kernel implementation for Haswell architecture.</p><p><strong>bl_dgemm_asm_kernel.c</strong> gives an <strong>AVX&#x2F;AVX2</strong> assembly micro-kernel implementation for Haswell architecture.</p><h3 id="4-3-Advanced-techniques"><a href="#4-3-Advanced-techniques" class="headerlink" title="4.3 Advanced techniques"></a>4.3 Advanced techniques</h3><p>You can find the vector instructions online:</p><p><strong>Intel Intrinsics Guide</strong></p><p><strong>Intel ISA Extensions</strong></p><h4 id="4-3-1-An-introduction-example-for-“axpy”"><a href="#4-3-1-An-introduction-example-for-“axpy”" class="headerlink" title="4.3.1 An introduction example for “axpy”"></a>4.3.1 An introduction example for “axpy”</h4><p>我们提供了一个实现“axpy”的示例，以演示如何使用Intel AVX intrinsic和Assembly(在misc&#x2F;examples子目录中)。</p><p><img src="/2023/02/12/blislib002/image-20230216134020439.png" alt="image-20230216134020439"></p><p>这个例子可以作为学习基本broacast&#x2F;fma&#x2F;load&#x2F;store指令的一个很好的起点。此外，这个示例实际上是4×4 rank-1更新的“broadcast”实现的原语。</p><h4 id="4-3-2-4×4-rank-1-update"><a href="#4-3-2-4×4-rank-1-update" class="headerlink" title="4.3.2 4×4 rank-1 update"></a>4.3.2 4×4 rank-1 update</h4><p>微内核实现可以归结为4×4级别1的更新。有两种可能的实现:一种基于广播(图5)，另一种是蝴蝶排列(图6)。您还可以尝试其他可能的实现。</p><h3 id="4-4-Your-mission-if-you-choose-to-accept-it"><a href="#4-4-Your-mission-if-you-choose-to-accept-it" class="headerlink" title="4.4 Your mission, if you choose to accept it"></a>4.4 Your mission, if you choose to accept it</h3><p>我们在my_dgemm中为您提供了简化BLIS框架的参考实现。代码的组织方式与图3所示相同。但是，每个循环中的步长并没有很好地选择，并且微内核实现是一个简单的C版本。因此。您不会期望代码具有高性能。我们要你做的就是:</p><ul><li>在include&#x2F;bl_config.h文件中指定分块参数mC, nC, kC和微内核大小参数mR, nR;</li><li>使用矢量intrinsic或汇编代码实现高效的微内核。将代码放在kernels&#x2F;bl_dgemm_int_kernel.c(用于向量intrinsic)或kernels&#x2F;bl_dgemm_asm_kernel.c(用于as汇编)中。需要在“include&#x2F; BL_config.h”中修改“BL_MICRO_KERNEL”，指定微内核的函数名。</li></ul><p><img src="/2023/02/12/blislib002/image-20230216140558800.png" alt="image-20230216140558800"></p><h2 id="5-Step-4-Parallelizing-with-OpenMP"><a href="#5-Step-4-Parallelizing-with-OpenMP" class="headerlink" title="5 Step 4: Parallelizing with OpenMP"></a>5 Step 4: Parallelizing with OpenMP</h2><p>BLIS构造GotoBLAS方法实现Gemm的好处是，它在tt C中公开了5个循环，这些循环可以很容易地与OpenMP指令并行。</p><h3 id="5-1-To-parallelize-or-not-to-parallelize-that’s-the-question"><a href="#5-1-To-parallelize-or-not-to-parallelize-that’s-the-question" class="headerlink" title="5.1 To parallelize or not to parallelize, that’s the question"></a>5.1 To parallelize or not to parallelize, that’s the question</h3><p>最基本的问题是要并行化哪个循环。在[12]中详细讨论了每个循环的并行化的优点和缺点。对于多核体系结构(具有相对较少核的多线程体系结构)，可以在早期的论文[15]中找到结果。</p><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6 Conclusion"></a>6 Conclusion</h2><p>我们使用GEMM作为案例研究来展示如何为性能进行编程</p><p><img src="/2023/02/12/blislib002/image-20230216141029854.png" alt="image-20230216141029854"></p><p><img src="/2023/02/12/blislib002/image-20230216141041389.png" alt="image-20230216141041389"></p><p><img src="/2023/02/12/blislib002/image-20230216141057850.png" alt="image-20230216141057850"></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>dgemm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JZ6 从尾到头打印链表</title>
    <link href="/2023/02/07/niuke003/"/>
    <url>/2023/02/07/niuke003/</url>
    
    <content type="html"><![CDATA[<h2 id="JZ6-从尾到头打印链表"><a href="#JZ6-从尾到头打印链表" class="headerlink" title="JZ6 从尾到头打印链表"></a><strong>JZ6</strong> <strong>从尾到头打印链表</strong></h2><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=265&tqId=39210&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=265&difficulty=undefined&judgeStatus=undefined&tags=&title=">从尾到头打印链表_牛客题霸_牛客网 (nowcoder.com)</a></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  struct ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        struct ListNode *next;</span><br><span class="hljs-comment">*        ListNode(int x) :</span><br><span class="hljs-comment">*              val(x), next(NULL) &#123;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*  &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">while</span> (head!=<span class="hljs-literal">NULL</span>) &#123;<br>            s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>(),head-&gt;val);<span class="hljs-comment">//利用迭代器头插</span><br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>牛客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JZ5 替换空格</title>
    <link href="/2023/02/07/niuke002/"/>
    <url>/2023/02/07/niuke002/</url>
    
    <content type="html"><![CDATA[<h2 id="JZ5-替换空格"><a href="#JZ5-替换空格" class="headerlink" title="JZ5 替换空格"></a><strong>JZ5</strong> <strong>替换空格</strong></h2><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=265&tqId=39209&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=undefined&judgeStatus=undefined&tags=&title=">替换空格_牛客题霸_牛客网 (nowcoder.com)</a></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        string str2 =<span class="hljs-string">&quot;%20&quot;</span>;<br>        string str3;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i]!=<span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-comment">//不是空格就插入到str3</span><br>                str3.<span class="hljs-built_in">push_back</span>(s[i]);<br>            <span class="hljs-keyword">else</span><br>                str3.<span class="hljs-built_in">append</span>(str2);<span class="hljs-comment">//如果是空格就把str2插入到str3</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> str3;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>牛客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JZ3 数组中重复的数字</title>
    <link href="/2023/02/07/niuke001/"/>
    <url>/2023/02/07/niuke001/</url>
    
    <content type="html"><![CDATA[<h2 id="JZ3-数组中重复的数字"><a href="#JZ3-数组中重复的数字" class="headerlink" title="JZ3 数组中重复的数字"></a>JZ3 数组中重复的数字</h2><h2 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h2><p><a href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=265&tqId=39207&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=undefined&judgeStatus=undefined&tags=&title=">数组中重复的数字_牛客题霸_牛客网 (nowcoder.com)</a></p><h2 id="完整解答："><a href="#完整解答：" class="headerlink" title="完整解答："></a>完整解答：</h2><p>set::count()是C++ STL中的内置函数，它返回元素在集合中出现的次数。由于set容器仅包含唯一元素，因此只能返回1或0。</p><ul><li>用法：set_name.count(element)</li><li>参数：该函数接受一个强制性参数element，该元素指定要返回其计数的元素。</li><li>返回值：该函数返回1或0，因为该集合仅包含唯一元素。如果设置的容器中存在该值，则返回1。如果容器中不存在它，则返回0。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param numbers int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;numbers.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(numbers[i])&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">//此元素重复，则返回</span><br>                <span class="hljs-keyword">return</span> numbers[i];<br>            <span class="hljs-keyword">else</span><br>                s.<span class="hljs-built_in">insert</span>(numbers[i]);<span class="hljs-comment">//不重复则加入集合</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://blog.csdn.net/cmehppc/article/details/121712019">(64条消息) 【c++】set.count()用法_杳杳捞到月亮了吗的博客-CSDN博客_c++set count</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>牛客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵乘法最基础版本</title>
    <link href="/2023/02/06/matrix001/"/>
    <url>/2023/02/06/matrix001/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵乘法最基础版本"><a href="#矩阵乘法最基础版本" class="headerlink" title="矩阵乘法最基础版本"></a>矩阵乘法最基础版本</h2><h3 id="数学原理示例"><a href="#数学原理示例" class="headerlink" title="数学原理示例"></a>数学原理示例</h3><p><img src="/2023/02/06/matrix001/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pYW5uaWFueGk=,size_16,color_FFFFFF,t_70.png" alt="img"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>用A的第i行分别和B的第j列的各个元素相乘求和，求得C的第i行j列的元素，这种算法中，B的访问是按列进行访问的，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//m是A矩阵的行,k是A矩阵的列,n是B矩阵的列</span><br><span class="hljs-keyword">double</span> temp=<span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<span class="hljs-comment">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<span class="hljs-comment">//遍历C矩阵i行j列</span><br>        temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; k; p++)&#123;<span class="hljs-comment">//用p循环累加和计算C[i][j] </span><br>            <span class="hljs-comment">//计算区域</span><br>            temp += A[i][p] * B[p][j];<span class="hljs-comment">//遍历A矩阵各行与B矩阵各列</span><br>        &#125;<br>        C[i][j] = temp;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果C矩阵m行n列</span><br></code></pre></div></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/niannianxi/article/details/104028215">(64条消息) C语言实现矩阵的乘法_꧁年年曦꧂的博客-CSDN博客_c语言矩阵乘法</a></p><p><a href="https://www.jb51.net/article/75750.htm">C语言科学计算入门之矩阵乘法的相关计算_C 语言_脚本之家 (jb51.net)</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matrix</tag>
      
      <tag>GEMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>register关键字</title>
    <link href="/2023/02/02/register/"/>
    <url>/2023/02/02/register/</url>
    
    <content type="html"><![CDATA[<h2 id="register关键字"><a href="#register关键字" class="headerlink" title="register关键字"></a>register关键字</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> val = <span class="hljs-number">100</span>;<br><span class="hljs-comment">//寄存器变量没有地址，不能取地址</span><br>val = <span class="hljs-number">200</span>; <span class="hljs-comment">//可以被写入</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, val);<br><span class="hljs-comment">// 在gcc编译器下 也不允许取地址</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//由于使用register关键字，直接将val存在寄存器内，因此val没有内存地址，因此不能进行取地址操作。</span><br></code></pre></div></td></tr></table></figure><ol><li>我们通常采用局部变量采用 register 的，全局变量会导致 CPU 当中的寄存器被长时间占用。</li><li>一个变量被存放到寄存器当中，那么这个变量的效率就会大大的提高,因为不用访存读取</li><li>register关键字可以与指针变量一起使用。</li><li>寄存器是一个存储类，并且C不允许变量使用多个存储类说明符。因此，register不能与static一起使用。</li><li>寄存器只能在一个块内使用（局部），而不能在全局范围内（在主外部）使用</li><li>寄存器数量有限</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xie.infoq.cn/article/f6093f4eebd3664c0a1514e26">【C语言】register 关键字_11月月更_謓泽_InfoQ写作社区</a></p><p><a href="https://zhuanlan.zhihu.com/p/263575137">一步带您了解C语言中的“register”关键字 - 知乎 (zhihu.com)</a></p><p><a href="https://www.ab62.cn/article/5406.html">C语言关键字之auto register详解_C 语言_AB教程网 (ab62.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>register</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLISlab dgemm优化</title>
    <link href="/2023/02/02/blislab/"/>
    <url>/2023/02/02/blislab/</url>
    
    <content type="html"><![CDATA[<h1 id="BLISlab-dgemm优化"><a href="#BLISlab-dgemm优化" class="headerlink" title="BLISlab dgemm优化"></a>BLISlab dgemm优化</h1><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><strong>Git地址：</strong><a href="https://github.com/flame/blislab">https://github.com/flame/blislab</a></p><p><strong>视频教程：</strong><a href="https://www.bilibili.com/video/BV1c94y117Uw?vd_source=3ae32e36058f58c5b85935fca9b77797%E3%80%90%E6%BE%8E%E5%B3%B0%E7%A7%91%E6%8A%80-%E5%BC%A0%E5%85%88%E8%BD%B6%E8%80%81%E5%B8%88%E3%80%91">https://www.bilibili.com/video/BV1c94y117Uw?vd_source=3ae32e36058f58c5b85935fca9b77797【澎峰科技-张先轶老师】</a></p><p><strong>阅读</strong>：tutorial.pdf【位于代码包中】</p><h2 id="Step0"><a href="#Step0" class="headerlink" title="Step0"></a>Step0</h2><h3 id="1-克隆项目到本地"><a href="#1-克隆项目到本地" class="headerlink" title="1.克隆项目到本地"></a>1.克隆项目到本地</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git clone https://github.com/flame/blislab.git<br></code></pre></div></td></tr></table></figure><h3 id="2-代码结构"><a href="#2-代码结构" class="headerlink" title="2.代码结构"></a>2.代码结构</h3><p><img src="/2023/02/02/blislab/image-20230202155728203.png" alt="image-20230202155728203"></p><h3 id="3-编译环境"><a href="#3-编译环境" class="headerlink" title="3.编译环境"></a>3.编译环境</h3><p><img src="/2023/02/02/blislab/image-20230202155820411.png" alt="image-20230202155820411"></p><h3 id="4-运行环境配置脚本"><a href="#4-运行环境配置脚本" class="headerlink" title="4.运行环境配置脚本"></a>4.运行环境配置脚本</h3><p><img src="/2023/02/02/blislab/image-20230202160027957.png" alt="image-20230202160027957"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@hadoop1 step0]# source ./sourceme.sh <br>BLISLAB_DIR = .<br>BLISLAB_USE_INTEL = false<br>BLISLAB_USE_BLAS = false<br>COMPILER_OPT_LEVEL = O3<br>BLAS_DIR = /u/jianyu/lib/openblas<br></code></pre></div></td></tr></table></figure><h3 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5.Makefile"></a>5.Makefile</h3><p><img src="/2023/02/02/blislab/image-20230202160244490.png" alt="image-20230202160244490"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@hadoop1 step0]# make<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/my_dgemm.c -o dgemm/my_dgemm.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/bl_dgemm_ref.c -o dgemm/bl_dgemm_ref.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/bl_dgemm_util.c -o dgemm/bl_dgemm_util.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>ar cr lib/libblislab.a dgemm/my_dgemm.o dgemm/bl_dgemm_ref.o dgemm/bl_dgemm_util.o    <br>ranlib lib/libblislab.a<br>gcc -O3 -march=core-avx2 -fPIC -shared -o lib/libblislab.so dgemm/my_dgemm.o dgemm/bl_dgemm_ref.o dgemm/bl_dgemm_util.o     ./lib/libblislab.a -lpthread -lm -lrt<br>cd ./test &amp;&amp; make &amp;&amp; cd . -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>make[1]: 进入目录“/root/blislab/step0/test”<br>gcc -O3 -march=core-avx2 -fPIC test_bl_dgemm.c -o test_bl_dgemm.x -I../include -I../kernels -I/u/jianyu/lib/openblas/include ../lib/libblislab.a -lpthread -lm -lrt<br>make[1]: 离开目录“/root/blislab/step0/test”<br></code></pre></div></td></tr></table></figure><h3 id="6-make-gnu-inc"><a href="#6-make-gnu-inc" class="headerlink" title="6.make.gnu.inc"></a>6.make.gnu.inc</h3><p><img src="/2023/02/02/blislab/image-20230202160608401.png" alt="image-20230202160608401"></p><h3 id="7-ref参考实现是否调用BLAS"><a href="#7-ref参考实现是否调用BLAS" class="headerlink" title="7.ref参考实现是否调用BLAS"></a>7.ref参考实现是否调用BLAS</h3><p><img src="/2023/02/02/blislab/image-20230202160904158.png" alt="image-20230202160904158"></p><h3 id="8-my-dgemm-c"><a href="#8-my-dgemm-c" class="headerlink" title="8.my_dgemm.c"></a>8.my_dgemm.c</h3><p><img src="/2023/02/02/blislab/image-20230202160939940.png" alt="image-20230202160939940"></p><h3 id="9-相关数据变量含义"><a href="#9-相关数据变量含义" class="headerlink" title="9.相关数据变量含义"></a>9.相关数据变量含义</h3><p><img src="/2023/02/02/blislab/image-20230202161055971.png" alt="image-20230202161055971"></p><h3 id="10-代码采用列主元"><a href="#10-代码采用列主元" class="headerlink" title="10.代码采用列主元"></a>10.代码采用列主元</h3><p><img src="/2023/02/02/blislab/image-20230202161219553.png" alt="image-20230202161219553"></p><h3 id="11-dgemm使用脚本测试"><a href="#11-dgemm使用脚本测试" class="headerlink" title="11.dgemm使用脚本测试"></a>11.dgemm使用脚本测试</h3><p>Test目录下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@hadoop1 test]# ./run_bl_dgemm.sh <br>result=[<br><span class="hljs-meta">%</span><span class="bash">m%n%k%MY_GFLOPS%REF_GFLOPS</span><br>   16    16    16  7.35  1.93<br>   32    32    32  7.88  1.29<br>   48    48    48  9.81  1.17<br>   64    64    64  8.98  1.20<br>   80    80    80  9.59  1.11<br>   96    96    96  7.74  1.08<br>  112   112   112  8.32  0.95<br>  128   128   128  7.74  1.04<br>  144   144   144  7.39  0.99<br>  160   160   160  7.13  1.06<br>  176   176   176  7.58  1.06<br>  192   192   192  7.73  0.98<br>  208   208   208  7.29  1.01<br>  224   224   224  7.90  0.97<br>  240   240   240  7.61  1.00<br>  256   256   256  6.72  0.96<br>  272   272   272  7.51  0.99<br>  288   288   288  7.39  0.99<br>  304   304   304  7.84  0.99<br>  320   320   320  7.61  0.97<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//run_bl_dgemm.sh</span><br>#!/bin/bash<br><br>#For Mac OS only<br><span class="hljs-keyword">export</span> DYLD_LIBRARY_PATH=/opt/intel/lib:/opt/intel/mkl/lib<br><br>#Single Thread<br><span class="hljs-keyword">export</span> KMP_AFFINITY=compact  #Rule to bind core to thread <span class="hljs-keyword">for</span> OMP thread with Intel compiler <span class="hljs-keyword">for</span> parallel version<br><span class="hljs-keyword">export</span> OMP_NUM_THREADS=<span class="hljs-number">1</span>     #Set OMP number of threads <span class="hljs-keyword">for</span> parallel version<br><span class="hljs-keyword">export</span> BLISLAB_IC_NT=<span class="hljs-number">1</span>       #Set BLISLAB number of threads <span class="hljs-keyword">for</span> parallel version<br>k_start=<span class="hljs-number">16</span><span class="hljs-comment">//起始大小</span><br>k_end=<span class="hljs-number">1024</span><span class="hljs-comment">//结束大小</span><br>k_blocksize=<span class="hljs-number">16</span><span class="hljs-comment">//步长</span><br>echo <span class="hljs-string">&quot;result=[&quot;</span><br>echo -e <span class="hljs-string">&quot;%m\t%n\t%k\t%MY_GFLOPS\t%REF_GFLOPS&quot;</span><br><span class="hljs-keyword">for</span> (( k=k_start; k&lt;=k_end; k+=k_blocksize ))<br><span class="hljs-keyword">do</span><br>    ./test_bl_dgemm.x     $k $k $k <br>done<br>echo <span class="hljs-string">&quot;];&quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="12-dgemm手动指定参数测试"><a href="#12-dgemm手动指定参数测试" class="headerlink" title="12.dgemm手动指定参数测试"></a>12.dgemm手动指定参数测试</h3><p>Test目录下</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">[root@hadoop1 test]# ./test_bl_dgemm.x <span class="hljs-number">256</span> <span class="hljs-number">256</span> <span class="hljs-number">256</span> <br>  <span class="hljs-number">256</span>   <span class="hljs-number">256</span>   <span class="hljs-number">256</span>  <span class="hljs-number">5.00</span>  <span class="hljs-number">0.84</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">[root@hadoop1 test]# ./test_bl_dgemm.x <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">128</span><br>   <span class="hljs-number">16</span>    <span class="hljs-number">32</span>   <span class="hljs-number">128</span>  <span class="hljs-number">8.77</span>  <span class="hljs-number">1.02</span><br></code></pre></div></td></tr></table></figure><p><strong>这里要注意哪个代表m,n,k?</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span>    m, n, k; <br><br>    <span class="hljs-keyword">if</span> ( argc != <span class="hljs-number">4</span> ) &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Error: require 3 arguments, but only %d provided.\n&quot;</span>, argc - <span class="hljs-number">1</span> );<br>        <span class="hljs-built_in">exit</span>( <span class="hljs-number">0</span> );<br>    &#125;<br><br>    <span class="hljs-built_in">sscanf</span>( argv[ <span class="hljs-number">1</span> ], <span class="hljs-string">&quot;%d&quot;</span>, &amp;m );<br>    <span class="hljs-built_in">sscanf</span>( argv[ <span class="hljs-number">2</span> ], <span class="hljs-string">&quot;%d&quot;</span>, &amp;n );<br>    <span class="hljs-built_in">sscanf</span>( argv[ <span class="hljs-number">3</span> ], <span class="hljs-string">&quot;%d&quot;</span>, &amp;k );<br><br>    <span class="hljs-built_in">test_bl_dgemm</span>( m, n, k );<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="13-计时区域"><a href="#13-计时区域" class="headerlink" title="13.计时区域"></a><strong>13.计时区域</strong></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; nrepeats; i ++ ) &#123;<br>        ref_beg = <span class="hljs-built_in">bl_clock</span>();<span class="hljs-comment">//blislib提供的封装</span><br>        &#123;<br>            <span class="hljs-built_in">bl_dgemm_ref</span>(<br>                    m,<br>                    n,<br>                    k,<br>                    A,<br>                    lda,<br>                    B,<br>                    ldb,<br>                    C_ref,<br>                    ldc_ref<br>                    );<br>        &#125;<br>        ref_time = <span class="hljs-built_in">bl_clock</span>() - ref_beg;<br><br>        <span class="hljs-keyword">if</span> ( i == <span class="hljs-number">0</span> ) &#123;<br>            ref_rectime = ref_time;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ref_rectime = ref_time &lt; ref_rectime ? ref_time : ref_rectime;<span class="hljs-comment">//多次计时取最优</span><br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h3 id="14-正确性检验"><a href="#14-正确性检验" class="headerlink" title="14.正确性检验"></a>14.正确性检验</h3><p>Test目录下Test_bl_gemm.c</p><p>结果比较：通过比较你的优化计算结果和参考计算结果对比</p><p>Gflops的计算</p><ul><li>有效浮点次数 &#x3D; 2*m*n*k</li><li>Gflops &#x3D; 有效浮点次数 &#x2F; 时间</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">computeError</span>(<br>        ldc,<br>        ldc_ref,<br>        m,<br>        n,<br>        C,<br>        C_ref<br>        );<br><br><span class="hljs-comment">// Compute overall floating point operations.</span><br>flops = ( m * n / ( <span class="hljs-number">1000.0</span> * <span class="hljs-number">1000.0</span> * <span class="hljs-number">1000.0</span> ) ) * ( <span class="hljs-number">2</span> * k );<br><br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%5d\t %5d\t %5d\t %5.2lf\t %5.2lf\n&quot;</span>, <br>        m, n, k, flops / bl_dgemm_rectime, flops / ref_rectime );<br></code></pre></div></td></tr></table></figure><h3 id="15-课后作业"><a href="#15-课后作业" class="headerlink" title="15.课后作业"></a>15.课后作业</h3><p><strong>perf工具的用法</strong>：</p><p><a href="https://xingyuanjie.top/2022/01/19/tool003/">perf-系统级性能分析工具 - Amicoyuan (xingyuanjie.top)</a></p><p><strong>分析不同的j,p,i循环顺序的性能：</strong></p><p>原因cache miss造成的差异</p><h2 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h2><h3 id="1-与Step0比较"><a href="#1-与Step0比较" class="headerlink" title="1.与Step0比较"></a>1.与Step0比较</h3><p><strong>左边是Step1右边是Step0</strong></p><p><img src="/2023/02/02/blislab/image-20230202165659964.png" alt="image-20230202165659964"></p><h3 id="2-基本分块"><a href="#2-基本分块" class="headerlink" title="2.基本分块"></a>2.基本分块</h3><p><img src="/2023/02/02/blislab/image-20230202170723811.png" alt="image-20230202170723811"></p><h3 id="3-反汇编"><a href="#3-反汇编" class="headerlink" title="3.反汇编"></a>3.反汇编</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@hadoop1 dgemm]# objdump -d ./my_dgemm.o &gt; my_dgemm.S<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">./my_dgemm.o：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;AddDot&gt;:<br>   0:85 ff                test   %edi,%edi<br>   2:7e 2e                jle    32 &lt;AddDot+0x32&gt;<br>   4:48 63 d2             movslq %edx,%rdx<br>   7:c4 c1 7b 10 01       vmovsd (%r9),%xmm0<br>   c:31 c0                xor    %eax,%eax<br>   e:48 c1 e2 03          shl    $0x3,%rdx<br>  12:66 0f 1f 44 00 00    nopw   0x0(%rax,%rax,1)<br>  18:c5 fb 10 0e          vmovsd (%rsi),%xmm1<br>  1c:48 01 d6             add    %rdx,%rsi<br>  1f:c4 e2 f1 b9 04 c1    vfmadd231sd (%rcx,%rax,8),%xmm1,%xmm0<br>  25:48 83 c0 01          add    $0x1,%rax<br>  29:c4 c1 7b 11 01       vmovsd %xmm0,(%r9)<br>  2e:39 c7                cmp    %eax,%edi<br>  30:7f e6                jg     18 &lt;AddDot+0x18&gt;<br>  32:f3 c3                repz retq <br>  34:66 90                xchg   %ax,%ax<br>  36:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)<br>  3d:00 00 00 <br><br>0000000000000040 &lt;AddDot_MRxNR&gt;:<br>  40:e9 00 00 00 00       jmpq   45 &lt;AddDot_MRxNR+0x5&gt;<br>  45:90                   nop<br>  46:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)<br>  4d:00 00 00 <br></code></pre></div></td></tr></table></figure><h3 id="4-反汇编（-fPIC引入的差异）"><a href="#4-反汇编（-fPIC引入的差异）" class="headerlink" title="4.反汇编（-fPIC引入的差异）"></a>4.反汇编（-fPIC引入的差异）</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@hadoop1 test]# objdump -d ./test_bl_dgemm.x  &gt; test.S<br></code></pre></div></td></tr></table></figure><p><img src="/2023/02/02/blislab/image-20230202171234007.png" alt="image-20230202171234007"></p><h3 id="5-Gcc生成汇编"><a href="#5-Gcc生成汇编" class="headerlink" title="5.Gcc生成汇编"></a>5.Gcc生成汇编</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@hadoop1 step1]# gcc -O3 -march=core-avx2 -fPIC -S dgemm/my_dgemm.c -o dgemm/my_dgemm1.S -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br></code></pre></div></td></tr></table></figure><p><img src="/2023/02/02/blislab/image-20230202171758087.png" alt="image-20230202171758087"></p><h3 id="6-Step0与Step1比较"><a href="#6-Step0与Step1比较" class="headerlink" title="6.Step0与Step1比较"></a>6.Step0与Step1比较</h3><p><img src="/2023/02/02/blislab/image-20230202172816584.png" alt="image-20230202172816584"></p><h3 id="7-分块，修改MR，-NR为4×4"><a href="#7-分块，修改MR，-NR为4×4" class="headerlink" title="7.分块，修改MR， NR为4×4"></a>7.分块，修改MR， NR为4×4</h3><p><img src="/2023/02/02/blislab/image-20230202173132817.png" alt="image-20230202173132817"></p><h3 id="8-分块（2×2）"><a href="#8-分块（2×2）" class="headerlink" title="8.分块（2×2）"></a>8.分块（2×2）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> AddDot_2×<span class="hljs-number">2</span>( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *A, <span class="hljs-keyword">int</span> lda, <span class="hljs-keyword">double</span> *B, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *C,<span class="hljs-keyword">int</span> ldc ) &#123;<br><span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> C00, C01, C10, C11;<br>    <span class="hljs-keyword">int</span> p;<br>    C00=<span class="hljs-number">0.0</span>;<br>    C01=<span class="hljs-number">0.0</span>;<br>    C10=<span class="hljs-number">0.0</span>;<br>    C11=<span class="hljs-number">0.0</span>;<br>    <br>    <span class="hljs-keyword">for</span>( p=<span class="hljs-number">0</span> ;p &lt; k; p++)<br>    &#123;<br>        C00 += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span>);<br>        C01 += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span>);<br>        C10 += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span>);<br>        C11 += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) +=C00;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) +=C01;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) +=C10;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) +=C11;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/02/02/blislab/image-20230202173645399.png" alt="image-20230202173645399"></p><h3 id="9-AddDot-2x2汇编代码"><a href="#9-AddDot-2x2汇编代码" class="headerlink" title="9.AddDot_2x2汇编代码"></a>9.AddDot_2x2汇编代码</h3><p><img src="/2023/02/02/blislab/image-20230202191728644.png" alt="image-20230202191728644"></p><h3 id="10-AddDot-2x2最内层循环展开"><a href="#10-AddDot-2x2最内层循环展开" class="headerlink" title="10.AddDot_2x2最内层循环展开"></a>10.AddDot_2x2最内层循环展开</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> AddDot_2×<span class="hljs-number">2</span>( <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">double</span> *A, <span class="hljs-keyword">int</span> lda, <span class="hljs-keyword">double</span> *B, <span class="hljs-keyword">int</span> ldb, <span class="hljs-keyword">double</span> *C,<span class="hljs-keyword">int</span> ldc ) &#123;<br><span class="hljs-keyword">register</span> <span class="hljs-keyword">double</span> C00, C01, C10, C11;<br>    <span class="hljs-keyword">int</span> p;<br>    C00=<span class="hljs-number">0.0</span>;<br>    C01=<span class="hljs-number">0.0</span>;<br>    C10=<span class="hljs-number">0.0</span>;<br>    C11=<span class="hljs-number">0.0</span>;<br>    <br>    <span class="hljs-keyword">for</span>( p=<span class="hljs-number">0</span> ;p &lt; k; p+=<span class="hljs-number">2</span>)<br>    &#123;<br>        C00 += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span>) + <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p+<span class="hljs-number">1</span>) * <span class="hljs-built_in">B</span>( p+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        C01 += <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span>) + <span class="hljs-built_in">A</span>( <span class="hljs-number">0</span>, p+<span class="hljs-number">1</span>) * <span class="hljs-built_in">B</span>( p+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        C10 += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">0</span>) + <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p+<span class="hljs-number">1</span>) * <span class="hljs-built_in">B</span>( p+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        C11 += <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p) * <span class="hljs-built_in">B</span>( p, <span class="hljs-number">1</span>) + <span class="hljs-built_in">A</span>( <span class="hljs-number">1</span>, p+<span class="hljs-number">1</span>) * <span class="hljs-built_in">B</span>( p+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) +=C00;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) +=C01;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) +=C10;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) +=C11;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/02/02/blislab/image-20230202192033816.png" alt="image-20230202192033816"></p><h3 id="11-AddDot-2x2汇编代码【最内层循环展开】"><a href="#11-AddDot-2x2汇编代码【最内层循环展开】" class="headerlink" title="11.AddDot_2x2汇编代码【最内层循环展开】"></a>11.AddDot_2x2汇编代码【最内层循环展开】</h3><p><img src="/2023/02/02/blislab/image-20230202192319993.png" alt="image-20230202192319993"></p><h2 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h2><h3 id="1-与Step1的性能比较"><a href="#1-与Step1的性能比较" class="headerlink" title="1.与Step1的性能比较"></a>1.与Step1的性能比较</h3><p><img src="/2023/02/02/blislab/image-20230206163219051.png" alt="image-20230206163219051"></p><h3 id="2-优化kernel-x2F-bl-dgemm-ukr-c"><a href="#2-优化kernel-x2F-bl-dgemm-ukr-c" class="headerlink" title="2.优化kernel&#x2F;bl_dgemm_ukr.c"></a>2.优化kernel&#x2F;bl_dgemm_ukr.c</h3><p><img src="/2023/02/02/blislab/image-20230206163713966.png" alt="image-20230206163713966"></p><p><img src="/2023/02/02/blislab/image-20230206163803615.png" alt="image-20230206163803615"></p><h3 id="3-优化后性能对比"><a href="#3-优化后性能对比" class="headerlink" title="3.优化后性能对比"></a>3.优化后性能对比</h3><p><img src="/2023/02/02/blislab/image-20230206163833950.png" alt="image-20230206163833950"></p><h3 id="4-下降原因分析"><a href="#4-下降原因分析" class="headerlink" title="4.下降原因分析"></a>4.下降原因分析</h3><p><img src="/2023/02/02/blislab/image-20230206164335213.png" alt="image-20230206164335213"></p><p><img src="/2023/02/02/blislab/image-20230206164734050.png" alt="image-20230206164734050"></p><h3 id="5-如何进行分块"><a href="#5-如何进行分块" class="headerlink" title="5.如何进行分块"></a>5.如何进行分块</h3><p><img src="/2023/02/02/blislab/image-20230206165017812.png" alt="image-20230206165017812"></p><p><img src="/2023/02/02/blislab/image-20230206165103417.png" alt="image-20230206165103417"></p><p><img src="/2023/02/02/blislab/image-20230206170050450.png" alt="image-20230206170050450"></p><p><img src="/2023/02/02/blislab/image-20230206170105998.png" alt="image-20230206170105998"></p><p><img src="/2023/02/02/blislab/image-20230206170126588.png" alt="image-20230206170126588"></p><p><img src="/2023/02/02/blislab/image-20230206170153251.png" alt="image-20230206170153251"></p><p><img src="/2023/02/02/blislab/image-20230206170226248.png" alt="image-20230206170226248"></p><p><img src="/2023/02/02/blislab/image-20230206170242872.png" alt="image-20230206170242872"></p><p><img src="/2023/02/02/blislab/image-20230206170320842.png" alt="image-20230206170320842"></p><p><img src="/2023/02/02/blislab/image-20230206170334857.png" alt="image-20230206170334857"></p><h3 id="6-Dgemm代码"><a href="#6-Dgemm代码" class="headerlink" title="6.Dgemm代码"></a>6.Dgemm代码</h3><p><img src="/2023/02/02/blislab/image-20230206171538013.png" alt="image-20230206171538013"></p><p><img src="/2023/02/02/blislab/image-20230206171556767.png" alt="image-20230206171556767"></p><p><img src="/2023/02/02/blislab/image-20230206171622104.png" alt="image-20230206171622104"></p><p><img src="/2023/02/02/blislab/image-20230206171639209.png" alt="image-20230206171639209"></p><h3 id="7-Dgemm-macro-kenrel代码"><a href="#7-Dgemm-macro-kenrel代码" class="headerlink" title="7.Dgemm macro kenrel代码"></a>7.Dgemm macro kenrel代码</h3><p><img src="/2023/02/02/blislab/image-20230206171903844.png" alt="image-20230206171903844"></p><p><img src="/2023/02/02/blislab/image-20230206171940282.png" alt="image-20230206171940282"></p><h3 id="8-Gemm汇总"><a href="#8-Gemm汇总" class="headerlink" title="8.Gemm汇总"></a>8.Gemm汇总</h3><p><img src="/2023/02/02/blislab/image-20230206172351890.png" alt="image-20230206172351890"></p><h3 id="9-拓展"><a href="#9-拓展" class="headerlink" title="9.拓展"></a>9.拓展</h3><p><img src="/2023/02/02/blislab/image-20230206172425329.png" alt="image-20230206172425329"></p><h3 id="10-双缓冲优化"><a href="#10-双缓冲优化" class="headerlink" title="10.双缓冲优化"></a>10.双缓冲优化</h3><p><img src="/2023/02/02/blislab/image-20230206172846408.png" alt="image-20230206172846408"></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>dgemm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA线程管理</title>
    <link href="/2023/01/28/cuda006/"/>
    <url>/2023/01/28/cuda006/</url>
    
    <content type="html"><![CDATA[<h3 id="1-线程管理"><a href="#1-线程管理" class="headerlink" title="1.线程管理"></a>1.线程管理</h3><p>当核函数在主机端启动时，它的执行会移动到设备上，此时设备中会产生大量的线程并且每个线程都执行由核函数指定的语句。了解如何组织线程是CUDA编程的一个关键部分。CUDA明确了线程层次抽象的概念以便于你组织线程。这是一个两层的线程层次结构，由线程块和线程块网格构成，如图2-5所示。</p><p><img src="/2023/01/28/cuda006/image-20230128160011560.png" alt="image-20230128160011560"></p><p>由一个内核启动所产生的所有线程统称为一个网格。同一网格中的所有线程共享相同的全局内存空间。一个网格由多个线程块构成，一个线程块包含一组线程，同一线程块内的线程协作可以通过以下方式来实现。</p><p>​-同步</p><p>​-共享内存</p><p>不同块内的线程不能协作。</p><p>线程依靠以下两个坐标变量来区分彼此。</p><p>​-blockIdx(线程块在线程格内的索引)</p><p>​-threadIdx(块内的线程索引)</p><p>这些变量是核函数中需要预初始化的内置变量。当执行一个核函数时，CUDA运行时为每个线程分配坐标变量blockIdx和threadIdx。基于这些坐标，你可以将部分数据分配给不同的线程。</p><p>该坐标变量是基于uint3定义的CUDA内置的向量类型，是一个包含3个无符号整数的结构，可以通过x,y,z三个字段来指定。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">blockIdx.x<br>blockIdx.y<br>blockIdx.z<br>threadIdx.x<br>threadIdx.y<br>threadIdx.z<br></code></pre></div></td></tr></table></figure><p>CUDA可以组织三维的网格和块。图2-5展示了一个线程层次结构的示例，其结构是一个包含二维块的二维网格。网格和块的维度由下列两个内置变量指定。</p><p>​-blockDim(线程块的维度，用每个线程块中的线程数来表示)</p><p>​-gridDim(线程格的维度，用每个线程格中的线程数来表示)</p><p>它们是dim3类型的变量，是基于uint3定义的整数型向量，用来表示维度。当定义一个dim3类型的变量时，所有未指定的元素都被初始化为1。dim3类型变量中的每个组件可以通过它的x,y,z字段获得。如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">blockDim.x<br>blockDim.y<br>blockDim.z<br></code></pre></div></td></tr></table></figure><h3 id="2-网格和线程块的维度"><a href="#2-网格和线程块的维度" class="headerlink" title="2.网格和线程块的维度"></a>2.网格和线程块的维度</h3><p>通常，一个线程格会被组织成线程块的二维数组形式，一个线程块会被组织成线程的三维数组形式。</p><p>线程格和线程块均使用3个dim3类型的无符号整型字段，而未使用的字段将被初始化为1且忽略不计。</p><p>在CUDA程序中有两组不同的网格和块变量：手动定义的dim3数据类型和预定义的uint3数据类型。在主机端，作为内核调用的一部分，你可以使用dim3数据类型定义一个网格和块的维度。当执行核函数时，CUDA运行时会生成相应的内置预初始化的网格，块和线程变量，它们在核函数内均可被访问到且为unit3类型。手动定义的dim3类型的网络和块变量仅在主机端可见，而unit3类型的内置预初始化的网格和块变量仅在设备端可见。</p><p>你可以通过代码清单2-2来验证这些变量如何使用。首先，定义程序所用的数据大小，为了对此进行说明，我们定义一个较小的数据。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> nElem = <span class="hljs-number">6</span>;<br></code></pre></div></td></tr></table></figure><p>接下来，定义块的尺寸并基于块和数据的大小计算网格尺寸。在下面例子中，定义了一个包含3个线程的一维线程块，以及一个基于块和数据大小定义的一定数量线程块的一维线程网格。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">((nElem+block.x<span class="hljs-number">-1</span>)/block.x)</span></span>;<br></code></pre></div></td></tr></table></figure><p>你会发现网格大小是块大小的倍数。以下主机端上的程序段用来检查网格和块维度。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d grid.y %d grid.z %d\n&quot;</span>,grid.x,grid.y,grid.z);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;block.x %d block.y %d block.z %d\n&quot;</span>,block.x,block.y,block.z);<br></code></pre></div></td></tr></table></figure><p>在核函数中，每个线程都输出自己的线程索引，块索引，块维度和网格维度。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;threadIdx:(%d, %d, %d) blockIdx:(%d, %d, %d) blockDim:(%d, %d, %d) &quot;</span> <span class="hljs-string">&quot;gridDim:(%d, %d, %d)\n&quot;</span>, threadIdx.x, threadIdx,y, threadIdz.z,blockIdx.x, blockIdx.y, blockIdx.z, blockDim.x, blockDim.y, blockDim.z, gridDim.x,gridDim.y,gridDim.z);<br></code></pre></div></td></tr></table></figure><p>把代码合并保存成名为checkDimension.cu的文件，如代码清单2-2所示。</p><p><strong>代码清单2-2     检查网络和块的索引和维度（checkDimension.cu）</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">checkIndex</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;threadIdx:(%d, %d, %d) blockIdx:(%d, %d, %d) blockDim:(%d, %d, %d) &quot;</span> <span class="hljs-string">&quot;gridDim:(%d, %d, %d)\n&quot;</span>, threadIdx.x, threadIdx,y, threadIdz.z, blockIdx.x, blockIdx.y, blockIdx.z, blockDim.x, blockDim.y, blockDim.z, gridDim.x,gridDim.y,gridDim.z);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-comment">//define total data element</span><br>    <span class="hljs-keyword">int</span> nElem = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">//define grid and block structure</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">((nElem+block.x<span class="hljs-number">-1</span>)/block.x)</span></span>;<br>    <br>    <span class="hljs-comment">//check grid and block dimension from host side</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d grid.y %d grid.z %d\n&quot;</span>,grid.x,grid.y,grid.z);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;block.x %d block.y %d block.z %d\n&quot;</span>,block.x,block.y,block.z);<br><br>    <span class="hljs-comment">//check grid and block dimension from device side</span><br>    checkIndex&lt;&lt;&lt;grid, block&gt;&gt;&gt;();<br>    <br>    <span class="hljs-comment">//reset device before you leave</span><br>    <span class="hljs-built_in">cudaDeviceReset</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在开始编译和运行这段程序：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc -arch=sm_20 checkDimension.cu -o check<br>./check<br></code></pre></div></td></tr></table></figure><p>因为printf函数只支持Fermi及以上版本的GPU架构，所以必须添加-arch&#x3D;sm_20编译器选项。默认情况下，nvcc会产生支持最低版本GPU架构的代码。这个应用程序的运行结果如下。可以看到，每个线程都有自己的坐标，所有的线程都有相同的块维度和网格维度。</p><p><img src="/2023/01/28/cuda006/image-20230129172501750.png" alt="image-20230129172501750"></p><h3 id="3-从主机端和设备端访问网格-x2F-块变量"><a href="#3-从主机端和设备端访问网格-x2F-块变量" class="headerlink" title="3.从主机端和设备端访问网格&#x2F;块变量"></a>3.从主机端和设备端访问网格&#x2F;块变量</h3><p>区别主机端和设备端的网格和块变量的访问是很重要的。例如，声明一个主机端的块变量，你按如下定义它的坐标并对其进行访问：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">block.x,block.y,block.z<br></code></pre></div></td></tr></table></figure><p>在设备端，你已经预定义了内置块变量的大小：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">blockDim.x,blockDim.y,blockDim.z<br></code></pre></div></td></tr></table></figure><p>总之，在启动内核之前就定义了主机端的网格和块变量，并从主机端通过由x,y,z三个字段决定的矢量结构来访问它们。当内核启动时，可以使用内核中预初始化的内置变量。</p><p>对于一个给定的数据大小，确定网格和块尺寸的一般步骤为：</p><p>​-确定块的大小</p><p>​-在已知数据大小和块大小的基础上计算网格维度</p><p>要确定块尺寸，通常需要考虑：</p><p>​-内核的性能特性</p><p>​-GPU资源的限制</p><p>代码清单2-3使用了一个一维网格和一个一维块来说明当块的大小改变时，网格的尺寸也会随之改变。</p><p><strong>代码清单2-3 在主机上定义网格和块的大小（defineGridBlock.cu）</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-comment">//define total data element</span><br>    <span class="hljs-keyword">int</span> nElem = <span class="hljs-number">1024</span>;<br>    <br>    <span class="hljs-comment">//define grid and block structure</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">1024</span>)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span> <span class="hljs-params">((nElem+block.x<span class="hljs-number">-1</span>)/block.x)</span></span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d block.x %d \n&quot;</span>,grid.x, block.x);<br>    <br>    <span class="hljs-comment">//reset block</span><br>    block.x = <span class="hljs-number">512</span>;<br>    grid.x = (nElem+block.x<span class="hljs-number">-1</span>)/block.x;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d block.x %d \n&quot;</span>,grid.x, block.x);<br>    <br>    <span class="hljs-comment">//reset block</span><br>    block.x = <span class="hljs-number">256</span>;<br>    grid.x = (nElem+block.x<span class="hljs-number">-1</span>)/block.x;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d block.x %d \n&quot;</span>,grid.x, block.x);<br>    <br>    <span class="hljs-comment">//reset block</span><br>    block.x = <span class="hljs-number">128</span>;<br>    grid.x = (nElem+block.x<span class="hljs-number">-1</span>)/block.x;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid.x %d block.x %d \n&quot;</span>,grid.x, block.x);<br>    <br>    <span class="hljs-comment">//reset device before you leave</span><br>    <span class="hljs-built_in">cudaDeviceReset</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>用下列命令编译和运行这段程序：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc defineGridBlock.cu-o block<br>./block<br></code></pre></div></td></tr></table></figure><p>下面是一个输出示例。由于应用程序中的数据大小是固定的，因此当块的大小发生改变时，相应的网格尺寸也会发生改变。</p><p><img src="/2023/01/28/cuda006/image-20230129174300533.png" alt="image-20230129174300533"></p><h3 id="4-线程层次结构"><a href="#4-线程层次结构" class="headerlink" title="4.线程层次结构"></a>4.线程层次结构</h3><p>CUDA的特点之一就是通过编程模型揭示了一个两层的线程层次结构。由于一个内核启动的网格和块的维数会影响性能，这一结构为程序员优化程序提供了一个额外的途径。</p><p>网格和块的维度存在几个限制因素，对于块大小的一个主要限制因素就是可利用的计算资源，如寄存器，共享内存等。某些限制可以通过查询GPU设备撤回。</p><p>网格和块从逻辑上代表了一个核函数的线程层次结构。</p><h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA内存管理</title>
    <link href="/2023/01/17/cuda005/"/>
    <url>/2023/01/17/cuda005/</url>
    
    <content type="html"><![CDATA[<h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1.内存管理"></a>1.内存管理</h3><p>CUDA编程模型假设系统是由一个主机和一个设备组成的，而且各自拥有独立的内存。核函数是在设备上运行的。为使你拥有充分的控制权并使系统达到最佳性能，CUDA运行时负责分配与释放设备内存，并且在主机内存和设备内存之间传输数据。表2-1列出了标准的C函数以及相应地针对内存操作的CUDA C函数。</p><p>用于执行GPU内存分配的是cudaMalloc函数，其函数原型为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">cudaError_t <span class="hljs-title">cudaMalloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>** devPtr, <span class="hljs-keyword">size_t</span> size)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/2023/01/17/cuda005/image-20230117223254853.png" alt="image-20230117223254853"></p><p>该函数负责向设备分配一定字节的线性内存，并以devPtr的形式返回指向所分配内存的指针。cudaMalloc与标准C语言中的malloc函数几乎一样，只是此函数在GPU的内存里分配内存。通过充分保持与标准C语言运行库中的接口一致性，可以实现CUDA应用程序的轻松接入。</p><p>cudaMemcpy函数负责主机和设备之间的数据传输，其函数原型为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">cudaError_t <span class="hljs-title">cudaMencpy</span><span class="hljs-params">( <span class="hljs-keyword">void</span>* dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* src, <span class="hljs-keyword">size_t</span> count, cudaMemcpyKind kind)</span></span><br></code></pre></div></td></tr></table></figure><p>此函数从src指向的源存储区复制一定数量的字节到dst指向的目标存储区。复制方向由kind指定，其中的kind有以下几种。</p><ol><li>cudaMemcpyHostToHost</li><li>cudaMemcpyHostToDevice</li><li>cudaMemcpyDeviceToHost</li><li>cudaMemcpyDeviceToDevice</li></ol><p>这个函数以同步方式执行，因为在cudaMemcpy函数返回以及传输操作完成之前主机应用程序是阻塞的。除了内核启动之外的CUDA调用都会返回一个错误的枚举类型cudaError_t。如果GPU内存分配成功，函数返回：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">cudaSuccess<br></code></pre></div></td></tr></table></figure><p>否则返回：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">cudaErrorMemoryAllocation<br></code></pre></div></td></tr></table></figure><p>可以使用以下CUDA运行时函数将错误代码转化为可读的错误消息：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">cudaGetErroeString</span><span class="hljs-params">(cudaError_t error)</span></span><br></code></pre></div></td></tr></table></figure><p>cudaGetErrorString函数和C语言中的strerror函数类似。</p><p>CUDA编程模型从GPU架构中抽象出一个内存层次结构，图2-3所示的是一个简化的GPU内存结构，它主要包含两部分：全局内存和共享内存。</p><h3 id="2-内存层次结构"><a href="#2-内存层次结构" class="headerlink" title="2.内存层次结构"></a>2.内存层次结构</h3><p>CUDA编程模型最显著的一个特点就是揭示了内存层次结构。每一个GPU设备都有用于不同用途的存储类型。</p><p>在GPU内存层次结构中，最主要的两种内存是全局内存和共享内存。全局类似于CPU的系统内存，而共享内存类似于CPU的缓存。然而GPU的共享内存可以由CUDA C的内核直接控制。</p><p><img src="/2023/01/17/cuda005/image-20230128140743600.png" alt="image-20230128140743600"></p><p>下面，我们将通过一个简单的两个数组相加的例子来学习如何在主机和设备之间进行数据传输，以及如何使用CUDA C编程。如图2-4所示，数组a的第一个元素与数组b的第一个元素相加，得到的结果作为数组c的第一个元素，重复这个过程直到数组中的所有元素都进行了一次运算。‘</p><p><img src="/2023/01/17/cuda005/image-20230128141008674.png" alt="image-20230128141008674"></p><p>首先，执行主机端代码使两个数组相加（如代码清单2-1所示）。</p><h4 id="代码清单2-1-sumArraysOnHost-c"><a href="#代码清单2-1-sumArraysOnHost-c" class="headerlink" title="代码清单2-1 sumArraysOnHost.c"></a>代码清单2-1 sumArraysOnHost.c</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sumArraysOnHost</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, <span class="hljs-keyword">float</span> *C, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> idx=<span class="hljs-number">0</span>;idx&lt;n;idx++)<br>        C[idx]=A[idx]+B[idx];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialData</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *ip,<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>    <span class="hljs-comment">//generate different seed for random number time_t t;</span><br>    <span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) <span class="hljs-built_in">time</span> (&amp;t));<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        ip[i]=(<span class="hljs-keyword">float</span>)(<span class="hljs-built_in">rand</span>() &amp; OxFF)/<span class="hljs-number">10.0f</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> nElem =<span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">size_t</span> nBytes = nElem *<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">float</span>);<br>    <br>    <span class="hljs-keyword">float</span> *h_A, *h_B, *h_C;<br>    h_A = (<span class="hljs-keyword">float</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    h_B = (<span class="hljs-keyword">float</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    h_C = (<span class="hljs-keyword">float</span> *)<span class="hljs-built_in">malloc</span>(nBytes);<br>    <br>    <span class="hljs-built_in">initialData</span>(h_A, nElem);<br>    <span class="hljs-built_in">initialData</span>(h_B, nElem);<br>    <br>    <span class="hljs-built_in">sumArraysOnHost</span>(h_A, h_B, h_C, nElem);<br>    <br>    <span class="hljs-built_in">free</span>(h_A);<br>    <span class="hljs-built_in">free</span>(h_B);<br>    <span class="hljs-built_in">free</span>(h_C);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>这是一个纯C语言编写的程序，你可以用C语言编译器进行编译，也可以像下面这样用nvcc进行编译。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc -Xcompiler -std=c99 sumArraysOnHost.c -o sum<br>./sum<br></code></pre></div></td></tr></table></figure><p>nvcc封装了几种内部编译工具，CUDA编译器允许通过命令行选项在不同阶段启动不同的工具完成编译工作。-Xcompiler用于指定命令行选项是指向C编译器还是预处理器。在前面的例子中，将-std&#x3D;c99传递给编译器，因为这里的C程序是按照C99标准编写的。</p><p>现在，你可以在GPU上修改代码来进行数组加法运算，用cudaMalloc在GPU上申请内存。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">float</span> *h_A, *h_B, *h_C;<br><span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_A, nBytes);<br><span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_B, nBytes);<br><span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-keyword">float</span>**)&amp;d_C, nBytes);<br></code></pre></div></td></tr></table></figure><p>使用cudaMemcpy函数把数据从主机内存拷贝到GPU的全局内存中，参考cudaMemcpyHostToDevice指定数据拷贝方向。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">cudaMemcpy</span>(d_A, h_A, nBytes, cudaMemcpyHostToDevice);<br><span class="hljs-built_in">cudaMemcpy</span>(d_B, h_B, nBytes, cudaMemcpyHostToDevice);<br></code></pre></div></td></tr></table></figure><p>当数据被转移到GPU的全局内存后，主机端调用核函数在GPU上进行数组求和。一旦内核被调用，控制权立刻被传回主机，这样的话，当核函数在GPU上运行时，主机可以执行其他函数。因此，内核与主机是异步的。</p><p>当内核在GPU上完成了对所有数组元素的处理后，其结果将以数组d_C的形式存储在GPU的全局内存中，然后用cudaMemcpy函数把结果从GPU复制回到主机的数组gpuRef中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">cudaMemcpy</span>(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost);<br></code></pre></div></td></tr></table></figure><p>cudaMemcpy的调用会导致主机运行阻塞。cudaMemcpyDeviceToHost的作用就是将存储在GPU上的数组d_C中的结果复制到gpuRef中。最后，调用cudaFree释放GPU的内存。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">cudaFree</span>(d_A);<br><span class="hljs-built_in">cudaFree</span>(d_B);<br><span class="hljs-built_in">cudaFree</span>(d_C);<br></code></pre></div></td></tr></table></figure><h3 id="3-不同的存储空间"><a href="#3-不同的存储空间" class="headerlink" title="3.不同的存储空间"></a>3.不同的存储空间</h3><p>使用CUDA C进行编程的人最常犯的错误就是对不同内存空间的不恰当引用。对于在GPU上被分配的内存来说，设备指针在主机代码中可能并没有被引用。如果你执行了错误的内存分配，如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">gpuRef = d_C<br></code></pre></div></td></tr></table></figure><p>而不是用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">cudaMemcpy</span>(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost);<br></code></pre></div></td></tr></table></figure><p>应用程序在运行时将会崩溃。</p><p>为了避免这类错误，CUDA6.0提出了统一寻址，使用一个指针来访问CPU和GPU的内存</p><h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4.参考资料"></a>4.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA编程结构</title>
    <link href="/2023/01/17/cuda004/"/>
    <url>/2023/01/17/cuda004/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA编程结构"><a href="#CUDA编程结构" class="headerlink" title="CUDA编程结构"></a>CUDA编程结构</h2><p>CUDA编程模型使用由C语言扩展生成的注释代码在异构计算系统中执行应用程序。</p><p>在一个异构环境中包含多个CPU和GPU，每个GPU和CPU的内存都由一条PCI-Express总线分隔开。因此，需要注意区别以下内容。</p><ol><li>主机：CPU及其内存（主机内存）</li><li>设备：GPU及其内存（设备内存）</li></ol><p>为了清楚地指明不同的内存空间，在本书的示例代码中，主机内存中的变量名以h__为前缀，设备内存中的变量名以d__为前缀。</p><p>从CUDA6.0开始，NVDIA提出了名为“统一寻址”（Unified Memory）的编程模型的改进，它连接了主机内存和设备内存空间，可使用单个指针访问CPU和GPU内存，无须彼此之间手动拷贝数据。现在，重要的是应学会如何为主机和设备分配内存空间以及如何在CPU和GPU之间拷贝共享数据。这种程序员管理模式控制下的内存和数据可以优化应用程序并实现硬件系统利用率的最大化。</p><p>内核（kernel）是CUDA编程模型的一个重要组成部分，其代码在GPU上运行。作为一个开发人员，你可以串行的执行核函数。在此背景下，CUDA的调度管理程序员在GPU线程上编写核函数。在主机上，基于应用程序数据以及GPU的性能定义如何让设备实现算法功能。这样做的目的是使你专注于算法的逻辑（通过编写串行代码），且在创建和管理大量的GPU线程时不必拘泥于细节。</p><p>多数情况下，主机可以独立地对设备进行操作。内核一旦被启动，端粒权立刻返回给主机，释放CPU来执行由设备上运行的并行代码实现的额外的任务。CUDA编程模型主要是异步的，因此在GPU上进行的运算可以与主机-设备通信重叠。一个典型的CUDA程序包括由并行代码互补的串行代码。如图2-2所示，串行代码（及任务并行代码）在主机CPU上执行，而并行代码在GPU上执行。主机代码按照ANSI C标准进行编写，而设备代码使用CUDA C进行编写。你可以将所有的代码统一放在一个源文件中，也可以使用多个源文件来构建应用程序和库。NVIDIA的C编译器(nvcc)为主机和设备生成可执行代码。</p><p>一个典型的CUDA程序实现流程遵循以下模式</p><ol><li>把数据从CPU内存拷贝到GPU内存</li><li>调用核函数对存储在GPU内存中的数据进行操作</li><li>将数据从GPU内存传送回到CPU内存</li></ol><p>首先，你要学习的是内存管理及主机和设备之间的数据传输。</p><p><img src="/2023/01/17/cuda004/image-20230117220146068.png" alt="image-20230117220146068"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA编程模型概述</title>
    <link href="/2023/01/17/cuda003/"/>
    <url>/2023/01/17/cuda003/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA编程模型概述"><a href="#CUDA编程模型概述" class="headerlink" title="CUDA编程模型概述"></a>CUDA编程模型概述</h2><p>CUDA编程模型提供了一个计算机架构抽象作为应用程序和其可用硬件之间的桥梁。图2-1说明了程序和编程模型实现之间的抽象结构的重要。通信抽象是程序与编程模型实现之间的分界线，它通过专业的硬件原语和操作系统的编译器或库来实现。利用编程模型所编写的程序指定了程序的各组成部分是如何共享信息及相互协作的。编程模型从逻辑上提供了一个特定的计算机架构，通常它体现在编程语言或编程环境中。</p><p><img src="/2023/01/17/cuda003/image-20230117203406633.png" alt="image-20230117203406633"></p><p>除了与其他并行编程模型共有的抽象外，CUDA编程模型还利用GPU架构的计算能力提供了以下几个特有功能。</p><ol><li>一种通过层次结构在GPU中组织线程的方法</li><li>一种通过层次结构在GPU中访问内存的方法</li></ol><p>以程序员的角度可以从以下几个不同的层面来看待并行计算。</p><ol><li>领域层</li><li>逻辑层</li><li>硬件层</li></ol><p>在编程与算法设计的过程中，你最关心的应是在领域层如何解析数据和函数，以便在并行环境中能正确，高效地解决问题。当进入编程阶段，你的关注点应转向如何组织并发线程。在这个阶段，你需要从逻辑层面来思考，以确保你的线程和计算能正确地解决问题。在C语言并行编程中，需要使用pthreads或OpenMP技术来显式地管理线程。CUDA提出了一个线程层次结构抽象的概念，以允许控制线程行为。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA:一种异构计算平台</title>
    <link href="/2023/01/16/cuda002/"/>
    <url>/2023/01/16/cuda002/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA-一种异构计算平台"><a href="#CUDA-一种异构计算平台" class="headerlink" title="CUDA:一种异构计算平台"></a>CUDA:一种异构计算平台</h2><h3 id="1-CUDA的简单介绍"><a href="#1-CUDA的简单介绍" class="headerlink" title="1.CUDA的简单介绍"></a>1.CUDA的简单介绍</h3><p>CUDA是一种通用的并行计算平台和编程模型，它利用NVIDIA GPU中的并行计算引擎能够有效地解决复杂的计算问题。通过使用CUDA，你可以像在CPU上，通过GPU来进行计算。</p><p>CUDA平台可以通过CUDA加速库，编译器指令，应用编程接口以及行业标准程序语言的扩展（包括C,C++,Fortran，Python，如图1-12所示）来使用。</p><p>CUDA C是标准ANSI C语言的一个扩展，它带有的少数语言扩展功能使异构编程成为可能，同时也能通过API来管理设备，内存和其他任务。CUDA还是一个可扩展的编程模型，它使程序能对有不同数量核的GPU明显地扩展其并行性，同时对熟悉C编程语言的程序员来说也比较容易上手。</p><p><img src="/2023/01/16/cuda002/image-20230116175503342.png" alt="image-20230116175503342"></p><p>CUDA提供了两层API来管理GPU设备和组织线程，如图1-13所示。</p><p><img src="/2023/01/16/cuda002/image-20230116175610403.png" alt="image-20230116175610403"></p><p>-CUDA驱动API</p><p>-CUDA运行时API</p><p>驱动API是一种低级API，它相对来说较难编程，但是它对于在GPU设备使用上提供了更多的控制。运行时API是一个高级API，他在驱动API的上层实现。每个运行时API函数都被分解为更多传给驱动API的基本运算。</p><h3 id="2-运行时API与驱动API"><a href="#2-运行时API与驱动API" class="headerlink" title="2.运行时API与驱动API"></a>2.运行时API与驱动API</h3><p>运行时API和驱动API之间没有明显的性能差异。在设备端，内核是如何使用内存以及你是如何组织线程的，对性能有更显著的影响。</p><p>这两种API是相互排斥的，你必须使用两者之一，从两者中混合函数调用是不可能的。本书中所有例子都使用运行时API。</p><p>一个CUDA程序包含了以下两个部分的混合。</p><p>-在CPU上运行的主机代码</p><p>-在GPU上运行的设备代码</p><p>NVIDIA的CUDA nvcc编译器在编译过程中将设备代码从主机代码中分离出来。如图1-14所示，主机代码是标准的C代码，使用C编译器进行编译。设备代码，也就是核函数，是用扩展的带有标记数据并行函数关键字的CUDA C语言编写的。设备代码通过nvcc进行编译。在链接阶段，在内核程序调用和显示GPU设备操作中添加CUDA运行时库。</p><p><img src="/2023/01/16/cuda002/image-20230116180725596.png" alt="image-20230116180725596"></p><p>CUDA nvcc编译器是以广泛使用LLVM开源编译系统为基础的。在GPU加速器的支持下，通过使用CUDA编译器SDK，你可以创建或扩展编程语言，如图1-15所示。</p><p>CUDA平台也是支持多样化并行计算生态系统的基础，如图1-26所示。现在，随着越来越多的公司可以提供全球性的工具，服务和解决方案，CUDA生态系统迅速成长。如果你想在GPU上建立你的应用程序，强化GPU性能最简单方式是使用CUDA工具包（cuda-toolkit），它为C和C++开发人员提供了一个综合的开发环境。CUDA工具包包括编译器，数学库，以及调式和优化应用程序性能的工具。同时提供了代码样例，编程指南，用户手册，API参考文档和其他帮助你入门的文档。</p><p><img src="/2023/01/16/cuda002/image-20230116181439404.png" alt="image-20230116181439404"></p><p><img src="/2023/01/16/cuda002/image-20230116181447616.png" alt="image-20230116181447616"></p><h3 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.参考资料"></a>3.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA用GPU输出Hello World</title>
    <link href="/2023/01/16/cuda001/"/>
    <url>/2023/01/16/cuda001/</url>
    
    <content type="html"><![CDATA[<h2 id="用GPU输出Hello-World"><a href="#用GPU输出Hello-World" class="headerlink" title="用GPU输出Hello World"></a>用GPU输出Hello World</h2><h3 id="1-检查环境"><a href="#1-检查环境" class="headerlink" title="1.检查环境"></a>1.检查环境</h3><p>学习一个新编程语言的最好方式就是使用这种语言来编写程序。在本节，你将开始编写在GPU上运行的第一个内核代码。像其他任何编程语言一样编写GPU上的第一个程序是输出字符串“Hello World”。</p><p>如果这是你第一次使用CUDA,在Linux系统中，你可以想使用以下命令来检查CUDA编译器是否正确安装：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">which nvcc<br></code></pre></div></td></tr></table></figure><p>通常的结果可能是</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">/usr/local/cuda/bin/nvcc<br></code></pre></div></td></tr></table></figure><p>你还需要检查你的机器上是否安装了GPU加速卡。对吃你可以在Linux系统上使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ls -l /dev/nv*<br></code></pre></div></td></tr></table></figure><p>通常的结果是：</p><p><img src="/2023/01/16/cuda001/image-20230116170920773.png" alt="image-20230116170920773"></p><p>在这个例子中，你发现了两个GPU卡（不同的用户配置可能有所不同，因此显示结果会有所差异）。</p><h3 id="2-第一个CUDA-C程序"><a href="#2-第一个CUDA-C程序" class="headerlink" title="2.第一个CUDA C程序"></a>2.第一个CUDA C程序</h3><p>现在你要准备好写你的第一个CUDA C程序。写一个CUDA C程序，你需要以下几个步骤：</p><ol><li>用专用扩展名.cu来创建一个源文件。</li><li>使用CUDA nvcc编译器来编译程序。</li><li>从命令行运行可执行文件，这个文件有可在GPU上运行的内核代码。</li></ol><p>首先，我们编写一个C语言程序来输出“Hello World”,如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World from CPU!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>把代码保存到hello.cu中，然后使用nvcc编译器来编译。CUDA nvcc编译器和gcc编译器及其他编译器有相似的语义</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc hello.cu -o hello<br></code></pre></div></td></tr></table></figure><p>如果你运行可执行文件hello，将会输出：</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Hello World <span class="hljs-keyword">from</span> CPU!<br></code></pre></div></td></tr></table></figure><p>接下来，编写一个内核函数，命名为helloFromGPU，用它来输出字符串“Hello World from GPU!”。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">helloFromGPU</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World from GPU!\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>修饰符__global__告诉编译器这个函数将会从CPU中调用，然后在GPU上执行。用下面代码启用内核函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">helloFromGPU&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">10</span>&gt;&gt;&gt;();<br></code></pre></div></td></tr></table></figure><p>三重尖括号意味着从主线程到设备端代码的调用。一个内核函数通过一组线程来执行，所有线程执行相同的代码。三重尖括号里面的参数是执行配置，用来说明使用多少线程来执行内核函数。在这个例子中，有10个GPU线程被调用。综上所述，得到代码清单1-1所示的程序。</p><h3 id="3-代码清单1-1Hello-World-from-GPU-hello-cu"><a href="#3-代码清单1-1Hello-World-from-GPU-hello-cu" class="headerlink" title="3.代码清单1-1Hello World from GPU! (hello.cu)"></a>3.代码清单1-1Hello World from GPU! (hello.cu)</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">helloFromGPU</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World from GPU!\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//hello from cpu</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World from CPU!\n&quot;</span>);<br>    <br>    <br>    helloFromGPU&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">10</span>&gt;&gt;&gt;();<br>    <span class="hljs-built_in">cudaDeviceReset</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>函数cudaDeviceRest（）用来显式地释放和清空当前进程中与当前设别有关的所有资源。如下所示，在nvcc命令行中使用-arch sm_20进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvcc -arch sm_20 hello.cu -o hello<br></code></pre></div></td></tr></table></figure><p>开关语句-arch sm_20使编译器为Fermi架构生成设备代码。运行这个可执行文件，它将输出10条字符串“Hello World from CPU!”，每个线程输出一条。</p><p><img src="/2023/01/16/cuda001/image-20230116173446169.png" alt="image-20230116173446169"></p><h3 id="4-一个典型的CUDA编程结构包括5个主要步骤"><a href="#4-一个典型的CUDA编程结构包括5个主要步骤" class="headerlink" title="4.一个典型的CUDA编程结构包括5个主要步骤"></a>4.一个典型的CUDA编程结构包括5个主要步骤</h3><ol><li>分配GPU内存</li><li>从CPU内存中拷贝数据到GPU内存</li><li>调用CUDA内核函数来完成程序指定的运算</li><li>将数据从GPU拷回CPU内存</li><li>释放GPU内存空间</li></ol><p>在hello.cu中，你只看到了第三步：调用内核。</p><h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP生产者消费者问题(未完结)</title>
    <link href="/2023/01/14/openmp006/"/>
    <url>/2023/01/14/openmp006/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenMP生产者消费者问题"><a href="#OpenMP生产者消费者问题" class="headerlink" title="OpenMP生产者消费者问题"></a>OpenMP生产者消费者问题</h2><p><strong>本节将讨论一个不适合用parallel for指令或者for指令来并行化的问题。</strong></p><h3 id="1-队列"><a href="#1-队列" class="headerlink" title="1.队列"></a>1.队列</h3><p>队列是一种抽象的数据结构，插入元素时将元素插入到队列“尾部”，而读取元素时，队列“头部”的元素被返回并从队列中被移除。队列可以看做是在超市中等待付款的消费者的抽象，队列中的元素是消费者。新的消费者到达时排在等待队列的尾部，下一个付款离开等待队列的是排在队列头部的消费者。</p><p>当一个新的元素插入到队列的尾部时，通常称这个新的元素“入队”了；当一个元素从队列的头部被移除时，通常称这个元素“出队”了。</p><p>队列在计算机科学中随处可见。例如，如果有多个进程，每个进程都试图向硬盘写入数据，为了确保每次只有一个进程在写硬盘，一种自然而然的方法是将进程组织为队列。换句话说，排在队列第一个的进程在当前进程结束对硬盘的使用后，第一个获得硬盘的访问权限；排在队列第二个的进程在排在队列第一个的进程使用完硬盘后获得硬盘的访问权限，依此类推。</p><p>队列也是在多线程应用程序中经常使用到的数据结构。例如，我们有几个“生产者”线程和几个“消费者”线程。生产者线程“产生”对服务器数据的请求———例如当前股票的价格，而消费者线程通过发现和生成数据（例如，当前股票的价格）来“消费”请求。生产者线程将请求入队，而消费者线程将请求从队列中移除。在这个例子中，只有当消费者线程将请求的数据发送给生产者线程时，进程才会结束。</p><h3 id="2-消息传递"><a href="#2-消息传递" class="headerlink" title="2.消息传递"></a>2.消息传递</h3><p>生产者和消费者问题模型的另外一个应用是在共享内存系统上实现消息传递。每一个线程有一个消息共享队列，当一个线程要向另一个线程“发送消息“时，他将消息放入目标线程的消息队列中。一个线程接受消息时只需从它的消息队列的头部取出消息。</p><p>这里我们将实现一个简单的消息传递程序，在这个程序中，每个线程随机产生整数”消息“和消息的日志目标线程。当创建一条消息后，线程将消息加入到合适的消息队列中。当发送消息之后，该线程查看它自己的消息队列以获知它是否收到了消息，如果它收到了消息，它将从队首的消息出队并打印该消息。每个线程交替发送和接受消息，用户需要指定每个线程发送消息的数目。当一个线程发送完所有消息后，该线程不断接受消息直到所有的线程都已完成，此时所有的线程都结束了。每个线程的伪代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(send_msgs = <span class="hljs-number">0</span>; sent_msgs &lt; send_max ;sent_msgs++)&#123;<br>    <span class="hljs-built_in">Send_msg</span>();<br>    <span class="hljs-built_in">Try_receive</span>();<br>&#125;<br><br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">Done</span>())<br>    <span class="hljs-built_in">Try_receive</span>();<br></code></pre></div></td></tr></table></figure><h3 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3.发送消息"></a>3.发送消息</h3><p>需要注意的是，访问消息队列并将消息入队，可能是一个临界区。尽管我们还没有深入地研究如何实现消息队列，但我们很有可能需要用一个变量来跟踪队列的尾部。例如，使用一个单链表来实现消息队列，链表的尾部对应着队列的尾部。然后，为了有效地进行入队操作，需要存储指向链表尾部的指针，当一条新消息入队时，需要检查和更新这个队尾指针。如果两个线程试图同时进行这些操作，那么可能会丢失一条已经由其中一个线程入队的消息.（画张图能够有助于理解这种情况！）两个操作的结果会发生冲突，因此入队操作形成了临界区。</p><p>Send_msg()函数的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">mesg = <span class="hljs-built_in">random</span>();<br>dest = <span class="hljs-built_in">random</span>() % thread_count;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical</span><br><span class="hljs-built_in">Enqueue</span>(queue,dest,my_rank.mesg);<br></code></pre></div></td></tr></table></figure><p>注意在上面的实现中，允许线程向它自己发送消息。</p><h3 id="4-接受消息"><a href="#4-接受消息" class="headerlink" title="4.接受消息"></a>4.接受消息</h3><p>接受消息的同步问题与发送消息有些不同。只有消息队列的拥有者（即目标线程）可以从给定的消息队列中获取消息。如果消息队列中至少有两条消息，那么只要每次只出队一条消息，那么出队操作和入队操作就不可能冲突。因此如果队列中至少有两条消息，通过跟踪队列的大小就可以避免任何同步（例如critical指令）</p><p>现在的问题是如何存储队列大小。如果只使用一个变量来存储队列的大小，那么对该变量的操作会形成临界区。然而可以使用两个变量：enqueued和dequeued，那么队列中消息的个数（队列的大小）就为</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue_size = enqueued - dequeued<br></code></pre></div></td></tr></table></figure><p>并且，唯一能够更新dequeued的线程是消息队列的拥有者。可以看到在一个线程使用enqueued计算队列大小queue_size的同时，另外一个线程可以更新enqueued。为了解释这种情况，假如进程q正在计算queue_size，那么它将可能得到enqueued新的或者旧的值。当queue_size实际值是1或者2时，线程q可能会得到queue_size是0或者1。但这只会引起程序一定的延迟，而不会引起程序错误。如果queue_size本应该是1，却误计算为0，那么线程q延迟一段时间后会试图重新计算队列的大小；如果queue_size本应该是2，却误计算为1，那么线程q将执行临界区指令，虽然这本来是不必要的。</p><p>因此，可以按照如下的方式实现Try_receive:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue_size = enqueued - dequeued;<br><span class="hljs-keyword">if</span>(queue_size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(queue_size == <span class="hljs-number">1</span>)<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical</span><br>    <span class="hljs-built_in">Dequeue</span>(queue,&amp;src,&amp;mesg);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">Dequeue</span>(queue,&amp;src,&amp;mesg);<br><span class="hljs-built_in">Print_message</span>(src,mesg);<br></code></pre></div></td></tr></table></figure><h3 id="5-终止检测"><a href="#5-终止检测" class="headerlink" title="5.终止检测"></a>5.终止检测</h3><p>接下来，我们探讨如何实现Done函数。首先，我们给出一个”直接“的实现，但这个实现隐藏着问题：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue_size = enqueued - dequeued;<br><span class="hljs-keyword">if</span>(queue_size == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> True;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> False;<br></code></pre></div></td></tr></table></figure><p>如果线程u执行这段代码，那么很有可能有些线程，如线程v，在线程u计算出queue_size &#x3D; 0后向线程u发送一条消息。当然，线程u在得出queue_size &#x3D; 0后将终止，那么线程v发送给它的消息就永远不会被接受到。</p><p>然而，在我们程序中，每个线程在执行完for循环后将不再发送任何消息。因此可以增加一个计数器done_sending，每个线程在for循环结束后将该计数器加1，Done的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue_size = enqueued - dequeued;<br><span class="hljs-keyword">if</span>(queue_size == <span class="hljs-number">0</span> &amp;&amp; done_sending == thread_count)<br>    <span class="hljs-keyword">return</span> TRUE;<br><span class="hljs-keyword">else</span><br>    rerun FALSE;<br></code></pre></div></td></tr></table></figure><h3 id="6-启动"><a href="#6-启动" class="headerlink" title="6.启动"></a>6.启动</h3><p>当程序开始执行时，主线程将得到命令行参数并且分配一个数组空间给消息队列，每个线程对应着一个消息队列。由于每个线程可以向其他任意的下次线程发送消息，所以这个数组应该被所有线程共享，而且每个线程可以向任何一个消息队列插入一条消息。消息队列（至少）可以存储：</p><ol><li>消息列表</li><li>队尾指针或索引</li><li>队首指针或索引</li><li>入队消息的数目</li><li>出队消息的数目</li></ol><p>最好将队列存在消息队列的结构体中，为了减少参数传递时复制的开销，最好用指向结构体的指针数组来实现消息队列。因此，一旦主线程分配了队列数组，就可以使用parallel指令开始执行线程，每个线程可以为自己的队列分配存储空间。</p><p>这里一个重要的问题是：一个或者多个线程可能在其他线程之前完成它的队列分配。如果这种情况出现了，那么完成分配的线程可能会试图开始向那些还没有完成队列分配的线程发送消息，这将导致程序崩溃。因此，我们必须确保任何一个线程都必须在所有的线程都完成了队列分配后才开始发送消息。回想一下，之前我们见过一些OpenMP指令在结束时提供隐式路障，即任何一个线程都必须等到组中所有的线程完成了某个程序块后才可以接着执行后续代码。然而，在这个例子中，我们处于parallel块的中间，所以我们不能依赖于OpenMP提供的隐式路障——我们应当使用显式路障。幸运的是，OpenMP提供了相应的指令：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp barrier</span><br></code></pre></div></td></tr></table></figure><p>当线程遇到路障时，它将被阻塞，直到组中所有的线程都到达了这个路障。当组中所有的线程都到达了这个路障时，这些线程就可以接着往下执行。</p><h3 id="7-atomic指令"><a href="#7-atomic指令" class="headerlink" title="7.atomic指令"></a>7.atomic指令</h3><p>发送完所有的消息后，每个线程在执行最后的循环以便接受消息之前，需要对done_sending加1.显然，对done_sending的增量操作是临界区，可以通过critical指令来保护它。然后，OpenMP提供了另外一种可能更加高效的指令：atomic指令：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp atomic</span><br></code></pre></div></td></tr></table></figure><p>与critical指令不同，它只能保护由一条C语言赋值语句所形成的临界区。此外，语句必须是一下几种形式之一：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">x &lt;op&gt; = &lt;expression&gt;<br>x++;<br>++x;<br>x--;<br>--x;<br></code></pre></div></td></tr></table></figure><p><op>可以是以下任意的二元操作符：</op></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">+,*,-,/,&amp;,|,^,&lt;&lt;,<span class="hljs-keyword">or</span> &gt;&gt;<br></code></pre></div></td></tr></table></figure><p>这里要记住，<expression>不能引用x。</expression></p><p>需要注意的是，只有x的装载和存储可以确保是受保护的，例如在下面的代码中：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp atomic</span><br>x += y++;<br></code></pre></div></td></tr></table></figure><p>其他线程对x的更新必须等到该线程对x的更新结束之后。但是对y的更新不受保护，因此程序的结果是不可预测的。</p><p>atomic指令的思想是许多处理器提供专门的装载-修改-存储(load-modify-store)指令。使用这种专门的指令而不使用保护临界区的通用结构，可以更高效地保护临界区。</p><h3 id="8-临界区和锁"><a href="#8-临界区和锁" class="headerlink" title="8.临界区和锁"></a>8.临界区和锁</h3><p>为了完成对消息传递程序的讨论，我们需要进一步仔细研究OpenMP critical指令的规范。在更早的例子中，程序最多只有一个临界区，critical指令强制所有的线程对该区域进行互斥访问。在这个程序中，临界区的使用将更加复杂。我们将在源代码中看到3个在critical或atomic指令后面的代码块：</p><ol><li>done_sending++</li><li>Enqueue(q_p,my_rank,mesg);</li><li>Dequeue(q_p,&amp;src,&amp;mesg);</li></ol><p>然而，我们不需要强制对3个代码块都进行互斥访问，甚至不需要强制对第二个和第三个代码块进行完全的互斥访问。例如，线程0在向线程1的消息队列写消息的同时，线程1可以向线程2的消息队列写消息。但是OpenMP的规定第二个和第三个代码块是被critical指令保护的代码块。在OpenMP看来，我们的程序有两个不同的临界区；被atomic指令保护的done_sending++和“复合”临界区。在“复合”临界区中，程序读取和发送消息。</p><p>强制线程间的互斥会使程序的执行串行化。OpenMP默认的做法是将所有的临界区代码块作为复合临界区的一部分，这可能非常不利于程序的性能。OpenMP提供了向critical指令添加名字的选项：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical(name)</span><br></code></pre></div></td></tr></table></figure><p>采取这种方式，两个用不同名字的critical指令保护的代码块就可以同时执行。我们想为每一个线程的消息队列的临界区提供不同的名字，但是临界区的名字是在程序编译过程中设置的。因此，我们需要在程序执行的过程中设置临界区的名字。但是按照为我们的设置，当我们想让访问不同队列的线程可以同时访问相同的代码块时，被命名的critical指令就不能满足我们的要求了。</p><p>解决方案是使用锁（lock）。锁由一个数据结构和定义在这个数据结构上的函数组成，这些函数使得程序员可以显式地强制对临界区进行互斥访问。锁的使用可以大概用下面的伪代码描述：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*Executed by one thread*/</span><br>initialize the lock data structure;<br>...<br><span class="hljs-comment">/*Executed by multiple threads*/</span><br>Attempt to lock <span class="hljs-keyword">or</span> set the lock data structure;<br>Critical section;<br>Unlock <span class="hljs-keyword">or</span> unset the lock data structure;<br>...<br><span class="hljs-comment">/*Executed by one thread*/</span><br>Destory the lock data structure;<br></code></pre></div></td></tr></table></figure><p>锁的数据结构被执行临界区的线程所共享，这些线程中的某个线程（如主线程）会初始化锁。而当所有的线程都使用完锁后，某个线程应当负责销毁锁。</p><p>在一个线程进入临界区前，它尝试通过调用锁函数来上锁（set）。如果没有其他的线程正在执行临界区代码，那么它将获得锁并进入临界区。当该线程执行完临界区代码后，它调用解锁函数释放（relinquish或者unset）锁，以便其他线程可以获得锁。</p><p>当一个线程拥有锁时，其他线程都不能进入该临界区。其他线程尝试通过调用锁函数进入该临界区时会阻塞。如果有多个线程被锁函数阻塞，则当临界区的线程释放锁时，这些线程中的某个线程会获得锁，而其他线程仍被阻塞。</p><p>OpenMP有两种锁：简单（simple）锁和嵌套（nested）锁。简单锁在被释放前只能获得一次，而一个嵌套锁在被释放前可以被同一个线程获得多次。OpenMP简单锁的类型是omp_lock_t，定义简单锁的函数包括：</p><p><img src="/2023/01/14/openmp006/image-20230116165204803.png" alt="image-20230116165204803"></p><p>相关的类型和函数在头文件omp.h中声明。第一个函数的作为是初始化锁，所以此时锁处于解锁状态，换句话说，此时没有线程拥有这个锁。第二个函数尝试获得锁，如果成功，调用该函数的线程可以继续执行；如果失败，调用该函数的线程将被阻塞，直到锁被其他线程释放。第三个函数释放锁，以便其他线程可以获得该锁。第四个函数销毁锁。</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP循环调度</title>
    <link href="/2023/01/14/openmp005/"/>
    <url>/2023/01/14/openmp005/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenMP循环调度"><a href="#OpenMP循环调度" class="headerlink" title="OpenMP循环调度"></a>OpenMP循环调度</h2><h3 id="1-循环调度"><a href="#1-循环调度" class="headerlink" title="1.循环调度"></a>1.循环调度</h3><p>当第一次遇到parallel for指令时，我们看到将各次循环分配给线程的操作是由系统完成的。然而，大部分OpenMP实现只是粗略地使用块分割：如果在串行循环中有n次迭代，那么在并行循环中，前n&#x2F;thread_count个迭代分配给线程0，接下来的n&#x2F;thread_count个迭代分配给线程1，依此类推。不难想到，这种分配方式肯定不是最优的。例如，假如我们想要并行化循环：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sum = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>    sum+=<span class="hljs-built_in">f</span>(i);<br></code></pre></div></td></tr></table></figure><p>同时，假设对f函数调用所需要的时间与参数i的大小成正比，那么与分配给线程0的工作相比，分配给线程thread_count-1的工作量相对较大。一个更好的分配方案是轮流分配线程的工作（循环划分）。在循环划分中，各次迭代被“轮流”地一次一个地分配给线程。假如 t&#x3D;thread_count。那么一个循环划分将如下分配各次迭代：</p><p><img src="/2023/01/14/openmp005/image-20230114132246596.png" alt="image-20230114132246596"></p><p>为了了解这样分配是如何影响性能的，我们编写了如下程序。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j,start=i*(i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>,finish=start+i;<br>    <span class="hljs-keyword">double</span> return_val = <span class="hljs-number">0.0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(j = start; j&lt;=finish; j++)&#123;<br>        return_val += <span class="hljs-built_in">sin</span>(j);<br>    &#125;<br>    <span class="hljs-keyword">return</span> return_val;<br>    <span class="hljs-comment">/* f */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>每当函数f（i）调用i次sin函数。例如，执行f（2i）的时间几乎是执行f（i）的时间的两倍。</p><p>当n&#x3D;10000并且只用一个线程运行程序时，运行时间是3.67秒。当用两个线程和缺省分配方式（第0-5000次迭代分配给线程0，第5001-10000次迭代分配给线程1），运行程序时，运行时间为2.76秒。加速比仅为1.33.然而，当运行两个线程并采用循环划分时，运行时间减少到1.84秒。与单线程运行相比，加速比为1.99；与双线程，块分割相比，加速比为1.5！</p><p>我们看到一个好的迭代分配能够对性能有很大的影响。再OpenMP中，将循环分配给线程称为调度，schedule子句用于在parallel for或者for指令中进行迭代分配。</p><h3 id="2-schedule子句"><a href="#2-schedule子句" class="headerlink" title="2.schedule子句"></a>2.schedule子句</h3><p>在例子中，我们已经知道如何乎获取缺省调度：只需要添加parallel for指令和reduction子句：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sum=<span class="hljs-number">0.0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    sum+=<span class="hljs-built_in">f</span>(i);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>为了对线程进行调度，可以添加一个schedule子句到parallel for指令中：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sum=<span class="hljs-number">0.0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)schedule(static,1)</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    sum+=<span class="hljs-built_in">f</span>(i);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一般而言，schedule子句有如下形式：</p><p>schedule（<type>[.<chunksize>]）</chunksize></type></p><p>type可以是下列任意一个：</p><ol><li>static：迭代能够在循环执行前分配给线程</li><li>dynamic或guided：迭代在循环执行时被分配给线程，因此在一个线程完成了它的当前迭代集合后，它能从运行时系统中请求更多</li><li>auto：编译器和运行时系统决定调度方式</li><li>runtime：调度在运行时决定</li></ol><p>chunksize是一个正整数。在OpenMP中，迭代块是在顺序循环中连续执行的一块迭代语句，块中的迭代次数是chunksize。只有static，dynamic和guided调度有chunksize。这虽然决定了调度的细节，但准确的解释还是依赖于type。</p><h3 id="3-stastic调度类型"><a href="#3-stastic调度类型" class="headerlink" title="3.stastic调度类型"></a>3.stastic调度类型</h3><p>对于static调度，系统以轮转的方式分配chunksize块个迭代给每个线程。例如，假如有12个迭代，0，1，—，11和3个线程，如果在parallel for或for指令中使用schedule（static，1）迭代将如下分配：</p><p><img src="/2023/01/14/openmp005/image-20230114141741424.png" alt="image-20230114141741424"></p><p>如果使用schedule（static，2），迭代将如下进行分配：</p><p><img src="/2023/01/14/openmp005/image-20230114141830866.png" alt="image-20230114141830866"></p><p>如果使用schedule（static，4），迭代将如下分配：</p><p><img src="/2023/01/14/openmp005/image-20230114141909092.png" alt="image-20230114141909092"></p><p>因此，子句schedule（static,total_iterations&#x2F;thread_count）就相当于被大部分OpenMP实现所使用的缺省调度。</p><p>这里，chunksize可以被忽略。如果他被忽略了，chunksize就近似等于total_iterations&#x2F;thread_count。</p><h3 id="4-dynamic和guided调度类型"><a href="#4-dynamic和guided调度类型" class="headerlink" title="4.dynamic和guided调度类型"></a>4.dynamic和guided调度类型</h3><p>在dynamic调度中，迭代也被分成chunksize个连续迭代的块。每个线程执行一块，并且当一个线程完成一块时，它将从运行时系统请求另一块，直到所有的迭代完成。chunksize可以被忽略。当它被忽略时，chunksize为1。</p><p>在guided调度中，每个线程也执行一块，并且当一个线程完成一块时，将请求另一块。然而，在guided调度中，当块完成后，新块的大小会变小。例如，在我们的系统中，如果用parallel for指令和schedule（guided）子句来运行梯形积分法程序，那么当n&#x3D;10000并且thread_count&#x3D;2时。迭代将如表5-3那样分配。块的大小近似等于剩下的迭代数除以线程数。第一个块的大小9999&#x2F;2≈5000，因为有9999个迭代未被分配的迭代。第二个块的大小为4999&#x2F;2≈2500，一次类推。</p><p><img src="/2023/01/14/openmp005/image-20230114143233692.png" alt="image-20230114143233692"></p><p>在guided调度中，如果没有指定chunksize，那么块的大小为1；如果指定了chunksize，那么块的大小就是chunksize，除了最后一块的大小可以比chunksize小。</p><h3 id="5-runtime调度类型"><a href="#5-runtime调度类型" class="headerlink" title="5.runtime调度类型"></a>5.runtime调度类型</h3><p>为了理解schedule（runtime），我们需要离题一会儿，讨论一下环境变量。正如名字所暗示的，环境变量是能够被运行时系统所访问的命名值，即它们在程序的环境中是可得的。一些经常被使用的环境变量是PATH,HOME和SHELL。PATH变量明确了当寻找一个可执行文件时shell应该搜索哪些目录。它通常在UNIX和Windows系统中定义。HOME变量指定用户主目录的位置，而SHELL变量指定用户shell的可执行位置。这样通常在UNIX系统中。在类UNIX系统（例如Linux和Mac OS X）和Windows，环境变量能够在命令行中检查和指定。在类UNIX系统中，能使用shell命令行；在windows中，能使用集成开发环境的命令行。</p><p>例如，如果我们正使用bash shell，要检查一个环境变量的值只需要输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span></span><br></code></pre></div></td></tr></table></figure><p>我们能够使用export命令来设置一个环境变量的值</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"><span class="hljs-built_in">export</span> TEST_VAR = <span class="hljs-string">&quot;hello&quot;</span></span><br></code></pre></div></td></tr></table></figure><p>如何检查和设置特定系统的环境变量，请咨询本地系统的专家。</p><p>当schedule（runtime）指定时，系统使用环境变量OMP_SCHEDULE在运行时来决定如何调度循环。OMP_SCHEDULE环境变量会呈现任何能够被static，dynamic或guided调度所使用的值。例如，假设在程序中有一条parallel for指令，并且它已经被schedule（runtime）修改了。那么如果使用bash shell，就能通过执行以下命令将一个循环分配所得到的迭代分配给线程：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"><span class="hljs-built_in">export</span> OMP_SCHEDULE=<span class="hljs-string">&quot;static,1&quot;</span></span><br></code></pre></div></td></tr></table></figure><p>现在，当开始执行程序时，系统将调度for循环的迭代，就如同使用子句schedule（static，1）修改了parallel for指令那样。</p><h3 id="6-调度选择"><a href="#6-调度选择" class="headerlink" title="6.调度选择"></a>6.调度选择</h3><p>如果需要并行化一个for循环，那么我们如何决定使用哪一种电镀和chuncksize的大小？实际上，每一中schedule子句有不同的系统开销。dynamic调度的系统开销要大于static调度，而guided调度的系统开销是三种方式中最大的。因此，如果不使用schedule子句就已经达到了令人满意的性能，就不需要进行多余的工作。但是，如果我们怀疑调度的性能可以提升，那么我们可以对各种调度进行试验。</p><p>在本节开始提供的例子中，在程序使用两个线程的情况下，使用schedule（static，1）代替默认调度时，加速比从1.33提升到1.99。因为在两个线程的条件下，加速比几乎不可能比1.99更好，所以我们可以不用再尝试其他的调度方式，至少在只用两个线程并且迭代数为10000的情况下是这样。如果做更多的试验，改变线程的个数和迭代的次数，我们可能会发现：最优的调度方式是由线程的个数和迭代的次数共同决定的。</p><p>如果我们断定默认的调度方式性能低下，那么我们会做大量的实验来寻找最优的调度方式和迭代次数。在进行了大量的工作以后，我们可能发现，这些循环没有得到很好的并行化，没有哪一种调度可以带来比较显著的性能提升。编程作业5.4就是这样一个例子。</p><p>但在某些情况下，应该优先考虑有些调度：</p><ol><li>如果循环的每次迭代需要几乎相同的计算量，那么可能默认的调度方式能提供最好的性能</li><li>如果随着循环的进行，迭代的计算量线性猛增（或递减），那么采用比较小的chuncksize的static调度可能会提供最好的性能</li><li>如果每次迭代的开销事先不能确定，那么就可能需要尝试使用多种不同的调度策略。在这种情况下，应当使用schedule（runtime）子句，通过富裕环境变量OMP_SCHEDULE不同的值来比较不同调度策略下程序的性能</li></ol><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><ol><li>调度方式对加速效果的重要性</li><li>合理分析任务特性，选择最适合的调度方式</li></ol><h3 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8.参考资料"></a>8.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP排序</title>
    <link href="/2023/01/13/openmp004/"/>
    <url>/2023/01/13/openmp004/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenMP排序"><a href="#OpenMP排序" class="headerlink" title="OpenMP排序"></a>OpenMP排序</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(list_length = n; list.length &gt;= <span class="hljs-number">2</span>; list_length--)<span class="hljs-comment">//升序排列</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; list_length<span class="hljs-number">-1</span>; i++)<br>        <span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br>            tmp = a[i];<br>            a[i] = a[i+<span class="hljs-number">1</span>];<br>            a[i+<span class="hljs-number">1</span>] = tmp;<br>        &#125;<br></code></pre></div></td></tr></table></figure><p>​显然，在外部循环中有一个循环依赖，在外部循环的任何一次迭代中，当前列表的内容依赖于外部循环的前一次迭代。例如，如果在算法开始时，a&#x3D;3,4,1,2，那么外部循环的第二次迭代将对列表3，1，2进行操作，因为4在第一次迭代中应该已经被移动到列表的最后了。但如果前两次迭代同时执行，则可能第二次迭代的有效列表包含4。</p><p>​内部循环的循环依赖也很容易发现。在第i次迭代中，被比较的元素依赖于第i-1次迭代。如果在第i-1次迭代中a[i-1]和a[i]没有交换，那么第i次迭代将比较a[i]和a[i+1]。另一方面，如果第i-1次迭代交换了a[i-1]和a[i]，那么第i次迭代将比较原始的a[i-1] (现在是a[i]和a[i+1])。例如，假如当前列表是{3，1，2}。那么当i&#x3D;1时，我们将比较3和2，但如果i&#x3D;0和i&#x3D;1次迭代同时发生，则完全有可能i&#x3D;1次迭代回比较1和2。</p><p>​我们完全不清楚怎样在不完全重写算法的情况下一处任何一个循环依赖。记住。即使我们总能找到循环依赖，但可能很难甚至不可能移除它。对于并行化for循环而言，parallel for指令不是一个通用的解决方法。</p><h3 id="2-奇偶交换排序"><a href="#2-奇偶交换排序" class="headerlink" title="2.奇偶交换排序"></a>2.奇偶交换排序</h3><p>​奇偶交换排序是一个与冒泡排序相似的算法，但它相对来说更容易并行化。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(phase = <span class="hljs-number">0</span>;phase &lt; n ; phase++)<br>    <span class="hljs-keyword">if</span>(phase % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n ;i += <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>] &gt; a[i]) <span class="hljs-built_in">swap</span>(a[i<span class="hljs-number">-1</span>],a[i]);<br><span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt; n<span class="hljs-number">-1</span> ;i += <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>]) <span class="hljs-built_in">swap</span>(a[i],a[i+<span class="hljs-number">1</span>]);<br></code></pre></div></td></tr></table></figure><p>列表a存储n个整数，算法对他们进行升序排列。在一个“偶阶段”（phase %2 &#x3D;&#x3D;0 ）里，每个偶下标元素a[i]与它左边的元素a[i-1]相比较。如果他们是没有排好序的，就交换它们。在一个“奇阶段”里，每个奇下标元素与它右边的元素相比较。如果他们是没有排好序的，则交换他们。有定理证明：在n个阶段后，列表可以完成排序。</p><p>​作为一个简单的例子，假设a&#x3D;{9,7,8,6}。表5-1显示了各个阶段的情况。在这个例子中，最后的阶段不是必要的，但算法并不在执行每个阶段前检查列表是否已经有序。</p><p><img src="/2023/01/13/openmp004/image-20230113174202896.png" alt="image-20230113174202896"></p><p>​不难看到外部循环有一个循环依赖。例如在a &#x3D; {9，7，8，6}之前。在阶段0中，内部循环将比较（9，7）和（8，6）这两对中的元素，这两对都会被交换。因此对于阶段1，列表将是{7，9，6，8}，并在阶段1中（9，6）中的元素被比较并交换。然而，如果阶段0和阶段1同时执行，则在阶段1中被检查可能是（7，8），是有序的。此外，我们尚不清楚如何消除这个循环依赖，因此并行化外部for循环不是一个好的选择。</p><p>​但是，内部for循环并没有任何循环依赖。例如，在偶阶段循环中，变量i是奇数，所以对于两个不同的i值，例如，i&#x3D;j和i&#x3D;k，{j-1,j}和{k-1,k}将是不同的。（a[j-1],a[j]）和（a[k-1],a[k]）所产生的比较和可能的交换能够同时进行。</p><p>​所以，我们试图使用程序5-4的代码并行化奇偶变化排序，但还是会有一些潜在的问题，首先，尽管任何一个偶阶段迭代并不依赖任何这个阶段的其他迭代，但是还需要注意，对p阶段和p+1阶段却并不是这样的。我们需要确定在任何一个线程开始p+1阶段之前，所有的线程必须先完成p阶段。然而，像parallel指令那样，parallel for指令在循环结束处有一个隐式的路障，因此，在所有的线程完成当前阶段（即阶段P之前），没有线程能够进入下一阶段，即p+1阶段。【这里需要注意在MPI中并没有隐式的路障来实现这个功能，需要程序员手动设置路障点】</p><p>​其次，是创建和合并线程的开销。OpenMP实现可能会在每一遍外部循环都创建和合并thread__count个线程。表5-2的第一行显示了当输入列表包含20000个元素时，在我们系统上运行1，2，3，4个线程的运行时间。</p><h3 id="3-程序5-4奇偶排序的第一个OpenMP实现"><a href="#3-程序5-4奇偶排序的第一个OpenMP实现" class="headerlink" title="3.程序5-4奇偶排序的第一个OpenMP实现"></a>3.程序5-4奇偶排序的第一个OpenMP实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(phase = <span class="hljs-number">0</span>;phase &lt; n; phase++)&#123;<br>    <span class="hljs-keyword">if</span>(phase %<span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp)</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i+=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]&gt;a[i])&#123;<br>                tmp = a[i<span class="hljs-number">-1</span>];<br>                a[i<span class="hljs-number">-1</span>] = a[i];<br>                a[i] =tmp;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp)</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i+=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br>                tmp = a[i+<span class="hljs-number">1</span>];<br>                a[i+<span class="hljs-number">1</span>] = a[i];<br>                a[i] = tmp;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2023/01/13/openmp004/image-20230113225724364.png" alt="image-20230113225724364"></p><p>​这些时间耗费并不非常糟糕，但是我们想看看是否能做得更好。每次执行内部循环时，使用同样数量的线程。因此只创建一次线程，并在每次内部循环的执行中重用它们，这样做可能更好。幸运的是，OpenMP提供了允许这样做的指令。用parallel指令在外部循环前创建thread__count个线程的集合。然后，我们不在每次内部循环执行时创建一组新的线程，而是使用一个for指令，告诉OpenMP用已有的线程组来并行化for循环，对原有OpenMP实现的改动显示在程序5-5中。</p><h3 id="4-程序5-5奇偶排序的第二个OpenMP实现"><a href="#4-程序5-5奇偶排序的第二个OpenMP实现" class="headerlink" title="4.程序5-5奇偶排序的第二个OpenMP实现"></a>4.程序5-5奇偶排序的第二个OpenMP实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp,phase)</span><br><span class="hljs-keyword">for</span>(phase = <span class="hljs-number">0</span>;phase &lt; n; phase++)&#123;<br>    <span class="hljs-keyword">if</span>(phase %<span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp for</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i+=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]&gt;a[i])&#123;<br>                tmp = a[i<span class="hljs-number">-1</span>];<br>                a[i<span class="hljs-number">-1</span>] = a[i];<br>                a[i] =tmp;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp for</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i+=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;<br>                tmp = a[i+<span class="hljs-number">1</span>];<br>                a[i+<span class="hljs-number">1</span>] = a[i];<br>                a[i] = tmp;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>与parallel for指令不同的是，for指令并不创建任何线程。它使用已经在parallel块中创建的线程。在循环的末尾有一个隐式的路障。代码的结果（最终列表）将因此与原有的并行化代码所取得到的结果一样。</p><p>​奇偶排序的第二个版本的运行时间显示在表5-2的第二行。当使用两个或更多线程时，使用两条for指令的版本要比使用两条parallel for指令的版本快17%。因此对于这个系统而言，为这点改变所做的小小努力是值得的。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ol><li>循环依赖总会出现，我们可能会很难去解决它甚至根本无法解决。</li><li>在构造并行区时要尽量减少创建和合并线程的开销</li></ol><h3 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6.参考文献"></a>6.参考文献</h3><p>并行程序导论 （美）Peter S.Pacheco</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP π值估计</title>
    <link href="/2023/01/09/openmp003/"/>
    <url>/2023/01/09/openmp003/</url>
    
    <content type="html"><![CDATA[<h2 id="π值估计"><a href="#π值估计" class="headerlink" title="π值估计"></a>π值估计</h2><h3 id="1-数学背景"><a href="#1-数学背景" class="headerlink" title="1.数学背景"></a>1.数学背景</h3><p><img src="/2023/01/09/openmp003/image-20230109150836877.png" alt="image-20230109150836877"></p><p>我们能够在串行代码下实行这个公式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> factor = <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span> ; k &lt; n; k++)&#123;<br>    sum += factor /(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br>    factor = - factor;<br>&#125;<br>pi_approx = <span class="hljs-number">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure><h3 id="2-OpenMP并行化"><a href="#2-OpenMP并行化" class="headerlink" title="2.OpenMP并行化"></a>2.OpenMP并行化</h3><p>为了使用OpenMP来并行化，可以首先倾向于这样做：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span> <span class="hljs-keyword">double</span> factor = <span class="hljs-number">1.0</span>;<br><span class="hljs-number">2</span> <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br><span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)  <span class="hljs-comment">//对sum进行求和归约</span></span><br><span class="hljs-number">4</span> <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span> ; k &lt; n; k++)&#123;<br><span class="hljs-number">5</span>     sum += factor /(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br><span class="hljs-number">6</span>     factor = - factor;<br><span class="hljs-number">7</span> &#125;<br><span class="hljs-number">8</span> pi_approx = <span class="hljs-number">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure><p>然而，第k次迭代中对第6行的factor的更新和接下来的第k + 1次迭代中对第5行的sum的累加是一个循环依赖（数据依赖）。如果第k次迭代被分配·到一个线程，而第k + 1次迭代被分配给另一个线程，则我们不能保证第6行中factor的值是正确的。</p><p>在这种情况下我们能通过检查系数来解决这个问题：</p><p><img src="/2023/01/09/openmp003/image-20230109161031989.png" alt="image-20230109161031989"></p><p>可以看到：在第k次迭代，factor的值应该是<img src="/2023/01/09/openmp003/image-20230109161206995.png" alt="image-20230109161206995">。如果k是偶数，那么值是+1；如果k是奇数，值是-1。</p><h3 id="3-消除循环依赖（数据依赖）"><a href="#3-消除循环依赖（数据依赖）" class="headerlink" title="3.消除循环依赖（数据依赖）"></a>3.消除循环依赖（数据依赖）</h3><p>因此，如果将下述代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">sum += factor /(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br>factor = - factor;<br></code></pre></div></td></tr></table></figure><p>替换为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)<span class="hljs-comment">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    factor = <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">else</span><br>    factor = <span class="hljs-number">-1.0</span>;<br>sum += factor/(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure><p>这样就消除了循环依赖（数据依赖）。</p><h3 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4.作用域"></a>4.作用域</h3><p>​然而，事情仍然不是完全正确的。如果在我们的系统上使用两个线程运行程序，并设n&#x3D;1000，那么结果仍然是错误的。例如，</p><p><img src="/2023/01/09/openmp003/image-20230109164120205.png" alt="image-20230109164120205"></p><p>另一方面，如果只有一个线程运行程序，我们总是得到：</p><p><img src="/2023/01/09/openmp003/image-20230109164204808.png" alt="image-20230109164204808"></p><p>为什么会有这种错误。在一个已经被parallel for指令并行化的块中，缺省情况下任何在循环前声明的变量（唯一的例外是循环变量）在线程间都是共享的。因此factor被共享（被所有线程所共享）。例如，线程0可能会给他赋值1，但在它能用这个值更新sum前，线程1可能又给他赋值为-1了。因此，除了消除计算factor时的循环依赖（数据依赖）外，我们还需要保证每个线程有它自己的factor副本，就是说，为了使代码正确，我们需要保证factor有私有作用域（简单来说就是保证当前线程的factor的值不能被其他线程修改，也只有当前线程能更新和使用factor）。通过添加一个private子句到parallel指令中来实现这一目标。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"> <span class="hljs-keyword">double</span> factor = <span class="hljs-number">1.0</span>;<br> <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum) private(factor)  <span class="hljs-comment">//对sum进行求和归约</span></span><br> <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span> ; k &lt; n; k++)&#123;<br>     <span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)<span class="hljs-comment">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    factor = <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">else</span><br>    factor = <span class="hljs-number">-1.0</span>;<br>     sum += factor /(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br> &#125;<br> pi_approx = <span class="hljs-number">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure><p>在private子句内列举的变量，在每个线程上都有一个私有副本被创建。因此，在我们的例子中，thread_count个线程中的每一个都有它自己的factor变量的副本，因此一个线程对factor的更新不会影响另一个线程的factor值。</p><p>​要记住的重要的一点是，一个有私有作用域的变量的值在parallel块或者parallel for块的开始处是未指定的。它的值在parallel或parallel for块完成之后也是未指定的。例如，下列代码中的第一个printf语句的输出是非确定的，因为在它被现实初始化之前就打印了私有变量x。类似地，最终的printf输出也是非确定的，因为他在parallel块完成之后打印x。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel num_threads(thread_count) private(x)</span><br>&#123;<br>    <span class="hljs-keyword">int</span> my_rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d &gt; before initialization,x = %d\n&quot;</span>,myrank,x);<br>    x = <span class="hljs-number">2</span>*my_rank + <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d &gt; after initialization,x = %d\n&quot;</span>,my_rank,x);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After parallel block, x = %d\n&quot;</span>,x);<br></code></pre></div></td></tr></table></figure><h3 id="5-关于作用域的更多问题"><a href="#5-关于作用域的更多问题" class="headerlink" title="5.关于作用域的更多问题"></a>5.关于作用域的更多问题</h3><p>​关于变量factor的问题是常见问题中的一个。我们通常需要考虑在parallel块或parallel for块中的每个变量的作用域。因此，与其让OpenMP决定每个变量的作用域，还不如让程序员明确块中每个变量的作用域。事实上，OpenMP提供了一个子句default，该子句显示地要求我们这样做。如果我们添加子句：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in"><span class="hljs-keyword">default</span></span>(none)<br></code></pre></div></td></tr></table></figure><p>到parallel或parallel for指令中，那么编译器将要求我们明确在这个块中使用的每个变量和已经在块之外声明的变量的作用域。（在一个块中声明的变量都是私有的，因为它们会被分配给线程的栈。）</p><p>​例如，使用一个default（none）子句，对π的计算将如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for num_threads(thread_count) default(none) reduction(+:sum) private(k,factor)  <span class="hljs-comment">//对sum进行求和归约</span></span><br> <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span> ; k &lt; n; k++)&#123;<br>     <span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> ==<span class="hljs-number">0</span>)<span class="hljs-comment">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    factor = <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">else</span><br>    factor = <span class="hljs-number">-1.0</span>;<br>     sum += factor /(<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>);<br> &#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，我们在for循环中使用4个变量。由于default子句，我们需要明确每个变量的作用域。正如我们已经注意到的，sum是一个归约变量（同时拥有私有和共享作用域的属性）。我们也已经注意到factor和循环变量中k应该有私有作用域。从未在parallel或parallel for块中更新的变量，如这个例子中的n，能够被安全的共享。与私有变量不同，共享变量在块内具有在parallel或parallel for块之前的值，在块之后的值与块内的最后一个值相同。因此，如果n在块之前被初始化为1000，则在parallel for语句中他将保持这个值。因为在for循环中值没有改变，所有在循环结束后它将保持这个值。</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><ol><li>分析数学背景，解决循环依赖（数据依赖）</li><li>判断变量的作用域</li></ol><h3 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7.参考资料"></a>7.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP寻找循环依赖</title>
    <link href="/2023/01/06/openmp002/"/>
    <url>/2023/01/06/openmp002/</url>
    
    <content type="html"><![CDATA[<h3 id="1-OpenMP寻找循环依赖"><a href="#1-OpenMP寻找循环依赖" class="headerlink" title="1.OpenMP寻找循环依赖"></a>1.OpenMP寻找循环依赖</h3><p>​当我们试图使用一个parallel for指令时，首先应该注意的是：要小心发现循环依赖。我们不需要担心一般的数据依赖。例如，在下面循环中：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    x[i] = a + i*h;<span class="hljs-comment">//2</span><br>    y[i] = <span class="hljs-built_in">exp</span>(x[i]);<span class="hljs-comment">//3</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在第二行和第三行之间有一个数据依赖。然而，如下的并行化没有问题。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    x[i] = a + i*h;<span class="hljs-comment">//3</span><br>    y[i] = <span class="hljs-built_in">exp</span>(x[i]);<span class="hljs-comment">//4</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>因为x[ i ]的计算与它接下来的使用总是被分配给同一个进程。</p><p>​我们也应该观察到，有依赖关系的语句，其中至少一条语句会有序地写或更新变量。因此为了检测循环依赖，我们只需要重点观察被循环体更新的变量，即我们应该寻找在一个迭代中被读或被写，而在另一个迭代中被写的变量。</p><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h3><ol><li>数据依赖在优化过程中非常常见</li><li>如何解决数据依赖对提升并行化的效果影响很大</li></ol><h3 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.参考资料"></a>3.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenMP梯度积分法</title>
    <link href="/2023/01/03/openmp001/"/>
    <url>/2023/01/03/openmp001/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenMP梯度积分法"><a href="#OpenMP梯度积分法" class="headerlink" title="OpenMP梯度积分法"></a>OpenMP梯度积分法</h2><h3 id="1-梯度积分法"><a href="#1-梯度积分法" class="headerlink" title="1.梯度积分法"></a>1.梯度积分法</h3><p><img src="/2023/01/03/openmp001/image-20230106165434252.png" alt="001"></p><p><img src="/2023/01/03/openmp001/image-20230106165507737.png" alt="image-20230106165507737"></p><h3 id="2-识别两类任务"><a href="#2-识别两类任务" class="headerlink" title="2.识别两类任务"></a>2.识别两类任务</h3><p><img src="/2023/01/03/openmp001/image-20230106164847677.png" alt="image-20230106164847677"></p><ol><li>单个梯形的面积计算</li><li>梯形面积求和</li></ol><p>在2.1的任务中，没有任务间的通信，但这一组任务中的每一组任务都与2.2的任务通信</p><h3 id="3-累加线程结果"><a href="#3-累加线程结果" class="headerlink" title="3.累加线程结果"></a>3.累加线程结果</h3><p>​使用一个共享变量作为所有线程的和 ，每个线程可以将它计算的部分结果累加到共享变量中，让每个线程执行类似下面的语句：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical</span><br>global_result += myresult;                <span class="hljs-comment">//需要互斥访问</span><br></code></pre></div></td></tr></table></figure><p>竞争条件，使用临界区解决。保证每次只有一个线程执行这段结构性代码。</p><h3 id="4-程序完整代码"><a href="#4-程序完整代码" class="headerlink" title="4.程序完整代码"></a>4.程序完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;omp.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Trap</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">double</span> *global_result_p)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>&#123;<br><span class="hljs-keyword">double</span> global_result = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">double</span> a,b;<span class="hljs-comment">//为了区分local_a,local_b</span><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> thread_count;<br><br>thread_count = <span class="hljs-number">8</span>;                                      <span class="hljs-comment">//指定你的线程数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter a,b, and n\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf %d&quot;</span>,&amp;a,&amp;b,&amp;n);<br>    <br>    <span class="hljs-comment">//并行区开始</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel num_threads(thread_count)<span class="hljs-comment">//指定Trap函数由thread_count个线程执行</span></span><br><span class="hljs-built_in">Trap</span>(a,b,n,&amp;global_result);<br><span class="hljs-comment">//并行区结束</span><br>    <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;With n = %d trapezoids, our estimate\n&quot;</span>,n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;of the integral from %f to %f = %.4lf\n&quot;</span>,a,b,global_result);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Trap</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">double</span> *global_result_p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> h,x,my_result;<br><span class="hljs-keyword">double</span> local_a,local_b;<br><span class="hljs-keyword">int</span> i,local_n;<span class="hljs-comment">//local_n代表本进程被分配了多少个任务</span><br><span class="hljs-keyword">int</span> my_rank = <span class="hljs-built_in">omp_get_thread_num</span>();<br><span class="hljs-keyword">int</span> thread_count = <span class="hljs-built_in">omp_get_num_threads</span>();<br><br>h = (b-a)/n;<span class="hljs-comment">//梯形底的长度</span><br>local_n = n/thread_count;<span class="hljs-comment">//每个线程分配的梯形数，保证能整除</span><br>local_a = a + my_rank*local_n*h;<span class="hljs-comment">//区间的左端点</span><br>local_b = local_a + local_n*h;<span class="hljs-comment">//区间的右端点</span><br><span class="hljs-comment">//对global_result共享部分和</span><br>    my_result = (<span class="hljs-built_in">f</span>(local_a) + <span class="hljs-built_in">f</span>(local_b))/<span class="hljs-number">2.0</span>;<span class="hljs-comment">//f(x)是目标函数</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span> ; i&lt;=local_n<span class="hljs-number">-1</span>; i++)&#123;<br>x = local_a + i*h;<br>my_result += <span class="hljs-built_in">f</span>(x);<br>&#125;<br>my_result = my_result*h;<br>    <span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp critical<span class="hljs-comment">//临界区，这里可以直接使用OpenMP提供的reduction</span></span><br>*global_result_p += my_result;<span class="hljs-comment">//线程将部分和结果累加到共享变量</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ol><li>核心是拆分任务区域，把子任务分配到个个线程</li><li>共享变量的选取决定了可并行度</li><li>通过共享变量实现了归约的操作(这里使用到了临界区)</li></ol><h3 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6.参考资料"></a>6.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国内常用镜像源</title>
    <link href="/2022/06/22/mirror001/"/>
    <url>/2022/06/22/mirror001/</url>
    
    <content type="html"><![CDATA[<h2 id="国内常用镜像源"><a href="#国内常用镜像源" class="headerlink" title="国内常用镜像源"></a>国内常用镜像源</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">清华大学： https:<span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple/</span><br>阿里云： https:<span class="hljs-comment">//mirrors.aliyun.com/pypi/simple/</span><br>豆瓣： http:<span class="hljs-comment">//pypi.douban.com/simple/</span><br>中国科学技术大学： http:<span class="hljs-comment">//pypi.mirrors.ustc.edu.cn/simple/</span><br>华中科技大学：http:<span class="hljs-comment">//pypi.hustunique.com/simple/</span><br>山东理工大学：http:<span class="hljs-comment">//pypi.sdutlinux.org/simple/</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mirror</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐</title>
    <link href="/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><h2 id="CPU读取内存的方式"><a href="#CPU读取内存的方式" class="headerlink" title="CPU读取内存的方式"></a>CPU读取内存的方式</h2><p>CPU读取内存的方式其实非常复杂，为了更进一步的了解相关的原理，需要对计算机组成原理进行深度学习。</p><h3 id="Memory-access-granularity-内存读取粒度"><a href="#Memory-access-granularity-内存读取粒度" class="headerlink" title="Memory access granularity(内存读取粒度)"></a>Memory access granularity(内存读取粒度)</h3><p>However, your computer’s processor does not read from and write to memory in byte-sized chunks. Instead, it accesses memory in two-, four-, eight- 16- or even 32-byte chunks. We’ll call the size in which a processor accesses memory its memory access granularity.</p><p>CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为<em>memory access granularity（粒度）</em> 本人把它翻译为“内存读取粒度” 。</p><p><a href="https://www.cnblogs.com/feng9exe/p/10059543.html">https://www.cnblogs.com/feng9exe/p/10059543.html</a> ”内存对齐“</p><h2 id="内存对齐举例"><a href="#内存对齐举例" class="headerlink" title="内存对齐举例"></a>内存对齐举例</h2><p>假设此计算机的内存读取粒度是4。</p><h3 id="如果内存对齐时"><a href="#如果内存对齐时" class="headerlink" title="如果内存对齐时"></a>如果内存对齐时</h3><p>前提知识：</p><p>1 Byte &#x3D; 8bit </p><p>1 int8 占用 1 Byte</p><p>1 int16 占用 2 Byte</p><p>1 int32 占用 4 Byte</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//一个结构体的定义如下</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span></span><br><span class="hljs-class">&#123;</span><br>    int8 a;<br>    int32 b;<br>&#125;<br></code></pre></div></td></tr></table></figure><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th align="center">4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>int8 a</td><td></td><td></td><td></td><td align="center">int32 b</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>我们可以发现int8 a储存在0号内存上，占用1个Byte，1-3号内存空下了3个Byte。int32 b储存在了4-7号内存，一共4个Byte。</p><p>由于此计算机的内存读取粒度时是4</p><p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p><p>当需要读取b(4-7号内存时)，计算机会读取4-7号内存，访问次数1次。</p><h3 id="如果内存没有对齐时"><a href="#如果内存没有对齐时" class="headerlink" title="如果内存没有对齐时"></a>如果内存没有对齐时</h3><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>int8 a</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>我们可以发现int8 a储存在0号内存上，占用了1个Byte。int32 b储存在1-4号内存上，一共4个Byte。</p><p>由于此计算机的内存读取粒度时是4</p><p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p><p>当需要读取b(1-4号内存)时，计算机会先读取0-3号一组内存，去掉0号内存，再读取4-7号一组内存，去掉5-7号内存，随后再拼接1-3号内存和4号内存组成完整的b。访问次数2次。</p><h2 id="内存对齐的目的"><a href="#内存对齐的目的" class="headerlink" title="内存对齐的目的"></a>内存对齐的目的</h2><p>合理的内存对齐可以高效的利用硬件性能，减少处理器内存访问次数。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0</a> “内存对齐”</p><p><a href="https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0</a> “内存对齐对程序性能的影响”</p>]]></content>
    
    
    <categories>
      
      <category>Computer Organization</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(一)-简单的发送接收</title>
    <link href="/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/"/>
    <url>/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-简单的发送接收"><a href="#MPI-简单的发送接收" class="headerlink" title="MPI-简单的发送接收"></a>MPI-简单的发送接收</h1><p>打印来自进程问候语句的MPI程序</p><h2 id="所使用的MPI原语"><a href="#所使用的MPI原语" class="headerlink" title="所使用的MPI原语"></a>所使用的MPI原语</h2><p><img src="/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi001.png"></p><p><img src="/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi002.png"></p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpicc  3.1.cpp -o 3.1</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>mpirun -np 4 .&#x2F;3.1(本地提交,采取4个进程)</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span>   <span class="hljs-comment">//头文件</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_STRING = <span class="hljs-number">100</span> ;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> greeting[MAX_STRING];<br><span class="hljs-keyword">int</span> comm_sz;<br><span class="hljs-keyword">int</span> my_rank;<br>MPI_Status status;<br><br><span class="hljs-built_in">MPI_Init</span>(&amp;argc,&amp;argv);<br><br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;comm_sz);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;my_rank);<br><br><span class="hljs-keyword">if</span>(my_rank != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//其他进程向0号进程发消息</span><br><span class="hljs-built_in">sprintf</span>(greeting,<span class="hljs-string">&quot;Greetings from process %d of %d!&quot;</span>,my_rank,comm_sz);<br><span class="hljs-built_in">MPI_Send</span>(greeting,<span class="hljs-built_in">strlen</span>(greeting)+<span class="hljs-number">1</span>,MPI_CHAR,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,MPI_COMM_WORLD); <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Greetings from process %d of %d!\n&quot;</span>,my_rank,comm_sz);<br><span class="hljs-comment">//0号进程接受来自其他进程的消息并输出</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=<span class="hljs-number">1</span>;q&lt;comm_sz;q++)<br>&#123;<br><span class="hljs-built_in">MPI_Recv</span>(greeting,MAX_STRING,MPI_CHAR,q,<span class="hljs-number">0</span>,MPI_COMM_WORLD,&amp;status);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,greeting);<br>&#125;<br>&#125;<br><span class="hljs-built_in">MPI_Finalize</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Greetings from process <span class="hljs-number">0</span> of <span class="hljs-number">4</span>!<br>Greetings from process <span class="hljs-number">1</span> of <span class="hljs-number">4</span>!<br>Greetings from process <span class="hljs-number">2</span> of <span class="hljs-number">4</span>!<br>Greetings from process <span class="hljs-number">3</span> of <span class="hljs-number">4</span>!<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(二)-内存对齐的应用</title>
    <link href="/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX指令集的简单操作-内存对齐版"><a href="#AVX指令集的简单操作-内存对齐版" class="headerlink" title="AVX指令集的简单操作(内存对齐版)"></a>AVX指令集的简单操作(内存对齐版)</h1><p>使用AVX指令集进行2个double型的数组相加操作</p><h2 id="常用的内存对齐函数"><a href="#常用的内存对齐函数" class="headerlink" title="常用的内存对齐函数"></a>常用的内存对齐函数</h2><p>因为AVX中要求mem__addr必须在32字节边界上对齐，否则可能会产生通用保护异常。  </p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br></code></pre></div></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)_mm_malloc(<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>),<span class="hljs-number">32</span>);<br></code></pre></div></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">aligned_alloc</span>(<span class="hljs-number">32</span>,<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br></code></pre></div></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__attribute__ ((<span class="hljs-built_in">aligned</span>(<span class="hljs-number">32</span>)))<span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>]  =&#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256d _mm256_load_pd (<span class="hljs-keyword">double</span> <span class="hljs-keyword">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure><p><strong>Description</strong></p><p>Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">dst[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>] := MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr]<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256 _mm256_add_ps (__m256 a, __m256 b)<br></code></pre></div></td></tr></table></figure><p><strong>Description</strong></p><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">FOR</span> j := <span class="hljs-number">0</span> to <span class="hljs-number">7</span><br><span class="hljs-attribute">i</span> := j*<span class="hljs-number">32</span><br><span class="hljs-attribute">dst</span>[i+<span class="hljs-number">31</span>:i] := a[i+<span class="hljs-number">31</span>:i] + b[i+<span class="hljs-number">31</span>:i]<br><span class="hljs-attribute">ENDFOR</span><br><span class="hljs-attribute">dst</span>[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="3-stream的作用：绕过缓存直接写入内存"><a href="#3-stream的作用：绕过缓存直接写入内存" class="headerlink" title="3.stream的作用：绕过缓存直接写入内存"></a>3.stream的作用：绕过缓存直接写入内存</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> _mm256_stream_pd (<span class="hljs-keyword">double</span> * mem_addr, __m256d a)<br></code></pre></div></td></tr></table></figure><p><strong>Description</strong></p><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr] := a[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><h2 id="样例程序举例："><a href="#样例程序举例：" class="headerlink" title="样例程序举例："></a>样例程序举例：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span>*a =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">9</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br><span class="hljs-keyword">double</span>*b =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">4</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br><span class="hljs-keyword">double</span> af[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125; ;<br><span class="hljs-keyword">double</span> bf[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span>*c =(<span class="hljs-keyword">double</span>*)<span class="hljs-built_in">memalign</span>(<span class="hljs-number">32</span>,<span class="hljs-number">4</span>*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">double</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>a[i]=af[i];<br>b[i]=bf[i];<br>&#125;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>__m256d v0;<br>__m256d v1;<br>__m256d v2;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span><span class="hljs-number">-4</span>;i+=<span class="hljs-number">4</span>)<br>&#123;<br>v0 = _mm256_load_pd(a+i);<br>v1 = _mm256_load_pd(b+i);<br>v2=_mm256_add_pd(v0,v1);<br> _mm256_stream_pd(c+i,v2);<br><br>&#125;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>c[i]=a[i]+b[i];<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is c.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,c[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure><h2 id="样例程序输出："><a href="#样例程序输出：" class="headerlink" title="样例程序输出："></a>样例程序输出：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is c.<br><span class="hljs-number">3.200000</span><br><span class="hljs-number">5.400000</span><br><span class="hljs-number">9.700000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">9.200000</span><br><span class="hljs-number">16.500000</span><br><span class="hljs-number">12.800000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">8.700000</span><br></code></pre></div></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(一)</title>
    <link href="/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX指令集的简单操作"><a href="#AVX指令集的简单操作" class="headerlink" title="AVX指令集的简单操作"></a>AVX指令集的简单操作</h1><p>使用AVX指令集进行2个double型的数组相加操作</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256 _mm256_loadu_ps (<span class="hljs-keyword">float</span> <span class="hljs-keyword">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p><h3 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">dst[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>] := MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr]<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256d _mm256_add_pd (__m256d a, __m256d b)<br></code></pre></div></td></tr></table></figure><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p><h3 id="Operation-1"><a href="#Operation-1" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span><br>i := j*<span class="hljs-number">64</span><br>dst[i+<span class="hljs-number">63</span>:i] := a[i+<span class="hljs-number">63</span>:i] + b[i+<span class="hljs-number">63</span>:i]<br>ENDFOR<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> _mm256_storeu_pd (<span class="hljs-keyword">double</span> * mem_addr, __m256d a)<br></code></pre></div></td></tr></table></figure><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p><h3 id="Operation-2"><a href="#Operation-2" class="headerlink" title="Operation"></a>Operation</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr] := a[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><h2 id="未进行AVX向量化的情况"><a href="#未进行AVX向量化的情况" class="headerlink" title="未进行AVX向量化的情况"></a>未进行AVX向量化的情况</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span> c[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>c[i]=a[i]+b[i];<br><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is c.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,c[i]);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is c.<br><span class="hljs-number">3.200000</span><br><span class="hljs-number">5.400000</span><br><span class="hljs-number">9.700000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">9.200000</span><br><span class="hljs-number">16.500000</span><br><span class="hljs-number">12.800000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">8.700000</span><br></code></pre></div></td></tr></table></figure><h2 id="进行AVX向量化的情况"><a href="#进行AVX向量化的情况" class="headerlink" title="进行AVX向量化的情况"></a>进行AVX向量化的情况</h2><h3 id="程序源代码-1"><a href="#程序源代码-1" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span> c[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>__m256d v0;<br>__m256d v1;<br>__m256d v2;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span><span class="hljs-number">-4</span>;i+=<span class="hljs-number">4</span>)<br>&#123;<br>v0 = _mm256_loadu_pd(a+i);<br>v1 = _mm256_loadu_pd(b+i);<br>v2=_mm256_add_pd(v0,v1);<br> _mm256_storeu_pd(c+i,v2);<br><br>&#125;<br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br>c[i]=a[i]+b[i];<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is c with AVX.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,c[i]);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure><h3 id="程序输出-1"><a href="#程序输出-1" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is c with AVX.<br><span class="hljs-number">3.200000</span><br><span class="hljs-number">5.400000</span><br><span class="hljs-number">9.700000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">9.200000</span><br><span class="hljs-number">16.500000</span><br><span class="hljs-number">12.800000</span><br><span class="hljs-number">13.000000</span><br><span class="hljs-number">8.700000</span><br></code></pre></div></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slurm</title>
    <link href="/2022/05/20/slurm001/"/>
    <url>/2022/05/20/slurm001/</url>
    
    <content type="html"><![CDATA[<h2 id="Slurm"><a href="#Slurm" class="headerlink" title="Slurm"></a>Slurm</h2><h4 id="1-sstat-查看RUNNING作业"><a href="#1-sstat-查看RUNNING作业" class="headerlink" title="1.sstat 查看RUNNING作业"></a>1.sstat 查看RUNNING作业</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sstat -e<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/slurm001/image-20220520174453969.png" alt="image-20220520174453969"></p><p><strong>使用举例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sstat -a --format=&quot;JobId,Pids,AveCPU,AveRSS,MaxRSS&quot;  1755818<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/slurm001/image-20220520175001331.png" alt="image-20220520175001331"></p><h4 id="2-sacct-查看FINISHED作业"><a href="#2-sacct-查看FINISHED作业" class="headerlink" title="2.sacct 查看FINISHED作业"></a>2.sacct 查看FINISHED作业</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sacct -e<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/slurm001/image-20220520174622868.png" alt="image-20220520174622868"></p><p><strong>使用举例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sacct --format=&quot;JobId,Elapsed,CPUTime,CPUTimeRAW,AveCPU,TotalCPU,UserCPU,SystemCPU,AveRSS,MaxRSS&quot; -j 1754217<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/slurm001/image-20220520174807162.png" alt="image-20220520174807162"></p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://blog.csdn.net/kongxx/article/details/52556943">(28条消息) Slurm查看作业CPU和MEM_kongxx的博客-CSDN博客_slurm 查看节点</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Slurm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numactl</title>
    <link href="/2022/05/20/numactl001/"/>
    <url>/2022/05/20/numactl001/</url>
    
    <content type="html"><![CDATA[<ol><li></li></ol><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">numactl --hardware<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/numactl001/image-20220520173911653.png" alt="image-20220520173911653"></p><ol start="2"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shelll">numastat<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/numactl001/image-20220520174030171.png" alt="image-20220520174030171"></p><ol start="3"><li></li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">numactl --show<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/numactl001/image-20220520174148487.png" alt="image-20220520174148487"></p><h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p><a href="https://blog.csdn.net/qccz123456/article/details/81979819">(28条消息) Linux工具之numactl_qccz123456的博客-CSDN博客_numactl</a></p><p><a href="https://baijiahao.baidu.com/s?id=1699088343604813491&wfr=spider&for=pc&searchword=numactl">宋宝华：为什么numactl内存绑定对代码段不起作用 (baidu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Numactl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux的jobs,fg,bg命令</title>
    <link href="/2022/05/20/Linux002/"/>
    <url>/2022/05/20/Linux002/</url>
    
    <content type="html"><![CDATA[<h3 id="linux让前台程序脱离终端运行"><a href="#linux让前台程序脱离终端运行" class="headerlink" title="linux让前台程序脱离终端运行"></a>linux让前台程序脱离终端运行</h3><p>1.首先运行你的程序</p><p><img src="/2022/05/20/Linux002/image-20220520171436032.png" alt="image-20220520171436032"></p><p>2.随后使用Ctrl + z，挂起你的进程</p><p><img src="/2022/05/20/Linux002/image-20220520171510946.png" alt="image-20220520171510946"></p><p>3.然后使用jobs查看所有的进程</p><p><img src="/2022/05/20/Linux002/image-20220520171913979.png" alt="image-20220520171913979"></p><p>4.随后使用bg+id，表示该任务为后台1号任务</p><p>bg命令用于将作业放到后台运行，使前台可以执行其他任务</p><p><img src="/2022/05/20/Linux002/image-20220520172110992.png" alt="image-20220520172110992"></p><h3 id="linux让后台程序移动到前台终端"><a href="#linux让后台程序移动到前台终端" class="headerlink" title="linux让后台程序移动到前台终端"></a>linux让后台程序移动到前台终端</h3><p>Linux常用命令fg主要用于将后台作业移动到前台终端运行</p><p><img src="/2022/05/20/Linux002/image-20220520172358345.png" alt="image-20220520172358345"></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用指令</title>
    <link href="/2022/05/20/Linux001/"/>
    <url>/2022/05/20/Linux001/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h2><h4 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">kill <span class="hljs-number">-9</span> id<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/20/Linux001/image-20220520171246860.png" alt="image-20220520171246860"></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcov代码覆盖率测试-完整样例-SLIC</title>
    <link href="/2022/05/08/tool004/"/>
    <url>/2022/05/08/tool004/</url>
    
    <content type="html"><![CDATA[<h2 id="gcov代码覆盖率测试-完整样例-SLIC"><a href="#gcov代码覆盖率测试-完整样例-SLIC" class="headerlink" title="gcov代码覆盖率测试-完整样例-SLIC"></a>gcov代码覆盖率测试-完整样例-SLIC</h2><h3 id="gcov代码覆盖率测试介绍："><a href="#gcov代码覆盖率测试介绍：" class="headerlink" title="gcov代码覆盖率测试介绍："></a>gcov代码覆盖率测试介绍：</h3><p><a href="https://xingyuanjie.top/2022/01/18/tool002/">gcov代码覆盖率测试 - 计算机奇妙之旅 (xingyuanjie.top)</a></p><h3 id="完整样例-SLIC："><a href="#完整样例-SLIC：" class="headerlink" title="完整样例-SLIC："></a>完整样例-SLIC：</h3><p><a href="https://xingyuanjie.top/2022/05/08/tool004/result.zip">https://xingyuanjie.top/2022/05/08/tool004/result.zip</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
      <tag>gcov</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-036 网红点打卡攻略 (25 分)</title>
    <link href="/2022/04/23/Algorithm032/"/>
    <url>/2022/04/23/Algorithm032/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-036-网红点打卡攻略-25-分"><a href="#L2-036-网红点打卡攻略-25-分" class="headerlink" title="L2-036 网红点打卡攻略 (25 分)"></a>L2-036 网红点打卡攻略 (25 分)</h2><p>一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个正整数：网红点的个数 <em>N</em>（1&lt;<em>N</em>≤200）和网红点之间通路的条数 <em>M</em>。随后 <em>M</em> 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 <em>N</em> 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 <code>0</code>。</p><p>再下一行给出一个正整数 <em>K</em>，是待检验的攻略的数量。随后 <em>K</em> 行，每行给出一条待检攻略，格式为：</p><p><em>n</em> <em>V</em>1 <em>V</em>2 ⋯ Vn</p><p>其中 <em>n</em>(≤200) 是攻略中的网红点数，<em>Vi</em> 是路径上的网红点编号。这里假设你从家里出发，从 <em>V</em>1 开始打卡，最后从 <em>Vn</em> 回家。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在第一行输出满足要求的攻略的个数。</p><p>在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。</p><p>题目保证至少存在一个有效攻略，并且总路费不超过 109。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">6 13<br>0 5 2<br>6 2 2<br>6 0 1<br>3 4 2<br>1 5 2<br>2 5 1<br>3 1 1<br>4 1 2<br>1 6 1<br>6 3 2<br>1 2 1<br>4 5 3<br>2 0 2<br>7<br>6 5 1 4 3 6 2<br>6 5 2 1 6 3 4<br>8 6 2 1 6 3 4 5 2<br>3 2 1 5<br>6 6 1 3 4 5 2<br>7 6 2 1 3 4 5 2<br>6 5 2 1 4 3 6<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">3<br>5 11<br></code></pre></div></td></tr></table></figure><h3 id="样例说明："><a href="#样例说明：" class="headerlink" title="样例说明："></a>样例说明：</h3><p>第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。</p><p>第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 &#x3D; 14；</p><p>第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &#x3D; 11，是一条更省钱的攻略；</p><p>第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<br><span class="hljs-keyword">int</span> minsize=INT_MAX;<span class="hljs-comment">//初始化为INT_MAX</span><br><span class="hljs-keyword">int</span> minid=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b]=c;<br>        g[b][a]=c;<br>    &#125;<br>    <span class="hljs-keyword">int</span> time;<br>    cin&gt;&gt;time;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-keyword">int</span> roll[k+<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">int</span> has[k+<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">memset</span>(has,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(has));<br>        roll[<span class="hljs-number">0</span>]=roll[k+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//起点和终点必定是家</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=k ; ++i) &#123;<br>            cin&gt;&gt;roll[i];<br>            <span class="hljs-keyword">if</span>(has[roll[i]]) has[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//每个打卡点仅能打卡一次</span><br>            <span class="hljs-keyword">else</span> has[roll[i]]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> tmpsize=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(k!=n||has[<span class="hljs-number">0</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=k+<span class="hljs-number">1</span> ; ++l) &#123;<br>            <span class="hljs-keyword">if</span>(g[roll[l<span class="hljs-number">-1</span>]][roll[l]]==<span class="hljs-number">0</span>)<br>            &#123;<br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tmpsize+=g[roll[l<span class="hljs-number">-1</span>]][roll[l]];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmpsize&lt;minsize)&#123;<br>                minsize=tmpsize;<br>                minid=j+<span class="hljs-number">1</span>;<br><br>            &#125;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    cout&lt;&lt;minid&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;minsize&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059">题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-039 清点代码库 (25 分)</title>
    <link href="/2022/04/23/Algorithm031/"/>
    <url>/2022/04/23/Algorithm031/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-039-清点代码库-25-分"><a href="#L2-039-清点代码库-25-分" class="headerlink" title="L2-039 清点代码库 (25 分)"></a>L2-039 清点代码库 (25 分)</h2><p><img src="/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg" alt="code.jpg"></p><p>上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”</p><p>这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 <strong>int</strong> 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出 2 个正整数，依次为 <em>N</em>（≤104）和 <em>M</em>（≤102），对应功能模块的个数和系列测试输入的个数。</p><p>随后 <em>N</em> 行，每行给出一个功能模块的 <em>M</em> 个对应输出，数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第一行输出不同功能的个数 <em>K</em>。随后 <em>K</em> 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。</p><p>注：所谓数列 { <em>A</em>1, …, <em>A</em>M } 比 { <em>B</em>1, …, <em>B</em>M } 大，是指存在 1≤i&lt;*M*，使得 *A*1&#x3D;*B*1，…，*Ai*&#x3D;*Bi* 成立，且 *Ai*+1&gt;<em>B</em>+1。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">7 3<br>35 28 74<br>-1 -1 22<br>28 74 35<br>-1 -1 22<br>11 66 0<br>35 28 74<br>35 28 74<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">4<br>3 35 28 74<br>2 -1 -1 22<br>1 11 66 0<br>1 28 74 35<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>利用map的映射关系</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; mp;   <span class="hljs-comment">//key，value</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; a,pair&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.second==b.second)<br>    &#123;<br>        <span class="hljs-keyword">return</span> a.first&lt;b.first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.second&gt;b.second;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            tmp.<span class="hljs-built_in">push_back</span>(num);<br>        &#125;<br>        mp[tmp]++;<br>        tmp.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    vector&lt;pair&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">v</span>(mp.<span class="hljs-built_in">begin</span>(),mp.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//把map类型转化成vector</span><br>    cout&lt;&lt;v.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmp);<span class="hljs-comment">//sort排序，注意终点和起点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;v.<span class="hljs-built_in">size</span>() ; ++k) &#123;<br>        cout&lt;&lt;v[k].second&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(i!=m<span class="hljs-number">-1</span>)&#123;<br>                cout&lt;&lt;v[k].first[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;v[k].first[i]&lt;&lt;endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362">题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>Vector</tag>
      
      <tag>Map</tag>
      
      <tag>Pair</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-005 集合相似度 (25 分)</title>
    <link href="/2022/04/23/Algorithm030/"/>
    <url>/2022/04/23/Algorithm030/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-005-集合相似度-25-分"><a href="#L2-005-集合相似度-25-分" class="headerlink" title="L2-005 集合相似度 (25 分)"></a>L2-005 集合相似度 (25 分)</h2><p>给定两个整数集合，它们的相似度定义为：Nc&#x2F;Nt×100%。其中Nc是两个集合都有的不相等整数的个数，Nt是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤50），是集合的个数。随后<em>N</em>行，每行对应一个集合。每个集合首先给出一个正整数<em>M</em>（≤104），是集合中元素的个数；然后跟<em>M</em>个[0,109]区间内的整数。</p><p>之后一行给出一个正整数<em>K</em>（≤2000），随后<em>K</em>行，每行对应一对需要计算相似度的集合的编号（集合从1到<em>N</em>编号）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">3<br>3 99 87 101<br>4 87 101 5 87<br>7 99 101 18 5 135 18 99<br>2<br>1 2<br>1 3<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">50.00%<br>33.33%<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>双set模拟</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    set&lt;<span class="hljs-keyword">int</span>&gt; s[<span class="hljs-number">55</span>];<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            s[i].<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> find;<br>    cin&gt;&gt;find;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;find ; ++l) &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>        set&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br>        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (it=s[a<span class="hljs-number">-1</span>].<span class="hljs-built_in">begin</span>(); it!=s[a<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>() ; it++) &#123;<br>            <span class="hljs-keyword">if</span>(s[b<span class="hljs-number">-1</span>].<span class="hljs-built_in">find</span>(*it)!=s[b<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//找到了</span><br>                cnt++;<span class="hljs-comment">//Nc</span><br>            &#125;<br>        &#125;<br>        sum=s[a<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>()+s[b<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>()-cnt;<span class="hljs-comment">//Nt=两个集合的总个数-相同个数</span><br>        <span class="hljs-keyword">double</span> ans=<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(cnt)/<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(sum))*<span class="hljs-number">100.0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf%\n&quot;</span>,ans);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805070149828608">题目详情 - L2-005 集合相似度 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL中map的使用</title>
    <link href="/2022/04/16/Algorithm029/"/>
    <url>/2022/04/16/Algorithm029/</url>
    
    <content type="html"><![CDATA[<h2 id="STL中map的使用"><a href="#STL中map的使用" class="headerlink" title="STL中map的使用"></a>STL中map的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>map 是 STL 的一个关联容器，它提供一对一的数据处理能力。</p><p>map 对象是<strong>模板类</strong>，需要<strong>关键字</strong>和<strong>存储对象</strong>两个模板参数：其中第一个参数称为关键字，每个关键字只能在 map 中出现一次；第二个参数称为该关键字的值。可以将关键字和存储对象理解为“{键，值}对”。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt; mp;<br></code></pre></div></td></tr></table></figure><h3 id="map的数据插入操作"><a href="#map的数据插入操作" class="headerlink" title="map的数据插入操作"></a>map的数据插入操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//使用insert函数插入pair数据</span><br>mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;xingyuanjie&quot;</span>));<br><span class="hljs-comment">//使用数组方式插入数据</span><br>mp[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;wangzhouyang&quot;</span>;<br></code></pre></div></td></tr></table></figure><p><strong>说明：上面的两种方法是有区别的，用 insert 函数插入数据，涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能实现数据插入的；但是数组方式能够插入数据，插入的数据会覆盖该关键字之前对应的值。</strong></p><h3 id="map中数据的遍历"><a href="#map中数据的遍历" class="headerlink" title="map中数据的遍历"></a>map中数据的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br><span class="hljs-keyword">for</span> (it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++) &#123;<br>    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="map中数据的查找"><a href="#map中数据的查找" class="headerlink" title="map中数据的查找"></a>map中数据的查找</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br>it=mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(it!=mp.<span class="hljs-built_in">end</span>())&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Find it, the relative value is: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;Can not find the relative value.&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="map中数据的删除"><a href="#map中数据的删除" class="headerlink" title="map中数据的删除"></a>map中数据的删除</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<span class="hljs-comment">//迭代器</span><br>it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br>mp.<span class="hljs-built_in">erase</span>(it);<br></code></pre></div></td></tr></table></figure><h3 id="map中数据的排序"><a href="#map中数据的排序" class="headerlink" title="map中数据的排序"></a>map中数据的排序</h3><p><strong>map 中的所有元素都会根据元素的键值，自动进行升序排序。</strong></p><h3 id="完整操作"><a href="#完整操作" class="headerlink" title="完整操作"></a>完整操作</h3><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;<span class="hljs-keyword">int</span>,string&gt; mp;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//使用insert函数插入pair数据</span><br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;xingyuanjie&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;shicheng&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;tanghaipeng&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;zhouyuhao&quot;</span>));<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;heqichuan&quot;</span>));<br>    <span class="hljs-comment">//使用数组方式插入数据</span><br>    mp[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;wangzhouyang&quot;</span>;<br>    <span class="hljs-comment">//map的遍历</span><br>    map&lt;<span class="hljs-keyword">int</span>,string&gt;::iterator it;<br>    <span class="hljs-keyword">for</span> (it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++) &#123;<br>        cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//查找操作</span><br>    it=mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(it!=mp.<span class="hljs-built_in">end</span>())&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Find it, the relative value is: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Can not find the relative value.&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//删除操作</span><br>    it = mp.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br>    mp.<span class="hljs-built_in">erase</span>(it);<br>    <span class="hljs-keyword">for</span> (it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++) &#123;<br>        cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span> shicheng<br><span class="hljs-number">2</span> wangzhouyang<br><span class="hljs-number">3</span> xingyuanjie<br><span class="hljs-number">4</span> tanghaipeng<br><span class="hljs-number">5</span> heqichuan<br><span class="hljs-number">6</span> zhouyuhao<br>Find it, the relative value is: shicheng<br><span class="hljs-number">1</span> shicheng<br><span class="hljs-number">3</span> xingyuanjie<br><span class="hljs-number">4</span> tanghaipeng<br><span class="hljs-number">5</span> heqichuan<br><span class="hljs-number">6</span> zhouyuhao<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/liitdar/article/details/80009712">(20条消息) STL中map介绍_liitdar的博客-CSDN博客_stlmap</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-010 排座位 (25 分)</title>
    <link href="/2022/04/16/Algorithm028/"/>
    <url>/2022/04/16/Algorithm028/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-010-排座位-25-分"><a href="#L2-010-排座位-25-分" class="headerlink" title="L2-010 排座位 (25 分)"></a><strong>L2-010 排座位 (25 分)</strong></h2><p>布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出3个正整数：<code>N</code>（≤100），即前来参宴的宾客总人数，则这些人从1到<code>N</code>编号；<code>M</code>为已知两两宾客之间的关系数；<code>K</code>为查询的条数。随后<code>M</code>行，每行给出一对宾客之间的关系，格式为：<code>宾客1 宾客2 关系</code>，其中<code>关系</code>为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后<code>K</code>行，每行给出一对需要查询的宾客编号。</p><p>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出<code>No problem</code>；如果他们之间并不是朋友，但也不敌对，则输出<code>OK</code>；如果他们之间有敌对，然而也有共同的朋友，则输出<code>OK but...</code>；如果他们之间只有敌对关系，则输出<code>No way</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">7 8 4<br>5 6 1<br>2 7 -1<br>1 3 1<br>3 4 1<br>6 7 -1<br>1 2 1<br>1 4 1<br>2 3 -1<br>3 4<br>5 7<br>2 3<br>7 2<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">No problem<br>OK<br>OK but...<br>No way<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接矩阵 + 并查集</strong></p><p><strong>并查集具体链接：</strong></p><p><a href="https://xingyuanjie.top/2022/01/04/Algorithm004/">并查集 - 计算机奇妙之旅 (xingyuanjie.top)</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> pre[<span class="hljs-number">100</span>];<span class="hljs-comment">//父节点</span><br><span class="hljs-keyword">int</span> deep[<span class="hljs-number">100</span>];<span class="hljs-comment">//深度</span><br><span class="hljs-keyword">int</span> g[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<span class="hljs-comment">//邻接矩阵建图</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        pre[i]=i;<br>        deep[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(pre[x]==x)&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> pre[x]=<span class="hljs-built_in">find</span>(pre[x]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    x=<span class="hljs-built_in">find</span>(x);<br>    y=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(deep[x]&lt;deep[y])&#123;<br>        pre[x]=y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        pre[y]=x;<br>        <span class="hljs-keyword">if</span>(deep[x]==deep[y])&#123;<br>            deep[x]++;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m,k;<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">105</span>);<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b]=g[b][a]=c;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-number">1</span>) <span class="hljs-built_in">unit</span>(a,b);<span class="hljs-comment">//如果是朋友则合并</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;k ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">1</span>&amp;&amp;g[b][a]==<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;No problem&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">0</span>&amp;&amp;g[b][a]==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;OK&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//两人毫无关系</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">-1</span>&amp;&amp;g[b][a]==<span class="hljs-number">-1</span>&amp;&amp;<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b)) cout&lt;&lt;<span class="hljs-string">&quot;OK but...&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//敌对且有共同朋友</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-number">-1</span>&amp;&amp;g[b][a]==<span class="hljs-number">-1</span>) cout&lt;&lt;<span class="hljs-string">&quot;No way&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//仅敌对</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/weixin_45260385/article/details/109752008">(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680">题目详情 - L2-010 排座位 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-009 抢红包 (25 分)</title>
    <link href="/2022/04/16/Algorithm027/"/>
    <url>/2022/04/16/Algorithm027/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-009-抢红包-25-分"><a href="#L2-009-抢红包-25-分" class="headerlink" title="L2-009 抢红包 (25 分)"></a><strong>L2-009 抢红包 (25 分)</strong></h2><p>没有人没抢过红包吧…… 这里给出<em>N</em>个人之间互相发红包、抢红包的记录，请你统计一下他们抢红包的收获。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤104），即参与发红包和抢红包的总人数，则这些人从1到<em>N</em>编号。随后<em>N</em>行，第<em>i</em>行给出编号为<em>i</em>的人发红包的记录，格式如下：</p><p><em>K     N</em>1 <em>P</em>1⋯ NK PK</p><p>其中<em>K</em>（0≤<em>K</em>≤20）是发出去的红包个数，<em>N</em>i<em>是抢到红包的人的编号，</em>Pi（&gt;0）是其抢到的红包金额（以分为单位）。注意：对于同一个人发出的红包，每人最多只能抢1次，不能重复抢。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照收入金额从高到低的递减顺序输出每个人的编号和收入金额（以元为单位，输出小数点后2位）。每个人的信息占一行，两数字间有1个空格。如果收入金额有并列，则按抢到红包的个数递减输出；如果还有并列，则按个人编号递增输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">10<br>3 2 22 10 58 8 125<br>5 1 345 3 211 5 233 7 13 8 101<br>1 7 8800<br>2 1 1000 2 1000<br>2 4 250 10 320<br>6 5 11 9 22 8 33 7 44 10 55 4 2<br>1 3 8800<br>2 1 23 2 123<br>1 8 250<br>4 2 121 4 516 7 112 9 10<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">1 11.63<br>2 3.63<br>8 3.63<br>3 2.11<br>7 1.69<br>6 -1.67<br>9 -2.18<br>10 -3.26<br>5 -3.26<br>4 -12.32<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>结构体 + Sort</strong></p><p><strong>需要注意的就是double类型相等的比较</strong></p><p><strong>首先，浮点数在计算机中并不能精确的表示，所以在判断两个double类型的数时需要其他的手段，而不是直接 a&#x3D;&#x3D; b</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-keyword">int</span> id=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> money=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">double</span> dis=<span class="hljs-number">1e-6</span>;<span class="hljs-comment">//定义一个误差</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(student a,student b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a.money-b.money)&lt;dis)&#123;<span class="hljs-comment">//如果两个double型相减在误差的范围内，我们认定这两个double类型相等</span><br>        <span class="hljs-keyword">if</span>(a.cnt==b.cnt)&#123;<br>            <span class="hljs-keyword">return</span> a.id&lt;b.id;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> a.cnt&gt;b.cnt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.money&gt;b.money;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    student st[n+<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        st[i].id=i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> p;<br>            <span class="hljs-keyword">double</span> x;<br>            cin&gt;&gt;p&gt;&gt;x;<br>            st[p<span class="hljs-number">-1</span>].money+=x/<span class="hljs-number">100</span>;<br>            st[i].money-=x/<span class="hljs-number">100</span>;<br>            st[p<span class="hljs-number">-1</span>].cnt++;<span class="hljs-comment">//记录抢到的红包数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(st,st+n,cmp);<span class="hljs-comment">//sort从数组下标0开始排序，左闭右开</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;n ; ++k) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf\n&quot;</span>,st[k].id,st[k].money);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/dingpiao190/article/details/73512811?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">(20条消息) double类型是否相等的判断方法_dingpiao190的博客-CSDN博客_double判断相等</a></p><p><a href="https://blog.csdn.net/patrick_star_cowboy/article/details/82083392">(20条消息) 如何判断两个double类型的数是否相等？_Patrick-Star的博客-CSDN博客_两个double怎么判断相等</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805066890854400">题目详情 - L2-009 抢红包 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>结构体</tag>
      
      <tag>Double类型相等比较</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-003 月饼 (25 分)</title>
    <link href="/2022/04/15/Algorithm026/"/>
    <url>/2022/04/15/Algorithm026/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-003-月饼-25-分"><a href="#L2-003-月饼-25-分" class="headerlink" title="L2-003 月饼 (25 分)"></a>L2-003 月饼 (25 分)</h2><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45&#x2F;2 &#x3D; 94.5（亿元）。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 <em>N</em> 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 <em>D</em> 表示市场最大需求量。随后一行给出 <em>N</em> 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 <em>N</em> 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">3 20<br>18 15 10<br>75 72 45<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">94.50<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>贪心 + Sort</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mooncake</span>&#123;</span><br>    <span class="hljs-keyword">double</span> pow;<br>    <span class="hljs-keyword">double</span> price;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(mooncake a,mooncake b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.price*<span class="hljs-number">1.0</span>/a.pow&gt;b.price*<span class="hljs-number">1.0</span>/b.pow;<span class="hljs-comment">//返回单价高的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">double</span> d;<br>    cin&gt;&gt;n&gt;&gt;d;<br>    mooncake m[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin&gt;&gt;m[i].pow;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n ; ++j) &#123;<br>        cin&gt;&gt;m[j].price;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(m,m+n,cmp);<br>    <span class="hljs-keyword">double</span> price=<span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">double</span> tmpd=d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;n ; ++k) &#123;<span class="hljs-comment">//模拟求解</span><br>        <span class="hljs-keyword">if</span>(m[k].pow&lt;=tmpd)&#123;<br>            tmpd-=m[k].pow;<br>            price+=m[k].price;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m[k].pow&gt;tmpd)&#123;<br>            price+=tmpd*(m[k].price/m[k].pow);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f\n&quot;</span>,price);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805071789801472">题目详情 - L2-003 月饼 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>结构体</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-013 红色警报 (25 分)</title>
    <link href="/2022/04/15/Algorithm025/"/>
    <url>/2022/04/15/Algorithm025/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-013-红色警报-25-分"><a href="#L2-013-红色警报-25-分" class="headerlink" title="L2-013 红色警报 (25 分)"></a>L2-013 红色警报 (25 分)</h2><p>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个整数<code>N</code>（0 &lt; <code>N</code> ≤ 500）和<code>M</code>（≤ 5000），分别为城市个数（于是默认城市从0到<code>N</code>-1编号）和连接两城市的通路条数。随后<code>M</code>行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数<code>K</code>和随后的<code>K</code>个被攻占的城市的编号。</p><p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出<code>Red Alert: City k is lost!</code>，其中<code>k</code>是该城市的编号；否则只输出<code>City k is lost.</code>即可。如果该国失去了最后一个城市，则增加一行输出<code>Game Over.</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">5 4<br>0 1<br>1 3<br>3 0<br>0 4<br>5<br>1 2 0 4 3<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">City 1 is lost.<br>City 2 is lost.<br>Red Alert: City 0 is lost!<br>City 4 is lost.<br>City 3 is lost.<br>Game Over.<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接矩阵建图 + DFS统计连通分量数</strong></p><p><strong>对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数</strong></p><p><strong>无向图中的极大连通子图称为连通分量</strong></p><p><strong>极大连通子图必须连通，且包含尽可能多的顶点和边</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<span class="hljs-comment">//邻接矩阵存图</span><br><span class="hljs-keyword">int</span> visit[<span class="hljs-number">505</span>];<span class="hljs-comment">//标记访问数组</span><br><span class="hljs-keyword">int</span> lost[<span class="hljs-number">505</span>];<span class="hljs-comment">//记录被攻占的城市</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span></span>&#123;<span class="hljs-comment">//正常的DFS</span><br>    visit[node]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(visit[i]==<span class="hljs-number">0</span>&amp;&amp;g[node][i]==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfstrave</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(visit,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(visit));<span class="hljs-comment">//初始化访问数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(lost[i]==<span class="hljs-number">1</span>) visit[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//如果该城市被攻占，则标记他为以访问</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(visit[i]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(i);<br>            cnt++;      <span class="hljs-comment">//统计连通分量数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(lost,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(lost));<span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        g[a][b]=g[b][a]=<span class="hljs-number">1</span>;<span class="hljs-comment">//存储无向图</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-built_in">dfstrave</span>();<span class="hljs-comment">//获得初始的连通分量数</span><br>    <span class="hljs-keyword">int</span> k;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w=<span class="hljs-number">0</span>;w&lt;k;w++)&#123;<br>        <span class="hljs-keyword">int</span> city;<br>        cin&gt;&gt;city;<br>        lost[city]=<span class="hljs-number">1</span>;<span class="hljs-comment">//记录该城市被攻占</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(g[city][i]==<span class="hljs-number">1</span>)&#123;<br>                g[city][i]=g[i][city]=<span class="hljs-number">0</span>;<span class="hljs-comment">//标记和他相连的城市不再相连</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> tempcnt=<span class="hljs-built_in">dfstrave</span>();<span class="hljs-comment">//当前的连通分量</span><br>        <span class="hljs-keyword">if</span>(tempcnt&lt;=cnt)&#123;<span class="hljs-comment">//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;City %d is lost.\n&quot;</span>, city);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则，连通性被改变了</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Red Alert: City %d is lost!\n&quot;</span>, city);<br>        &#125;<br>        cnt=tempcnt;<span class="hljs-comment">//更新连通分量</span><br>        <span class="hljs-keyword">if</span>(w==n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//城市已经被攻占完毕</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over.\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208">题目详情 - L2-013 红色警报 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-011 玩转二叉树 (25 分)</title>
    <link href="/2022/04/14/Algorithm024/"/>
    <url>/2022/04/14/Algorithm024/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-011-玩转二叉树-25-分"><a href="#L2-011-玩转二叉树-25-分" class="headerlink" title="L2-011 玩转二叉树 (25 分)"></a><strong>L2-011 玩转二叉树 (25 分)</strong></h2><p>给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">7<br>1 2 3 4 5 6 7<br>4 1 3 2 6 5 7<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">4 6 1 7 5 3 2<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>镜面反转即为在层序遍历时交换左右子树的遍历顺序，左-&gt;右变成右-&gt;左</strong></p><p><strong>前序 + 中序 建树 + BFS</strong></p><p><strong>建树详细过程：</strong></p><p><a href="https://xingyuanjie.top/2022/04/07/Algorithm014/">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;BiTNode,*BiTree;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> in[<span class="hljs-number">35</span>];<br><span class="hljs-keyword">int</span> pre[<span class="hljs-number">35</span>];<br><span class="hljs-function">BiTree <span class="hljs-title">PostCreate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prel,<span class="hljs-keyword">int</span> prer,<span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<span class="hljs-comment">//前序加中序建树</span><br>    <span class="hljs-keyword">if</span>(prel&gt;prer)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>    root-&gt;data=pre[prel];<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inl; i &lt;=inr; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(pre[prel]==in[i])&#123;<br>            index=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> numleft=index-inl;<br>    root-&gt;lchild=<span class="hljs-built_in">PostCreate</span>(prel+<span class="hljs-number">1</span>,prel+numleft,inl,index<span class="hljs-number">-1</span>);<br>    root-&gt;rchild=<span class="hljs-built_in">PostCreate</span>(prel+numleft+<span class="hljs-number">1</span>,prer,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;BiTree&gt; q;<br>    q.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        BiTNode *tmp =q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(i!=n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//输出格式控制</span><br>            cout&lt;&lt;tmp-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;tmp-&gt;data;<br>        &#125;<br>        i++;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//镜面反转，左-&gt;右变成右-&gt;左</span><br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;rchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;lchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree tree;<br>    tree=<span class="hljs-literal">NULL</span>;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        cin&gt;&gt;in[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n ; ++j) &#123;<br>        cin&gt;&gt;pre[j];<br>    &#125;<br>    tree=<span class="hljs-built_in">PostCreate</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">LevelOrder</span>(tree);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784">题目详情 - L2-011 玩转二叉树 (25 分) (pintia.cn)</a></p><p><a href="https://xingyuanjie.top/2022/04/07/Algorithm014/">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-035 完全二叉树的层序遍历 (25 分)</title>
    <link href="/2022/04/14/Algorithm023/"/>
    <url>/2022/04/14/Algorithm023/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-035-完全二叉树的层序遍历-25-分"><a href="#L2-035-完全二叉树的层序遍历-25-分" class="headerlink" title="L2-035 完全二叉树的层序遍历 (25 分)"></a>L2-035 完全二叉树的层序遍历 (25 分)</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是<strong>完美二叉树</strong>。对于深度为 <em>D</em> 的，有 <em>N</em> 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 <em>N</em> 个结点，这样的树就是<strong>完全二叉树</strong>。</p><p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>N</em>（≤30），即树中结点个数。第二行给出后序遍历序列，为 <em>N</em> 个不超过 100 的正整数。同一行中所有数字都以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">8<br>91 71 2 34 10 15 55 18<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">18 34 55 71 2 10 15 91<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>后序遍历建树 + 完全二叉树性质</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> tree[<span class="hljs-number">10001</span>];<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//根据后序遍历建树</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i&lt;=n)&#123;<span class="hljs-comment">//当2*i&lt;=n时，结点i的左孩子编号为2*i，否则无左孩子</span><br>        <span class="hljs-built_in">post</span>(<span class="hljs-number">2</span>*i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>&lt;=n)&#123;<span class="hljs-comment">//当2*i+1&lt;=n时，结点i的右孩子编号为2*i+1，否则无右孩子</span><br>        <span class="hljs-built_in">post</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>);<br>    &#125;<br>    cin&gt;&gt;tree[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">post</span>(<span class="hljs-number">1</span>);           <span class="hljs-comment">//后序遍历建树</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<span class="hljs-comment">//顺序输出即为层序遍历</span><br>        <span class="hljs-keyword">if</span>(i!=n)&#123;<br>            cout&lt;&lt;tree[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;tree[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Binary tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-031 深入虎穴 (25 分)</title>
    <link href="/2022/04/13/Algorithm022/"/>
    <url>/2022/04/13/Algorithm022/</url>
    
    <content type="html"><![CDATA[<p>著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。</p><p>内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在一行中给出正整数 <em>N</em>（&lt;105），是门的数量。最后 <em>N</em> 行，第 <em>i</em> 行（1≤<em>i</em>≤<em>N</em>）按以下格式描述编号为 <em>i</em> 的那扇门背后能通向的门：</p><figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-built_in">K</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">[</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">...</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">]</span><br></code></pre></div></td></tr></table></figure><p>其中 <code>K</code> 是通道的数量，其后是每扇门的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">13<br>3 2 3 4<br>2 5 6<br>1 7<br>1 8<br>1 9<br>0<br>2 11 10<br>1 13<br>0<br>0<br>1 12<br>0<br>0<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">12<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表 + BFS</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v[<span class="hljs-number">100005</span>];<br><span class="hljs-keyword">int</span> book[<span class="hljs-number">100005</span>];<br><span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//BFS</span><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<span class="hljs-comment">//根节点入队</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        x=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;v[x].<span class="hljs-built_in">size</span>() ; ++i) &#123;<br>            q.<span class="hljs-built_in">push</span>(v[x][i]);<br>        &#125;<br>    &#125;<span class="hljs-comment">//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</span><br>    <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=time ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            book[num]=<span class="hljs-number">1</span>;<br>            v[i].<span class="hljs-built_in">push_back</span>(num);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;=n ; ++k) &#123;<span class="hljs-comment">//找入口</span><br>        <span class="hljs-keyword">if</span>(book[k]==<span class="hljs-number">0</span>) start=k;<span class="hljs-comment">//没有门通向的门，即为入口</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">bfs</span>();<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888">题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-040 哲哲打游戏 (25 分)</title>
    <link href="/2022/04/13/Algorithm021/"/>
    <url>/2022/04/13/Algorithm021/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-040-哲哲打游戏-25-分"><a href="#L2-040-哲哲打游戏-25-分" class="headerlink" title="L2-040 哲哲打游戏 (25 分)"></a><strong>L2-040 哲哲打游戏 (25 分)</strong></h2><p>哲哲是一位硬核游戏玩家。最近一款名叫《达诺达诺》的新游戏刚刚上市，哲哲自然要快速攻略游戏，守护硬核游戏玩家的一切！</p><p>为简化模型，我们不妨假设游戏有 <em>N</em> 个剧情点，通过游戏里不同的操作或选择可以从某个剧情点去往另外一个剧情点。此外，游戏还设置了一些<strong>存档</strong>，在某个剧情点可以将玩家的游戏进度保存在一个档位上，读取存档后可以回到剧情点，重新进行操作或者选择，到达不同的剧情点。</p><p>为了追踪硬核游戏玩家哲哲的攻略进度，你打算写一个程序来完成这个工作。假设你已经知道了游戏的全部剧情点和流程，以及哲哲的游戏操作，请你输出哲哲的游戏进度。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行是两个正整数 <em>N</em> 和 <em>M</em> (1≤<em>N</em>,<em>M</em>≤105)，表示总共有 <em>N</em> 个剧情点，哲哲有 <em>M</em> 个游戏操作。</p><p>接下来的 <em>N</em> 行，每行对应一个剧情点的发展设定。第 <em>i</em> 行的第一个数字是 <em>K**i</em>，表示剧情点 <em>i</em> 通过一些操作或选择能去往下面 <em>K**i</em> 个剧情点；接下来有 <em>K**i</em> 个数字，第 <em>k</em> 个数字表示做第 <em>k</em> 个操作或选择可以去往的剧情点编号。</p><p>最后有 <em>M</em> 行，每行第一个数字是 0、1 或 2，分别表示：</p><ul><li>0 表示哲哲做出了某个操作或选择，后面紧接着一个数字 <em>j</em>，表示哲哲在当前剧情点做出了第 <em>j</em> 个选择。我们保证哲哲的选择永远是合法的。</li><li>1 表示哲哲进行了一次存档，后面紧接着是一个数字 <em>j</em>，表示存档放在了第 <em>j</em> 个档位上。</li><li>2 表示哲哲进行了一次读取存档的操作，后面紧接着是一个数字 <em>j</em>，表示读取了放在第 <em>j</em> 个位置的存档。</li></ul><p>约定：所有操作或选择以及剧情点编号都从 1 号开始。存档的档位不超过 100 个，编号也从 1 开始。游戏默认从 1 号剧情点开始。总的选项数（即 ∑<em>K**i</em>）不超过 106。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对于每个 1（即存档）操作，在一行中输出存档的剧情点编号。</p><p>最后一行输出哲哲最后到达的剧情点编号。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">10 11<br>3 2 3 4<br>1 6<br>3 4 7 5<br>1 3<br>1 9<br>2 3 5<br>3 1 8 5<br>1 9<br>2 8 10<br>0<br>1 1<br>0 3<br>0 1<br>1 2<br>0 2<br>0 2<br>2 2<br>0 3<br>0 1<br>1 1<br>0 2<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">1<br>3<br>9<br>10<br></code></pre></div></td></tr></table></figure><h3 id="样例解释："><a href="#样例解释：" class="headerlink" title="样例解释："></a>样例解释：</h3><p>简单给出样例中经过的剧情点顺序：</p><p>1 -&gt; 4 -&gt; 3 -&gt; 7 -&gt; 8 -&gt; 3 -&gt; 5 -&gt; 9 -&gt; 10。</p><p>档位 1 开始存的是 1 号剧情点；档位 2 存的是 3 号剧情点；档位 1 后来又存了 9 号剧情点。</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表 + 模拟，主要是理解题意</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> save[<span class="hljs-number">105</span>];<span class="hljs-comment">//存档点</span><br>    <span class="hljs-keyword">int</span> now=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前剧情点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> num;<br>        cin&gt;&gt;num;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;num ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> x;<br>            cin&gt;&gt;x;<br>            v[i].<span class="hljs-built_in">push_back</span>(x);<span class="hljs-comment">//邻接表存操作数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt;k ; ++l) &#123;<span class="hljs-comment">//模拟过程</span><br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>)&#123;<br>            save[b]=now;<br>            cout&lt;&lt;now&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>)&#123;<br>            now=v[now][b<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">2</span>)&#123;<br>            now=save[b];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;now&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652363">题目详情 - L2-040 哲哲打游戏 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-027 名人堂与代金券 (25 分)</title>
    <link href="/2022/04/13/Algorithm020/"/>
    <url>/2022/04/13/Algorithm020/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-027-名人堂与代金券-25-分"><a href="#L2-027-名人堂与代金券-25-分" class="headerlink" title="L2-027 名人堂与代金券 (25 分)"></a>L2-027 名人堂与代金券 (25 分)</h2><p>对于在中国大学MOOC（<a href="http://www.icourse163.org/">http://www.icourse163.org/</a> ）学习“数据结构”课程的学生，想要获得一张合格证书，总评成绩必须达到 60 分及以上，并且有另加福利：总评分在 [G, 100] 区间内者，可以得到 50 元 PAT 代金券；在 [60, G) 区间内者，可以得到 20 元PAT代金券。全国考点通用，一年有效。同时任课老师还会把总评成绩前 K 名的学生列入课程“名人堂”。本题就请你编写程序，帮助老师列出名人堂的学生，并统计一共发出了面值多少元的 PAT 代金券。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出 3 个整数，分别是 N（不超过 10 000 的正整数，为学生总数）、G（在 (60,100) 区间内的整数，为题面中描述的代金券等级分界线）、K（不超过 100 且不超过 N 的正整数，为进入名人堂的最低名次）。接下来 N 行，每行给出一位学生的账号（长度不超过15位、不带空格的字符串）和总评成绩（区间 [0, 100] 内的整数），其间以空格分隔。题目保证没有重复的账号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出发出的 PAT 代金券的总面值。然后按总评成绩非升序输出进入名人堂的学生的名次、账号和成绩，其间以 1 个空格分隔。需要注意的是：成绩相同的学生享有并列的排名，排名并列时，按账号的字母序升序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">10 80 5<br>cy@zju.edu.cn 78<br>cy@pat-edu.com 87<br>1001@qq.com 65<br>uh-oh@163.com 96<br>test@126.com 39<br>anyone@qq.com 87<br>zoe@mit.edu 80<br>jack@ucla.edu 88<br>bob@cmu.edu 80<br>ken@163.com 70<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">360<br>1 uh-oh@163.com 96<br>2 jack@ucla.edu 88<br>3 anyone@qq.com 87<br>3 cy@pat-edu.com 87<br>5 bob@cmu.edu 80<br>5 zoe@mit.edu 80<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>结构体数组+sort排序，需要注意输出格式控制</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-keyword">int</span> score=<span class="hljs-number">0</span>;<br>    string email;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(student a,student b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.score==b.score) <span class="hljs-keyword">return</span> a.email&lt;b.email;<span class="hljs-comment">//如果分数相同返回字典序小的</span><br>    <span class="hljs-keyword">return</span> a.score&gt;b.score;<span class="hljs-comment">//返回分数最大的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n,g,k;<br>    cin&gt;&gt;n&gt;&gt;g&gt;&gt;k;<br>    student st[n];<br>    <span class="hljs-keyword">int</span> money=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<span class="hljs-comment">//输入加存钱</span><br>        cin&gt;&gt;st[i].email&gt;&gt;st[i].score;<br>        <span class="hljs-keyword">if</span>(g&lt;=st[i].score&amp;&amp;st[i].score&lt;=<span class="hljs-number">100</span>)&#123;<br>            money+=<span class="hljs-number">50</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">60</span>&lt;=st[i].score&amp;&amp;st[i].score&lt;g)&#123;<br>            money+=<span class="hljs-number">20</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(st,st+n,cmp);<span class="hljs-comment">//排序</span><br>    cout&lt;&lt;money&lt;&lt;endl;<br>    <span class="hljs-keyword">int</span> cnt =<span class="hljs-number">1</span>;<span class="hljs-comment">//用来判断用否超过名人堂个数</span><br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-comment">//遍历st结构体数组</span><br>    <span class="hljs-keyword">int</span> same=<span class="hljs-number">1</span>;<span class="hljs-comment">//分数相同的个数</span><br>    <span class="hljs-keyword">int</span> fscore=st[<span class="hljs-number">0</span>].score;<span class="hljs-comment">//用来判断分数是否相同</span><br>    <span class="hljs-comment">//这道题就格式输出需要注意下！</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><br>        <span class="hljs-keyword">if</span>(fscore==st[i].score)&#123;<br>            cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].email&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].score&lt;&lt;endl;<span class="hljs-comment">//相同即输出</span><br>            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>) same++;<span class="hljs-comment">//不为0号，则same++。</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(fscore&gt;st[i].score)&#123;<br>            cnt=cnt+same;<span class="hljs-comment">//不等，更新cnt值</span><br>            same=<span class="hljs-number">1</span>;<span class="hljs-comment">//更新same值</span><br>            <span class="hljs-keyword">if</span>(cnt&gt;k)&#123; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//大于名人堂个数结束</span><br>            cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].email&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;st[i].score&lt;&lt;endl;<br>            fscore=st[i].score;<span class="hljs-comment">//更新用来判断分数是否相同的fscore</span><br><br>        &#125;<br>        i++;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805055176163328">题目详情 - L2-027 名人堂与代金券 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-026 小字辈 (25 分)</title>
    <link href="/2022/04/13/Algorithm019/"/>
    <url>/2022/04/13/Algorithm019/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-026-小字辈-25-分"><a href="#L2-026-小字辈-25-分" class="headerlink" title="L2-026 小字辈 (25 分)"></a><strong>L2-026 小字辈 (25 分)</strong></h2><p>本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父&#x2F;母。家谱中辈分最高的老祖宗对应的父&#x2F;母编号为 -1。一行中的数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">9<br>2 6 5 5 -1 5 6 4 7<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">4<br>1 9<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表建树+BFS</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; tree[<span class="hljs-number">100005</span>];<span class="hljs-comment">//邻接表建树</span><br><span class="hljs-keyword">int</span> deeptree[<span class="hljs-number">100005</span>];<span class="hljs-comment">//记录树的深度</span><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> root;<span class="hljs-comment">//根节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//bfs</span><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<span class="hljs-comment">//根节点入队</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        x=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;tree[x].<span class="hljs-built_in">size</span>() ; ++i) &#123;<br>            deeptree[tree[x][i]]=deeptree[x]+<span class="hljs-number">1</span>;<span class="hljs-comment">//每一层的深度为上一层加1</span><br>            q.<span class="hljs-built_in">push</span>(tree[x][i]);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> deeptree[x];<span class="hljs-comment">//返回最后一个结点的深度，即深度的最大值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> a[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        cin&gt;&gt;a[i];<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">-1</span>)&#123;<br>            root=i;<span class="hljs-comment">//找根节点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ; ++j) &#123;<span class="hljs-comment">//建树</span><br>        tree[a[j]].<span class="hljs-built_in">push_back</span>(j);<span class="hljs-comment">//j是a[j]的孩子节点</span><br>        <span class="hljs-keyword">if</span>(a[j]==<span class="hljs-number">-1</span>) deeptree[j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//初始化根节点深度为1</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-built_in">bfs</span>();<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">int</span> maxdeepcnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录最大深度的个数</span><br>    <span class="hljs-keyword">int</span> tmp[n];<span class="hljs-comment">//找最大深度的id</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;=n ; ++k) &#123;<br>        <span class="hljs-keyword">if</span>(ans==deeptree[k])&#123;<br>            maxdeepcnt++;<br>            tmp[maxdeepcnt]=k;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//输出格式控制</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=maxdeepcnt ; ++l) &#123;<br>        <span class="hljs-keyword">if</span>(l!=maxdeepcnt) cout&lt;&lt;tmp[l]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;tmp[l]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808">题目详情 - L2-026 小字辈 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-023 图着色问题 (25 分)</title>
    <link href="/2022/04/12/Algorithm018/"/>
    <url>/2022/04/12/Algorithm018/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-023-图着色问题-25-分"><a href="#L2-023-图着色问题-25-分" class="headerlink" title="L2-023 图着色问题 (25 分)"></a>L2-023 图着色问题 (25 分)</h2><p>图着色问题是一个著名的NP完全问题。给定无向图<em>G</em>&#x3D;(<em>V</em>,<em>E</em>)，问可否用<em>K</em>种颜色为<em>V</em>中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？</p><p>但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出3个整数<em>V</em>（0&lt;<em>V</em>≤500）、<em>E</em>（≥0）和<em>K</em>（0&lt;<em>K</em>≤<em>V</em>），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到<em>V</em>编号。随后<em>E</em>行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数<em>N</em>（≤20），是待检查的颜色分配方案的个数。随后<em>N</em>行，每行顺次给出<em>V</em>个顶点的颜色（第<em>i</em>个数字表示第<em>i</em>个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每种颜色分配方案，如果是图着色问题的一个解则输出<code>Yes</code>，否则输出<code>No</code>，每句占一行。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><img src="/2022/04/12/Algorithm018/graph.png" alt="graph" style="zoom: 67%;"><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">6 8 3<br>2 1<br>1 3<br>4 6<br>2 5<br>2 4<br>5 4<br>5 6<br>3 6<br>4<br>1 2 3 3 1 2<br>4 5 6 6 4 5<br>1 2 3 4 5 6<br>2 3 4 2 3 4<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">Yes<br>Yes<br>No<br>No<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>Set + 邻接表</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> v,e,k;<br>    cin&gt;&gt;v&gt;&gt;e&gt;&gt;k;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; g[<span class="hljs-number">505</span>];<span class="hljs-comment">//邻接表</span><br>    <span class="hljs-keyword">int</span> color[<span class="hljs-number">505</span>];<span class="hljs-comment">//记录颜色</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;e ; ++i) &#123;       <span class="hljs-comment">//建立邻接表</span><br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        g[a].<span class="hljs-built_in">push_back</span>(b);<br>        g[b].<span class="hljs-built_in">push_back</span>(a);<br>    &#125;<br>    <span class="hljs-keyword">int</span> time;<br>    cin&gt;&gt;time;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;time ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>        set&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-comment">//用来统计颜色总数</span><br>        s.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=v; ++i) &#123;<br>            <span class="hljs-keyword">int</span> num;<br>            cin&gt;&gt;num;<br>            color[i]=num;<br>            s.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()!=k)&#123;<span class="hljs-comment">//如果颜色数不等于k即非法</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=v ; ++l) &#123;<span class="hljs-comment">//遍历邻接表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;g[l].<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">if</span>(color[l]==color[g[l][i]])&#123;<span class="hljs-comment">//如果相邻结点颜色一样则为假</span><br>                    flag=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805057298481152">题目详情 - L2-023 图着色问题 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-022 重排链表 (25 分)</title>
    <link href="/2022/04/12/Algorithm017/"/>
    <url>/2022/04/12/Algorithm017/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-022-重排链表-25-分"><a href="#L2-022-重排链表-25-分" class="headerlink" title="L2-022 重排链表 (25 分)"></a>L2-022 重排链表 (25 分)</h2><p>给定一个单链表 <em>L</em>1→<em>L</em>2→⋯→<em>Ln</em>−1→<em>Ln</em>，请编写程序将链表重新排列为 <em>Ln</em>→<em>L</em>1→<em>Ln</em>−1→<em>L</em>2→⋯。例如：给定<em>L</em>为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数<em>N</em> (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。</p><p>接下来有<em>N</em>行，每行格式为：</p><figure class="highlight purebasic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span><br></code></pre></div></td></tr></table></figure><p>其中<code>Address</code>是结点地址；<code>Data</code>是该结点保存的数据，为不超过105的正整数；<code>Next</code>是下一结点的地址。题目保证给出的链表上至少有两个结点。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">00100 6<br>00000 4 99999<br>00100 1 12309<br>68237 6 -1<br>33218 3 00000<br>99999 5 68237<br>12309 2 33218<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">68237 6 00100<br>00100 1 99999<br>99999 5 12309<br>12309 2 00000<br>00000 4 33218<br>33218 3 -1<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>利用双向链表，头尾指针来模拟</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linklist</span>&#123;</span><br>    <span class="hljs-keyword">int</span> address=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录当前结点的地址，虽然也没用到</span><br>    <span class="hljs-keyword">int</span> data=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录数据域</span><br>    <span class="hljs-keyword">int</span> next=<span class="hljs-number">0</span>;<span class="hljs-comment">//指向下一个结点的地址</span><br>    <span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>;<span class="hljs-comment">//指向上一个结点的地址</span><br>&#125;l[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> start,back=<span class="hljs-number">-1</span>;<span class="hljs-comment">//头尾指针</span><br>    <span class="hljs-keyword">int</span> tmp;<span class="hljs-comment">//用来遍历当前链表用于统计链表的长度</span><br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;start&gt;&gt;n;<br>    tmp=start;<br>    <span class="hljs-keyword">int</span> address, data, next;<br>    l[start].pre=<span class="hljs-number">-1</span>;   <span class="hljs-comment">//初始化第一个结点的前一个结点位置为-1</span><br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;  <span class="hljs-comment">//记录链表长</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>       cin&gt;&gt;address&gt;&gt;data&gt;&gt;next;<br>       l[address].address=address;<br>       l[address].data=data;<br>       l[address].next=next;<br>       <span class="hljs-keyword">if</span>(next!=<span class="hljs-number">-1</span>)&#123;<br>           l[next].pre=address;<span class="hljs-comment">//设值上一个结点的地址</span><br>       &#125;<br>    &#125;<br>    <span class="hljs-comment">//这道题比较坑的地方是会出现不是这个链表的结点，所以n不是真正的链表长，需要统计真正的链表长</span><br>    <span class="hljs-comment">//如果没注意这点，第三个测试点会不通过，不过也能得到21分</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        cnt++;<span class="hljs-comment">//统计链表长</span><br>        <span class="hljs-keyword">if</span>(l[tmp].next==<span class="hljs-number">-1</span>)&#123;<br>            back=tmp;       <span class="hljs-comment">//尾指针</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        tmp=l[tmp].next;<br>    &#125;<br>    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//flag=0动尾指针,flag=1动头指针。我并没有改变原来链表！</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;cnt ; ++k) &#123;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(k==cnt<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %d\n&quot;</span>,l[back].address,l[back].data,<span class="hljs-number">-1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>,l[back].address,l[back].data,start);<br>                &#125;<br>                back=l[back].pre;<br>                flag=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(k==cnt<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %d\n&quot;</span>,l[start].address,l[start].data,<span class="hljs-number">-1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>,l[start].address,l[start].data,back);<br>                &#125;<br>                start=l[start].next;<br>                flag=<span class="hljs-number">0</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805057860517888">题目详情 - L2-022 重排链表 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>LinkList</tag>
      
      <tag>双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-021 点赞狂魔 (25 分)</title>
    <link href="/2022/04/11/Algorithm016/"/>
    <url>/2022/04/11/Algorithm016/</url>
    
    <content type="html"><![CDATA[<h1 id="L2-021-点赞狂魔-25-分"><a href="#L2-021-点赞狂魔-25-分" class="headerlink" title="L2-021 点赞狂魔 (25 分)"></a>L2-021 点赞狂魔 (25 分)</h1><p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤100），是待统计的用户数。随后<em>N</em>行，每行列出一位用户的点赞标签。格式为“<code>Name</code> <em>K</em> <em>F</em>1⋯<em>F**K</em>”，其中<code>Name</code>是不超过8个英文小写字母的非空用户名，1≤<em>K</em>≤1000，<em>F**i</em>（<em>i</em>&#x3D;1,⋯,<em>K</em>）是特性标签的编号，我们将所有特性标签从 1 到 107 编号。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用<code>-</code>补齐缺失，例如<code>mike jenny -</code>就表示只有2人。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">5<br>bob 11 101 102 103 104 105 106 107 108 108 107 107<br>peter 8 1 2 3 4 3 2 5 1<br>chris 12 1 2 3 4 5 6 7 8 9 1 2 3<br>john 10 8 7 6 5 4 3 2 1 7 5<br>jack 9 6 7 8 9 10 11 12 13 14<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">jack chris john<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>结构体数组 + sort排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span>&#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">10</span>];<br>    set&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-comment">//set容器中的每个元素值唯一</span><br>    <span class="hljs-keyword">int</span> all=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录点赞次数</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(person a,person b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.s.<span class="hljs-built_in">size</span>()==b.s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a.all&lt;b.all;<span class="hljs-comment">//如果有并列，则输出标签出现次数平均值最小的那个</span><br>    <span class="hljs-keyword">return</span> a.s.<span class="hljs-built_in">size</span>()&gt;b.s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//点赞的不同标签的数量最多的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    person p[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        cin&gt;&gt;p[i].name;<br>        <span class="hljs-keyword">int</span> time;<br>        cin&gt;&gt;time;<br>        p[i].all=time;<span class="hljs-comment">//记录点赞次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; time; ++j) &#123;<br>            <span class="hljs-keyword">int</span> tmp;<br>            cin&gt;&gt;tmp;<br>            p[i].s.<span class="hljs-built_in">insert</span>(tmp);<span class="hljs-comment">//插入set容器</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(p,p+n,cmp);<span class="hljs-comment">//排序</span><br>    <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">3</span>)&#123;<br>        cout&lt;&lt;p[<span class="hljs-number">0</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p[<span class="hljs-number">1</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p[<span class="hljs-number">2</span>].name&lt;&lt;endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)&#123;<br>        cout&lt;&lt;p[<span class="hljs-number">0</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p[<span class="hljs-number">1</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>        cout&lt;&lt;p[<span class="hljs-number">0</span>].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805058485469184">题目详情 - L2-021 点赞狂魔 (25 分) (pintia.cn)</a></p><p><a href="https://blog.csdn.net/changjiale110/article/details/79108447">(19条消息) STL中的set使用方法详细！！！！_知足–常乐的博客-CSDN博客_set stl</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的STL中字符串string自带方法find查找</title>
    <link href="/2022/04/08/Algorithm015/"/>
    <url>/2022/04/08/Algorithm015/</url>
    
    <content type="html"><![CDATA[<h1 id="C-的STL中字符串string自带方法find查找"><a href="#C-的STL中字符串string自带方法find查找" class="headerlink" title="C++的STL中字符串string自带方法find查找"></a>C++的STL中字符串string自带方法find查找</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;abcd&quot;</span>;<br>cout &lt;&lt; str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-comment">//返回的是下标的值而不是指针或是迭代器</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;abcd&quot;</span><br>string sub = <span class="hljs-string">&quot;cd&quot;</span><br><span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">find</span>(sub)!=string::npos)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;找到了&quot;</span>&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;没有找到&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>要是没有找到，返回的是str::npos<br>注意，只有string的find方法是返回的下标，因为string是顺序索引，set,map,multiset,multimap都不是顺序索引的数据结构，所以返回的是迭代器。</p><h2 id="样例一-L1-070-吃火锅-15-分"><a href="#样例一-L1-070-吃火锅-15-分" class="headerlink" title="样例一:L1-070 吃火锅 (15 分)"></a>样例一:<strong>L1-070 吃火锅 (15 分)</strong></h2><p><strong>题目链接：</strong></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053</a></p><p><img src="/2022/04/08/Algorithm015/68518b64-f2f7-4694-aaeb-d32afe657f7b.jpg" alt="chg.jpg"></p><p>以上图片来自微信朋友圈：这种天气你有什么破事打电话给我基本没用。但是如果你说“吃火锅”，那就厉害了，我们的故事就开始了。</p><p>本题要求你实现一个程序，自动检查你朋友给你发来的信息里有没有 <code>chi1 huo3 guo1</code>。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入每行给出一句不超过 80 个字符的、以回车结尾的朋友信息，信息为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。当读到某一行只有一个英文句点 <code>.</code> 时，输入结束，此行不算在朋友信息里。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出朋友信息的总条数。然后对朋友的每一行信息，检查其中是否包含 <code>chi1 huo3 guo1</code>，并且统计这样厉害的信息有多少条。在第二行中首先输出第一次出现 <code>chi1 huo3 guo1</code> 的信息是第几条（从 1 开始计数），然后输出这类信息的总条数，其间以一个空格分隔。题目保证输出的所有数字不超过 100。</p><p>如果朋友从头到尾都没提 <code>chi1 huo3 guo1</code> 这个关键词，则在第二行输出一个表情 <code>-_-#</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">Hello!<br>are you there?<br>wantta chi1 huo3 guo1?<br>that&#x27;s so li hai le<br>our story begins from chi1 huo3 guo1 le<br>.<br></code></pre></div></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">5<br>3 2<br></code></pre></div></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">Hello!<br>are you there?<br>wantta qi huo3 guo1 chi1huo3guo1?<br>that&#x27;s so li hai le<br>our story begins from ci1 huo4 guo2 le<br>.<br></code></pre></div></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">5<br>-_-#<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来判断是否是第一次找到吃火锅</span><br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录总行数</span><br>    <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录有多少个吃火锅</span><br>    <span class="hljs-keyword">int</span> firstp=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录第一次出现吃火锅的位置</span><br>    string cmp=<span class="hljs-string">&quot;chi1 huo3 guo1&quot;</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        string s;<br>        s.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">getline</span>(cin,s);<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>&amp;&amp;s==<span class="hljs-string">&quot;.&quot;</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        string tmp =s;<br>        <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">find</span>(cmp)!=string::npos)&#123;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>) &#123;<br>                flag =<span class="hljs-number">1</span>;<br>                firstp = cnt+<span class="hljs-number">1</span>;<br>            &#125;<br>            count=count+<span class="hljs-number">1</span>;<br>        &#125;<br>        cnt=cnt+<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        cout&lt;&lt;cnt&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;-_-#&quot;</span>&lt;&lt;endl;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;cnt&lt;&lt;endl;<br>        cout&lt;&lt;firstp&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;count&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_50675813/article/details/113313343">(18条消息) c++STL中的find()函数 有两种使用方法_我们不生产代码，只是代码的搬运工的博客-CSDN博客_c++中find函数的使用方法</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Find</tag>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由遍历顺序构建二叉树(前序+中序;后序+中序)</title>
    <link href="/2022/04/07/Algorithm014/"/>
    <url>/2022/04/07/Algorithm014/</url>
    
    <content type="html"><![CDATA[<h1 id="由遍历顺序构建二叉树-前序-中序-后序-中序"><a href="#由遍历顺序构建二叉树-前序-中序-后序-中序" class="headerlink" title="由遍历顺序构建二叉树(前序+中序;后序+中序)"></a>由遍历顺序构建二叉树(前序+中序;后序+中序)</h1><h2 id="前序-中序"><a href="#前序-中序" class="headerlink" title="前序+中序"></a>前序+中序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BiTree <span class="hljs-title">PreAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prel,<span class="hljs-keyword">int</span> prer, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(prel&gt;prer)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<span class="hljs-comment">//记住分配空间</span><br>    root-&gt;data=preF[prel];<span class="hljs-comment">//前序遍历的第一个结点是根结点</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=inl;i&lt;=inr;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(preF[prel]==inF[i])&#123;<br>            index=i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//前序遍历的第一个结点是根结点,所以新的递归区间是prel+1,到prel+index-inl,</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+<span class="hljs-number">1</span>,prel+index-inl,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//前序遍历是根左右，所以新的递归区间是prel+index-inl+1,prep</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+index-inl+<span class="hljs-number">1</span>,prer,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="后序-中序"><a href="#后序-中序" class="headerlink" title="后序+中序"></a>后序+中序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BiTree <span class="hljs-title">PostAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> postl,<span class="hljs-keyword">int</span> postr, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(postl&gt;postr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>    root-&gt;data=posts[postr];<span class="hljs-comment">//后序遍历的最后一个结点是根结点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inl; i &lt;=inr ; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(posts[postr]==ins[i])<br>        &#123;<br>            index =i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//后续遍历的最后一个结点是根节点，所以新的递归区间是，postl,postl+index-inl-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl,postl+index-inl<span class="hljs-number">-1</span>,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//后序遍历是左右根，所以新的递归区间是postl+index-inl,postr-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl+index-inl,postr<span class="hljs-number">-1</span>,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h2><p><strong>前序+中序；后序+中序。递归调用可视化查看：(有助于理解递归调用过程)</strong></p><p><a href="https://pythontutor.com/">Python Tutor - Visualize Python, Java, C, C++, JavaScript, TypeScript, and Ruby code execution</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125;BiTNode,*BiTree;<br><span class="hljs-comment">//tree</span><br><span class="hljs-keyword">int</span> preF[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">int</span> inF[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//中序遍历</span><br><span class="hljs-comment">//trees</span><br><span class="hljs-keyword">int</span> posts[<span class="hljs-number">7</span>]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//后序遍历</span><br><span class="hljs-keyword">int</span> ins[<span class="hljs-number">7</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<span class="hljs-comment">//中序遍历</span><br><span class="hljs-function">BiTree <span class="hljs-title">PreAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prel,<span class="hljs-keyword">int</span> prer, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(prel&gt;prer)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<span class="hljs-comment">//记住分配空间</span><br>    root-&gt;data=preF[prel];<span class="hljs-comment">//前序遍历的第一个结点是根结点</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=inl;i&lt;=inr;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(preF[prel]==inF[i])&#123;<br>            index=i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//前序遍历的第一个结点是根结点,所以新的递归区间是prel+1,到prel+index-inl,</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+<span class="hljs-number">1</span>,prel+index-inl,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//前序遍历是根左右，所以新的递归区间是prel+index-inl+1,prep</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PreAndInCreateTree</span>(prel+index-inl+<span class="hljs-number">1</span>,prer,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function">BiTree <span class="hljs-title">PostAndInCreateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> postl,<span class="hljs-keyword">int</span> postr, <span class="hljs-keyword">int</span> inl,<span class="hljs-keyword">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(postl&gt;postr)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    root=(BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode));<br>    root-&gt;data=posts[postr];<span class="hljs-comment">//后序遍历的最后一个结点是根结点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inl; i &lt;=inr ; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(posts[postr]==ins[i])<br>        &#123;<br>            index =i;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//找到了根结点，目的是在中序遍历中划分左右子树</span><br>        &#125;<br>    &#125;<span class="hljs-comment">//则其左子树节点个数为index-inl</span><br>    <span class="hljs-comment">//后续遍历的最后一个结点是根节点，所以新的递归区间是，postl,postl+index-inl-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是inl,index-1</span><br>    root-&gt;lchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl,postl+index-inl<span class="hljs-number">-1</span>,inl,index<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//后序遍历是左右根，所以新的递归区间是postl+index-inl,postr-1</span><br>    <span class="hljs-comment">//中序遍历是左根右，所以新的递归区间是index+1,inr</span><br>    root-&gt;rchild=<span class="hljs-built_in">PostAndInCreateTree</span>(postl+index-inl,postr<span class="hljs-number">-1</span>,index+<span class="hljs-number">1</span>,inr);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;BiTree&gt; q;<br>    q.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        BiTNode *tmp =q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;tmp-&gt;data;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    BiTree tree;<br>    tree=<span class="hljs-literal">NULL</span>;<br>    tree=<span class="hljs-built_in">PreAndInCreateTree</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;输入为前序加中序遍历，输出他的层序遍历：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">LevelOrder</span>(tree);<br>    cout&lt;&lt;endl;<br>    BiTree trees;<br>    trees=<span class="hljs-literal">NULL</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;输入为后序加中序遍历，输出他的层序遍历：&quot;</span>&lt;&lt;endl;<br>    trees=<span class="hljs-built_in">PostAndInCreateTree</span>(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">LevelOrder</span>(trees);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">输入为前序加中序遍历，输出他的层序遍历：<br><span class="hljs-number">425136</span><br>输入为后序加中序遍历，输出他的层序遍历：<br><span class="hljs-number">4163572</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的存储结构</title>
    <link href="/2022/04/06/Algorithm012/"/>
    <url>/2022/04/06/Algorithm012/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h2 id="1-顺序存储方式"><a href="#1-顺序存储方式" class="headerlink" title="1.顺序存储方式"></a>1.顺序存储方式</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 100</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    ElemType value;<span class="hljs-comment">//结点中的数据元素</span><br>    <span class="hljs-keyword">bool</span> isEmpty;<span class="hljs-comment">//结点是否为空</span><br>&#125;;<br><br>TreeNode t[MaxSize];<br></code></pre></div></td></tr></table></figure><h2 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="2.链式存储结构"></a>2.链式存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125;BiTNode,*BiTree;<br></code></pre></div></td></tr></table></figure><h2 id="3-三叉链表"><a href="#3-三叉链表" class="headerlink" title="3.三叉链表"></a>3.三叉链表</h2><p>三叉链表—方便找父节点</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">parent</span>;</span><span class="hljs-comment">//父结点指针</span><br>&#125;BiTNode,*BiTree;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串的存储结构</title>
    <link href="/2022/04/06/Algorithm011/"/>
    <url>/2022/04/06/Algorithm011/</url>
    
    <content type="html"><![CDATA[<h1 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h1><h2 id="1-定长顺序存储表示"><a href="#1-定长顺序存储表示" class="headerlink" title="1.定长顺序存储表示"></a>1.定长顺序存储表示</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLEN 255<span class="hljs-comment">//预定义最大串长</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">char</span> ch[MAXLEN];<span class="hljs-comment">//每个分量存储一个字符</span><br>    <span class="hljs-keyword">int</span> length;<span class="hljs-comment">//串的实际长度</span><br>&#125;SSting;<br></code></pre></div></td></tr></table></figure><h2 id="2-堆分配存储表示"><a href="#2-堆分配存储表示" class="headerlink" title="2.堆分配存储表示"></a>2.堆分配存储表示</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">char</span> *ch;<span class="hljs-comment">//按串长分配存储区，ch指向串的基地址</span><br>    <span class="hljs-keyword">int</span> length;<span class="hljs-comment">//串的长度</span><br>&#125;HString;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(六)-两个矩阵相加MPI版本</title>
    <link href="/2022/04/02/mpi006/"/>
    <url>/2022/04/02/mpi006/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI学习-六-两个矩阵相加MPI版本"><a href="#MPI学习-六-两个矩阵相加MPI版本" class="headerlink" title="MPI学习(六)-两个矩阵相加MPI版本"></a>MPI学习(六)-两个矩阵相加MPI版本</h1><p>这里，我们演示了两个简单的程序，一个是矩阵相加串行版本，一个是矩阵相加MPI版本</p><h2 id="串行版本"><a href="#串行版本" class="headerlink" title="串行版本"></a>串行版本</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<br><span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<br><span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<br><span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>&#125;;<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<br><span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<br><span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">17</span>,<span class="hljs-number">5</span>,<br><span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c)); <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>&#123;<br>c[i][j]=a[i][j]+b[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">11</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">15</span> <span class="hljs-number">17</span><br><span class="hljs-number">20</span> <span class="hljs-number">22</span> <span class="hljs-number">28</span> <span class="hljs-number">17</span><br><span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">35</span> <span class="hljs-number">19</span><br></code></pre></div></td></tr></table></figure><h2 id="MPI版本"><a href="#MPI版本" class="headerlink" title="MPI版本"></a>MPI版本</h2><h3 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h3><p>北京超级云计算中心A3分区</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>mpi&#x2F;intel&#x2F;2017.5</p><h3 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h3><p>mpicxx mpi006.c -o mpi006</p><h3 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h3><p>srun -p amd_256 -N 1 -n  5  .&#x2F;mpi006(使用SLURM任务调度系统)</p><p>1个分区，核数为5</p><h3 id="程序源代码-1"><a href="#程序源代码-1" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc ,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<br><span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<br><span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<br><span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>&#125;;<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<br><span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<br><span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">17</span>,<span class="hljs-number">5</span>,<br><span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-keyword">int</span> tmp[<span class="hljs-number">4</span>];<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));<br><span class="hljs-keyword">int</span> myid, numprocs;<br>MPI_Status status;<br>MPI_Request request;<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc,&amp;argv);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;numprocs);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;myid);<br><span class="hljs-keyword">if</span>(myid == <span class="hljs-number">0</span>)<span class="hljs-comment">//0号进程接受来自其他进程的消息</span><br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;numprocs;i++)<br>&#123;<br><span class="hljs-built_in">MPI_Irecv</span>(&amp;c[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],<span class="hljs-number">4</span>,MPI_INT,i,<span class="hljs-number">0</span>,MPI_COMM_WORLD,&amp;request);<span class="hljs-comment">//采用非阻塞接受</span><br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//打印矩阵</span><br>&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,c[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(myid != <span class="hljs-number">0</span> )<span class="hljs-comment">//当进程不是0号进程时，则向0号进程发送消息</span><br>&#123;<br><span class="hljs-built_in">memset</span>(tmp,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(tmp));<span class="hljs-comment">//初始化tmp数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br>tmp[i]=a[myid<span class="hljs-number">-1</span>][i]+b[myid<span class="hljs-number">-1</span>][i];<span class="hljs-comment">//用tmp来临时存储相加结果，随后发送给0号进程</span><br><br>&#125;<br><span class="hljs-built_in">MPI_Isend</span>(&amp;tmp,<span class="hljs-number">4</span>,MPI_INT,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,MPI_COMM_WORLD,&amp;request);<span class="hljs-comment">//采用非阻塞发送</span><br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br>&#125;<br><span class="hljs-built_in">MPI_Finalize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序输出-1"><a href="#程序输出-1" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">11</span> <br><span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">15</span> <span class="hljs-number">17</span> <br><span class="hljs-number">20</span> <span class="hljs-number">22</span> <span class="hljs-number">28</span> <span class="hljs-number">17</span> <br><span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">35</span> <span class="hljs-number">19</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2022/03/31/Algorithm010/"/>
    <url>/2022/03/31/Algorithm010/</url>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的顺序存储解构"><a href="#队列的顺序存储解构" class="headerlink" title="队列的顺序存储解构"></a>队列的顺序存储解构</h3><h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><p>队列的顺序存储类型可描述为</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义队列中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放队列元素</span><br>    <span class="hljs-keyword">int</span> front,rear;<span class="hljs-comment">//队头指针和队尾指针</span><br>&#125;SqQueue;<br></code></pre></div></td></tr></table></figure><h4 id="循环队列的操作"><a href="#循环队列的操作" class="headerlink" title="循环队列的操作"></a>循环队列的操作</h4><p>(1)初始化</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>    Q.rear=Q.front=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化队首、队尾指针</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>(2)判队空</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//队空条件</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>(3)入队</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MaxSize==Q.front)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//队满则报错</span><br>    Q.data[Q.rear]=x;<br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队尾指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>(4)出队</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//队列空则报错</span><br>    x=Q.data[Q.front];<br>    Q.front=(Q.front+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队头指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="循环队列的完整操作"><a href="#循环队列的完整操作" class="headerlink" title="循环队列的完整操作"></a>循环队列的完整操作</h4><h5 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义队列中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放队列元素</span><br>    <span class="hljs-keyword">int</span> front,rear;<span class="hljs-comment">//队头指针和队尾指针</span><br>&#125;SqQueue;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>    Q.rear=Q.front=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化队首、队尾指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//队空条件</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MaxSize==Q.front)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//队满则报错</span><br>    Q.data[Q.rear]=x;<br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队尾指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//队列空则报错</span><br>    x=Q.data[Q.front];<br>    Q.front=(Q.front+<span class="hljs-number">1</span>)%MaxSize;<span class="hljs-comment">//队头指针加1取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintSqQueue</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<span class="hljs-comment">//遍历操作 </span><br><span class="hljs-keyword">int</span> point = Q.front;<br><span class="hljs-keyword">while</span>(point!=Q.rear)<span class="hljs-comment">//如果point指向Q.rear说明遍历结束 </span><br>&#123;<span class="hljs-comment">//也就是point指向了队尾元素的下一个位置 </span><br>cout&lt;&lt;Q.data[point]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>point=(point+<span class="hljs-number">1</span>)%MaxSize;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>SqQueue Q;<span class="hljs-comment">//声明了一个顺序队列 </span><br><span class="hljs-built_in">InitQueue</span>(Q);<span class="hljs-comment">//初始化这个队列 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-built_in">EnQueue</span>(Q,i);<span class="hljs-comment">//入队操作 </span><br>&#125;<br><span class="hljs-built_in">PrintSqQueue</span>(Q);<span class="hljs-comment">//遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">DeQueue</span>(Q,x);<span class="hljs-comment">//出队 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是第&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;次出队&quot;</span>&lt;&lt;<span class="hljs-string">&quot;出队的元素是&quot;</span> &lt;&lt;x&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isEmpty</span>(Q))<span class="hljs-comment">//队列非空则遍历 </span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;当前队列为：&quot;</span>;<br><span class="hljs-built_in">PrintSqQueue</span>(Q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;此时的队列为空队列&quot;</span>&lt;&lt;endl;<br>&#125;<br><br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h5 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">1</span>次出队出队的元素是<span class="hljs-number">0</span><br>当前队列为：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">2</span>次出队出队的元素是<span class="hljs-number">1</span><br>当前队列为：<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">3</span>次出队出队的元素是<span class="hljs-number">2</span><br>当前队列为：<span class="hljs-number">3</span> <span class="hljs-number">4</span><br>这是第<span class="hljs-number">4</span>次出队出队的元素是<span class="hljs-number">3</span><br>当前队列为：<span class="hljs-number">4</span><br>这是第<span class="hljs-number">5</span>次出队出队的元素是<span class="hljs-number">4</span><br>此时的队列为空队列<br></code></pre></div></td></tr></table></figure><h3 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h3><h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><p>队列的链式存储类型可描述为</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><span class="hljs-comment">//链式队列结点</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LinkNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//链式队列</span><br>    LinkNode *front,*rear;<span class="hljs-comment">//队列的对头和队尾指针</span><br>&#125;LinkQueue;<br></code></pre></div></td></tr></table></figure><h4 id="链式队列的基本操作"><a href="#链式队列的基本操作" class="headerlink" title="链式队列的基本操作"></a>链式队列的基本操作</h4><p>(1)初始化</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    Q.front = Q.rear=(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<span class="hljs-comment">//建立头结点</span><br>    Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始为空</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>(2判队空</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>(3)入队</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;<br>    LinkNode *s =(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<br>    s-&gt;data=x;<span class="hljs-comment">//创建新结点，插入到链尾</span><br>    s-&gt;next=<span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next=s;<br>    Q.rear=s;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>(4)出队</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//空队</span><br>    LinkNode *p =Q.front-&gt;next;<br>    x=p-&gt;data;<br>    Q.front-&gt;next=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear==p)&#123;<br>        Q.rear = Q.front;<span class="hljs-comment">//若原队列中只有一个结点，删除后变空</span><br>    &#125;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="链式队列的完整操作"><a href="#链式队列的完整操作" class="headerlink" title="链式队列的完整操作"></a>链式队列的完整操作</h4><h5 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><span class="hljs-comment">//链式队列结点</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LinkNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//链式队列</span><br>    LinkNode *front,*rear;<span class="hljs-comment">//队列的对头和队尾指针</span><br>&#125;LinkQueue;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    Q.front = Q.rear=(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<span class="hljs-comment">//建立头结点</span><br>    Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始为空</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front==Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    LinkNode *s =(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LinkNode));<br>    s-&gt;data=x;<span class="hljs-comment">//创建新结点，插入到链尾</span><br>    s-&gt;next=<span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next=s;<br>    Q.rear=s;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,<span class="hljs-keyword">int</span> &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//空队</span><br>    LinkNode *p =Q.front-&gt;next;<br>    x=p-&gt;data;<br>    Q.front-&gt;next=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear==p)&#123;<br>        Q.rear = Q.front;<span class="hljs-comment">//若原队列中只有一个结点，删除后变空</span><br>    &#125;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintQueue</span><span class="hljs-params">(LinkQueue Q)</span><span class="hljs-comment">//遍历队列 </span></span><br><span class="hljs-function"></span>&#123;<br>LinkNode *tmp=Q.front-&gt;next;<span class="hljs-comment">//声明一个结点用于遍历</span><br><span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果这个结点为空则停止遍历</span><br>&#123;<span class="hljs-comment">//这里即tmp已经指向最后一个元素的-&gt;next</span><br>cout&lt;&lt;tmp-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//因为在初始化时已经置最后一个元素的-&gt;next=NULL</span><br>tmp=tmp-&gt;next;<span class="hljs-comment">//所以说这里只需要判断tmp为空即可</span><br>&#125;<br>cout&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>LinkQueue Q;<span class="hljs-comment">//声明链式一个队列 </span><br><span class="hljs-built_in">InitQueue</span>(Q);<span class="hljs-comment">//初始化队列 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">5</span>;i&gt;<span class="hljs-number">0</span>;i--)     <span class="hljs-comment">//创建队列 </span><br>&#123;<br><span class="hljs-built_in">EnQueue</span>(Q,i);<br>&#125;<br><span class="hljs-built_in">PrintQueue</span>(Q);      <span class="hljs-comment">//遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-built_in">DeQueue</span>(Q,x);<span class="hljs-comment">//出队 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是第&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;次出队&quot;</span>&lt;&lt;<span class="hljs-string">&quot;出队的元素是&quot;</span> &lt;&lt;x&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))<span class="hljs-comment">//队列非空则遍历 </span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;当前队列为：&quot;</span>;<br><span class="hljs-built_in">PrintQueue</span>(Q);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;此时的队列为空队列&quot;</span>&lt;&lt;endl;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="程序输出：-1"><a href="#程序输出：-1" class="headerlink" title="程序输出："></a>程序输出：</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">1</span>次出队出队的元素是<span class="hljs-number">5</span><br>当前队列为：<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">2</span>次出队出队的元素是<span class="hljs-number">4</span><br>当前队列为：<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">3</span>次出队出队的元素是<span class="hljs-number">3</span><br>当前队列为：<span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是第<span class="hljs-number">4</span>次出队出队的元素是<span class="hljs-number">2</span><br>当前队列为：<span class="hljs-number">1</span><br>这是第<span class="hljs-number">5</span>次出队出队的元素是<span class="hljs-number">1</span><br>此时的队列为空队列<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2022/03/30/Algorithm009/"/>
    <url>/2022/03/30/Algorithm009/</url>
    
    <content type="html"><![CDATA[<h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><h3 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h3><p>栈的顺序存储类型可描述为：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义栈中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放栈中元素</span><br>    <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶指针</span><br>&#125;SqStack;<br></code></pre></div></td></tr></table></figure><h3 id="顺序栈的基本运算"><a href="#顺序栈的基本运算" class="headerlink" title="顺序栈的基本运算"></a>顺序栈的基本运算</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;s)</span></span>&#123;<br>    s.top=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化栈顶指针</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="判栈空"><a href="#判栈空" class="headerlink" title="判栈空"></a>判栈空</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//不空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;s,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == MaxSize<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈满，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s.data[++s.top]=x;<span class="hljs-comment">//指针先加1，在入栈</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;s,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    x=s.data[s.top--];<span class="hljs-comment">//先出栈，指针再减1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s,ElemType &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span> )<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   x=s.data[s.top];<span class="hljs-comment">//x记录栈顶元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="顺序栈的完整操作"><a href="#顺序栈的完整操作" class="headerlink" title="顺序栈的完整操作"></a>顺序栈的完整操作</h3><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//定义栈中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MaxSize];<span class="hljs-comment">//存放栈中元素</span><br>    <span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶指针</span><br>&#125;SqStack;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;s)</span></span>&#123;<br>    s.top=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化栈顶指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//不空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;s,ElemType x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == MaxSize<span class="hljs-number">-1</span>)<span class="hljs-comment">//栈满，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s.data[++s.top]=x;<span class="hljs-comment">//指针先加1，在入栈</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;s,ElemType &amp;x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    x=s.data[s.top--];<span class="hljs-comment">//先出栈，指针再减1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack s,ElemType &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.top == <span class="hljs-number">-1</span> )<span class="hljs-comment">//栈空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   x=s.data[s.top];<span class="hljs-comment">//x记录栈顶元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintSqStack</span><span class="hljs-params">(SqStack s)</span><span class="hljs-comment">//遍历栈 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> tmp = s.top;<br><span class="hljs-keyword">while</span>(tmp!=<span class="hljs-number">-1</span>)<span class="hljs-comment">//如果tmp==-1说明遍历结束 </span><br>&#123; <br>cout&lt;&lt;s.data[tmp--]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>SqStack s;<span class="hljs-comment">//声明一个顺序栈 </span><br><span class="hljs-built_in">InitStack</span>(s);<span class="hljs-comment">//初始化一个顺序栈 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-built_in">Push</span>(s,i);<span class="hljs-comment">//入栈 </span><br>&#125;<br><span class="hljs-built_in">PrintSqStack</span>(s);<span class="hljs-comment">//遍历 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<span class="hljs-comment">//为了对比GetTop和Pop操作 </span><br><span class="hljs-keyword">int</span> x; <br><span class="hljs-built_in">GetTop</span>(s,x);<span class="hljs-comment">//取栈顶元素 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是GetTop操作,栈顶元素为&quot;</span>&lt;&lt;x&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;这是GetTop操作后的栈遍历:&quot;</span>;<br><span class="hljs-built_in">PrintSqStack</span>(s); <br><span class="hljs-built_in">Pop</span>(s,x);<span class="hljs-comment">//出栈 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;这是Pop操作,出栈的元素为&quot;</span>&lt;&lt;x&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">StackEmpty</span>(s))<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;这是Pop操作后的栈遍历:&quot;</span>;<br><span class="hljs-built_in">PrintSqStack</span>(s); <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;此时栈空！&quot;</span>&lt;&lt;endl;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">5</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">5</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">4</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">4</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">3</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">3</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">2</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">2</span> <span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">2</span><br>这是Pop操作后的栈遍历:<span class="hljs-number">1</span><br>这是GetTop操作,栈顶元素为<span class="hljs-number">1</span><br>这是GetTop操作后的栈遍历:<span class="hljs-number">1</span><br>这是Pop操作,出栈的元素为<span class="hljs-number">1</span><br>此时栈空！<br></code></pre></div></td></tr></table></figure><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>栈的链式存储类型可描述为</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Linknode</span>&#123;</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Linknode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span><br>&#125;*Linknode;<span class="hljs-comment">//栈类型操作</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双链表与静态链表</title>
    <link href="/2022/03/29/Algorithm008/"/>
    <url>/2022/03/29/Algorithm008/</url>
    
    <content type="html"><![CDATA[<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>双链表中结点类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>&#123;</span><span class="hljs-comment">//定义双链表结点类型</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span><span class="hljs-comment">//前驱和后继指针</span><br>&#125;DNode,*DLinkList;<br></code></pre></div></td></tr></table></figure><h3 id="双链表的插入操作"><a href="#双链表的插入操作" class="headerlink" title="双链表的插入操作"></a>双链表的插入操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//p所指结点是s所指结点的前驱结点</span><br>s-&gt;next=p-&gt;next;           <span class="hljs-comment">//将结点*s插入到结点*p之后</span><br>p-&gt;next-&gt;prior=s;<br>s-&gt;prior=p;<br>p-&gt;next=s;<br></code></pre></div></td></tr></table></figure><h3 id="双链表的删除操作"><a href="#双链表的删除操作" class="headerlink" title="双链表的删除操作"></a>双链表的删除操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//删除双链表中结点*p的后继结点*q</span><br>p-&gt;next=q-&gt;next;<br>q-&gt;next-&gt;prior=p;<br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放节点空间</span><br></code></pre></div></td></tr></table></figure><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>静态链表结构类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize 50<span class="hljs-comment">//静态链表的最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-comment">//静态链表结构类型的定义</span><br>    ElemType data;<span class="hljs-comment">//储存数据元素</span><br>    <span class="hljs-keyword">int</span> next;<span class="hljs-comment">//下一个元素的数组下标</span><br>&#125;SLinkList[MaxSize];<br></code></pre></div></td></tr></table></figure><h3 id="对静态链表结构类型的定义的理解与猜想验证"><a href="#对静态链表结构类型的定义的理解与猜想验证" class="headerlink" title="对静态链表结构类型的定义的理解与猜想验证"></a>对静态链表结构类型的定义的理解与猜想验证</h3><p><img src="/2022/03/29/Algorithm008/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8-16485415016461.png" alt="静态链表"></p><p><img src="/2022/03/29/Algorithm008/123-16485415073922.png" alt="123"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表上的基本操作</title>
    <link href="/2022/03/28/Algorithm007/"/>
    <url>/2022/03/28/Algorithm007/</url>
    
    <content type="html"><![CDATA[<h2 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h2><p>单链表中结点类型的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span><br>&#125;LNode,*LinkList;<br></code></pre></div></td></tr></table></figure><h2 id="单链表上基本操作的实现"><a href="#单链表上基本操作的实现" class="headerlink" title="单链表上基本操作的实现"></a>单链表上基本操作的实现</h2><h3 id="1-采用头插法建立单链表"><a href="#1-采用头插法建立单链表" class="headerlink" title="1.采用头插法建立单链表"></a>1.采用头插法建立单链表</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//逆向建立单链表</span><br>    LNode *s;<br>    <span class="hljs-keyword">int</span> x;<br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//创建头结点</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始化为空链表</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<span class="hljs-comment">//输入结点的值</span><br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<span class="hljs-comment">//输入9999表示结束</span><br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//建立新结点</span><br>        s-&gt;data = x;<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;<span class="hljs-comment">//将新结点插入表中，L为头指针</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-采用尾插法建立单链表"><a href="#2-采用尾插法建立单链表" class="headerlink" title="2.采用尾插法建立单链表"></a>2.采用尾插法建立单链表</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">List_TailInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//正向建立单链表</span><br>    <span class="hljs-keyword">int</span> x;<span class="hljs-comment">//设置元素类型为整型</span><br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>    LNode *s,*r=L;<span class="hljs-comment">//r为表尾指针</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<br>        s-&gt;data=x;<br>        r-&gt;next = s;<br>        r = s;<span class="hljs-comment">//r指向新的表尾结点</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        <br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-按序号查找结点值"><a href="#3-按序号查找结点值" class="headerlink" title="3.按序号查找结点值"></a>3.按序号查找结点值</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">LNode *<span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<span class="hljs-comment">//计数，初始为1</span><br>    LNode *p = L-&gt;next;<span class="hljs-comment">//第1个结点指针赋给p</span><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> L;<span class="hljs-comment">//若i等于0，则返回头结点</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//若i无效，则返回NULL</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)<span class="hljs-comment">//从第一个结点开始找，查找第i个结点</span><br>    &#123;<br>        p=p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-按值查找表结点"><a href="#4-按值查找表结点" class="headerlink" title="4.按值查找表结点"></a>4.按值查找表结点</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,ElemType e)</span></span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=e)<span class="hljs-comment">//从第i个结点开始查找data域为e的结点</span><br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//找到后返回该结点指针，否则返回NULL</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-插入结点操作"><a href="#5-插入结点操作" class="headerlink" title="5.插入结点操作"></a>5.插入结点操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//p所指结点是s所指结点的前驱结点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>LNode *p;<br>LNode *s=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//一定要分配空间！！！！！</span><br>s-&gt;data=x;<br>s-&gt;next=<span class="hljs-literal">NULL</span>; <br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>s-&gt;next =p-&gt;next;<br>p-&gt;next=s;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;插入值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> ; <br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对某一结点进行前插操作</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//注意与插入结点相对比!!!!!!!!</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delect</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//p所指结点是q所指结点的前驱结点</span><br>LNode *p;<br>LNode *q=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));   <span class="hljs-comment">//申请空间 </span><br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);    <span class="hljs-comment">//查找删除位置的前驱结点</span><br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>||p-&gt;next==<span class="hljs-literal">NULL</span>)          <span class="hljs-comment">//p==NULL是i值不合法的情况 </span><br>&#123;    <span class="hljs-comment">//p-&gt;next==NUll是i-1号结点后已无其他结点 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;删除值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">free</span>(q);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>q=p-&gt;next;<span class="hljs-comment">//令q指向被删除的结点</span><br>p-&gt;next=q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-删除结点操作"><a href="#6-删除结点操作" class="headerlink" title="6.删除结点操作"></a>6.删除结点操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//p所指结点是q所指结点的前驱结点</span><br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>)<span class="hljs-comment">//查找删除位置的前驱结点</span><br>q=p-&gt;next;<span class="hljs-comment">//令q指向被删除的结点</span><br>p-&gt;next=q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放结点的储存空间</span><br></code></pre></div></td></tr></table></figure><p>拓展:删除结点*p</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">q=p-&gt;next;<span class="hljs-comment">//令q指向*p的后继节点</span><br>p-&gt;data = p-&gt;next-&gt;data<span class="hljs-comment">//和后继结点交换数据域</span><br>p-&gt;next = q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放后继结点的储存空间</span><br></code></pre></div></td></tr></table></figure><h2 id="单链表上基本操作的完整实现"><a href="#单链表上基本操作的完整实现" class="headerlink" title="单链表上基本操作的完整实现"></a>单链表上基本操作的完整实现</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针域</span><br>&#125;LNode,*LinkList;<br><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//逆向建立单链表</span><br>    LNode *s;<br>    <span class="hljs-keyword">int</span> x;<br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//创建头结点</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始化为空链表</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<span class="hljs-comment">//输入结点的值</span><br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<span class="hljs-comment">//输入9999表示结束</span><br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//建立新结点</span><br>        s-&gt;data = x;<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;<span class="hljs-comment">//将新结点插入表中，L为头指针</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><span class="hljs-function">LNode *<span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<span class="hljs-comment">//计数，初始为1</span><br>    LNode *p = L-&gt;next;<span class="hljs-comment">//第1个结点指针赋给p</span><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> L;<span class="hljs-comment">//若i等于0，则返回头结点</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//若i无效，则返回NULL</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)<span class="hljs-comment">//从第一个结点开始找，查找第i个结点</span><br>    &#123;<br>        p=p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span><br>&#125;<br><span class="hljs-function">LNode *<span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,ElemType e)</span></span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=e)<span class="hljs-comment">//从第i个结点开始查找data域为e的结点</span><br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//找到后返回该结点指针，否则返回NULL</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintLinkList</span><span class="hljs-params">(LinkList L)</span></span>&#123;        <span class="hljs-comment">//这段代码根据链表表尾结点的 next 指针指向 NULL 来遍历整个链表。</span><br>LNode *tmp = L-&gt;next;<br><span class="hljs-keyword">if</span>(tmp==<span class="hljs-literal">NULL</span>)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;链表为空&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> ; <br>&#125;<br><span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>cout&lt;&lt;tmp-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>tmp=tmp-&gt;next;<br>&#125;<br>cout&lt;&lt;endl; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>LNode *p;<br>LNode *s=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));<span class="hljs-comment">//申请空间 </span><br>s-&gt;data=x;<br>s-&gt;next=<span class="hljs-literal">NULL</span>; <br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>s-&gt;next =p-&gt;next;<br>p-&gt;next=s;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;插入值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> ; <br>&#125;<br><br>&#125;<br><span class="hljs-comment">//注意与插入结点相对比!!!!!!!!</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delect</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br><span class="hljs-comment">//p所指结点是q所指结点的前驱结点</span><br>LNode *p;<br>LNode *q=(LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(LNode));   <span class="hljs-comment">//申请空间 </span><br>p=<span class="hljs-built_in">GetElem</span>(L,i<span class="hljs-number">-1</span>);    <span class="hljs-comment">//查找删除位置的前驱结点</span><br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>||p-&gt;next==<span class="hljs-literal">NULL</span>)          <span class="hljs-comment">//p==NULL是i值不合法的情况 </span><br>&#123;    <span class="hljs-comment">//p-&gt;next==NUll是i-1号结点后已无其他结点 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;删除值非法&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">free</span>(q);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>q=p-&gt;next;<span class="hljs-comment">//令q指向被删除的结点</span><br>p-&gt;next=q-&gt;next;<span class="hljs-comment">//将*q结点从链中“断开”</span><br><span class="hljs-built_in">free</span>(q);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>LinkList L;<span class="hljs-comment">//声明一个单链表 </span><br><span class="hljs-built_in">List_HeadInsert</span>(L);<span class="hljs-comment">//使用头插法插入4个元素，分别是1,2,3,4 </span><br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br>LNode *tmp;<br>tmp=<span class="hljs-built_in">GetElem</span>(L,<span class="hljs-number">2</span>);<span class="hljs-comment">//找到位置为2的元素 </span><br><span class="hljs-keyword">if</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;位置为2的元素是：&quot;</span>&lt;&lt;tmp-&gt;data&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;非法的位置&quot;</span>&lt;&lt;endl;<br>&#125;<br>tmp=<span class="hljs-built_in">LocateElem</span>(L,<span class="hljs-number">1</span>);<span class="hljs-comment">//找到值为1的元素</span><br><span class="hljs-keyword">if</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;存在值为1的元素：&quot;</span>&lt;&lt;tmp-&gt;data&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;没有找到该值&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br><span class="hljs-built_in">Insert</span>(L,<span class="hljs-number">5</span>,<span class="hljs-number">110</span>);<span class="hljs-comment">//在5这个位置插入元素110</span><br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br><span class="hljs-built_in">Delect</span>(L,<span class="hljs-number">2</span>);        <span class="hljs-comment">//删除位序为2的元素</span><br><span class="hljs-built_in">PrintLinkList</span>(L);<span class="hljs-comment">//遍历这个单链表</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>位置为<span class="hljs-number">2</span>的元素是：<span class="hljs-number">3</span><br>存在值为<span class="hljs-number">1</span>的元素：<span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">110</span><br><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">110</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表的定义</title>
    <link href="/2022/03/28/Algorithm006/"/>
    <url>/2022/03/28/Algorithm006/</url>
    
    <content type="html"><![CDATA[<h1 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h1><h2 id="1-单链表的定义"><a href="#1-单链表的定义" class="headerlink" title="1.单链表的定义"></a>1.单链表的定义</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>      <span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;         <span class="hljs-comment">//每个结点存放一个数据元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-comment">//指针指向下一个节点</span><br>&#125;LNode,*LinkList;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>      <span class="hljs-comment">//定义单链表结点类型</span><br>    ElemType data;         <span class="hljs-comment">//每个结点存放一个数据元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-comment">//指针指向下一个节点</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> <span class="hljs-title">LNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></div></td></tr></table></figure><p>这两种定义是一模一样的！</p><p>要表示一个单链表时，只需要声明一个头指针L，指向单链表的第一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">LNoode *L;      <span class="hljs-comment">//声明一个指向单链表第一个结点的指针</span><br><span class="hljs-comment">//或：</span><br>LinkList L;     <span class="hljs-comment">//声明一个指向单链表第一个结点的指针</span><br></code></pre></div></td></tr></table></figure><h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">LNode *L；<br><span class="hljs-comment">//和：</span><br>LinkList L;<br><span class="hljs-comment">//两者的区别就是强调不同</span><br></code></pre></div></td></tr></table></figure><p><img src="/2022/03/28/Algorithm006/%E6%BC%94%E7%A4%BA.png"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优先队列</title>
    <link href="/2022/03/11/Algorithm005/"/>
    <url>/2022/03/11/Algorithm005/</url>
    
    <content type="html"><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>定义：priority_queue&lt;Type, Container, Functional&gt;</p><p>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。</p><p>当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。<br>一般是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//升序队列，小顶堆</span><br>priority_queue &lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br><span class="hljs-comment">//降序队列，大顶堆</span><br>priority_queue &lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt; &gt;q;<br><br><span class="hljs-comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span><br></code></pre></div></td></tr></table></figure><h2 id="样例一P1090-NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G"><a href="#样例一P1090-NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G" class="headerlink" title="样例一P1090 [NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G"></a>样例一P1090 [NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p><p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p><p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p><p>例如有 33种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 、 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 &#x3D;3+12&#x3D;15 。可以证明 15为最小的体力耗费值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>共两行。<br>第一行是一个整数 n*(1≤<em>n</em>≤10000) ，表示果子的种类数。</p><p>第二行包含 <em>n</em> 个整数，用空格分隔，第 <em>i</em> 个整数 a<strong>i*(1≤*a</strong>i<em>≤20000) 是第 i</em> 种果子的数目。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^{31} 。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a><strong>输入 #1</strong></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3</span> <br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span> <br></code></pre></div></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a><strong>输出 #1</strong></h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> num;<br>        cin&gt;&gt;num;<br>        q.<span class="hljs-built_in">push</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n<span class="hljs-number">-1</span> ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> a=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">int</span> b=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        ans+=a+b;<br>        q.<span class="hljs-built_in">push</span>(a+b);<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/huashanqingzhu/p/11040390.html">c++优先队列(priority_queue)用法详解 - 华山青竹 - 博客园 (cnblogs.com)</a></p><p>[P1090 <a href="https://www.luogu.com.cn/problem/P1090">NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perf-系统级性能分析工具</title>
    <link href="/2022/01/19/tool003/"/>
    <url>/2022/01/19/tool003/</url>
    
    <content type="html"><![CDATA[<p>系统级性能优化通常包括两个阶段：性能剖析（performance profiling）和代码优化。</p><p>性能剖析的目标是寻找性能瓶颈，查找引发性能问题的原因及热点代码。</p><p>代码优化的目标是针对具体性能问题而优化代码或编译选项，以改善软件性能。</p><p>在性能剖析阶段，需要借助于现有的profiling工具，如perf等。在代码优化阶段往往需要借助开发者的经验，编写简洁高效的代码，甚至在汇编级别合理使用各种指令，合理安排各种指令的执行顺序。</p><p>perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。<br>通过perf，应用程序可以利用PMU、tracepoint和内核中的计数器来进行性能统计。它不但可以分析制定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用程序和内核，从而全面理解应用程序中的性能瓶颈。</p><p>使用perf，可以分析程序运行期间发生的硬件事件，比如instructions retired、processor clock cycles等；也可以分析软件时间，比如page fault和进程切换。</p><p>perf是一款综合性分析工具，大到系统全局性性能，再小到进程线程级别，甚至到函数及汇编级别。</p><p>perf提供了十八般武器，可以拿大刀大卸八块，也可以拿起手术刀细致分析。</p><h1 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1. 背景知识"></a>1. 背景知识</h1><h2 id="1-1-tracepoints"><a href="#1-1-tracepoints" class="headerlink" title="1.1 tracepoints"></a>1.1 tracepoints</h2><p>tracepoints是散落在内核源码中的一些hook，它们可以在特定的代码被执行到时触发，这一特定可以被各种trace&#x2F;debug工具所使用。</p><p>perf将tracepoint产生的时间记录下来，生成报告，通过分析这些报告，便可以了解程序运行期间内核的各种细节，对性能症状做出准确的诊断。</p><p>这些tracepint的对应的sysfs节点在&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events目录下。</p><h2 id="1-2-硬件特性之cache"><a href="#1-2-硬件特性之cache" class="headerlink" title="1.2 硬件特性之cache"></a>1.2 硬件特性之cache</h2><p>内存读写是很快的，但是还是无法和处理器指令执行速度相比。为了从内存中读取指令和数据，处理器需要等待，用处理器时间来衡量，这种等待非常漫长。cache是一种SRAM，读写速度非常快，能和处理器相匹配。因此将常用的数据保存在cache中，处理器便无需等待，从而提高性能。cache的尺寸一般都很小，充分利用cache是软件调优非常重要部分。</p><h1 id="2-主要关注点"><a href="#2-主要关注点" class="headerlink" title="2. 主要关注点"></a>2. 主要关注点</h1><p>基于性能分析，可以进行算法优化（空间复杂度和时间复杂度权衡）、代码优化（提高执行速度、减少内存占用）。</p><p>评估程序对硬件资源的使用情况，例如各级cache的访问次数、各级cache的丢失次数、流水线停顿周期、前端总线访问次数等。</p><p>评估程序对操作系统资源的使用情况，系统调用次数、上下文切换次数、任务迁移次数。</p><p>事件可以分为三种：</p><ol><li>Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。</li><li>Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如进程切换，tick数等。</li><li>Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。</li></ol><h1 id="3-perf的使用"><a href="#3-perf的使用" class="headerlink" title="3. perf的使用"></a>3. perf的使用</h1><p>perf –help后可以看到perf的二级命令</p><p><img src="/2022/01/19/tool003/image-20220119120817508.png"></p><h2 id="3-1perf-list"><a href="#3-1perf-list" class="headerlink" title="3.1perf list"></a>3.1perf list</h2><p>perf list查看支持的事件类型</p><p><img src="/2022/01/19/tool003/image-20220119121131231.png"></p><h2 id="3-2perf-top"><a href="#3-2perf-top" class="headerlink" title="3.2perf top"></a>3.2perf top</h2><p>即可以正常显示perf top如下：</p><p>第一列：符号引发的性能事件的比例，指占用的cpu周期比例。</p><p>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。</p><p>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库；[k]表述此符号属于内核或模块。</p><p>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p><p><img src="/2022/01/19/tool003/image-20220119121453395.png"></p><h2 id="3-3-perf-stat"><a href="#3-3-perf-stat" class="headerlink" title="3.3 perf stat"></a>3.3 perf stat</h2><p>perf stat用于运行指令，并分析其统计结果。虽然perf top也可以指定pid，但是必须先启动应用才能查看信息。</p><p>perf stat能完整统计应用整个生命周期的信息。</p><p>命令格式为：</p><blockquote><p>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] <command><br>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] — <command> [<options>]</options></EVENT></EVENT></p></blockquote><p><img src="/2022/01/19/tool003/image-20220119122351095.png" alt="image-20220119122351095"></p><p><img src="/2022/01/19/tool003/C2DDB2280E83453D6D8FE0D11A4380C3.png"></p><p>cpu-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized &#x3D; task-clock &#x2F; time elapsed，CPU的占用率。</p><p>context-switches：程序在运行过程中上下文的切换次数。</p><p>CPU-migrations：程序在运行过程中发生的处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。</p><p>CPU迁移和上下文切换：发生上下文切换不一定会发生CPU迁移，而发生CPU迁移时肯定会发生上下文切换。发生上下文切换有可能只是把上下文从当前CPU中换出，下一次调度器还是将进程安排在这个CPU上执行。</p><p>page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。</p><p>cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles &#x2F; task-clock算出。</p><p>stalled-cycles-frontend：指令读取或解码的质量步骤，未能按理想状态发挥并行左右，发生停滞的时钟周期。</p><p>stalled-cycles-backend：指令执行步骤，发生停滞的时钟周期。</p><p>instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。</p><p>branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p><h2 id="3-4-perf-record-amp-report"><a href="#3-4-perf-record-amp-report" class="headerlink" title="3.4 perf record &amp; report"></a>3.4 perf record &amp; report</h2><p>运行一个命令，并将其数据保存到perf.data中。随后，可以使用perf report进行分析。</p><p>perf record和perf report可以更精确的分析一个应用，perf record可以精确到函数级别。并且在函数里面混合显示汇编语言和代码。</p><p><img src="/2022/01/19/tool003/image-20220119123152290.png"></p><p>1.编译程序(这里以test.c为例子)</p><p><img src="/2022/01/19/tool003/image-20220119124049654.png"></p><p>2.perf record</p><p><img src="/2022/01/19/tool003/image-20220119124217563.png"></p><p>3.perf report</p><p><img src="/2022/01/19/tool003/image-20220119124149337.png"></p><p><img src="/2022/01/19/tool003/image-20220119124013315.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/arnoldlu/p/6241297.html">系统级性能分析工具perf的介绍与使用 - ArnoldLu - 博客园 (cnblogs.com)</a>-系统性能分析工具perf的介绍与使用</p><p><a href="https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=11304698501320722134&spm_id_from=333.337.0.0">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcov代码覆盖率测试</title>
    <link href="/2022/01/18/tool002/"/>
    <url>/2022/01/18/tool002/</url>
    
    <content type="html"><![CDATA[<h1 id="gcov代码覆盖率测试"><a href="#gcov代码覆盖率测试" class="headerlink" title="gcov代码覆盖率测试"></a>gcov代码覆盖率测试</h1><h2 id="gcov的简单介绍"><a href="#gcov的简单介绍" class="headerlink" title="gcov的简单介绍"></a>gcov的简单介绍</h2><p>1.gcov是一个测试代码覆盖率的工具。与GCC一起使用来分析程序，以帮助创建更高效、更快的运行代码，并发现程序的未测试部分<br>2.是一个命令行方式的控制台程序。需要结合lcov,gcovr等前端图形工具才能实现统计数据图形化<br>3.伴随GCC发布，不需要单独下载gcov工具。配合GCC共同实现对c&#x2F;c++文件的语句覆盖和分支覆盖测试<br>4.与程序概要分析工具（profiling tool，例如gprof）一起工作，可以估计程序中哪段代码最耗时</p><h2 id="gcov能做什么"><a href="#gcov能做什么" class="headerlink" title="gcov能做什么"></a>gcov能做什么</h2><p>使用像gcov或gprof这样的分析器，您可以找到一些基本的性能统计数据：</p><ul><li>每一行代码执行的频率是多少</li><li>实际执行了哪些行代码，配合测试用例达到满意的覆盖率和预期工作</li><li>每段代码使用了多少计算时间，从而找到热点优化代码</li><li>gcov创建一个sourcefile.gcov的日志文件，此文件标识源文件sourcefile.c每一行执行的次数,您可以与gprof一起使用这些日志文件来帮助优化程序的性能。gprof提供了您可以使用的时间信息以及从gcov获得的信息。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.通过将一些代码行合并到一个函数中，可能不会提供足够的信息来查找代码使用大量计算机时间的“热点”。同样地，由于gcov按行(在最低的分辨率下)积累统计数据，它最适合于只在每行上放置一个语句的编程风格。如果您使用扩展到循环或其他控制结构的复杂宏，那么统计信息就没有那么有用了——它们只报告出现宏调用的行。如果您的复杂宏的行为类似于函数，那么您可以用inline fu替换它们。<br>2.gcov只在使用GCC编译的代码上工作。它与任何其他概要或测试覆盖机制不兼容。</p><h2 id="使用gcov的3个阶段"><a href="#使用gcov的3个阶段" class="headerlink" title="使用gcov的3个阶段"></a>使用gcov的3个阶段</h2><h3 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1.编译阶段"></a>1.编译阶段</h3><p>要开启gcov功能，需要在源码编译参数中加入-fprofile-arcs -ftest-coverage</p><ul><li>-ftest-coverage：在编译的时候产生.gcno文件，它包含了重建基本块图和相应的块的源码的行号的信息。</li><li>-fprofile-arcs：在运行编译过的程序的时候，会产生.gcda文件，它包含了弧跳变的次数等信息。</li></ul><p>以下我们以test.c这个程序为例子，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> a =<span class="hljs-number">20220118</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>编译阶段：</strong></p><p><img src="/2022/01/18/tool002/image-20220118145007919.png"></p><h3 id="2-gcov收集代码运行信息"><a href="#2-gcov收集代码运行信息" class="headerlink" title="2. gcov收集代码运行信息"></a>2. gcov收集代码运行信息</h3><ul><li>运行<code>./test</code>产生<code>test.gcda</code>文件，其中包含了代码基本块和狐跳变次数统计信息</li></ul><p><img src="/2022/01/18/tool002/image-20220118145103922.png"></p><h4 id="3-生成gcov代码覆盖率报告"><a href="#3-生成gcov代码覆盖率报告" class="headerlink" title="3. 生成gcov代码覆盖率报告"></a>3. 生成gcov代码覆盖率报告</h4><ul><li>再次运行<code>gcov test.c</code>产生的<code>test.c.gcov</code>中包含了代码覆盖率数据,其数据的来源为<code>test.gcda</code></li></ul><p><img src="/2022/01/18/tool002/image-20220118145303290.png"></p><h3 id="4-查看生成gcov代码覆盖率报告"><a href="#4-查看生成gcov代码覆盖率报告" class="headerlink" title="4.查看生成gcov代码覆盖率报告"></a>4.查看生成gcov代码覆盖率报告</h3><p><img src="/2022/01/18/tool002/image-20220118145514099.png"></p><p>可以看到以下结果：</p><ul><li>其中<code>#####</code>表示未运行的行</li><li>每行前面的数字表示行运行的次数</li><li>—代表不必执行</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">-:    <span class="hljs-number">0</span>:Source:test.c<br>-:    <span class="hljs-number">0</span>:Graph:test.gcno<br>-:    <span class="hljs-number">0</span>:Data:test.gcda<br>-:    <span class="hljs-number">0</span>:Runs:<span class="hljs-number">1</span><br>-:    <span class="hljs-number">0</span>:Programs:<span class="hljs-number">1</span><br>-:    <span class="hljs-number">1</span>:<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">1</span>:    <span class="hljs-number">2</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">-:    3:</span>&#123;<br><span class="hljs-number">1</span>:    <span class="hljs-number">4</span>:        <span class="hljs-keyword">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-number">1</span>:    <span class="hljs-number">5</span>:        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-number">5</span>:    <span class="hljs-number">6</span>:        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>-:    <span class="hljs-number">7</span>:        &#123;<br><span class="hljs-number">4</span>:    <span class="hljs-number">8</span>:           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>-:    <span class="hljs-number">9</span>:        &#125;<br><span class="hljs-number">1</span>:   <span class="hljs-number">10</span>:        <span class="hljs-keyword">int</span> a =<span class="hljs-number">20220118</span>;<br><span class="hljs-number">1</span>:   <span class="hljs-number">11</span>:        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a);<br><span class="hljs-number">1</span>:   <span class="hljs-number">12</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>-:   <span class="hljs-number">13</span>:&#125;<br></code></pre></div></td></tr></table></figure><h2 id="配合lcov使用，图形化显示"><a href="#配合lcov使用，图形化显示" class="headerlink" title="配合lcov使用，图形化显示"></a>配合lcov使用，图形化显示</h2><p><strong>1.centos安装lcov:</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">yum install lcov<br></code></pre></div></td></tr></table></figure><p><strong>2.运行lcov，生成相应信息</strong></p><p><img src="/2022/01/18/tool002/image-20220118151526665.png"></p><p>运行结果：</p><p><img src="/2022/01/18/tool002/image-20220118151553801.png"></p><p><strong>3.生成web可视化信息</strong></p><p><img src="/2022/01/18/tool002/image-20220118151821325.png"></p><p>运行结果：</p><p><img src="/2022/01/18/tool002/image-20220118151853477.png"></p><p><strong>4.打包result文件</strong></p><p><img src="/2022/01/18/tool002/image-20220118152629648.png"></p><p><strong>5.从服务器下载到本地</strong></p><p><img src="/2022/01/18/tool002/image-20220118152705023.png"></p><p><strong>6.查看web</strong></p><p>​1）查看index.html：</p><p><img src="/2022/01/18/tool002/image-20220118152825105.png"></p><p>​2）详细信息：</p><p><img src="/2022/01/18/tool002/image-20220118152908078.png"></p><p>上述界面包含：</p><ul><li>函数覆盖率（执行率）</li><li>代码行数覆盖率（执行率）</li><li>语句执行次数</li><li>源码级的详细信息</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/yanxiangyfg/article/details/80989680">(6条消息) gcov代码覆盖率测试-原理和实践总结_yanxiangyfg的专栏-CSDN博客_gcov代码覆盖率</a>-gcov代码覆盖率测试-原理和实践总结</p><p><a href="https://blog.csdn.net/u012247418/article/details/90137291">(6条消息) 代码覆盖率测试工具：gcov和lcov的使用_ARM-Linux-CSDN博客</a>-代码覆盖率测试工具：gcov和lcov的使用</p><p><a href="https://www.cnblogs.com/haoshine/p/5777735.html">linux文件夹打包命令 - 小作一个 - 博客园 (cnblogs.com)</a>-Linux文件打包命令</p><p><a href="https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=16561916178807634748&spm_id_from=333.337.0.0">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(五)-INT型数组相加操作</title>
    <link href="/2022/01/17/AVX005/"/>
    <url>/2022/01/17/AVX005/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX向量化学习-五-INT型数组相加操作"><a href="#AVX向量化学习-五-INT型数组相加操作" class="headerlink" title="AVX向量化学习(五)-INT型数组相加操作"></a>AVX向量化学习(五)-INT型数组相加操作</h1><p>使用AVX指令集进行2个INT型的数组相加操作</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256i _mm256_loadu_si256 (__m256i <span class="hljs-keyword">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure><p><strong>Synopsis</strong></p><p>m256i _mm256_loadu_si256 (m256i const * mem_addr)<br>#include &lt;immintrin.h&gt;<br>Instruction: vmovdqu ymm, m256<br>CPUID Flags: AVX</p><p><strong>Description</strong></p><p>Load 256-bits of integer data from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">dst[<span class="hljs-number">255</span>:<span class="hljs-number">0</span>] := MEM[mem_addr+<span class="hljs-number">255</span>:mem_addr] <br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">7</td><td align="center">0.5</td></tr><tr><td align="left">Skylake</td><td align="center">7</td><td align="center">0.5</td></tr><tr><td align="left">Broadwell</td><td align="center">1</td><td align="center">0.25</td></tr><tr><td align="left">Haswell</td><td align="center">1</td><td align="center">0.25</td></tr><tr><td align="left">Ivy Bridge</td><td align="center">1</td><td align="center">0.5</td></tr></tbody></table><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256i _mm256_add_epi32 (__m256i a, __m256i b)<br></code></pre></div></td></tr></table></figure><p><strong>Synopsis</strong></p><p>m256i _mm256_add_epi32 (m256i a, __m256i b)<br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd ymm, ymm, ymm<br>CPUID Flags: AVX2</p><p><strong>Description</strong></p><p>Add packed 32-bit integers in a and b, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">FOR</span> j := <span class="hljs-number">0</span> to <span class="hljs-number">7</span> <br>     <span class="hljs-attribute">i</span> := j*<span class="hljs-number">32</span> <br>     <span class="hljs-attribute">dst</span>[i+<span class="hljs-number">31</span>:i] := a[i+<span class="hljs-number">31</span>:i] + b[i+<span class="hljs-number">31</span>:i] <br><span class="hljs-attribute">ENDFOR</span> <br><span class="hljs-attribute">dst</span>[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">1</td><td align="center">0.33</td></tr><tr><td align="left">Skylake</td><td align="center">1</td><td align="center">0.33</td></tr><tr><td align="left">Broadwell</td><td align="center">1</td><td align="center">0.5</td></tr><tr><td align="left">Haswell</td><td align="center">1</td><td align="center">0.5</td></tr></tbody></table><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">40</span>];<br><span class="hljs-keyword">int</span> b[<span class="hljs-number">40</span>];<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> ans1[<span class="hljs-number">40</span>];    <span class="hljs-comment">//记录串行结果 </span><br><span class="hljs-keyword">int</span> ans2[<span class="hljs-number">40</span>]; <span class="hljs-comment">//记录AVX向量化后的结果</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br>a[i]=i;<br>b[i]=<span class="hljs-number">2</span>*i;<br>&#125;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br>ans1[i]=a[i]+b[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;串行计算结果：\n&quot;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans1[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>__m256i v0;<br>__m256i v1;<br>__m256i v2;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span><span class="hljs-number">-8</span>;i+=<span class="hljs-number">8</span>)<br>&#123;<br>v0 = _mm256_loadu_si256((<span class="hljs-keyword">const</span> __m256i*)(a+i)); <span class="hljs-comment">//强制类型转换</span><br>v1 = _mm256_loadu_si256((<span class="hljs-keyword">const</span> __m256i*)(b+i)); <span class="hljs-comment">//强制类型转化</span><br>v2 = _mm256_add_epi32(v0,v1);     <span class="hljs-comment">//v0+v1</span><br>_mm256_storeu_si256((__m256i*)(ans2+i),v2);<br><br>&#125;<span class="hljs-comment">//边界处理</span><br><span class="hljs-keyword">for</span> (;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br>ans2[i]=a[i]+b[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;并行计算结果：\n&quot;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans2[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">串行计算结果：<br><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">15</span> <span class="hljs-number">18</span> <span class="hljs-number">21</span> <span class="hljs-number">24</span> <span class="hljs-number">27</span> <span class="hljs-number">30</span> <span class="hljs-number">33</span> <span class="hljs-number">36</span> <span class="hljs-number">39</span> <span class="hljs-number">42</span> <span class="hljs-number">45</span> <span class="hljs-number">48</span> <span class="hljs-number">51</span> <span class="hljs-number">54</span> <span class="hljs-number">57</span> <span class="hljs-number">60</span> <span class="hljs-number">63</span> <span class="hljs-number">66</span> <span class="hljs-number">69</span> <span class="hljs-number">72</span> <span class="hljs-number">75</span> <span class="hljs-number">78</span> <span class="hljs-number">81</span> <span class="hljs-number">84</span> <span class="hljs-number">87</span> <span class="hljs-number">90</span> <span class="hljs-number">93</span> <span class="hljs-number">96</span> <span class="hljs-number">99</span> <span class="hljs-number">102</span> <span class="hljs-number">105</span> <span class="hljs-number">108</span> <span class="hljs-number">111</span> <span class="hljs-number">114</span> <span class="hljs-number">117</span><br>并行计算结果：<br><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">15</span> <span class="hljs-number">18</span> <span class="hljs-number">21</span> <span class="hljs-number">24</span> <span class="hljs-number">27</span> <span class="hljs-number">30</span> <span class="hljs-number">33</span> <span class="hljs-number">36</span> <span class="hljs-number">39</span> <span class="hljs-number">42</span> <span class="hljs-number">45</span> <span class="hljs-number">48</span> <span class="hljs-number">51</span> <span class="hljs-number">54</span> <span class="hljs-number">57</span> <span class="hljs-number">60</span> <span class="hljs-number">63</span> <span class="hljs-number">66</span> <span class="hljs-number">69</span> <span class="hljs-number">72</span> <span class="hljs-number">75</span> <span class="hljs-number">78</span> <span class="hljs-number">81</span> <span class="hljs-number">84</span> <span class="hljs-number">87</span> <span class="hljs-number">90</span> <span class="hljs-number">93</span> <span class="hljs-number">96</span> <span class="hljs-number">99</span> <span class="hljs-number">102</span> <span class="hljs-number">105</span> <span class="hljs-number">108</span> <span class="hljs-number">111</span> <span class="hljs-number">114</span> <span class="hljs-number">117</span><br></code></pre></div></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(四)-INT类型转化成DOUBLE类型</title>
    <link href="/2022/01/17/AVX004/"/>
    <url>/2022/01/17/AVX004/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX向量化学习-四-INT类型转化成DOUBLE类型"><a href="#AVX向量化学习-四-INT类型转化成DOUBLE类型" class="headerlink" title="AVX向量化学习(四)-INT类型转化成DOUBLE类型"></a>AVX向量化学习(四)-INT类型转化成DOUBLE类型</h1><p>使用AVX指令集把INT类型转化为DOUBLE类型</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m128i _mm_setr_epi32 (<span class="hljs-keyword">int</span> e3, <span class="hljs-keyword">int</span> e2, <span class="hljs-keyword">int</span> e1, <span class="hljs-keyword">int</span> e0)<br></code></pre></div></td></tr></table></figure><p><strong>Synopsis</strong></p><p>__m128i _mm_setr_epi32 (int e3, int e2, int e1, int e0)<br>#include &lt;emmintrin.h&gt;<br>Instruction: <strong>Sequence</strong><br>CPUID Flags: SSE2</p><p><strong>Description</strong></p><p>Set packed 32-bit integers in dst with the supplied values in reverse order.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">dst[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] := e3 <br>dst[<span class="hljs-number">63</span>:<span class="hljs-number">32</span>] := e2 <br>dst[<span class="hljs-number">95</span>:<span class="hljs-number">64</span>] := e1 <br>dst[<span class="hljs-number">127</span>:<span class="hljs-number">96</span>] := e0<br></code></pre></div></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256d _mm256_cvtepi32_pd (__m128i a)<br></code></pre></div></td></tr></table></figure><p><strong>Synopsis</strong></p><p>m256d _mm256_cvtepi32_pd (m128i a)<br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtdq2pd ymm, xmm<br>CPUID Flags: AVX</p><p><strong>Description</strong></p><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span> <br>    i := j*<span class="hljs-number">32</span> <br>    m := j*<span class="hljs-number">64</span> <br>    dst[m+<span class="hljs-number">63</span>:m] := <span class="hljs-built_in">Convert_Int32_To_FP64</span>(a[i+<span class="hljs-number">31</span>:i]) <br>ENDFOR <br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">7</td><td align="center">1</td></tr><tr><td align="left">Skylake</td><td align="center">7</td><td align="center">1</td></tr><tr><td align="left">Broadwell</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="left">Haswell</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="left">Ivy Bridge</td><td align="center">4</td><td align="center">1</td></tr></tbody></table><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>g++ int_to_double.cpp -msse2 -mavx -o test01</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>.&#x2F;test01</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    __m128i x = _mm_setr_epi32(a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>],a[<span class="hljs-number">3</span>]);   <span class="hljs-comment">//load</span><br> __m256d v5=_mm256_cvtepi32_pd(x);       <span class="hljs-comment">//convert</span><br>    _mm256_storeu_pd(b,v5);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>    &#123;<br>    cout&lt;&lt;b[i]&lt;&lt;endl;<br>&#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gprof、gprof2dot.py、dot使用方法简介</title>
    <link href="/2022/01/09/tool001/"/>
    <url>/2022/01/09/tool001/</url>
    
    <content type="html"><![CDATA[<h1 id="gprof、gprof2dot-py、dot使用方法简介"><a href="#gprof、gprof2dot-py、dot使用方法简介" class="headerlink" title="gprof、gprof2dot.py、dot使用方法简介"></a>gprof、gprof2dot.py、dot使用方法简介</h1><h2 id="1-：gprof使用步骤如下，以SLIC为例："><a href="#1-：gprof使用步骤如下，以SLIC为例：" class="headerlink" title="(1)：gprof使用步骤如下，以SLIC为例："></a>(1)：gprof使用步骤如下，以SLIC为例：</h2><h3 id="1-在编译过程中添加-pg选项，命令如下："><a href="#1-在编译过程中添加-pg选项，命令如下：" class="headerlink" title="1 在编译过程中添加-pg选项，命令如下："></a>1 在编译过程中添加-pg选项，命令如下：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">gcc -pg SLIC.cpp -o SLIC<br></code></pre></div></td></tr></table></figure><h3 id="2-运行程序，运行结束之后会形成文件gmon-out，命令如下"><a href="#2-运行程序，运行结束之后会形成文件gmon-out，命令如下" class="headerlink" title="2 运行程序，运行结束之后会形成文件gmon.out，命令如下:"></a>2 运行程序，运行结束之后会形成文件gmon.out，命令如下:</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./SLIC</span><br></code></pre></div></td></tr></table></figure><h3 id="3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下："><a href="#3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下：" class="headerlink" title="3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下："></a>3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下：</h3><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">gprof ./SLIC &gt; <span class="hljs-keyword">prof</span>.<span class="hljs-built_in">log</span><br></code></pre></div></td></tr></table></figure><p>分析prof.log就可以获得程序的调用关系、函数执行时间等信息。对gprof的分析方法见以下blog</p><p><a href="http://blog.csdn.net/macky0668/article/details/6839517">http://blog.csdn.net/macky0668/article/details/6839517</a></p><h2 id="2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台"><a href="#2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台" class="headerlink" title="(2)：配合gprof2dot.py与dot工具的使用(我是安装在了Win10平台)"></a>(2)：配合<em>gprof2dot.py</em>与dot工具的使用(我是安装在了Win10平台)</h2><p>以上方法仍然存在一个问题就是分析结果不够直观，特别是函数的调用关系。因此为解决以上问题，可以配合<em>gprof2dot.py</em>与dot工具的使用。</p><h3 id="1-安装gprof2dot-py与dot"><a href="#1-安装gprof2dot-py与dot" class="headerlink" title="1.安装gprof2dot.py与dot"></a>1.安装<em>gprof2dot.py</em>与dot</h3><p><a href="https://github.com/jrfonseca/gprof2dot">GitHub - jrfonseca&#x2F;gprof2dot: Converts profiling output to a dot graph.</a></p><h3 id="2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具"><a href="#2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具" class="headerlink" title="2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具"></a>2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具</h3><p><a href="https://graphviz.org/download/source/">Source Code | Graphviz</a></p><p>在使用上述工具前，还需要先产生prof.log文件，prof.log文件的产生方法见上文。</p><h3 id="3-首先通过命令行进入你安装gprof2dot-py的根目录："><a href="#3-首先通过命令行进入你安装gprof2dot-py的根目录：" class="headerlink" title="3.首先通过命令行进入你安装gprof2dot.py的根目录："></a>3.首先通过命令行进入你安装gprof2dot.py的根目录：</h3><p><img src="/2022/01/09/tool001/image-20220109165659998.png"></p><h3 id="4-通过以下命令即可得到函数调用图："><a href="#4-通过以下命令即可得到函数调用图：" class="headerlink" title="4.通过以下命令即可得到函数调用图："></a>4.通过以下命令即可得到函数调用图：</h3><p><img src="/2022/01/09/tool001/image-20220109170212157.png"></p><h3 id="5-结果如下："><a href="#5-结果如下：" class="headerlink" title="5.结果如下："></a>5.结果如下：</h3><p><img src="/2022/01/09/tool001/image-20220109170315471.png"></p><h2 id="3-：接上文补充几点可能无法产生gmon-out文件的情况："><a href="#3-：接上文补充几点可能无法产生gmon-out文件的情况：" class="headerlink" title="(3)：接上文补充几点可能无法产生gmon.out文件的情况："></a>(3)：接上文补充几点可能无法产生gmon.out文件的情况：</h2><p>  1.程序不是从main return或exit()退出，则可能不生成gmon.out。<br>  2.程序如果崩溃，可能不生成gmon.out。<br>  3.测试发现在虚拟机上运行，可能不生成gmon.out。<br>  4.程序忽略SIGPROF信号！一定不能捕获、忽略SIGPROF信号。man手册对SIGPROF的解释是：profiling timer expired. 如果忽略这个信号，gprof的输出则是：Each sample counts as 0.01 seconds. no time accumulated.<br>  5.如果程序运行时间非常短，则gprof可能无效</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://blog.csdn.net/u012927281/article/details/51132064">(4条消息) gprof、gprof2dot.py、dot使用方法简介_Andy.Wang的博客-CSDN博客_gprof2dot</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/01/04/Algorithm004/"/>
    <url>/2022/01/04/Algorithm004/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集（Disjoint Set）是一种非常精巧而实用的数据结构。用于处理不相交集合的合并问题。</p><p>并查集用来管理元素分组情况。并查集可以高效地进行如下操作。</p><p>1.查询元素 a和元素 b是否属于同一组。<br>2.合并元素 a和元素 b所在的组。<br><img src="/2022/01/04/Algorithm004/20191114081139557.png"></p><p><img src="/2022/01/04/Algorithm004/20191114081642983-16413015433853.png"></p><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><p>我们准备 n个节点来表示 n个元素。最开始时没有边。</p><p><img src="/2022/01/04/Algorithm004/20191114081846480.png"></p><h2 id="2-查询"><a href="#2-查询" class="headerlink" title="2.查询"></a>2.查询</h2><p>为了查询两个节点是否属于同一组，我们需要沿着树向上走，来查询包含这个元素的树的根是谁。如果两个节点走到了同一个根，那么就可以知道它们属于同一组。</p><p>在下图中，元素 2 和元素 5都走到了元素 1，因此它们属于同一组。另一方面，由于元素 7 走到的是元素 6，因此同元素 2或元素 5 属于不同组。</p><p><img src="/2022/01/04/Algorithm004/20191114082935860.png"></p><h2 id="3-合并"><a href="#3-合并" class="headerlink" title="3.合并"></a>3.合并</h2><p>像下图一样，从一个组的根向另一个组的根连边，这样两棵树就变成了一棵树， 也就把两个组合并为一个组了。</p><p><img src="/2022/01/04/Algorithm004/20191114082505100.png"></p><h2 id="4-路径压缩"><a href="#4-路径压缩" class="headerlink" title="4.路径压缩"></a>4.路径压缩</h2><p>上面的查询程序 find() 沿着搜索路径找到根结点，这条路径可能很长。</p><p>优化：沿路径返回时，顺便把 i 所属的集改成根结点。下次再搜，复杂度是 O(1)。</p><p>这种方法称为路径压缩，在递归过程中，整个搜索路径上的元素所属的集都被改为根结点。</p><p>路径压缩的思想是，我们只关心每个结点的父结点，而并不太关心树的真正的结构。路径压缩不仅优化了下次查询，而且也优化了合并，因为合并时也用到了查询。<br><img src="/2022/01/04/Algorithm004/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODE1MTg4,size_16,color_FFFFFF,t_70.png"><img src="/2022/01/04/Algorithm004/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODE1MTg4,size_16,color_FFFFFF,t_70-16413019286669.png"></p><h2 id="5-按秩合并"><a href="#5-按秩合并" class="headerlink" title="5.按秩合并"></a>5.按秩合并</h2><p>合并元素 x 和 y 时，先搜到它们的根结点；<br>合并这两个根结点：把一个根结点的集改成另一个根结点。<br>这两个根结点的高度不同，把高度较小的集合并到较大的集上，能减少树的高度。</p><p><img src="/2022/01/04/Algorithm004/20191114090118888.png"></p><p>这样，在初始化时就要用一个数组定义元素 i的高度，在合并时更改。</p><p>下面代码加入了上述两个优化，我们用编号代表每个元素。数组 par[ ]表示的是父亲的编号，par[ x ] &#x3D; &#x3D; x  时，x 是所在的树的根。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> par[N];   <span class="hljs-comment">//父亲</span><br><span class="hljs-keyword">int</span> rank[N];  <span class="hljs-comment">//树的高度</span><br><br><span class="hljs-comment">// 初始化n个元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>par[i] = i;<br>rank[i] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查询树的根（路径压缩）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(par[x] == x)<br><span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> par[x] = <span class="hljs-built_in">find</span>(par[x]);<br>&#125;<br><br><span class="hljs-comment">// 合并x和y所属的集合（按秩合并）</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>x = <span class="hljs-built_in">find</span>(x);<br>y = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(x == y)  <span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span>(rank[x] &lt; rank[y])<br>par[x] = y;<br><span class="hljs-keyword">else</span><br>&#123;<br>par[y] = x;<br><span class="hljs-keyword">if</span>(rank[x] == rank[y])rank[x]++;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="样题一：L2-024-部落-25-分"><a href="#样题一：L2-024-部落-25-分" class="headerlink" title="样题一：L2-024 部落 (25 分)"></a>样题一：<strong>L2-024 部落 (25 分)</strong></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查任意两个人是否属于同一个部落。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤104），是已知小圈子的个数。随后<em>N</em>行，每行按下列格式给出一个小圈子里的人：</p><p><em>K</em> <em>P</em>[1] <em>P</em>[2] ⋯ <em>P</em>[<em>K</em>]</p><p>其中<em>K</em>是小圈子里的人数，<em>P</em>[<em>i</em>]（<em>i</em>&#x3D;1,⋯,<em>K</em>）是小圈子里每个人的编号。这里所有人的编号从1开始连续编号，最大编号不会超过104。</p><p>之后一行给出一个非负整数<em>Q</em>（≤104），是查询次数。随后<em>Q</em>行，每行给出一对被查询的人的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出<code>Y</code>，否则输出<code>N</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">4<br>3 10 1 2<br>2 3 4<br>4 1 5 7 8<br>3 9 6 4<br>2<br>10 5<br>3 7结尾无空行<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">10 2<br>Y<br>N结尾无空行<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  N=<span class="hljs-number">10005</span>;<br><span class="hljs-keyword">int</span> par[N];       <span class="hljs-comment">//父亲</span><br><span class="hljs-keyword">int</span> deep[N];      <span class="hljs-comment">//树的高度</span><br><span class="hljs-keyword">int</span> isroot[N];    <span class="hljs-comment">//用来记录互不相交的部落的个数。如果同属于一个部落，那个这个部落的元素的根节点都是一样的。</span><br>                  <span class="hljs-comment">//所以只要统计有多少个根节点就可以知道有多少个互不相交的部落个数</span><br>set&lt;<span class="hljs-keyword">int</span>&gt; st;      <span class="hljs-comment">//集合能很好的过滤到重复元素，可以很方便的用来统计不是重复元素的个数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        par[i] = i;<br>        deep[i] =<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(par[x] == x ) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> par[x] = <span class="hljs-built_in">find</span>(par[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    x=<span class="hljs-built_in">find</span>(x);<br>    y=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(deep[x]&lt;deep[y])<br>    &#123;<br>        par[x]=y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        par[y]=x;<br>        <span class="hljs-keyword">if</span>(deep[x]==deep[y]) deep[x]++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">10005</span>);<br>    <span class="hljs-built_in">memset</span>(isroot,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(isroot));<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> num,first;<br>        cin&gt;&gt;num&gt;&gt;first;<br>        st.<span class="hljs-built_in">insert</span>(first);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;num ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> next;<br>            cin&gt;&gt;next;<br>            st.<span class="hljs-built_in">insert</span>(next);<br>            <span class="hljs-built_in">unite</span>(first,next);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//寻找互不相交的部落</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=st.<span class="hljs-built_in">size</span>() ; ++l) &#123;<br>        isroot[<span class="hljs-built_in">find</span>(l)]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">1</span>; m &lt;=st.<span class="hljs-built_in">size</span>() ; ++m) &#123;<br>        ans+=isroot[m];<br>    &#125;<br>    cout&lt;&lt;st.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">int</span> time;<br>    cin&gt;&gt;time;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;time ; ++k) &#123;<br>        <span class="hljs-keyword">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b))<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Y&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;N&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="相关资料："><a href="#相关资料：" class="headerlink" title="相关资料："></a>相关资料：</h2><p><a href="https://blog.csdn.net/qq_42815188/article/details/86769629">(3条消息) 并查集_早睡身体好hh-CSDN博客_并查集</a>：早睡身体好hh-并查集(CSDN)</p><h2 id="样题链接："><a href="#样题链接：" class="headerlink" title="样题链接："></a>样题链接：</h2><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805056736444416">题目详情 - L2-024 部落 (25 分) (pintia.cn)</a>：L2-024 部落 (25 分)</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径-Floyed和Dijkstra</title>
    <link href="/2022/01/03/Algorithm003/"/>
    <url>/2022/01/03/Algorithm003/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径-Floyed和Dijkstra"><a href="#最短路径-Floyed和Dijkstra" class="headerlink" title="最短路径-Floyed和Dijkstra"></a>最短路径-Floyed和Dijkstra</h1><h2 id="Floyed"><a href="#Floyed" class="headerlink" title="Floyed"></a>Floyed</h2><h3 id="样题一：P1364-医院设置"><a href="#样题一：P1364-医院设置" class="headerlink" title="样题一：P1364 医院设置"></a>样题一：P1364 医院设置</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设有一棵二叉树，如图：</p><p><img src="/2022/01/03/Algorithm003/166.png"></p><p>其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 11。如上图中，若医院建在1 处，则距离和 &#x3D;4+12+2\times20+2\times40&#x3D;136&#x3D;4+12+2×20+2×40&#x3D;136；若医院建在 33 处，则距离和 &#x3D;4\times2+13+20+40&#x3D;81&#x3D;4×2+13+20+40&#x3D;81。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>第一行一个整数 n<em>n</em>，表示树的结点数。</p><p>接下来的 n<em>n</em> 行每行描述了一个结点的状况，包含三个整数 w, u, v<em>w</em>,<em>u</em>,<em>v</em>，其中 w<em>w</em> 为居民人口数，u<em>u</em> 为左链接（为 00 表示无链接），v<em>v</em> 为右链接（为 00 表示无链接）。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>一个整数，表示最小距离和。</p><h4 id="输入输出样例："><a href="#输入输出样例：" class="headerlink" title="输入输出样例："></a>输入输出样例：</h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">13 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">40 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">81<br></code></pre></div></td></tr></table></figure><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> tree[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];   <span class="hljs-comment">//tree的作用邻接矩阵建树</span><br><span class="hljs-keyword">int</span> w[<span class="hljs-number">1000</span>],l,r;  <span class="hljs-comment">//w每个结点的居民人口数</span><br><span class="hljs-keyword">int</span> mindis;       <span class="hljs-comment">//最小记录和</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            tree[i][j]=<span class="hljs-number">0X3FFFFFFF</span>;    <span class="hljs-comment">//初始化邻接矩阵</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>        tree[i][i]=<span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化</span><br>        cin&gt;&gt;w[i]&gt;&gt;l&gt;&gt;r;  <span class="hljs-comment">//读入数据</span><br>        <span class="hljs-keyword">if</span>(l&gt;<span class="hljs-number">0</span>) tree[i][l]=tree[l][i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(r&gt;<span class="hljs-number">0</span>) tree[i][r]=tree[r][i]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;=n ; ++k) <span class="hljs-comment">//用Floyed求任意两结点之间的最短路径</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(i!=k)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ; ++j) &#123;<br>                    <span class="hljs-keyword">if</span>(i!=j&amp;&amp;j!=k&amp;&amp;tree[i][k]+tree[k][j]&lt;tree[i][j])<br>                    &#123;<br>                        tree[i][j]=tree[i][k]+tree[k][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    mindis=INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//穷举医院建在N个结点，找出最短距离</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            sum+=tree[i][j]*w[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&lt;mindis) mindis=sum;<br>    &#125;<br>    cout&lt;&lt;mindis&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="样题二："><a href="#样题二：" class="headerlink" title="样题二："></a>样题二：</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p><img src="/2022/01/03/Algorithm003/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x5bm5fbWc=,size_16,color_FFFFFF,t_70.png"></p><p>输入n和m，代表n个节点，m条边，然后是m行输入，每行有x,y,z，代表x到y的路距离为z。<br>问题：从1出发到各点的最短路径</p><h4 id="测试样例："><a href="#测试样例：" class="headerlink" title="测试样例："></a>测试样例：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">7</span> <span class="hljs-number">12</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">20</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">50</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">30</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">25</span><br><span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">70</span><br><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">40</span><br><span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">50</span><br><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">25</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">55</span><br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span><br><span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">70</span><br><span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">50</span><br><span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span><br><span class="hljs-attribute">70</span><br></code></pre></div></td></tr></table></figure><h4 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">int</span> mapdis[maxn][maxn];  <span class="hljs-comment">//表示x-&gt;y的距离(有向)</span><br><span class="hljs-keyword">int</span> dis[maxn];  <span class="hljs-comment">//代表最短路径长</span><br><span class="hljs-keyword">int</span> path[maxn];  <span class="hljs-comment">//记录前驱节点</span><br><span class="hljs-keyword">int</span> vis[maxn]; <span class="hljs-comment">//用来记录该点是否已经是最短路径的点</span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dis));<br>    <span class="hljs-built_in">memset</span>(path,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(path));<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>    <br>    dis[s]=<span class="hljs-number">0</span>;   <span class="hljs-comment">//自身到自身的距离是0</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; <span class="hljs-comment">//用来记录当轮的起始点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;dis[i]&lt;dis[k])     <span class="hljs-comment">//如果这个点还不为最短路径的点，并且这个点的路径是现在所有点中最小的</span><br>            &#123;<br>                k=i;      <span class="hljs-comment">//那么就记录这个点为当轮的起始点</span><br>                  <span class="hljs-comment">//特殊的这里第一次找到的是起点，及s=1。</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!k) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//所有点已经为最短路径的点，则返回</span><br>        vis[k]=<span class="hljs-number">1</span>;       <span class="hljs-comment">//标记该点为最短路径的点</span><br>        <span class="hljs-comment">//松弛操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=n ; ++j) &#123;   <br>            <span class="hljs-comment">//第一次循环只有起点的邻接点的距离被更新</span><br>            <span class="hljs-comment">//每次都更新找到，新找到的点的邻接点(新找到的点也就是当轮的起始点)</span><br>            <span class="hljs-keyword">if</span>(dis[j]&gt;dis[k]+mapdis[k][j])  <span class="hljs-comment">//最短路是由最短路+某一条固定路组成</span><br>            &#123;<br>                dis[j]=dis[k]+mapdis[k][j];<span class="hljs-comment">//路径被改变</span><br>                path[j]=k;<span class="hljs-comment">//重新记录前驱，最短路是由最短路+某一条固定路组成，所以前驱是有效的</span><br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-comment">//递归打印</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">print</span>(path[x]);<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(mapdis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(mapdis));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> x,y,z;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-comment">//记录x-&gt;y的距离</span><br>        mapdis[x][y]=z;<br>    &#125;<br>    <span class="hljs-built_in">Dijkstra</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//求1出发到各点的最短路径</span><br>    <span class="hljs-keyword">int</span> order;    <span class="hljs-comment">//读入终点</span><br>    cin&gt;&gt;order;<br>    <span class="hljs-built_in">print</span>(path[order]);  <span class="hljs-comment">//打印最短路径</span><br>    cout&lt;&lt;order&lt;&lt;endl;<br>    cout&lt;&lt;dis[order];    <span class="hljs-comment">//最短路径长</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="样题三：L2-001-紧急救援-25-分"><a href="#样题三：L2-001-紧急救援-25-分" class="headerlink" title="样题三：L2-001 紧急救援 (25 分)"></a>样题三：<strong>L2-001 紧急救援 (25 分)</strong></h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h4><p>输入第一行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0 ~ (<em>N</em>−1)；<em>M</em>是快速道路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。</p><p>第二行给出<em>N</em>个正整数，其中第<em>i</em>个数是第<em>i</em>个城市的救援队的数目，数字间以空格分隔。随后的<em>M</em>行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h4><p>第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从<em>S</em>到<em>D</em>的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span><br><span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">10</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>结尾无空行<br></code></pre></div></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">2</span> <span class="hljs-number">60</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>结尾无空行<br></code></pre></div></td></tr></table></figure><h4 id="最短路径条数："><a href="#最短路径条数：" class="headerlink" title="最短路径条数："></a>最短路径条数：</h4><p>如果通过 <strong>index</strong> 点能把最短路径更新，那么最短路径条数就是从起点到<strong>index</strong>的最短路径条数。</p><p><img src="/2022/01/03/Algorithm003/134d3eff026ab567e3a337c45dda5d61.png"></p><p>例如这张图，如果<strong>index</strong>可以更新当前的最短路径，并且s通过1和2到达index点的距离都相等，那么从s到d的最短路径条数其实就是从s到index的最短路径条数，由此可以得到第一个式子</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">num[i]=num[index];<br></code></pre></div></td></tr></table></figure><p>如果通过index点的周转，距离不变（依然是最小值），这说明通过index周转使得最短路径条数又多出了一部分，只需要用之前得到的最短路径条数加上num[index]即可，由此得出第二个式子</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">num[i]+=num[index];<br></code></pre></div></td></tr></table></figure><h4 id="程序源代码：-2"><a href="#程序源代码：-2" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m,s,d;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">505</span>;<br><span class="hljs-keyword">int</span> arr[maxn];   <span class="hljs-comment">//记录每个城市的援兵数</span><br><span class="hljs-keyword">int</span> dismap[maxn][maxn];    <span class="hljs-comment">//储存X-Y的长度</span><br><span class="hljs-keyword">int</span> path[maxn];    <span class="hljs-comment">//前驱节点</span><br><span class="hljs-keyword">int</span> dis[maxn];     <span class="hljs-comment">//最短路径</span><br><span class="hljs-keyword">int</span> cost[maxn];    <span class="hljs-comment">//最大救援队数量</span><br><span class="hljs-keyword">int</span> vis[maxn];     <span class="hljs-comment">//用来记录该点是否已经是最短路径的点</span><br><span class="hljs-keyword">int</span> num[maxn];     <span class="hljs-comment">//最短路径的条数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(path,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(path));<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dis));<br>    <span class="hljs-built_in">memset</span>(cost,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(cost));<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>    <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num));<br>    dis[s]=<span class="hljs-number">0</span>;<br>    cost[s]=arr[s];   <span class="hljs-comment">//此时救援队数量等于出发点的救援队数量</span><br>    num[s]=<span class="hljs-number">1</span>;         <span class="hljs-comment">//一条最短路径</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> maxt =<span class="hljs-number">0x3f</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;dis[i]&lt;maxt)<br>            &#123;<br>                k=i;<br>                maxt=dis[i];<br>            &#125;<br>        &#125;<br>        vis[k]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;dis[j]&gt;dis[k]+dismap[k][j])&#123;<br>                dis[j]=dis[k]+dismap[k][j];<br>                path[j]=k;<br>                num[j]=num[k];   <span class="hljs-comment">//如果能更新，说明产生了新的最短路径，num[i]变为从s到k的路径条数</span><br>                cost[j] = cost[k]+arr[j];  <span class="hljs-comment">//产生了新的最短路径,人数为cost[k]+arr[j]</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vis[j]&amp;&amp;dis[j]==dis[k]+dismap[k][j])&#123; <span class="hljs-comment">//存在新的最短路径</span><br>                num[j]+=num[k];   <span class="hljs-comment">//最短路径条数更新</span><br>                <span class="hljs-comment">//无论援兵量是否能更新，既然已经有了另一条路与当前最短路长度相同</span><br><span class="hljs-comment">//就说明多了一些最短路条数</span><br>                <span class="hljs-keyword">if</span>(cost[j]&lt;cost[k]+arr[j])   <span class="hljs-comment">//援兵量能更新</span><br>                &#123;<br>                    cost[j]=cost[k]+arr[j];<br>                    path[j]=k;<br><br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">print</span>(path[x]);<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d;<br>    <span class="hljs-built_in">memset</span>(arr,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr));<br>    <span class="hljs-built_in">memset</span>(dismap,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dismap));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;n ; ++j) &#123;<br>        cin&gt;&gt;arr[j];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;m ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> x,y,z;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-comment">//此题是无向图</span><br>        dismap[x][y]=z;<br>        dismap[y][x]=z;<br>    &#125;<br>    <span class="hljs-built_in">dijk</span>(s);<br>    cout&lt;&lt;num[d]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cost[d]&lt;&lt;endl;<span class="hljs-comment">//打印最短路径条数和最大援兵数</span><br>    <span class="hljs-built_in">print</span>(path[d]);<br>    cout&lt;&lt;d&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="相关题目链接："><a href="#相关题目链接：" class="headerlink" title="相关题目链接："></a>相关题目链接：</h2><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://www.luogu.com.cn/problem/P1364">P1364 医院设置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></a>]: “ 样题一：P1364 医院设置”</p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805073643683840">题目详情 - L2-001 紧急救援 (25 分) (pintia.cn)</a> ：样题三：L2-001 紧急救援 (25 分)</p><p><a href="https://www.freesion.com/article/8556971489/">L2-001 紧急救援 (25 分)&amp;&amp;dijkstra - 灰信网（软件开发博客聚合） (freesion.com)</a>：样题三参考资料</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(五)-环形拓扑上利用MPI进行通信</title>
    <link href="/2022/01/01/mpi005/"/>
    <url>/2022/01/01/mpi005/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI学习-五-环形拓扑上利用MPI进行通信"><a href="#MPI学习-五-环形拓扑上利用MPI进行通信" class="headerlink" title="MPI学习(五)-环形拓扑上利用MPI进行通信"></a>MPI学习(五)-环形拓扑上利用MPI进行通信</h1><p>这里，我们演示了一个简单的MPI程序，它使用阻塞通信原语send和receive来进行广播操作：</p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpic++ mpi005.cpp -o mpi005</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>srun -p amd_256 -N 1 -n  4   .&#x2F;mpi005(使用SLURM任务调度系统)</p><p>1个分区，核数为4</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> rank, value, size;<br>MPI_Status status;<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc, &amp;argv);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;rank);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;size);<br><br><span class="hljs-keyword">if</span>(rank == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;value );<br><span class="hljs-comment">/*Master node sends out the value*/</span><br><span class="hljs-built_in">MPI_Send</span>(&amp;value, <span class="hljs-number">1</span>, MPI_INT, rank + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD);&#125;<span class="hljs-comment">//</span><br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">/*Slave nodes block on receive the send on the value*/</span><br>        <span class="hljs-comment">//接受上一个进程发送的消息</span><br><span class="hljs-built_in">MPI_Recv</span>(&amp;value, <span class="hljs-number">1</span>, MPI_INT, rank - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,MPI_COMM_WORLD, &amp;status);<br><br><span class="hljs-keyword">if</span>(rank &lt; size<span class="hljs-number">-1</span>)<br>&#123;<br>            <span class="hljs-comment">//向下一个进程发送消息</span><br><span class="hljs-built_in">MPI_Send</span>(&amp;value, <span class="hljs-number">1</span>, MPI_INT, rank + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, MPI_COMM_WORLD);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process %d got %d\n&quot;</span>, rank, value);<br>&#125;<br><span class="hljs-built_in">MPI_Finalize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br><br></code></pre></div></td></tr></table></figure><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//5 5为读入的value值</span><br>process <span class="hljs-number">1</span> got <span class="hljs-number">5</span><br>process <span class="hljs-number">2</span> got <span class="hljs-number">5</span><br>process <span class="hljs-number">3</span> got <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graph-Data Structure</title>
    <link href="/2021/12/22/algorithm002/"/>
    <url>/2021/12/22/algorithm002/</url>
    
    <content type="html"><![CDATA[<h1 id="Graph-Data-Structure"><a href="#Graph-Data-Structure" class="headerlink" title="Graph-Data Structure"></a>Graph-Data Structure</h1><h2 id="1-邻接表的应用"><a href="#1-邻接表的应用" class="headerlink" title="1.邻接表的应用"></a>1.邻接表的应用</h2><h3 id="样题一：L2-025-分而治之-25-分"><a href="#样题一：L2-025-分而治之-25-分" class="headerlink" title="样题一：L2-025 分而治之 (25 分)"></a>样题一：L2-025 分而治之 (25 分)</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">Np v<span class="hljs-selector-attr">[1]</span> v<span class="hljs-selector-attr">[2]</span> ... v<span class="hljs-selector-attr">[Np]</span><br></code></pre></div></td></tr></table></figure><p>其中 <code>Np</code> 是该方案中计划攻下的城市数量，后面的系列 <code>v[i]</code> 是计划攻下的城市编号。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>对每一套方案，如果可行就输出<code>YES</code>，否则输出<code>NO</code>。</p><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v[<span class="hljs-number">10005</span>]; <span class="hljs-comment">//声明邻接表</span><br>    <span class="hljs-keyword">int</span> n,num;<br>    cin&gt;&gt;n&gt;&gt;num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;num ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> start,end;<br>        cin&gt;&gt;start&gt;&gt;end;<br>        <span class="hljs-comment">//创建邻接表</span><br>        v[start].<span class="hljs-built_in">push_back</span>(end); <br>        v[end].<span class="hljs-built_in">push_back</span>(start);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> k;<br>    cin&gt;&gt;k;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;k ; ++j) &#123;<br>        <span class="hljs-keyword">int</span> np;<br>        cin&gt;&gt;np;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> book[<span class="hljs-number">10005</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//每轮炸毁城市初始化</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=np ; ++i) &#123;<br>            <span class="hljs-keyword">int</span> dead;<br>            cin&gt;&gt;dead;<br>            book[dead]=<span class="hljs-number">1</span>; <span class="hljs-comment">//被炸毁的城市标记为1</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;=n ; ++l) &#123;<br>            <br>            <span class="hljs-keyword">if</span>(book[l]==<span class="hljs-number">0</span>)<span class="hljs-comment">//没有被炸毁的城市</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;v[l].<span class="hljs-built_in">size</span>() ; ++i) &#123; <span class="hljs-comment">//遍历该城市的邻接表</span><br>                    <br>                    <span class="hljs-keyword">if</span>(book[v[l][i]]==<span class="hljs-number">0</span>) <span class="hljs-comment">//存在着还连通的城市</span><br>                    &#123;<br>                        flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//说明方案不可行</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="程序输入："><a href="#程序输入：" class="headerlink" title="程序输入："></a>程序输入：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">10</span> <span class="hljs-number">11</span><br><span class="hljs-number">8</span> <span class="hljs-number">7</span><br><span class="hljs-number">6</span> <span class="hljs-number">8</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-number">8</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">9</span> <span class="hljs-number">8</span><br><span class="hljs-number">9</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">10</span><br><span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span> <span class="hljs-number">10</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span><br><span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">NO<br>YES<br>YES<br>NO<br>NO<br></code></pre></div></td></tr></table></figure><h2 id="题目相关链接："><a href="#题目相关链接：" class="headerlink" title="题目相关链接："></a>题目相关链接：</h2><p>[<a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]">https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]</a>: “样例一:L2-025 分而治之 (25 分)”</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS-深度优先搜索</title>
    <link href="/2021/12/21/algorithm001/"/>
    <url>/2021/12/21/algorithm001/</url>
    
    <content type="html"><![CDATA[<h1 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS-深度优先搜索"></a>DFS-深度优先搜索</h1><h2 id="样题1-全排列"><a href="#样题1-全排列" class="headerlink" title="样题1-全排列"></a>样题1-全排列</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>输入一个数n，输出n的全排列</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">int</span> book[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> step)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span>(step==n+<span class="hljs-number">1</span>)  <span class="hljs-comment">//这里表示dfs结束,没有可以排的数字了</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>;  i&lt;=n ; i++) &#123;<br>            cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(book[i]==<span class="hljs-number">0</span>)  <span class="hljs-comment">//说明数字i还没有被使用,可以用来排列</span><br>        &#123;<br>            a[step]=i;<span class="hljs-comment">//排列数字i</span><br>            book[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//标记数字i为已使用</span><br>            <span class="hljs-built_in">dfs</span>(step+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//继续排列没有使用的数字</span><br>            book[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//这里表示dfs调用结束了,意思是数字i已经全部排列完了，但还需要</span><br>            <span class="hljs-comment">//按照顺序将数字i收回，重新排列。</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//dfs函数的开始</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序输入："><a href="#程序输入：" class="headerlink" title="程序输入："></a>程序输入：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><h3 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><h2 id="样题二-自然数的拆分问题"><a href="#样题二-自然数的拆分问题" class="headerlink" title="样题二-自然数的拆分问题"></a>样题二-自然数的拆分问题</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。现在给你一个自然数n，要求你求出n的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。</p><h3 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> num;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">100000</span>]=&#123;<span class="hljs-number">1</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//输出一种拆分方案</span><br><br>            <span class="hljs-keyword">if</span>(i!=t<span class="hljs-number">-1</span>) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;+&quot;</span>;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;a[i];<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=a[t<span class="hljs-number">-1</span>];i&lt;=n;i++) &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;num)<span class="hljs-comment">//当前数i要大于等于前一位数，且不超过n</span><br>        &#123;<br>            a[t]=i;<span class="hljs-comment">//保存当前拆分的数i</span><br>            n-=i;<span class="hljs-comment">//n减去数i，n的值将继续拆分</span><br>            <span class="hljs-built_in">dfs</span>(n,t+<span class="hljs-number">1</span>);<br>            n+=i;<span class="hljs-comment">//回溯：加上拆分的数，以便产生所有可能的拆分</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;num;<br>    <span class="hljs-built_in">dfs</span>(num,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序输入：-1"><a href="#程序输入：-1" class="headerlink" title="程序输入："></a>程序输入：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure><h3 id="程序输出：-1"><a href="#程序输出：-1" class="headerlink" title="程序输出："></a>程序输出：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">3</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">4</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span><br><span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">5</span><br><span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">4</span><br><span class="hljs-number">1</span>+<span class="hljs-number">3</span>+<span class="hljs-number">3</span><br><span class="hljs-number">1</span>+<span class="hljs-number">6</span><br><span class="hljs-number">2</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span><br><span class="hljs-number">2</span>+<span class="hljs-number">5</span><br><span class="hljs-number">3</span>+<span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><h2 id="样例三：L2-038-病毒溯源-25-分"><a href="#样例三：L2-038-病毒溯源-25-分" class="headerlink" title="样例三：L2-038 病毒溯源 (25 分)"></a>样例三：<strong>L2-038 病毒溯源 (25 分)</strong></h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>病毒容易发生变异。某种病毒可以通过突变产生若干变异的毒株，而这些变异的病毒又可能被诱发突变产生第二代变异，如此继续不断变化。</p><p>现给定一些病毒之间的变异关系，要求你找出其中最长的一条变异链。</p><p>在此假设给出的变异都是由突变引起的，不考虑复杂的基因重组变异问题 —— 即每一种病毒都是由唯一的一种病毒突变而来，并且不存在循环变异的情况。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出一个正整数 <em>N</em>（≤104），即病毒种类的总数。于是我们将所有病毒从 0 到 <em>N</em>−1 进行编号。</p><p>随后 <em>N</em> 行，每行按以下格式描述一种病毒的变异情况：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">k</span> 变异株<span class="hljs-number">1</span> …… 变异株k<br></code></pre></div></td></tr></table></figure><p>其中 <code>k</code> 是该病毒产生的变异毒株的种类数，后面跟着每种变异株的编号。第 <em>i</em> 行对应编号为 <em>i</em> 的病毒（0≤<em>i</em>&lt;<em>N</em>）。题目保证病毒源头有且仅有一个。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先输出从源头开始最长变异链的长度。</p><p>在第二行中输出从源头开始最长的一条变异链，编号间以 1 个空格分隔，行首尾不得有多余空格。如果最长链不唯一，则输出最小序列。</p><p>注：我们称序列 { <em>a</em>1,⋯,<em>a**n</em> } 比序列 { <em>b</em>1,⋯,<em>b**n</em> } “小”，如果存在 1≤<em>k</em>≤<em>n</em> 满足 <em>a**i</em>&#x3D;<em>b**i</em> 对所有 <em>i</em>&lt;<em>k</em> 成立，且 <em>a**k</em>&lt;<em>b**k</em>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">10<br>3 6 4 8<br>0<br>0<br>0<br>2 5 9<br>0<br>1 7<br>1 2<br>0<br>2 3 1结尾无空行<br></code></pre></div></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">4<br>0 4 9 1结尾无空行<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码：-2"><a href="#程序源代码：-2" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; ans, tmp;<br><span class="hljs-keyword">bool</span> a[<span class="hljs-number">10005</span>][<span class="hljs-number">10005</span>];<br><span class="hljs-keyword">bool</span> book[<span class="hljs-number">10005</span>];<br><span class="hljs-keyword">int</span> maxn;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root,<span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(len&gt;maxn)<br>    &#123;<br>        maxn =len;<br>        ans = tmp;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == maxn &amp;&amp; tmp &lt; ans)<br>    &#123;<br>        ans = tmp;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[root][i]) <span class="hljs-comment">//连通</span><br>        &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(i,len+<span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">int</span> root=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;n ; ++i) &#123;<br>        <span class="hljs-keyword">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;k ; ++j) &#123;<br>            <span class="hljs-keyword">int</span> x;<br>            cin&gt;&gt;x;<br>            book[x]=<span class="hljs-literal">true</span>;    <span class="hljs-comment">//用来判断谁是病毒源头，题目给出病毒源头有且仅有一个</span><br>            a[i][x]=<span class="hljs-literal">true</span>;    <span class="hljs-comment">//使用邻接矩阵来储存图，连通为true，否则为false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(book[root]) root++;  <span class="hljs-comment">//寻找病毒源头</span><br>    tmp.<span class="hljs-built_in">push_back</span>(root);<br>    <span class="hljs-built_in">dfs</span>(root,<span class="hljs-number">1</span>); <span class="hljs-comment">//从病毒源头开始dfs</span><br>    cout&lt;&lt;ans.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//输出格式控制</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); i++)&#123;<br>       <span class="hljs-keyword">if</span>(i!=ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>       &#123;<br>           cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span><br>       &#123;<br>           cout&lt;&lt;ans[i];<br>       &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="样题四：L2-020-功夫传人-25-分"><a href="#样题四：L2-020-功夫传人-25-分" class="headerlink" title="样题四：L2-020 功夫传人 (25 分)"></a>样题四：<strong>L2-020 功夫传人 (25 分)</strong></h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。</p><p>这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第<code>i</code>代传人只能在第<code>i-1</code>代传人中拜1个师傅。我们假设已知祖师爷的功力值为<code>Z</code>，每向下传承一代，就会减弱<code>r%</code>，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。</p><h3 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出3个正整数，分别是：<em>N</em>（≤105）——整个师门的总人数（于是每个人从0到<em>N</em>−1编号，祖师爷的编号为0）；<em>Z</em>——祖师爷的功力值（不一定是整数，但起码是正数）；<em>r</em> ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有<em>N</em>行，第<em>i</em>行（<em>i</em>&#x3D;0,⋯,<em>N</em>−1）描述编号为<em>i</em>的人所传的徒弟，格式为：</p><p><em>K**i</em> ID[1] ID[2] ⋯ ID[<em>K**i</em>]</p><p>其中<em>K**i</em>是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。<em>K**i</em>为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。</p><h3 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过1010。</p><h3 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs in">10 18.0 1.00<br>3 2 3 5<br>1 9<br>1 4<br>1 7<br>0 7<br>2 6 1<br>1 8<br>0 9<br>0 4<br>0 3结尾无空行<br></code></pre></div></td></tr></table></figure><h3 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs out">404<br>结尾无空行<br></code></pre></div></td></tr></table></figure><h3 id="程序源代码：-3"><a href="#程序源代码：-3" class="headerlink" title="程序源代码："></a>程序源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; tree[<span class="hljs-number">100000</span>];  <span class="hljs-comment">//用于邻接表建树</span><br><span class="hljs-keyword">int</span> book[<span class="hljs-number">100000</span>];<br><span class="hljs-keyword">double</span> sum;<br><span class="hljs-keyword">double</span> r;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">double</span> power)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(book[index]) <span class="hljs-comment">//是得道者就乘他的倍数 </span><br>    &#123;<br>        sum += power * book[index];<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tree[index].<span class="hljs-built_in">size</span>();i++)  <span class="hljs-comment">//遍历整个树</span><br>    &#123;<br>        <span class="hljs-built_in">dfs</span>(tree[index][i],power*r);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">double</span> z;<br>    cin&gt;&gt;n&gt;&gt;z&gt;&gt;r;<br>    r=(<span class="hljs-number">100</span>-r)/<span class="hljs-number">100.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)   <span class="hljs-comment">//这个弟子是否为得道者</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> power;<br>            cin&gt;&gt;power;<br>            book[i]=power;   <span class="hljs-comment">//记录得道者放大倍数</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k;j++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> id;<br>                cin&gt;&gt;id;<br>                tree[i].<span class="hljs-built_in">push_back</span>(id);      <span class="hljs-comment">//使用邻接表建树</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,z);<br>    cout&lt;&lt;(<span class="hljs-keyword">int</span>)sum&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="题目相关链接："><a href="#题目相关链接：" class="headerlink" title="题目相关链接："></a>题目相关链接：</h2><p>[<a href="https://www.luogu.com.cn/problem/P2404">P2404 自然数的拆分问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>]: “ 样例二-自然数的拆分问题”</p><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652361">题目详情 - L2-038 病毒溯源 (25 分) (pintia.cn)</a></a>]: “ 样例三-L2-038 病毒溯源 (25 分)”</p><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805059118809088">题目详情 - L2-020 功夫传人 (25 分) (pintia.cn)</a></a>]: “ 样例四-L2-020 功夫传人 (25 分)”</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning(一) 一个神经元网络-线性函数</title>
    <link href="/2021/12/09/tensorflow001/"/>
    <url>/2021/12/09/tensorflow001/</url>
    
    <content type="html"><![CDATA[<h1 id="一个神经元的网络-线性函数"><a href="#一个神经元的网络-线性函数" class="headerlink" title="一个神经元的网络(线性函数)"></a>一个神经元的网络(线性函数)</h1><p>线性函数 y &#x3D; 2 * x -1 </p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#构建模型</span><br>model = keras.Sequential([keras.layers.Dense(units=<span class="hljs-number">1</span>,input_shape=[<span class="hljs-number">1</span>])])<br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;sgd&#x27;</span>,loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>)<br><span class="hljs-comment">#准备训练数据</span><br>xs=np.array([-<span class="hljs-number">1.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">4.0</span>], dtype = <span class="hljs-built_in">float</span>)<br>ys=np.array([-<span class="hljs-number">3.0</span>,-<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">5.0</span>,<span class="hljs-number">7.0</span>], dtype = <span class="hljs-built_in">float</span>)<br><span class="hljs-comment">#训练模型</span><br>model.fit(xs,ys,epochs=<span class="hljs-number">500</span>)<br></code></pre></div></td></tr></table></figure><h2 id="训练模型过程-截取"><a href="#训练模型过程-截取" class="headerlink" title="训练模型过程(截取)"></a>训练模型过程(截取)</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">Epoch <span class="hljs-number">1</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 388ms/step - loss: <span class="hljs-number">3.4976</span><br>Epoch <span class="hljs-number">2</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">2.9127</span><br>Epoch <span class="hljs-number">3</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">2.4493</span><br>Epoch <span class="hljs-number">4</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">2.0814</span><br>Epoch <span class="hljs-number">5</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.7888</span><br>Epoch <span class="hljs-number">6</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.5555</span><br>Epoch <span class="hljs-number">7</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.3689</span><br>Epoch <span class="hljs-number">8</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.2191</span><br>Epoch <span class="hljs-number">9</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 3ms/step - loss: <span class="hljs-number">1.0983</span><br>Epoch <span class="hljs-number">10</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">1.0005</span><br>Epoch <span class="hljs-number">11</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 4ms/step - loss: <span class="hljs-number">0.9207</span><br>Epoch <span class="hljs-number">12</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 2ms/step - loss: <span class="hljs-number">0.8551</span><br>Epoch <span class="hljs-number">13</span>/<span class="hljs-number">500</span><br><span class="hljs-number">1</span>/<span class="hljs-number">1</span> [==============================] - 0s 5ms/step - loss: <span class="hljs-number">0.8009</span><br></code></pre></div></td></tr></table></figure><h2 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#使用模型(输入)</span><br><span class="hljs-built_in">print</span>(model.predict([<span class="hljs-number">2021</span>]))<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#输出</span><br>[[<span class="hljs-number">4036.6035</span>]]<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#输入</span><br>model.predict([<span class="hljs-number">10.0</span>])<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#输出</span><br>array([[<span class="hljs-number">18.984968</span>]], dtype=float32)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tensorflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(四)-广播、散播、收集、归约和全归约的MPI语法</title>
    <link href="/2021/11/27/mpi004/"/>
    <url>/2021/11/27/mpi004/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-广播、散播、收集、归约和全归约的MPI语法"><a href="#MPI-广播、散播、收集、归约和全归约的MPI语法" class="headerlink" title="MPI-广播、散播、收集、归约和全归约的MPI语法"></a>MPI-广播、散播、收集、归约和全归约的MPI语法</h1><h2 id="广播：MPI-Bcast"><a href="#广播：MPI-Bcast" class="headerlink" title="广播：MPI_Bcast"></a>广播：MPI_Bcast</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Bcast</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *buffer, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> root, MPI_Comm comm)</span></span><br><span class="hljs-function"><span class="hljs-comment">//int root 广播数据的根进程的标识号(整型)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi001.png"></p><h2 id="散播：MPI-Scatter"><a href="#散播：MPI-Scatter" class="headerlink" title="散播：MPI_Scatter"></a>散播：MPI_Scatter</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Scatter</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">int</span> sendcount, MPI_Datatype sendtype, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> root, MPI_Comm comm)</span></span><br><span class="hljs-function"><span class="hljs-comment">//void *sendbuf 发送消息缓冲区的起始地址(可选数据类型)</span></span><br><span class="hljs-function"><span class="hljs-comment">//void *recvbuf 接收消息缓冲区的起始地址(可选数据类型)</span></span><br><span class="hljs-function"></span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi002.png"></p><h2 id="收集：MPI-Gather"><a href="#收集：MPI-Gather" class="headerlink" title="收集：MPI_Gather"></a>收集：MPI_Gather</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Gather</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">int</span> sendcount, MPI_Datatype sendtype, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> recvcount, MPI_Datatype recvtype, <span class="hljs-keyword">int</span> root, MPI_Comm comm)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi003.png"></p><h2 id="归约：MPI-Reduce"><a href="#归约：MPI-Reduce" class="headerlink" title="归约：MPI_Reduce"></a>归约：MPI_Reduce</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Reduce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, MPI_Op op, <span class="hljs-keyword">int</span> root,  MPI_Comm comm)</span></span><br><span class="hljs-function"><span class="hljs-comment">//MPI_Op op  归约操作符(句柄)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi004.png"></p><p><img src="/2021/11/27/mpi004/mpi005.png"></p><h2 id="全归约：MPI-Allreduce"><a href="#全归约：MPI-Allreduce" class="headerlink" title="全归约：MPI_Allreduce"></a>全归约：MPI_Allreduce</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Allreduce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *sendbuf, <span class="hljs-keyword">void</span> *recvbuf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/mpi004/mpi006.png"></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(三)-通过OpenmMP使用MPI</title>
    <link href="/2021/11/26/mpi003/"/>
    <url>/2021/11/26/mpi003/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-通过OpenMP使用MPI"><a href="#MPI-通过OpenMP使用MPI" class="headerlink" title="MPI-通过OpenMP使用MPI"></a>MPI-通过OpenMP使用MPI</h1><p>OpenMP是另一种为基于共享内存的并行编程提供的应用编程接口。当人们想使用多核处理器时，通常使用OpenMP。下面是一个“Hello World”程序，使用了MPI和OpenMP的API。</p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpic++    -fopenmp  mpi003.cpp -o mpi003</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>srun -p amd_256 -N 2 -n  2   .&#x2F;mpi003(使用SLURM任务调度系统)</p><p>2个分区，核数为2</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;omp.h&gt;</span>  <span class="hljs-comment">//OpenMP所需要的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> myid, numprocs;<br><span class="hljs-keyword">int</span> namelen;<br><span class="hljs-keyword">int</span> thread_id , nthreads;<br><span class="hljs-keyword">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc, &amp;argv);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;myid);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;numprocs);<br><span class="hljs-built_in">MPI_Get_processor_name</span>(processor_name, &amp;namelen);<br>    <span class="hljs-comment">//构造并行区</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel private(thread_id, nthreads) num_threads(8) <span class="hljs-comment">//设置线程数为8</span></span><br>&#123;<br>thread_id = <span class="hljs-built_in">omp_get_thread_num</span>();  <span class="hljs-comment">//获得当前线程的id</span><br>nthreads = <span class="hljs-built_in">omp_get_num_threads</span>();  <span class="hljs-comment">//获得总的线程数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread number %d (on %d) for the MPI process number %d (on %d) [%s]\n&quot;</span>,<br>thread_id, nthreads, myid, numprocs, processor_name);<br>&#125; <br><span class="hljs-built_in">MPI_Finalize</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Thread number <span class="hljs-number">0</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">4</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">3</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">5</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">2</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">6</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">0</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">1</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">2</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">5</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">1</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">7</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">1</span> (on <span class="hljs-number">2</span>) [eb1316.para.bscc]<br>Thread number <span class="hljs-number">3</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">4</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">6</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br>Thread number <span class="hljs-number">7</span> (on <span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> the MPI process number <span class="hljs-number">0</span> (on <span class="hljs-number">2</span>) [eb1314.para.bscc]<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(二)-非阻塞通信程序(无缓冲)</title>
    <link href="/2021/11/26/mpi002/"/>
    <url>/2021/11/26/mpi002/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-非阻塞通信程序-无缓冲"><a href="#MPI-非阻塞通信程序-无缓冲" class="headerlink" title="MPI-非阻塞通信程序(无缓冲)"></a>MPI-非阻塞通信程序(无缓冲)</h1><p>非阻塞通信程序(无缓冲)是由MPI中的Isend和Ireceive来表示的，即异步通信。在这种情况下，发送进程发布一条“发送授权请求”(挂起的消息)的消息，并继续其程序的执行。当接收进程发布一个“同意发送”许可指令时，数据传输就启动了。所有的这些机制都是通过操作系统的信号进行内部管理的。当数据传输完成时，检查状态并指示进程是否可以安全地进行读&#x2F;写数据。                                                                      需要注意的是原语MPI_Wait(&amp;request,&amp;status)等到数据传输完成(或中断后)，使用一个成为status的状态变量来指示数据传输是否已经成功。</p><h2 id="相关的MPI原语"><a href="#相关的MPI原语" class="headerlink" title="相关的MPI原语"></a>相关的MPI原语</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Isend</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> dest, <span class="hljs-keyword">int</span> tag, MPI_comm comm, MPI_Request *req)</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Irecv</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">int</span> count, MPI_Datatype datatype, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> tag, MPI_Comm comm, MPI_Request *req)</span></span><br></code></pre></div></td></tr></table></figure><p>MPI_Request结构中经常使用的：当*req操作完成时返回 *flag &#x3D; 1,否则返回 0。</p><p>原语MPI_Wait一直等到*req所执行的操作完成。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MPI_Wait</span><span class="hljs-params">(MPI_Request *req, MPI_Status *status)</span></span><br></code></pre></div></td></tr></table></figure><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpicc  mpi002.cpp -o mpi002</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>mpirun -np 10   .&#x2F;mpi002(本地提交,采取10个进程)</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> myid, numprocs;<br><span class="hljs-keyword">int</span> tag,source,destination,count;<br><span class="hljs-keyword">int</span> buffer;<br>MPI_Status status;<br>MPI_Request request;<br><span class="hljs-built_in">MPI_Init</span>(&amp;argc,&amp;argv);<br><span class="hljs-built_in">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;numprocs);<br><span class="hljs-built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;myid);<br>tag =<span class="hljs-number">2021</span>; <span class="hljs-comment">/* any integer to tag messages */</span><br>source = <span class="hljs-number">0</span>;<br>count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(myid != source )<br>&#123;<br>buffer =<span class="hljs-number">2077</span>;<br><span class="hljs-comment">//其他进程向0号进程发送消息</span><br><span class="hljs-built_in">MPI_Isend</span>(&amp;buffer,count,MPI_INT,source,tag,MPI_COMM_WORLD,&amp;request);<br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor %d send %d to processor %d\n&quot;</span>,myid,buffer,source);<br>&#125;<br><br><span class="hljs-keyword">if</span>(myid == source )<br>&#123;<br><span class="hljs-comment">//0号进程接收来自其他进程的消息</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;numprocs;i++)<br>&#123;<br><span class="hljs-built_in">MPI_Irecv</span>(&amp;buffer,count,MPI_INT,i,tag,MPI_COMM_WORLD,&amp;request);<br><span class="hljs-built_in">MPI_Wait</span>(&amp;request,&amp;status);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;processor %d received %d from processor %d \n&quot;</span>,myid,buffer,i);<br>&#125;<br><br>&#125;<br><br><span class="hljs-built_in">MPI_Finalize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">processor <span class="hljs-number">2</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">3</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">5</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">6</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">7</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">8</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">9</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">4</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">1</span> send <span class="hljs-number">2077</span> to processor <span class="hljs-number">0</span><br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">1</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">2</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">3</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">4</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">5</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">6</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">7</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">8</span> <br>processor <span class="hljs-number">0</span> received <span class="hljs-number">2077</span> from processor <span class="hljs-number">9</span> <br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(三)-if判断的处理</title>
    <link href="/2021/11/24/AVX003/"/>
    <url>/2021/11/24/AVX003/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX-if判断的处理"><a href="#AVX-if判断的处理" class="headerlink" title="AVX-if判断的处理"></a>AVX-if判断的处理</h1><p>使用AVX指令集对if判断进行处理</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)<br></code></pre></div></td></tr></table></figure><p><strong>Description</strong></p><p>Blend packed double-precision (64-bit) floating-point elements from a and b using mask, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span><br>i := j*<span class="hljs-number">64</span><br>IF mask[i+<span class="hljs-number">63</span>]<br>dst[i+<span class="hljs-number">63</span>:i] := b[i+<span class="hljs-number">63</span>:i]<br>ELSE<br>dst[i+<span class="hljs-number">63</span>:i] := a[i+<span class="hljs-number">63</span>:i]<br>FI<br>ENDFOR<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">__m256d _mm256_cmp_pd (__m256d a, __m256d b, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> imm8)<br></code></pre></div></td></tr></table></figure><p><strong>Description</strong></p><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in dst.</p><p><strong>Operation</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">CASE</span> (imm8[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]) OF<br><span class="hljs-number">0</span>: OP := _CMP_EQ_OQ<br><span class="hljs-number">1</span>: OP := _CMP_LT_OS<br><span class="hljs-number">2</span>: OP := _CMP_LE_OS<br><span class="hljs-number">3</span>: OP := _CMP_UNORD_Q <br><span class="hljs-number">4</span>: OP := _CMP_NEQ_UQ<br><span class="hljs-number">5</span>: OP := _CMP_NLT_US<br><span class="hljs-number">6</span>: OP := _CMP_NLE_US<br><span class="hljs-number">7</span>: OP := _CMP_ORD_Q<br><span class="hljs-number">8</span>: OP := _CMP_EQ_UQ<br><span class="hljs-number">9</span>: OP := _CMP_NGE_US<br><span class="hljs-number">10</span>: OP := _CMP_NGT_US<br><span class="hljs-number">11</span>: OP := _CMP_FALSE_OQ<br><span class="hljs-number">12</span>: OP := _CMP_NEQ_OQ<br><span class="hljs-number">13</span>: OP := _CMP_GE_OS<br><span class="hljs-number">14</span>: OP := _CMP_GT_OS<br><span class="hljs-number">15</span>: OP := _CMP_TRUE_UQ<br><span class="hljs-number">16</span>: OP := _CMP_EQ_OS<br><span class="hljs-number">17</span>: OP := _CMP_LT_OQ<br><span class="hljs-number">18</span>: OP := _CMP_LE_OQ<br><span class="hljs-number">19</span>: OP := _CMP_UNORD_S<br><span class="hljs-number">20</span>: OP := _CMP_NEQ_US<br><span class="hljs-number">21</span>: OP := _CMP_NLT_UQ<br><span class="hljs-number">22</span>: OP := _CMP_NLE_UQ<br><span class="hljs-number">23</span>: OP := _CMP_ORD_S<br><span class="hljs-number">24</span>: OP := _CMP_EQ_US<br><span class="hljs-number">25</span>: OP := _CMP_NGE_UQ <br><span class="hljs-number">26</span>: OP := _CMP_NGT_UQ <br><span class="hljs-number">27</span>: OP := _CMP_FALSE_OS <br><span class="hljs-number">28</span>: OP := _CMP_NEQ_OS <br><span class="hljs-number">29</span>: OP := _CMP_GE_OQ<br><span class="hljs-number">30</span>: OP := _CMP_GT_OQ<br><span class="hljs-number">31</span>: OP := _CMP_TRUE_US<br>ESAC<br>FOR j := <span class="hljs-number">0</span> to <span class="hljs-number">3</span><br>i := j*<span class="hljs-number">64</span><br>dst[i+<span class="hljs-number">63</span>:i] := ( a[i+<span class="hljs-number">63</span>:i] OP b[i+<span class="hljs-number">63</span>:i] ) ? <span class="hljs-number">0xFFFFFFFFFFFFFFFF</span> : <span class="hljs-number">0</span><br>ENDFOR<br>dst[MAX:<span class="hljs-number">256</span>] := <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> a[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>,<span class="hljs-number">4.4</span>,<span class="hljs-number">5.5</span>,<span class="hljs-number">6.6</span>,<span class="hljs-number">7.7</span>,<span class="hljs-number">8.8</span>,<span class="hljs-number">2.1</span>&#125;;<br><span class="hljs-keyword">double</span> b[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">3.2</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">8.6</span>,<span class="hljs-number">3.7</span>,<span class="hljs-number">9.9</span>,<span class="hljs-number">5.1</span>,<span class="hljs-number">4.2</span>,<span class="hljs-number">6.6</span>&#125;;<br><span class="hljs-keyword">double</span> d[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>&#125;;     <span class="hljs-comment">//记录原始if判断后的值</span><br><span class="hljs-keyword">double</span> e[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>&#125;;     <span class="hljs-comment">//记录AVX-if判断后的值</span><br><br>__m256d v0;<br>__m256d v1;<br>__m256d v2,v3;<br>__m256d v4;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&gt;b[i])<br>&#123;<br>d[i] = a[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>d[i]=b[i];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span><span class="hljs-number">-4</span>;i+=<span class="hljs-number">4</span>)<br>&#123;<br>v0 = _mm256_loadu_pd(a+i);<br>v1 = _mm256_loadu_pd(b+i);<br>v2=_mm256_add_pd(v0,v1);<br>v3 =_mm256_blendv_pd(v0,v1,_mm256_cmp_pd(v0,v1,_CMP_LE_OQ));<br>_mm256_storeu_pd(e+i,v3);<br><br>&#125;<br>    <br><span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&gt;b[i])<br>&#123;<br>e[i] = a[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>e[i]=b[i];<br>&#125;<br>&#125;<br>    <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is d.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,d[i]);<br>&#125;<br>    <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is e with AVX.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,e[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">this</span> is d.<br><span class="hljs-number">2.100000</span><br><span class="hljs-number">3.200000</span><br><span class="hljs-number">6.400000</span><br><span class="hljs-number">8.600000</span><br><span class="hljs-number">5.500000</span><br><span class="hljs-number">9.900000</span><br><span class="hljs-number">7.700000</span><br><span class="hljs-number">8.800000</span><br><span class="hljs-number">6.600000</span><br><span class="hljs-keyword">this</span> is e with AVX.<br><span class="hljs-number">2.100000</span><br><span class="hljs-number">3.200000</span><br><span class="hljs-number">6.400000</span><br><span class="hljs-number">8.600000</span><br><span class="hljs-number">5.500000</span><br><span class="hljs-number">9.900000</span><br><span class="hljs-number">7.700000</span><br><span class="hljs-number">8.800000</span><br><span class="hljs-number">6.600000</span><br></code></pre></div></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p><p>[<a href="https://stackoverflow.com/questions/16988199/how-to-choose-avx-compare-predicate-variants">simd - How to choose AVX compare predicate variants - Stack Overflow</a>]: “Stack Overflow”</p><p>[<a href="https://www.officedaytime.com/simd512e/simdimg/si.php?f=blendvpd">blendvpd (officedaytime.com)</a>]: “_mm256_Blendv_pd()原理解释”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
