<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>内存对齐</title>
    <link href="/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><h2 id="CPU读取内存的方式"><a href="#CPU读取内存的方式" class="headerlink" title="CPU读取内存的方式"></a>CPU读取内存的方式</h2><p>CPU读取内存的方式其实非常复杂，为了更进一步的了解相关的原理，需要对计算机组成原理进行深度学习。</p><h3 id="Memory-access-granularity-内存读取粒度"><a href="#Memory-access-granularity-内存读取粒度" class="headerlink" title="Memory access granularity(内存读取粒度)"></a>Memory access granularity(内存读取粒度)</h3><p>However, your computer’s processor does not read from and write to memory in byte-sized chunks. Instead, it accesses memory in two-, four-, eight- 16- or even 32-byte chunks. We’ll call the size in which a processor accesses memory its memory access granularity.</p><p>CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为<em>memory access granularity（粒度）</em> 本人把它翻译为“内存读取粒度” 。</p><p><a href="https://www.cnblogs.com/feng9exe/p/10059543.html">https://www.cnblogs.com/feng9exe/p/10059543.html</a> ”内存对齐“</p><h2 id="内存对齐举例"><a href="#内存对齐举例" class="headerlink" title="内存对齐举例"></a>内存对齐举例</h2><p>假设此计算机的内存读取粒度是4。</p><h3 id="如果内存对齐时"><a href="#如果内存对齐时" class="headerlink" title="如果内存对齐时"></a>如果内存对齐时</h3><p>前提知识：</p><p>1 Byte &#x3D; 8bit </p><p>1 int8 占用 1 Byte</p><p>1 int16 占用 2 Byte</p><p>1 int32 占用 4 Byte</p><pre><code class="c++">//一个结构体的定义如下struct S&#123;    int8 a;    int32 b;&#125;</code></pre><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th align="center">4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>int8 a</td><td></td><td></td><td></td><td align="center">int32 b</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>我们可以发现int8 a储存在0号内存上，占用1个Byte，1-3号内存空下了3个Byte。int32 b储存在了4-7号内存，一共4个Byte。</p><p>由于此计算机的内存读取粒度时是4</p><p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p><p>当需要读取b(4-7号内存时)，计算机会读取4-7号内存，访问次数1次。</p><h3 id="如果内存没有对齐时"><a href="#如果内存没有对齐时" class="headerlink" title="如果内存没有对齐时"></a>如果内存没有对齐时</h3><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr><td>int8 a</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td>int32 b</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>我们可以发现int8 a储存在0号内存上，占用了1个Byte。int32 b储存在1-4号内存上，一共4个Byte。</p><p>由于此计算机的内存读取粒度时是4</p><p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p><p>当需要读取b(1-4号内存)时，计算机会先读取0-3号一组内存，去掉0号内存，再读取4-7号一组内存，去掉5-7号内存，随后再拼接1-3号内存和4号内存组成完整的b。访问次数2次。</p><h2 id="内存对齐的目的"><a href="#内存对齐的目的" class="headerlink" title="内存对齐的目的"></a>内存对齐的目的</h2><p>合理的内存对齐可以高效的利用硬件性能，减少处理器内存访问次数。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0</a> “内存对齐”</p><p><a href="https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0</a> “内存对齐对程序性能的影响”</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(一)-简单的发送接收</title>
    <link href="/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/"/>
    <url>/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-简单的发送接收"><a href="#MPI-简单的发送接收" class="headerlink" title="MPI-简单的发送接收"></a>MPI-简单的发送接收</h1><p>打印来自进程问候语句的MPI程序</p><h2 id="所使用的MPI原语"><a href="#所使用的MPI原语" class="headerlink" title="所使用的MPI原语"></a>所使用的MPI原语</h2><p><img src="/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi001.png"></p><p><img src="/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi002.png"></p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpicc  3.1.cpp -o 3.1</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>mpirun -np 4 .&#x2F;3.1(本地提交,采取4个进程)</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;mpi.h&gt;   //头文件const int MAX_STRING = 100 ;int main(int argc,char **argv)&#123;    char greeting[MAX_STRING];    int comm_sz;    int my_rank;    MPI_Status status;    MPI_Init(&amp;argc,&amp;argv);    MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);    MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);        if(my_rank != 0)    &#123;        //其他进程向0号进程发消息        sprintf(greeting,&quot;Greetings from process %d of %d!&quot;,my_rank,comm_sz);        MPI_Send(greeting,strlen(greeting)+1,MPI_CHAR,0,0,MPI_COMM_WORLD);     &#125;    else    &#123;        printf(&quot;Greetings from process %d of %d!\n&quot;,my_rank,comm_sz);        //0号进程接受来自其他进程的消息并输出        for(int q=1;q&lt;comm_sz;q++)        &#123;            MPI_Recv(greeting,MAX_STRING,MPI_CHAR,q,0,MPI_COMM_WORLD,&amp;status);            printf(&quot;%s\n&quot;,greeting);        &#125;    &#125;    MPI_Finalize();        return 0;&#125;</code></pre><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><pre><code class="c++">Greetings from process 0 of 4!Greetings from process 1 of 4!Greetings from process 2 of 4!Greetings from process 3 of 4!</code></pre>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(二)-内存对齐的应用</title>
    <link href="/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX指令集的简单操作-内存对齐版"><a href="#AVX指令集的简单操作-内存对齐版" class="headerlink" title="AVX指令集的简单操作(内存对齐版)"></a>AVX指令集的简单操作(内存对齐版)</h1><p>使用AVX指令集进行2个double型的数组相加操作</p><h2 id="常用的内存对齐函数"><a href="#常用的内存对齐函数" class="headerlink" title="常用的内存对齐函数"></a>常用的内存对齐函数</h2><p>因为AVX中要求mem__addr必须在32字节边界上对齐，否则可能会产生通用保护异常。  </p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><pre><code class="c++">double*a =(double*)memalign(32,9*sizeof(double));</code></pre><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><pre><code class="c++">double*a =(double*)_mm_malloc(9*sizeof(double),32);</code></pre><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><pre><code class="c++">double*a =(double*)aligned_alloc(32,9*sizeof(double));</code></pre><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><pre><code class="c++">__attribute__ ((aligned(32)))double a[9]  =&#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;</code></pre><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h3><pre><code class="c++">__m256d _mm256_load_pd (double const * mem_addr)</code></pre><p><strong>Description</strong></p><p>Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p><p><strong>Operation</strong></p><pre><code class="c++">dst[255:0] := MEM[mem_addr+255:mem_addr]dst[MAX:256] := 0</code></pre><h3 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h3><pre><code class="c++">__m256 _mm256_add_ps (__m256 a, __m256 b)</code></pre><p><strong>Description</strong></p><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p><p><strong>Operation</strong></p><pre><code>FOR j := 0 to 7    i := j*32    dst[i+31:i] := a[i+31:i] + b[i+31:i]ENDFORdst[MAX:256] := 0</code></pre><h3 id="3-stream的作用：绕过缓存直接写入内存"><a href="#3-stream的作用：绕过缓存直接写入内存" class="headerlink" title="3.stream的作用：绕过缓存直接写入内存"></a>3.stream的作用：绕过缓存直接写入内存</h3><pre><code class="c++">void _mm256_stream_pd (double * mem_addr, __m256d a)</code></pre><p><strong>Description</strong></p><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p><p><strong>Operation</strong></p><pre><code class="c++">MEM[mem_addr+255:mem_addr] := a[255:0]</code></pre><h2 id="样例程序举例："><a href="#样例程序举例：" class="headerlink" title="样例程序举例："></a>样例程序举例：</h2><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include &lt;immintrin.h&gt;int main()&#123;    double*a =(double*)memalign(32,9*sizeof(double));    double*b =(double*)memalign(32,4*sizeof(double));    double af[9]=&#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125; ;    double bf[9]=&#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;    double*c =(double*)memalign(32,4*sizeof(double));    for(int i =0;i&lt;9;i++)    &#123;        a[i]=af[i];        b[i]=bf[i];    &#125;    int i=0;    __m256d v0;    __m256d v1;    __m256d v2;    for(;i&lt;9-4;i+=4)    &#123;            v0 = _mm256_load_pd(a+i);            v1 = _mm256_load_pd(b+i);            v2=_mm256_add_pd(v0,v1);         _mm256_stream_pd(c+i,v2);                &#125;    for(;i&lt;9;i++)    &#123;        c[i]=a[i]+b[i];        &#125;    printf(&quot;this is c.\n&quot;);        for(int i=0;i&lt;9;i++)    &#123;        printf(&quot;%lf\n&quot;,c[i]);    &#125;    return 0; &#125; </code></pre><h2 id="样例程序输出："><a href="#样例程序输出：" class="headerlink" title="样例程序输出："></a>样例程序输出：</h2><pre><code class="c++">this is c.3.2000005.4000009.70000013.0000009.20000016.50000012.80000013.0000008.700000</code></pre><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(一)</title>
    <link href="/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX指令集的简单操作"><a href="#AVX指令集的简单操作" class="headerlink" title="AVX指令集的简单操作"></a>AVX指令集的简单操作</h1><p>使用AVX指令集进行2个double型的数组相加操作</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><pre><code class="c++">__m256 _mm256_loadu_ps (float const * mem_addr)</code></pre><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p><h3 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h3><pre><code class="c++">dst[255:0] := MEM[mem_addr+255:mem_addr]dst[MAX:256] := 0</code></pre><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><pre><code class="c++">__m256d _mm256_add_pd (__m256d a, __m256d b)</code></pre><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p><h3 id="Operation-1"><a href="#Operation-1" class="headerlink" title="Operation"></a>Operation</h3><pre><code class="c++">FOR j := 0 to 3    i := j*64    dst[i+63:i] := a[i+63:i] + b[i+63:i]ENDFORdst[MAX:256] := 0</code></pre><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><pre><code class="c++">void _mm256_storeu_pd (double * mem_addr, __m256d a)</code></pre><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p><h3 id="Operation-2"><a href="#Operation-2" class="headerlink" title="Operation"></a>Operation</h3><pre><code class="c++">MEM[mem_addr+255:mem_addr] := a[255:0]</code></pre><h2 id="未进行AVX向量化的情况"><a href="#未进行AVX向量化的情况" class="headerlink" title="未进行AVX向量化的情况"></a>未进行AVX向量化的情况</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><pre><code class="c++">#include&lt;stdio.h&gt;int main()&#123;    double a[9] = &#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;    double b[9] = &#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;    double c[9] = &#123;0&#125;;        for(int i=0 ;i&lt;9;i++)    &#123;        c[i]=a[i]+b[i];            &#125;        printf(&quot;this is c.\n&quot;);    for(int i=0;i&lt;9;i++)    &#123;        printf(&quot;%lf\n&quot;,c[i]);    &#125;        return 0; &#125; </code></pre><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><pre><code class="c++">this is c.3.2000005.4000009.70000013.0000009.20000016.50000012.80000013.0000008.700000</code></pre><h2 id="进行AVX向量化的情况"><a href="#进行AVX向量化的情况" class="headerlink" title="进行AVX向量化的情况"></a>进行AVX向量化的情况</h2><h3 id="程序源代码-1"><a href="#程序源代码-1" class="headerlink" title="程序源代码"></a>程序源代码</h3><pre><code class="c++">#include&lt;stdio.h&gt;#include &lt;immintrin.h&gt;int main()&#123;    double a[9] = &#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;    double b[9] = &#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;    double c[9] = &#123;0&#125;;    __m256d v0;    __m256d v1;    __m256d v2;    int i=0;    for(;i&lt;9-4;i+=4)    &#123;            v0 = _mm256_loadu_pd(a+i);            v1 = _mm256_loadu_pd(b+i);            v2=_mm256_add_pd(v0,v1);         _mm256_storeu_pd(c+i,v2);                &#125;    for(;i&lt;9;i++)    &#123;        c[i]=a[i]+b[i];        &#125;    printf(&quot;this is c with AVX.\n&quot;);        for(int i=0;i&lt;9;i++)    &#123;        printf(&quot;%lf\n&quot;,c[i]);    &#125;    return 0; &#125; </code></pre><h3 id="程序输出-1"><a href="#程序输出-1" class="headerlink" title="程序输出"></a>程序输出</h3><pre><code class="c++">this is c with AVX.3.2000005.4000009.70000013.0000009.20000016.50000012.80000013.0000008.700000</code></pre><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slurm</title>
    <link href="/2022/05/20/slurm001/"/>
    <url>/2022/05/20/slurm001/</url>
    
    <content type="html"><![CDATA[<h2 id="Slurm"><a href="#Slurm" class="headerlink" title="Slurm"></a>Slurm</h2><h4 id="1-sstat-查看RUNNING作业"><a href="#1-sstat-查看RUNNING作业" class="headerlink" title="1.sstat 查看RUNNING作业"></a>1.sstat 查看RUNNING作业</h4><pre><code class="shell">sstat -e</code></pre><p><img src="/2022/05/20/slurm001/image-20220520174453969.png" alt="image-20220520174453969"></p><p><strong>使用举例：</strong></p><pre><code class="shell">sstat -a --format=&quot;JobId,Pids,AveCPU,AveRSS,MaxRSS&quot;  1755818</code></pre><p><img src="/2022/05/20/slurm001/image-20220520175001331.png" alt="image-20220520175001331"></p><h4 id="2-sacct-查看FINISHED作业"><a href="#2-sacct-查看FINISHED作业" class="headerlink" title="2.sacct 查看FINISHED作业"></a>2.sacct 查看FINISHED作业</h4><pre><code class="shell">sacct -e</code></pre><p><img src="/2022/05/20/slurm001/image-20220520174622868.png" alt="image-20220520174622868"></p><p><strong>使用举例：</strong></p><pre><code class="shell">sacct --format=&quot;JobId,Elapsed,CPUTime,CPUTimeRAW,AveCPU,TotalCPU,UserCPU,SystemCPU,AveRSS,MaxRSS&quot; -j 1754217</code></pre><p><img src="/2022/05/20/slurm001/image-20220520174807162.png" alt="image-20220520174807162"></p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://blog.csdn.net/kongxx/article/details/52556943">(28条消息) Slurm查看作业CPU和MEM_kongxx的博客-CSDN博客_slurm 查看节点</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Slurm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numactl</title>
    <link href="/2022/05/20/numactl001/"/>
    <url>/2022/05/20/numactl001/</url>
    
    <content type="html"><![CDATA[<ol><li></li></ol><pre><code class="shell">numactl --hardware</code></pre><p><img src="/2022/05/20/numactl001/image-20220520173911653.png" alt="image-20220520173911653"></p><ol start="2"><li></li></ol><pre><code class="shelll">numastat</code></pre><p><img src="/2022/05/20/numactl001/image-20220520174030171.png" alt="image-20220520174030171"></p><ol start="3"><li></li></ol><pre><code class="c++">numactl --show</code></pre><p><img src="/2022/05/20/numactl001/image-20220520174148487.png" alt="image-20220520174148487"></p><h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p><a href="https://blog.csdn.net/qccz123456/article/details/81979819">(28条消息) Linux工具之numactl_qccz123456的博客-CSDN博客_numactl</a></p><p><a href="https://baijiahao.baidu.com/s?id=1699088343604813491&wfr=spider&for=pc&searchword=numactl">宋宝华：为什么numactl内存绑定对代码段不起作用 (baidu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Numactl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux的jobs,fg,bg命令</title>
    <link href="/2022/05/20/Linux002/"/>
    <url>/2022/05/20/Linux002/</url>
    
    <content type="html"><![CDATA[<h3 id="linux让前台程序脱离终端运行"><a href="#linux让前台程序脱离终端运行" class="headerlink" title="linux让前台程序脱离终端运行"></a>linux让前台程序脱离终端运行</h3><p>1.首先运行你的程序</p><p><img src="/2022/05/20/Linux002/image-20220520171436032.png" alt="image-20220520171436032"></p><p>2.随后使用Ctrl + z，挂起你的进程</p><p><img src="/2022/05/20/Linux002/image-20220520171510946.png" alt="image-20220520171510946"></p><p>3.然后使用jobs查看所有的进程</p><p><img src="/2022/05/20/Linux002/image-20220520171913979.png" alt="image-20220520171913979"></p><p>4.随后使用bg+id，表示该任务为后台1号任务</p><p>bg命令用于将作业放到后台运行，使前台可以执行其他任务</p><p><img src="/2022/05/20/Linux002/image-20220520172110992.png" alt="image-20220520172110992"></p><h3 id="linux让后台程序移动到前台终端"><a href="#linux让后台程序移动到前台终端" class="headerlink" title="linux让后台程序移动到前台终端"></a>linux让后台程序移动到前台终端</h3><p>Linux常用命令fg主要用于将后台作业移动到前台终端运行</p><p><img src="/2022/05/20/Linux002/image-20220520172358345.png" alt="image-20220520172358345"></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用指令</title>
    <link href="/2022/05/20/Linux001/"/>
    <url>/2022/05/20/Linux001/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h2><h4 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h4><pre><code class="c++">kill -9 id</code></pre><p><img src="/2022/05/20/Linux001/image-20220520171246860.png" alt="image-20220520171246860"></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcov代码覆盖率测试-完整样例-SLIC</title>
    <link href="/2022/05/08/tool004/"/>
    <url>/2022/05/08/tool004/</url>
    
    <content type="html"><![CDATA[<h2 id="gcov代码覆盖率测试-完整样例-SLIC"><a href="#gcov代码覆盖率测试-完整样例-SLIC" class="headerlink" title="gcov代码覆盖率测试-完整样例-SLIC"></a>gcov代码覆盖率测试-完整样例-SLIC</h2><h3 id="gcov代码覆盖率测试介绍："><a href="#gcov代码覆盖率测试介绍：" class="headerlink" title="gcov代码覆盖率测试介绍："></a>gcov代码覆盖率测试介绍：</h3><p><a href="https://xingyuanjie.top/2022/01/18/tool002/">gcov代码覆盖率测试 - 计算机奇妙之旅 (xingyuanjie.top)</a></p><h3 id="完整样例-SLIC："><a href="#完整样例-SLIC：" class="headerlink" title="完整样例-SLIC："></a>完整样例-SLIC：</h3><p><a href="https://xingyuanjie.top/2022/05/08/tool004/result.zip">https://xingyuanjie.top/2022/05/08/tool004/result.zip</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
      <tag>gcov</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的存储</title>
    <link href="/2022/05/06/Algorithm037/"/>
    <url>/2022/05/06/Algorithm037/</url>
    
    <content type="html"><![CDATA[<h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><pre><code class="c++">#define MaxVertexNum 100//顶点数目的最大值typedef char VertexType;//顶点的数据类型typedef int EdgeType;//带权图中边上权值的数据类型typedef struct&#123;    VertexType Vex[MaxVertexNum];//顶点表    EdgeType Edge[MaxVertexNum][MaxVertexNum];//邻接矩阵，边表    int vexnum,arcnum;//图中当前顶点数和弧数&#125;MGraph;</code></pre><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><pre><code class="c++">#define MaxVertexNum 100//图中顶点数目的最大值typedef struct ArcNode&#123;//边表结点    int adjvex;//该弧所指向的顶点的位置    struct ArcNode *next;//指向下一条弧的指针    //InfoType infp;//网的边权值&#125;ArcNode;typedef struct VNode&#123;//顶点表结点    VertexType data;//顶点信息    ArcNode *first;//指向第一条依附该顶点的弧的指针&#125;VNode,AdjList[MaxVertexNum];typedef struct&#123;    AdjList vertices;//邻接表    int vexnum,arcnum;//图的顶点数和弧数&#125;ALGraph;//ALGraph是以邻接表存储的图的类型</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树、森林</title>
    <link href="/2022/05/05/Algorithm036/"/>
    <url>/2022/05/05/Algorithm036/</url>
    
    <content type="html"><![CDATA[<h2 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><pre><code class="c++">#define MAX_TREE_SIZE 100//树中最多节点数typedef struct&#123;//树的结点定义    ElemType data;//数据元素    int parent;//双亲位置域&#125;PTNode;typedef struct&#123;//树的类型定义    PTNode nodes[MAX_TREE_SIZE];//双亲表示    int n;//节点数&#125;PTree;</code></pre><h4 id="孩子兄弟法"><a href="#孩子兄弟法" class="headerlink" title="孩子兄弟法"></a>孩子兄弟法</h4><pre><code class="c++">typedef struct CSNode&#123;    ElemType data;//数据域    struct CSNode *firstchild,*nextsibling;//第一个孩子和右兄弟指针&#125;CSNode,*CSTree;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Tree</tag>
      
      <tag>森林</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线索二叉树</title>
    <link href="/2022/05/04/Algorithm035/"/>
    <url>/2022/05/04/Algorithm035/</url>
    
    <content type="html"><![CDATA[<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h3><p>线索二叉树的存储结构描述如下</p><pre><code class="c++">ltag = 0 lchild域指示结点的左孩子ltag = 1 lchild域指示结点的前驱//rtag = 0 rchild域指示结点的右孩子rtag = 1 rchild域指示结点的后继</code></pre><pre><code class="c++">typedef struct ThreadNode&#123;    ElemType data;//数据元素    struct ThreadNode *lchild,*rchild;//左右孩子指针    int ltag,rtag;//左右线索标志&#125;ThreadNode，*ThreadTree;</code></pre><h3 id="中序线索二叉树的构造"><a href="#中序线索二叉树的构造" class="headerlink" title="中序线索二叉树的构造"></a>中序线索二叉树的构造</h3><pre><code class="c++">void InThread(ThreadTree &amp;p,ThreadNode &amp;pre)&#123;    if(p!=NULL)&#123;        InThread(p-&gt;lchild,pre);//递归，线索化左子树        &#123;            if(p-&gt;lchild==NULL)&#123;//左子树为空，建立前驱线索                p-&gt;lchild=pre;                p-&gt;ltag=1;            &#125;            if(pre!=NULL&amp;&amp;pre-&gt;rchild==NULL)&#123;                pre-&gt;rchild=p;//建立前驱结点的后继线索                pre-&gt;rtag=1;            &#125;            pre=p;//标记当前结点成为刚刚访问过的结点            InThread(p-&gt;rchild,pre);//递归，线索化右子树        &#125;//if(p!=NULL)    &#125;&#125;</code></pre><pre><code class="c++">void CreateInThread(ThreadTree T)&#123;    ThreadTree pre = NULL;    if(T!=NULL)&#123;//非空二叉树。线索化        InThread(T,pre);//线索化二叉树        pre-&gt;rchild=NULL;//处理遍历的最后一个结点        pre-&gt;rtag=1;    &#125;&#125;</code></pre><h3 id="中序线索二叉树的遍历"><a href="#中序线索二叉树的遍历" class="headerlink" title="中序线索二叉树的遍历"></a>中序线索二叉树的遍历</h3><p>1)求中序线索二叉树中中序序列下的第一个结点</p><pre><code class="c++">Thread *Firstnode(ThreadNode *p)&#123;    while(p-&gt;ltag==0) p=p-&gt;lchild;//最左下结点（不一定是叶结点）    return p;&#125;</code></pre><p>2)求中序线索二叉树中结点p在中序序列下的后继</p><pre><code class="c++">ThreadNode *Nextnode(ThreadNode *p)&#123;    if(p-&gt;rtag==0) return Firstnode(p-&gt;rchild);    else return p-&gt;rchild;//rtag==1直接返回后继线索&#125;</code></pre><p>3)利用上面两个算法，可以写出不含头节点的中序线索二叉树的中序遍历算法</p><pre><code class="c++">void Inorder(ThreadNode *T)&#123;    for(ThreadNode *p=Firstnode;p!=NULL;p=Nextnode(p))        visit(p);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Binary tree</tag>
      
      <tag>线索二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串的模式匹配算法-KMP算法</title>
    <link href="/2022/04/27/Algorithm034/"/>
    <url>/2022/04/27/Algorithm034/</url>
    
    <content type="html"><![CDATA[<h2 id="串的模式匹配算法-KMP算法"><a href="#串的模式匹配算法-KMP算法" class="headerlink" title="串的模式匹配算法-KMP算法"></a>串的模式匹配算法-KMP算法</h2><h3 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h3><pre><code class="c++">void get_next(SSting t,int next[])&#123;    int i=1,j=0;    next[1]=0;    while(i&lt;t.length)    &#123;        if(j==0||t.ch[i]==t.ch[j])        &#123;            i++;            j++;            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1        &#125;else&#123;            j=next[j];      //否则令j=next[j]，循环继续        &#125;    &#125;&#125;</code></pre><h3 id="KMP匹配算法"><a href="#KMP匹配算法" class="headerlink" title="KMP匹配算法"></a>KMP匹配算法</h3><pre><code class="c++">int Index_KMP(SSting s,SSting t,int next[])&#123;    int i=1,j=1;    while (i&lt;=s.length&amp;&amp;j&lt;=t.length)&#123;        if(j==0||s.ch[i]==t.ch[j])        &#123;            j++;                    //继续比较后续字符            i++;        &#125;else&#123;            j=next[j];              //模式串向右移动        &#125;    &#125;    if(j&gt;t.length)    &#123;        return i-t.length;          //匹配成功    &#125;else&#123;        return 0;    &#125;&#125;</code></pre><h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXLEN 255//预定义最大串长typedef struct&#123;    char ch[MAXLEN];//每个分量存储一个字符    int length;//串的实际长度&#125;SSting;void get_next(SSting t,int next[])&#123;    int i=1,j=0;    next[1]=0;    while(i&lt;t.length)    &#123;        if(j==0||t.ch[i]==t.ch[j])        &#123;            i++;            j++;            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1        &#125;else&#123;            j=next[j];      //否则令j=next[j]，循环继续        &#125;    &#125;&#125;int Index_KMP(SSting s,SSting t,int next[])&#123;    int i=1,j=1;    while (i&lt;=s.length&amp;&amp;j&lt;=t.length)&#123;        if(j==0||s.ch[i]==t.ch[j])        &#123;            j++;                    //继续比较后续字符            i++;        &#125;else&#123;            j=next[j];              //模式串向右移动        &#125;    &#125;    if(j&gt;t.length)    &#123;        return i-t.length;          //匹配成功    &#125;else&#123;        return 0;    &#125;&#125;int main()&#123;    SSting a,b;    string s1=&quot;ababcabcacbab&quot;;    string s2=&quot;abcac&quot;;    a.length=s1.size();    b.length=s2.size();    int next[s2.size()+1];    get_next(b,next);    for (int i = 0; i &lt;s1.size(); ++i) &#123;//初始化        a.ch[i+1]=s1[i];    &#125;    for (int j = 0; j &lt;s2.size() ; ++j) &#123;//初始化        b.ch[j+1]=s2[j];    &#125;    int x=Index_KMP(a,b,next);    if(x!=0)    &#123;        cout&lt;&lt;&quot;找到了位置是：&quot;&lt;&lt;x&lt;&lt;endl;    &#125;else&#123;        cout&lt;&lt;&quot;没有找到&quot;&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h3 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h3><pre><code class="c++">找到了位置是：6</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>String</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串-简单的模式匹配算法</title>
    <link href="/2022/04/27/Algorithm033/"/>
    <url>/2022/04/27/Algorithm033/</url>
    
    <content type="html"><![CDATA[<h2 id="串-简单的模式匹配算法"><a href="#串-简单的模式匹配算法" class="headerlink" title="串-简单的模式匹配算法"></a>串-简单的模式匹配算法</h2><h3 id="简单的模式匹配算法"><a href="#简单的模式匹配算法" class="headerlink" title="简单的模式匹配算法"></a>简单的模式匹配算法</h3><pre><code class="c++">int Index(SSting s,SSting t)        //简单的模式匹配算法&#123;    int i=1,j=1;    while(i&lt;=s.length &amp;&amp; j&lt;= t.length)    &#123;        if(s.ch[i]==t.ch[j])        &#123;            i++;                      //继续比较后继字符            j++;        &#125;else&#123;                        //指针后退重新开始匹配            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位            j=1;        &#125;    &#125;    if(j&gt;t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号    else return 0;&#125;</code></pre><h3 id="完整程序源代码"><a href="#完整程序源代码" class="headerlink" title="完整程序源代码"></a>完整程序源代码</h3><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXLEN 255//预定义最大串长typedef struct&#123;    char ch[MAXLEN];//每个分量存储一个字符    int length;//串的实际长度&#125;SSting;int Index(SSting s,SSting t)        //简单的模式匹配算法&#123;    int i=1,j=1;    while(i&lt;=s.length &amp;&amp; j&lt;= t.length)    &#123;        if(s.ch[i]==t.ch[j])        &#123;            i++;                      //继续比较后继字符            j++;        &#125;else&#123;                        //指针后退重新开始匹配            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位            j=1;        &#125;    &#125;    if(j&gt;t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号    else return 0;&#125;int main()&#123;    SSting a,b;    string s1=&quot;ababcabcacbab&quot;;    string s2=&quot;abcac&quot;;    a.length=s1.size();    b.length=s2.size();    for (int i = 0; i &lt;s1.size(); ++i) &#123;//初始化        a.ch[i+1]=s1[i];    &#125;    for (int j = 0; j &lt;s2.size() ; ++j) &#123;//初始化        b.ch[j+1]=s2[j];    &#125;    int x=Index(a,b);    if(x!=0)    &#123;        cout&lt;&lt;&quot;找到了位置是：&quot;&lt;&lt;x&lt;&lt;endl;    &#125;else&#123;        cout&lt;&lt;&quot;没有找到&quot;&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><pre><code class="c++">找到了位置是：6</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-036 网红点打卡攻略 (25 分)</title>
    <link href="/2022/04/23/Algorithm032/"/>
    <url>/2022/04/23/Algorithm032/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-036-网红点打卡攻略-25-分"><a href="#L2-036-网红点打卡攻略-25-分" class="headerlink" title="L2-036 网红点打卡攻略 (25 分)"></a>L2-036 网红点打卡攻略 (25 分)</h2><p>一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个正整数：网红点的个数 <em>N</em>（1&lt;<em>N</em>≤200）和网红点之间通路的条数 <em>M</em>。随后 <em>M</em> 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 <em>N</em> 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 <code>0</code>。</p><p>再下一行给出一个正整数 <em>K</em>，是待检验的攻略的数量。随后 <em>K</em> 行，每行给出一条待检攻略，格式为：</p><p><em>n</em> <em>V</em>1 <em>V</em>2 ⋯ Vn</p><p>其中 <em>n</em>(≤200) 是攻略中的网红点数，<em>Vi</em> 是路径上的网红点编号。这里假设你从家里出发，从 <em>V</em>1 开始打卡，最后从 <em>Vn</em> 回家。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在第一行输出满足要求的攻略的个数。</p><p>在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。</p><p>题目保证至少存在一个有效攻略，并且总路费不超过 109。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">6 130 5 26 2 26 0 13 4 21 5 22 5 13 1 14 1 21 6 16 3 21 2 14 5 32 0 276 5 1 4 3 6 26 5 2 1 6 3 48 6 2 1 6 3 4 5 23 2 1 56 6 1 3 4 5 27 6 2 1 3 4 5 26 5 2 1 4 3 6</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">35 11</code></pre><h3 id="样例说明："><a href="#样例说明：" class="headerlink" title="样例说明："></a>样例说明：</h3><p>第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。</p><p>第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 &#x3D; 14；</p><p>第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &#x3D; 11，是一条更省钱的攻略；</p><p>第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int g[205][205];int minsize=INT_MAX;//初始化为INT_MAXint minid=0;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    int cnt=0;    memset(g,0,sizeof(g));    for (int i = 0; i &lt;m ; ++i) &#123;        int a,b,c;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        g[a][b]=c;        g[b][a]=c;    &#125;    int time;    cin&gt;&gt;time;    for (int j = 0; j &lt;time ; ++j) &#123;        int k;        cin&gt;&gt;k;        int roll[k+5];        int has[k+5];        memset(has,0,sizeof(has));        roll[0]=roll[k+1]=0;//起点和终点必定是家        for (int i = 1; i &lt;=k ; ++i) &#123;            cin&gt;&gt;roll[i];            if(has[roll[i]]) has[0]=1;//每个打卡点仅能打卡一次            else has[roll[i]]=1;        &#125;        int flag=1;        int tmpsize=0;        if(k!=n||has[0]) continue;        for (int l = 1; l &lt;=k+1 ; ++l) &#123;            if(g[roll[l-1]][roll[l]]==0)            &#123;                flag=0;                break;            &#125;            tmpsize+=g[roll[l-1]][roll[l]];        &#125;        if(flag==1)        &#123;            if(tmpsize&lt;minsize)&#123;                minsize=tmpsize;                minid=j+1;            &#125;            cnt++;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;    cout&lt;&lt;minid&lt;&lt;&quot; &quot;&lt;&lt;minsize&lt;&lt;endl;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059">题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-039 清点代码库 (25 分)</title>
    <link href="/2022/04/23/Algorithm031/"/>
    <url>/2022/04/23/Algorithm031/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-039-清点代码库-25-分"><a href="#L2-039-清点代码库-25-分" class="headerlink" title="L2-039 清点代码库 (25 分)"></a>L2-039 清点代码库 (25 分)</h2><p><img src="/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg" alt="code.jpg"></p><p>上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”</p><p>这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 <strong>int</strong> 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出 2 个正整数，依次为 <em>N</em>（≤104）和 <em>M</em>（≤102），对应功能模块的个数和系列测试输入的个数。</p><p>随后 <em>N</em> 行，每行给出一个功能模块的 <em>M</em> 个对应输出，数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第一行输出不同功能的个数 <em>K</em>。随后 <em>K</em> 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。</p><p>注：所谓数列 { <em>A</em>1, …, <em>A</em>M } 比 { <em>B</em>1, …, <em>B</em>M } 大，是指存在 1≤i&lt;*M*，使得 *A*1&#x3D;*B*1，…，*Ai*&#x3D;*Bi* 成立，且 *Ai*+1&gt;<em>B</em>+1。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">7 335 28 74-1 -1 2228 74 35-1 -1 2211 66 035 28 7435 28 74</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">43 35 28 742 -1 -1 221 11 66 01 28 74 35</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>利用map的映射关系</strong></p><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;vector&lt;int&gt;,int&gt; mp;   //key，valuevector&lt;int&gt; tmp;int n,m;bool cmp(pair&lt;vector&lt;int&gt;,int&gt; a,pair&lt;vector&lt;int&gt;,int&gt; b)&#123;    if(a.second==b.second)    &#123;        return a.first&lt;b.first;    &#125;    return a.second&gt;b.second;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for (int i = 0; i &lt;n ; ++i) &#123;        for (int j = 0; j &lt; m; ++j) &#123;            int num;            cin&gt;&gt;num;            tmp.push_back(num);        &#125;        mp[tmp]++;        tmp.clear();    &#125;    vector&lt;pair&lt;vector&lt;int&gt;,int&gt;&gt; v(mp.begin(),mp.end());//把map类型转化成vector    cout&lt;&lt;v.size()&lt;&lt;endl;    sort(v.begin(),v.end(),cmp);//sort排序，注意终点和起点    for (int k = 0; k &lt;v.size() ; ++k) &#123;        cout&lt;&lt;v[k].second&lt;&lt;&quot; &quot;;        for (int i = 0; i &lt;m ; ++i) &#123;            if(i!=m-1)&#123;                cout&lt;&lt;v[k].first[i]&lt;&lt;&quot; &quot;;            &#125; else&#123;                cout&lt;&lt;v[k].first[i]&lt;&lt;endl;            &#125;        &#125;    &#125;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362">题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>Vector</tag>
      
      <tag>Map</tag>
      
      <tag>Pair</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-005 集合相似度 (25 分)</title>
    <link href="/2022/04/23/Algorithm030/"/>
    <url>/2022/04/23/Algorithm030/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-005-集合相似度-25-分"><a href="#L2-005-集合相似度-25-分" class="headerlink" title="L2-005 集合相似度 (25 分)"></a>L2-005 集合相似度 (25 分)</h2><p>给定两个整数集合，它们的相似度定义为：Nc&#x2F;Nt×100%。其中Nc是两个集合都有的不相等整数的个数，Nt是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤50），是集合的个数。随后<em>N</em>行，每行对应一个集合。每个集合首先给出一个正整数<em>M</em>（≤104），是集合中元素的个数；然后跟<em>M</em>个[0,109]区间内的整数。</p><p>之后一行给出一个正整数<em>K</em>（≤2000），随后<em>K</em>行，每行对应一对需要计算相似度的集合的编号（集合从1到<em>N</em>编号）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">33 99 87 1014 87 101 5 877 99 101 18 5 135 18 9921 21 3</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">50.00%33.33%</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>双set模拟</strong></p><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;    set&lt;int&gt; s[55];    cin&gt;&gt;n;    for (int i = 0; i &lt;n ; ++i) &#123;        int time;        cin&gt;&gt;time;        for (int j = 0; j &lt;time ; ++j) &#123;            int num;            cin&gt;&gt;num;            s[i].insert(num);        &#125;    &#125;    int find;    cin&gt;&gt;find;    for (int l = 0; l &lt;find ; ++l) &#123;        int a,b;        cin&gt;&gt;a&gt;&gt;b;        int sum=0;        set&lt;int&gt;::iterator it;//迭代器        int cnt=0;        for (it=s[a-1].begin(); it!=s[a-1].end() ; it++) &#123;            if(s[b-1].find(*it)!=s[b-1].end())&#123;//找到了                cnt++;//Nc            &#125;        &#125;        sum=s[a-1].size()+s[b-1].size()-cnt;//Nt=两个集合的总个数-相同个数        double ans=double(double(cnt)/double(sum))*100.0;        printf(&quot;%.2lf%\n&quot;,ans);    &#125;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805070149828608">题目详情 - L2-005 集合相似度 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL中map的使用</title>
    <link href="/2022/04/16/Algorithm029/"/>
    <url>/2022/04/16/Algorithm029/</url>
    
    <content type="html"><![CDATA[<h2 id="STL中map的使用"><a href="#STL中map的使用" class="headerlink" title="STL中map的使用"></a>STL中map的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>map 是 STL 的一个关联容器，它提供一对一的数据处理能力。</p><p>map 对象是<strong>模板类</strong>，需要<strong>关键字</strong>和<strong>存储对象</strong>两个模板参数：其中第一个参数称为关键字，每个关键字只能在 map 中出现一次；第二个参数称为该关键字的值。可以将关键字和存储对象理解为“{键，值}对”。</p><pre><code class="c++">map&lt;int,string&gt; mp;</code></pre><h3 id="map的数据插入操作"><a href="#map的数据插入操作" class="headerlink" title="map的数据插入操作"></a>map的数据插入操作</h3><pre><code class="c++">//使用insert函数插入pair数据mp.insert(pair&lt;int,string&gt;(3,&quot;xingyuanjie&quot;));//使用数组方式插入数据mp[2]=&quot;wangzhouyang&quot;;</code></pre><p><strong>说明：上面的两种方法是有区别的，用 insert 函数插入数据，涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能实现数据插入的；但是数组方式能够插入数据，插入的数据会覆盖该关键字之前对应的值。</strong></p><h3 id="map中数据的遍历"><a href="#map中数据的遍历" class="headerlink" title="map中数据的遍历"></a>map中数据的遍历</h3><pre><code class="c++">map&lt;int,string&gt;::iterator it;//迭代器for (it=mp.begin();it!=mp.end();it++) &#123;    cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;&#125;</code></pre><h3 id="map中数据的查找"><a href="#map中数据的查找" class="headerlink" title="map中数据的查找"></a>map中数据的查找</h3><pre><code class="c++">map&lt;int,string&gt;::iterator it;//迭代器it=mp.find(1);if(it!=mp.end())&#123;        cout &lt;&lt; &quot;Find it, the relative value is: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125;else&#123;           cout &lt;&lt; &quot;Can not find the relative value.&quot; &lt;&lt; endl;&#125;</code></pre><h3 id="map中数据的删除"><a href="#map中数据的删除" class="headerlink" title="map中数据的删除"></a>map中数据的删除</h3><pre><code class="c++">map&lt;int,string&gt;::iterator it;//迭代器it = mp.find(2);mp.erase(it);</code></pre><h3 id="map中数据的排序"><a href="#map中数据的排序" class="headerlink" title="map中数据的排序"></a>map中数据的排序</h3><p><strong>map 中的所有元素都会根据元素的键值，自动进行升序排序。</strong></p><h3 id="完整操作"><a href="#完整操作" class="headerlink" title="完整操作"></a>完整操作</h3><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;int,string&gt; mp;int main()&#123;    //使用insert函数插入pair数据    mp.insert(pair&lt;int,string&gt;(3,&quot;xingyuanjie&quot;));    mp.insert(pair&lt;int,string&gt;(1,&quot;shicheng&quot;));    mp.insert(pair&lt;int,string&gt;(4,&quot;tanghaipeng&quot;));    mp.insert(pair&lt;int,string&gt;(6,&quot;zhouyuhao&quot;));    mp.insert(pair&lt;int,string&gt;(5,&quot;heqichuan&quot;));    //使用数组方式插入数据    mp[2]=&quot;wangzhouyang&quot;;    //map的遍历    map&lt;int,string&gt;::iterator it;    for (it=mp.begin();it!=mp.end();it++) &#123;        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;    &#125;    //查找操作    it=mp.find(1);    if(it!=mp.end())&#123;        cout &lt;&lt; &quot;Find it, the relative value is: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;Can not find the relative value.&quot; &lt;&lt; endl;    &#125;    //删除操作    it = mp.find(2);    mp.erase(it);    for (it=mp.begin();it!=mp.end();it++) &#123;        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><pre><code class="c++">1 shicheng2 wangzhouyang3 xingyuanjie4 tanghaipeng5 heqichuan6 zhouyuhaoFind it, the relative value is: shicheng1 shicheng3 xingyuanjie4 tanghaipeng5 heqichuan6 zhouyuhao</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/liitdar/article/details/80009712">(20条消息) STL中map介绍_liitdar的博客-CSDN博客_stlmap</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-010 排座位 (25 分)</title>
    <link href="/2022/04/16/Algorithm028/"/>
    <url>/2022/04/16/Algorithm028/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-010-排座位-25-分"><a href="#L2-010-排座位-25-分" class="headerlink" title="L2-010 排座位 (25 分)"></a><strong>L2-010 排座位 (25 分)</strong></h2><p>布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出3个正整数：<code>N</code>（≤100），即前来参宴的宾客总人数，则这些人从1到<code>N</code>编号；<code>M</code>为已知两两宾客之间的关系数；<code>K</code>为查询的条数。随后<code>M</code>行，每行给出一对宾客之间的关系，格式为：<code>宾客1 宾客2 关系</code>，其中<code>关系</code>为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后<code>K</code>行，每行给出一对需要查询的宾客编号。</p><p>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出<code>No problem</code>；如果他们之间并不是朋友，但也不敌对，则输出<code>OK</code>；如果他们之间有敌对，然而也有共同的朋友，则输出<code>OK but...</code>；如果他们之间只有敌对关系，则输出<code>No way</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">7 8 45 6 12 7 -11 3 13 4 16 7 -11 2 11 4 12 3 -13 45 72 37 2</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">No problemOKOK but...No way</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接矩阵 + 并查集</strong></p><p><strong>并查集具体链接：</strong></p><p><a href="https://xingyuanjie.top/2022/01/04/Algorithm004/">并查集 - 计算机奇妙之旅 (xingyuanjie.top)</a></p><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;int pre[100];//父节点int deep[100];//深度int g[101][101];//邻接矩阵建图void init(int n)&#123;    for (int i = 0; i &lt;n ; ++i) &#123;        pre[i]=i;        deep[i]=0;    &#125;&#125;int find(int x)&#123;    if(pre[x]==x)&#123;        return x;    &#125; else&#123;        return pre[x]=find(pre[x]);    &#125;&#125;void unit(int x,int y)&#123;    x=find(x);    y=find(y);    if(x==y) return;    if(deep[x]&lt;deep[y])&#123;        pre[x]=y;    &#125;else&#123;        pre[y]=x;        if(deep[x]==deep[y])&#123;            deep[x]++;        &#125;    &#125;&#125;int main()&#123;    int n,m,k;    init(105);    memset(g,0,sizeof(g));    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for (int i = 0; i &lt;m ; ++i) &#123;        int a,b,c;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        g[a][b]=g[b][a]=c;        if(c==1) unit(a,b);//如果是朋友则合并    &#125;    for (int j = 0; j &lt;k ; ++j) &#123;        int a,b;        cin&gt;&gt;a&gt;&gt;b;        if(g[a][b]==1&amp;&amp;g[b][a]==1) cout&lt;&lt;&quot;No problem&quot;&lt;&lt;endl;        else if(g[a][b]==0&amp;&amp;g[b][a]==0) cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl;//两人毫无关系        else if(g[a][b]==-1&amp;&amp;g[b][a]==-1&amp;&amp;find(a)==find(b)) cout&lt;&lt;&quot;OK but...&quot;&lt;&lt;endl;//敌对且有共同朋友        else if(g[a][b]==-1&amp;&amp;g[b][a]==-1) cout&lt;&lt;&quot;No way&quot;&lt;&lt;endl;//仅敌对    &#125;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/weixin_45260385/article/details/109752008">(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680">题目详情 - L2-010 排座位 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-009 抢红包 (25 分)</title>
    <link href="/2022/04/16/Algorithm027/"/>
    <url>/2022/04/16/Algorithm027/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-009-抢红包-25-分"><a href="#L2-009-抢红包-25-分" class="headerlink" title="L2-009 抢红包 (25 分)"></a><strong>L2-009 抢红包 (25 分)</strong></h2><p>没有人没抢过红包吧…… 这里给出<em>N</em>个人之间互相发红包、抢红包的记录，请你统计一下他们抢红包的收获。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤104），即参与发红包和抢红包的总人数，则这些人从1到<em>N</em>编号。随后<em>N</em>行，第<em>i</em>行给出编号为<em>i</em>的人发红包的记录，格式如下：</p><p><em>K     N</em>1 <em>P</em>1⋯ NK PK</p><p>其中<em>K</em>（0≤<em>K</em>≤20）是发出去的红包个数，<em>N</em>i<em>是抢到红包的人的编号，</em>Pi（&gt;0）是其抢到的红包金额（以分为单位）。注意：对于同一个人发出的红包，每人最多只能抢1次，不能重复抢。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照收入金额从高到低的递减顺序输出每个人的编号和收入金额（以元为单位，输出小数点后2位）。每个人的信息占一行，两数字间有1个空格。如果收入金额有并列，则按抢到红包的个数递减输出；如果还有并列，则按个人编号递增输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">103 2 22 10 58 8 1255 1 345 3 211 5 233 7 13 8 1011 7 88002 1 1000 2 10002 4 250 10 3206 5 11 9 22 8 33 7 44 10 55 4 21 3 88002 1 23 2 1231 8 2504 2 121 4 516 7 112 9 10</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">1 11.632 3.638 3.633 2.117 1.696 -1.679 -2.1810 -3.265 -3.264 -12.32</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>结构体 + Sort</strong></p><p><strong>需要注意的就是double类型相等的比较</strong></p><p><strong>首先，浮点数在计算机中并不能精确的表示，所以在判断两个double类型的数时需要其他的手段，而不是直接 a&#x3D;&#x3D; b</strong></p><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;struct student&#123;    int id=0;    double money=0;    int cnt=0;&#125;;double dis=1e-6;//定义一个误差bool cmp(student a,student b)&#123;    if(abs(a.money-b.money)&lt;dis)&#123;//如果两个double型相减在误差的范围内，我们认定这两个double类型相等        if(a.cnt==b.cnt)&#123;            return a.id&lt;b.id;        &#125;else&#123;            return a.cnt&gt;b.cnt;        &#125;    &#125;    return a.money&gt;b.money;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    student st[n+5];    for (int i = 0; i &lt;n ; ++i) &#123;        int time;        cin&gt;&gt;time;        st[i].id=i+1;        for (int j = 0; j &lt;time ; ++j) &#123;            int p;            double x;            cin&gt;&gt;p&gt;&gt;x;            st[p-1].money+=x/100;            st[i].money-=x/100;            st[p-1].cnt++;//记录抢到的红包数        &#125;    &#125;    sort(st,st+n,cmp);//sort从数组下标0开始排序，左闭右开    for (int k = 0; k &lt;n ; ++k) &#123;        printf(&quot;%d %.2lf\n&quot;,st[k].id,st[k].money);    &#125;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://blog.csdn.net/dingpiao190/article/details/73512811?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">(20条消息) double类型是否相等的判断方法_dingpiao190的博客-CSDN博客_double判断相等</a></p><p><a href="https://blog.csdn.net/patrick_star_cowboy/article/details/82083392">(20条消息) 如何判断两个double类型的数是否相等？_Patrick-Star的博客-CSDN博客_两个double怎么判断相等</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805066890854400">题目详情 - L2-009 抢红包 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>结构体</tag>
      
      <tag>Double类型相等比较</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-003 月饼 (25 分)</title>
    <link href="/2022/04/15/Algorithm026/"/>
    <url>/2022/04/15/Algorithm026/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-003-月饼-25-分"><a href="#L2-003-月饼-25-分" class="headerlink" title="L2-003 月饼 (25 分)"></a>L2-003 月饼 (25 分)</h2><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45&#x2F;2 &#x3D; 94.5（亿元）。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 <em>N</em> 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 <em>D</em> 表示市场最大需求量。随后一行给出 <em>N</em> 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 <em>N</em> 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">3 2018 15 1075 72 45</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">94.50</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>贪心 + Sort</strong></p><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;struct mooncake&#123;    double pow;    double price;&#125;;bool cmp(mooncake a,mooncake b)&#123;    return a.price*1.0/a.pow&gt;b.price*1.0/b.pow;//返回单价高的&#125;int main()&#123;    int n;    double d;    cin&gt;&gt;n&gt;&gt;d;    mooncake m[n];    for (int i = 0; i &lt; n; ++i) &#123;        cin&gt;&gt;m[i].pow;    &#125;    for (int j = 0; j &lt;n ; ++j) &#123;        cin&gt;&gt;m[j].price;    &#125;    sort(m,m+n,cmp);    double price=0.0;    double tmpd=d;    for (int k = 0; k &lt;n ; ++k) &#123;//模拟求解        if(m[k].pow&lt;=tmpd)&#123;            tmpd-=m[k].pow;            price+=m[k].price;        &#125;else if(m[k].pow&gt;tmpd)&#123;            price+=tmpd*(m[k].price/m[k].pow);            break;        &#125;    &#125;    printf(&quot;%.2f\n&quot;,price);    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805071789801472">题目详情 - L2-003 月饼 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
      <tag>结构体</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-013 红色警报 (25 分)</title>
    <link href="/2022/04/15/Algorithm025/"/>
    <url>/2022/04/15/Algorithm025/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-013-红色警报-25-分"><a href="#L2-013-红色警报-25-分" class="headerlink" title="L2-013 红色警报 (25 分)"></a>L2-013 红色警报 (25 分)</h2><p>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个整数<code>N</code>（0 &lt; <code>N</code> ≤ 500）和<code>M</code>（≤ 5000），分别为城市个数（于是默认城市从0到<code>N</code>-1编号）和连接两城市的通路条数。随后<code>M</code>行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数<code>K</code>和随后的<code>K</code>个被攻占的城市的编号。</p><p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出<code>Red Alert: City k is lost!</code>，其中<code>k</code>是该城市的编号；否则只输出<code>City k is lost.</code>即可。如果该国失去了最后一个城市，则增加一行输出<code>Game Over.</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">5 40 11 33 00 451 2 0 4 3</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">City 1 is lost.City 2 is lost.Red Alert: City 0 is lost!City 4 is lost.City 3 is lost.Game Over.</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接矩阵建图 + DFS统计连通分量数</strong></p><p><strong>对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数</strong></p><p><strong>无向图中的极大连通子图称为连通分量</strong></p><p><strong>极大连通子图必须连通，且包含尽可能多的顶点和边</strong></p><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int g[505][505];//邻接矩阵存图int visit[505];//标记访问数组int lost[505];//记录被攻占的城市void dfs(int node)&#123;//正常的DFS    visit[node]=1;    for(int i=0;i&lt;n;i++)    &#123;        if(visit[i]==0&amp;&amp;g[node][i]==1)        &#123;            dfs(i);        &#125;    &#125;&#125;int dfstrave()&#123;    int cnt=0;    memset(visit,0,sizeof(visit));//初始化访问数组    for(int i=0;i&lt;n;i++)&#123;        if(lost[i]==1) visit[i]=1;//如果该城市被攻占，则标记他为以访问    &#125;    for(int i=0;i&lt;n;i++)&#123;        if(visit[i]==0)&#123;            dfs(i);            cnt++;      //统计连通分量数        &#125;    &#125;    return cnt;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    memset(lost,0,sizeof(lost));//初始化    memset(g,0,sizeof(g));//初始化    for(int i=0;i&lt;m;i++)&#123;        int a,b;        cin&gt;&gt;a&gt;&gt;b;        g[a][b]=g[b][a]=1;//存储无向图    &#125;    int cnt=dfstrave();//获得初始的连通分量数    int k;    cin&gt;&gt;k;    for(int w=0;w&lt;k;w++)&#123;        int city;        cin&gt;&gt;city;        lost[city]=1;//记录该城市被攻占        for(int i=0;i&lt;n;i++)&#123;            if(g[city][i]==1)&#123;                g[city][i]=g[i][city]=0;//标记和他相连的城市不再相连            &#125;        &#125;        int tempcnt=dfstrave();//当前的连通分量        if(tempcnt&lt;=cnt)&#123;//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变            printf(&quot;City %d is lost.\n&quot;, city);        &#125;else&#123;//否则，连通性被改变了            printf(&quot;Red Alert: City %d is lost!\n&quot;, city);        &#125;        cnt=tempcnt;//更新连通分量        if(w==n-1)&#123;//城市已经被攻占完毕            printf(&quot;Game Over.\n&quot;);        &#125;    &#125;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208">题目详情 - L2-013 红色警报 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接矩阵</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-011 玩转二叉树 (25 分)</title>
    <link href="/2022/04/14/Algorithm024/"/>
    <url>/2022/04/14/Algorithm024/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-011-玩转二叉树-25-分"><a href="#L2-011-玩转二叉树-25-分" class="headerlink" title="L2-011 玩转二叉树 (25 分)"></a><strong>L2-011 玩转二叉树 (25 分)</strong></h2><p>给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">71 2 3 4 5 6 74 1 3 2 6 5 7</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">4 6 1 7 5 3 2</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>镜面反转即为在层序遍历时交换左右子树的遍历顺序，左-&gt;右变成右-&gt;左</strong></p><p><strong>前序 + 中序 建树 + BFS</strong></p><p><strong>建树详细过程：</strong></p><p><a href="https://xingyuanjie.top/2022/04/07/Algorithm014/">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct BiTNode&#123;    int data;    struct BiTNode *lchild,*rchild;&#125;BiTNode,*BiTree;int n;int in[35];int pre[35];BiTree PostCreate(int prel,int prer,int inl,int inr)&#123;//前序加中序建树    if(prel&gt;prer)&#123;        return NULL;    &#125;    BiTNode *root;    root=(BiTNode*)malloc(sizeof(BiTNode));    root-&gt;data=pre[prel];    int index=0;    for (int i = inl; i &lt;=inr; ++i) &#123;        if(pre[prel]==in[i])&#123;            index=i;            break;        &#125;    &#125;    int numleft=index-inl;    root-&gt;lchild=PostCreate(prel+1,prel+numleft,inl,index-1);    root-&gt;rchild=PostCreate(prel+numleft+1,prer,index+1,inr);    return root;&#125;void LevelOrder(BiTree T)&#123;    queue&lt;BiTree&gt; q;    q.push(T);    int i=0;    while (!q.empty())&#123;        BiTNode *tmp =q.front();        q.pop();        if(i!=n-1)&#123;//输出格式控制            cout&lt;&lt;tmp-&gt;data&lt;&lt;&quot; &quot;;        &#125;else&#123;            cout&lt;&lt;tmp-&gt;data;        &#125;        i++;        if(tmp-&gt;rchild!=NULL)&#123;//镜面反转，左-&gt;右变成右-&gt;左            q.push(tmp-&gt;rchild);        &#125;        if(tmp-&gt;lchild!=NULL)&#123;            q.push(tmp-&gt;lchild);        &#125;    &#125;&#125;int main()&#123;    BiTree tree;    tree=NULL;    cin&gt;&gt;n;    for (int i = 0; i &lt;n ; ++i) &#123;        cin&gt;&gt;in[i];    &#125;    for (int j = 0; j &lt;n ; ++j) &#123;        cin&gt;&gt;pre[j];    &#125;    tree=PostCreate(0,n-1,0,n-1);    LevelOrder(tree);    cout&lt;&lt;endl;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784">题目详情 - L2-011 玩转二叉树 (25 分) (pintia.cn)</a></p><p><a href="https://xingyuanjie.top/2022/04/07/Algorithm014/">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-035 完全二叉树的层序遍历 (25 分)</title>
    <link href="/2022/04/14/Algorithm023/"/>
    <url>/2022/04/14/Algorithm023/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-035-完全二叉树的层序遍历-25-分"><a href="#L2-035-完全二叉树的层序遍历-25-分" class="headerlink" title="L2-035 完全二叉树的层序遍历 (25 分)"></a>L2-035 完全二叉树的层序遍历 (25 分)</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是<strong>完美二叉树</strong>。对于深度为 <em>D</em> 的，有 <em>N</em> 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 <em>N</em> 个结点，这样的树就是<strong>完全二叉树</strong>。</p><p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>N</em>（≤30），即树中结点个数。第二行给出后序遍历序列，为 <em>N</em> 个不超过 100 的正整数。同一行中所有数字都以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">891 71 2 34 10 15 55 18</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">18 34 55 71 2 10 15 91</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>后序遍历建树 + 完全二叉树性质</strong></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int tree[10001];int n;void post(int i)&#123;//根据后序遍历建树    if(2*i&lt;=n)&#123;//当2*i&lt;=n时，结点i的左孩子编号为2*i，否则无左孩子        post(2*i);    &#125;    if(2*i+1&lt;=n)&#123;//当2*i+1&lt;=n时，结点i的右孩子编号为2*i+1，否则无右孩子        post(2*i+1);    &#125;    cin&gt;&gt;tree[i];&#125;int main()&#123;    cin&gt;&gt;n;    post(1);           //后序遍历建树    for (int i = 1; i &lt;=n ; ++i) &#123;//顺序输出即为层序遍历        if(i!=n)&#123;            cout&lt;&lt;tree[i]&lt;&lt;&quot; &quot;;        &#125;else&#123;            cout&lt;&lt;tree[i];        &#125;    &#125;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Binary tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-031 深入虎穴 (25 分)</title>
    <link href="/2022/04/13/Algorithm022/"/>
    <url>/2022/04/13/Algorithm022/</url>
    
    <content type="html"><![CDATA[<p>著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。</p><p>内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在一行中给出正整数 <em>N</em>（&lt;105），是门的数量。最后 <em>N</em> 行，第 <em>i</em> 行（1≤<em>i</em>≤<em>N</em>）按以下格式描述编号为 <em>i</em> 的那扇门背后能通向的门：</p><pre><code>K D[1] D[2] ... D[K]</code></pre><p>其中 <code>K</code> 是通道的数量，其后是每扇门的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">133 2 3 42 5 61 71 81 902 11 101 13001 1200</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">12</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表 + BFS</strong></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; v[100005];int book[100005];int start=0;int bfs()&#123;//BFS    queue&lt;int&gt; q;    q.push(start);//根节点入队    int x;    while(!q.empty())&#123;        x=q.front();        q.pop();        for (int i = 0; i &lt;v[x].size() ; ++i) &#123;            q.push(v[x][i]);        &#125;    &#125;//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。    return x;//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for (int i = 1; i &lt;=n ; ++i) &#123;        int time;        cin&gt;&gt;time;        for (int j = 1; j &lt;=time ; ++j) &#123;            int num;            cin&gt;&gt;num;            book[num]=1;            v[i].push_back(num);        &#125;    &#125;    for (int k = 1; k &lt;=n ; ++k) &#123;//找入口        if(book[k]==0) start=k;//没有门通向的门，即为入口    &#125;    int ans=bfs();    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888">题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-040 哲哲打游戏 (25 分)</title>
    <link href="/2022/04/13/Algorithm021/"/>
    <url>/2022/04/13/Algorithm021/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-040-哲哲打游戏-25-分"><a href="#L2-040-哲哲打游戏-25-分" class="headerlink" title="L2-040 哲哲打游戏 (25 分)"></a><strong>L2-040 哲哲打游戏 (25 分)</strong></h2><p>哲哲是一位硬核游戏玩家。最近一款名叫《达诺达诺》的新游戏刚刚上市，哲哲自然要快速攻略游戏，守护硬核游戏玩家的一切！</p><p>为简化模型，我们不妨假设游戏有 <em>N</em> 个剧情点，通过游戏里不同的操作或选择可以从某个剧情点去往另外一个剧情点。此外，游戏还设置了一些<strong>存档</strong>，在某个剧情点可以将玩家的游戏进度保存在一个档位上，读取存档后可以回到剧情点，重新进行操作或者选择，到达不同的剧情点。</p><p>为了追踪硬核游戏玩家哲哲的攻略进度，你打算写一个程序来完成这个工作。假设你已经知道了游戏的全部剧情点和流程，以及哲哲的游戏操作，请你输出哲哲的游戏进度。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行是两个正整数 <em>N</em> 和 <em>M</em> (1≤<em>N</em>,<em>M</em>≤105)，表示总共有 <em>N</em> 个剧情点，哲哲有 <em>M</em> 个游戏操作。</p><p>接下来的 <em>N</em> 行，每行对应一个剧情点的发展设定。第 <em>i</em> 行的第一个数字是 <em>K**i</em>，表示剧情点 <em>i</em> 通过一些操作或选择能去往下面 <em>K**i</em> 个剧情点；接下来有 <em>K**i</em> 个数字，第 <em>k</em> 个数字表示做第 <em>k</em> 个操作或选择可以去往的剧情点编号。</p><p>最后有 <em>M</em> 行，每行第一个数字是 0、1 或 2，分别表示：</p><ul><li>0 表示哲哲做出了某个操作或选择，后面紧接着一个数字 <em>j</em>，表示哲哲在当前剧情点做出了第 <em>j</em> 个选择。我们保证哲哲的选择永远是合法的。</li><li>1 表示哲哲进行了一次存档，后面紧接着是一个数字 <em>j</em>，表示存档放在了第 <em>j</em> 个档位上。</li><li>2 表示哲哲进行了一次读取存档的操作，后面紧接着是一个数字 <em>j</em>，表示读取了放在第 <em>j</em> 个位置的存档。</li></ul><p>约定：所有操作或选择以及剧情点编号都从 1 号开始。存档的档位不超过 100 个，编号也从 1 开始。游戏默认从 1 号剧情点开始。总的选项数（即 ∑<em>K**i</em>）不超过 106。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对于每个 1（即存档）操作，在一行中输出存档的剧情点编号。</p><p>最后一行输出哲哲最后到达的剧情点编号。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">10 113 2 3 41 63 4 7 51 31 92 3 53 1 8 51 92 8 1001 10 30 11 20 20 22 20 30 11 10 2</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">13910</code></pre><h3 id="样例解释："><a href="#样例解释：" class="headerlink" title="样例解释："></a>样例解释：</h3><p>简单给出样例中经过的剧情点顺序：</p><p>1 -&gt; 4 -&gt; 3 -&gt; 7 -&gt; 8 -&gt; 3 -&gt; 5 -&gt; 9 -&gt; 10。</p><p>档位 1 开始存的是 1 号剧情点；档位 2 存的是 3 号剧情点；档位 1 后来又存了 9 号剧情点。</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表 + 模拟，主要是理解题意</strong></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    vector&lt;int&gt; v[n+1];    int save[105];//存档点    int now=1;//当前剧情点    for (int i = 1; i &lt;=n ; ++i) &#123;        int num;        cin&gt;&gt;num;        for (int j = 0; j &lt;num ; ++j) &#123;            int x;            cin&gt;&gt;x;            v[i].push_back(x);//邻接表存操作数        &#125;    &#125;    for (int l = 0; l &lt;k ; ++l) &#123;//模拟过程        int a,b;        cin&gt;&gt;a&gt;&gt;b;        if(a==1)&#123;            save[b]=now;            cout&lt;&lt;now&lt;&lt;endl;        &#125;        if(a==0)&#123;            now=v[now][b-1];        &#125;        if(a==2)&#123;            now=save[b];        &#125;    &#125;    cout&lt;&lt;now&lt;&lt;endl;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652363">题目详情 - L2-040 哲哲打游戏 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-027 名人堂与代金券 (25 分)</title>
    <link href="/2022/04/13/Algorithm020/"/>
    <url>/2022/04/13/Algorithm020/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-027-名人堂与代金券-25-分"><a href="#L2-027-名人堂与代金券-25-分" class="headerlink" title="L2-027 名人堂与代金券 (25 分)"></a>L2-027 名人堂与代金券 (25 分)</h2><p>对于在中国大学MOOC（<a href="http://www.icourse163.org/">http://www.icourse163.org/</a> ）学习“数据结构”课程的学生，想要获得一张合格证书，总评成绩必须达到 60 分及以上，并且有另加福利：总评分在 [G, 100] 区间内者，可以得到 50 元 PAT 代金券；在 [60, G) 区间内者，可以得到 20 元PAT代金券。全国考点通用，一年有效。同时任课老师还会把总评成绩前 K 名的学生列入课程“名人堂”。本题就请你编写程序，帮助老师列出名人堂的学生，并统计一共发出了面值多少元的 PAT 代金券。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出 3 个整数，分别是 N（不超过 10 000 的正整数，为学生总数）、G（在 (60,100) 区间内的整数，为题面中描述的代金券等级分界线）、K（不超过 100 且不超过 N 的正整数，为进入名人堂的最低名次）。接下来 N 行，每行给出一位学生的账号（长度不超过15位、不带空格的字符串）和总评成绩（区间 [0, 100] 内的整数），其间以空格分隔。题目保证没有重复的账号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出发出的 PAT 代金券的总面值。然后按总评成绩非升序输出进入名人堂的学生的名次、账号和成绩，其间以 1 个空格分隔。需要注意的是：成绩相同的学生享有并列的排名，排名并列时，按账号的字母序升序输出。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">10 80 5cy@zju.edu.cn 78cy@pat-edu.com 871001@qq.com 65uh-oh@163.com 96test@126.com 39anyone@qq.com 87zoe@mit.edu 80jack@ucla.edu 88bob@cmu.edu 80ken@163.com 70</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">3601 uh-oh@163.com 962 jack@ucla.edu 883 anyone@qq.com 873 cy@pat-edu.com 875 bob@cmu.edu 805 zoe@mit.edu 80</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>结构体数组+sort排序，需要注意输出格式控制</strong></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;struct student&#123;    int score=0;    string email;&#125;;bool cmp(student a,student b)&#123;    if(a.score==b.score) return a.email&lt;b.email;//如果分数相同返回字典序小的    return a.score&gt;b.score;//返回分数最大的&#125;int main()&#123;    int n,g,k;    cin&gt;&gt;n&gt;&gt;g&gt;&gt;k;    student st[n];    int money=0;    for (int i = 0; i &lt;n ; ++i) &#123;//输入加存钱        cin&gt;&gt;st[i].email&gt;&gt;st[i].score;        if(g&lt;=st[i].score&amp;&amp;st[i].score&lt;=100)&#123;            money+=50;        &#125;        if(60&lt;=st[i].score&amp;&amp;st[i].score&lt;g)&#123;            money+=20;        &#125;    &#125;    sort(st,st+n,cmp);//排序    cout&lt;&lt;money&lt;&lt;endl;    int cnt =1;//用来判断用否超过名人堂个数    int i=0;//遍历st结构体数组    int same=1;//分数相同的个数    int fscore=st[0].score;//用来判断分数是否相同    //这道题就格式输出需要注意下！    while(true) &#123;        if(fscore==st[i].score)&#123;            cout&lt;&lt;cnt&lt;&lt;&quot; &quot;&lt;&lt;st[i].email&lt;&lt;&quot; &quot;&lt;&lt;st[i].score&lt;&lt;endl;//相同即输出            if(i!=0) same++;//不为0号，则same++。        &#125;        if(fscore&gt;st[i].score)&#123;            cnt=cnt+same;//不等，更新cnt值            same=1;//更新same值            if(cnt&gt;k)&#123; break;&#125;//大于名人堂个数结束            cout&lt;&lt;cnt&lt;&lt;&quot; &quot;&lt;&lt;st[i].email&lt;&lt;&quot; &quot;&lt;&lt;st[i].score&lt;&lt;endl;            fscore=st[i].score;//更新用来判断分数是否相同的fscore        &#125;        i++;    &#125;    return 0;&#125;</code></pre><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805055176163328">题目详情 - L2-027 名人堂与代金券 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-026 小字辈 (25 分)</title>
    <link href="/2022/04/13/Algorithm019/"/>
    <url>/2022/04/13/Algorithm019/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-026-小字辈-25-分"><a href="#L2-026-小字辈-25-分" class="headerlink" title="L2-026 小字辈 (25 分)"></a><strong>L2-026 小字辈 (25 分)</strong></h2><p>本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父&#x2F;母。家谱中辈分最高的老祖宗对应的父&#x2F;母编号为 -1。一行中的数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">92 6 5 5 -1 5 6 4 7</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">41 9</code></pre><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><p><strong>邻接表建树+BFS</strong></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; tree[100005];//邻接表建树int deeptree[100005];//记录树的深度int n;int root;//根节点int bfs()&#123;//bfs    queue&lt;int&gt; q;    q.push(root);//根节点入队    int x;    while(!q.empty())&#123;        x=q.front();        q.pop();        for (int i = 0; i &lt;tree[x].size() ; ++i) &#123;            deeptree[tree[x][i]]=deeptree[x]+1;//每一层的深度为上一层加1            q.push(tree[x][i]);        &#125;    &#125;    return deeptree[x];//返回最后一个结点的深度，即深度的最大值&#125;int main()&#123;    n;    cin&gt;&gt;n;    int a[n];    for (int i = 1; i &lt;=n ; ++i) &#123;        cin&gt;&gt;a[i];        if(a[i]==-1)&#123;            root=i;//找根节点        &#125;    &#125;    for (int j = 1; j &lt;=n ; ++j) &#123;//建树        tree[a[j]].push_back(j);//j是a[j]的孩子节点        if(a[j]==-1) deeptree[j]=1;//初始化根节点深度为1    &#125;    int ans=bfs();    cout&lt;&lt;ans&lt;&lt;endl;    int maxdeepcnt=0;//记录最大深度的个数    int tmp[n];//找最大深度的id    for (int k = 1; k &lt;=n ; ++k) &#123;        if(ans==deeptree[k])&#123;            maxdeepcnt++;            tmp[maxdeepcnt]=k;        &#125;    &#125;    //输出格式控制    for (int l = 1; l &lt;=maxdeepcnt ; ++l) &#123;        if(l!=maxdeepcnt) cout&lt;&lt;tmp[l]&lt;&lt;&quot; &quot;;        else cout&lt;&lt;tmp[l]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808">题目详情 - L2-026 小字辈 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
      <tag>Binary tree</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-023 图着色问题 (25 分)</title>
    <link href="/2022/04/12/Algorithm018/"/>
    <url>/2022/04/12/Algorithm018/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-023-图着色问题-25-分"><a href="#L2-023-图着色问题-25-分" class="headerlink" title="L2-023 图着色问题 (25 分)"></a>L2-023 图着色问题 (25 分)</h2><p>图着色问题是一个著名的NP完全问题。给定无向图<em>G</em>&#x3D;(<em>V</em>,<em>E</em>)，问可否用<em>K</em>种颜色为<em>V</em>中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？</p><p>但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出3个整数<em>V</em>（0&lt;<em>V</em>≤500）、<em>E</em>（≥0）和<em>K</em>（0&lt;<em>K</em>≤<em>V</em>），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到<em>V</em>编号。随后<em>E</em>行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数<em>N</em>（≤20），是待检查的颜色分配方案的个数。随后<em>N</em>行，每行顺次给出<em>V</em>个顶点的颜色（第<em>i</em>个数字表示第<em>i</em>个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每种颜色分配方案，如果是图着色问题的一个解则输出<code>Yes</code>，否则输出<code>No</code>，每句占一行。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><img src="/2022/04/12/Algorithm018/graph.png" alt="graph" style="zoom: 67%;"><pre><code class="in">6 8 32 11 34 62 52 45 45 63 641 2 3 3 1 24 5 6 6 4 51 2 3 4 5 62 3 4 2 3 4</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">YesYesNoNo</code></pre><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>Set + 邻接表</strong></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int v,e,k;    cin&gt;&gt;v&gt;&gt;e&gt;&gt;k;    vector&lt;int&gt; g[505];//邻接表    int color[505];//记录颜色    for (int i = 0; i &lt;e ; ++i) &#123;       //建立邻接表        int a,b;        cin&gt;&gt;a&gt;&gt;b;        g[a].push_back(b);        g[b].push_back(a);    &#125;    int time;    cin&gt;&gt;time;    for (int j = 0; j &lt;time ; ++j) &#123;        int flag=1;        set&lt;int&gt; s;//用来统计颜色总数        s.clear();        for (int i = 1; i &lt;=v; ++i) &#123;            int num;            cin&gt;&gt;num;            color[i]=num;            s.insert(num);        &#125;        if(s.size()!=k)&#123;//如果颜色数不等于k即非法            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;            continue;        &#125;        for (int l = 1; l &lt;=v ; ++l) &#123;//遍历邻接表            for (int i = 0; i &lt;g[l].size(); ++i) &#123;                if(color[l]==color[g[l][i]])&#123;//如果相邻结点颜色一样则为假                    flag=0;                    break;                &#125;            &#125;        &#125;        if(flag==1)&#123;            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        &#125;else&#123;            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805057298481152">题目详情 - L2-023 图着色问题 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Graph</tag>
      
      <tag>邻接表</tag>
      
      <tag>Vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-022 重排链表 (25 分)</title>
    <link href="/2022/04/12/Algorithm017/"/>
    <url>/2022/04/12/Algorithm017/</url>
    
    <content type="html"><![CDATA[<h2 id="L2-022-重排链表-25-分"><a href="#L2-022-重排链表-25-分" class="headerlink" title="L2-022 重排链表 (25 分)"></a>L2-022 重排链表 (25 分)</h2><p>给定一个单链表 <em>L</em>1→<em>L</em>2→⋯→<em>Ln</em>−1→<em>Ln</em>，请编写程序将链表重新排列为 <em>Ln</em>→<em>L</em>1→<em>Ln</em>−1→<em>L</em>2→⋯。例如：给定<em>L</em>为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数<em>N</em> (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。</p><p>接下来有<em>N</em>行，每行格式为：</p><pre><code>Address Data Next</code></pre><p>其中<code>Address</code>是结点地址；<code>Data</code>是该结点保存的数据，为不超过105的正整数；<code>Next</code>是下一结点的地址。题目保证给出的链表上至少有两个结点。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">00100 600000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">68237 6 0010000100 1 9999999999 5 1230912309 2 0000000000 4 3321833218 3 -1</code></pre><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>利用双向链表，头尾指针来模拟</strong></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;struct linklist&#123;    int address=0;//记录当前结点的地址，虽然也没用到    int data=0;//记录数据域    int next=0;//指向下一个结点的地址    int pre=0;//指向上一个结点的地址&#125;l[100005];int main()&#123;    int start,back=-1;//头尾指针    int tmp;//用来遍历当前链表用于统计链表的长度    int n;    cin&gt;&gt;start&gt;&gt;n;    tmp=start;    int address, data, next;    l[start].pre=-1;   //初始化第一个结点的前一个结点位置为-1    int cnt=0;  //记录链表长    for (int i = 0; i &lt;n ; ++i) &#123;       cin&gt;&gt;address&gt;&gt;data&gt;&gt;next;       l[address].address=address;       l[address].data=data;       l[address].next=next;       if(next!=-1)&#123;           l[next].pre=address;//设值上一个结点的地址       &#125;    &#125;    //这道题比较坑的地方是会出现不是这个链表的结点，所以n不是真正的链表长，需要统计真正的链表长    //如果没注意这点，第三个测试点会不通过，不过也能得到21分    while (true) &#123;        cnt++;//统计链表长        if(l[tmp].next==-1)&#123;            back=tmp;       //尾指针            break;        &#125;        tmp=l[tmp].next;    &#125;    int flag=0;    //flag=0动尾指针,flag=1动头指针。我并没有改变原来链表！    for (int k = 0; k &lt;cnt ; ++k) &#123;            if(flag==0)&#123;                if(k==cnt-1)&#123;                    printf(&quot;%05d %d %d\n&quot;,l[back].address,l[back].data,-1);                &#125;else&#123;                    printf(&quot;%05d %d %05d\n&quot;,l[back].address,l[back].data,start);                &#125;                back=l[back].pre;                flag=1;            &#125;            else if(flag==1)&#123;                if(k==cnt-1)&#123;                    printf(&quot;%05d %d %d\n&quot;,l[start].address,l[start].data,-1);                &#125;else&#123;                    printf(&quot;%05d %d %05d\n&quot;,l[start].address,l[start].data,back);                &#125;                start=l[start].next;                flag=0;            &#125;    &#125;    return 0;&#125;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805057860517888">题目详情 - L2-022 重排链表 (25 分) (pintia.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>LinkList</tag>
      
      <tag>双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>L2-021 点赞狂魔 (25 分)</title>
    <link href="/2022/04/11/Algorithm016/"/>
    <url>/2022/04/11/Algorithm016/</url>
    
    <content type="html"><![CDATA[<h1 id="L2-021-点赞狂魔-25-分"><a href="#L2-021-点赞狂魔-25-分" class="headerlink" title="L2-021 点赞狂魔 (25 分)"></a>L2-021 点赞狂魔 (25 分)</h1><p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤100），是待统计的用户数。随后<em>N</em>行，每行列出一位用户的点赞标签。格式为“<code>Name</code> <em>K</em> <em>F</em>1⋯<em>F**K</em>”，其中<code>Name</code>是不超过8个英文小写字母的非空用户名，1≤<em>K</em>≤1000，<em>F**i</em>（<em>i</em>&#x3D;1,⋯,<em>K</em>）是特性标签的编号，我们将所有特性标签从 1 到 107 编号。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用<code>-</code>补齐缺失，例如<code>mike jenny -</code>就表示只有2人。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">5bob 11 101 102 103 104 105 106 107 108 108 107 107peter 8 1 2 3 4 3 2 5 1chris 12 1 2 3 4 5 6 7 8 9 1 2 3john 10 8 7 6 5 4 3 2 1 7 5jack 9 6 7 8 9 10 11 12 13 14</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">jack chris john</code></pre><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><p><strong>结构体数组 + sort排序</strong></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;struct person&#123;    char name[10];    set&lt;int&gt; s;//set容器中的每个元素值唯一    int all=0;//记录点赞次数&#125;;bool cmp(person a,person b)&#123;    if(a.s.size()==b.s.size()) return a.all&lt;b.all;//如果有并列，则输出标签出现次数平均值最小的那个    return a.s.size()&gt;b.s.size();//点赞的不同标签的数量最多的&#125;int main()&#123;    int n;    cin&gt;&gt;n;    person p[n];    for (int i = 0; i &lt;n ; ++i) &#123;        cin&gt;&gt;p[i].name;        int time;        cin&gt;&gt;time;        p[i].all=time;//记录点赞次数        for (int j = 0; j &lt; time; ++j) &#123;            int tmp;            cin&gt;&gt;tmp;            p[i].s.insert(tmp);//插入set容器        &#125;    &#125;    sort(p,p+n,cmp);//排序    if(n&gt;=3)&#123;        cout&lt;&lt;p[0].name&lt;&lt;&quot; &quot;&lt;&lt;p[1].name&lt;&lt;&quot; &quot;&lt;&lt;p[2].name&lt;&lt;endl;    &#125; else if(n==2)&#123;        cout&lt;&lt;p[0].name&lt;&lt;&quot; &quot;&lt;&lt;p[1].name&lt;&lt;&quot; &quot;&lt;&lt;&quot;-&quot;&lt;&lt;endl;    &#125;else if(n==1)&#123;        cout&lt;&lt;p[0].name&lt;&lt;&quot; &quot;&lt;&lt;&quot;-&quot;&lt;&lt;&quot; &quot;&lt;&lt;&quot;-&quot;&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805058485469184">题目详情 - L2-021 点赞狂魔 (25 分) (pintia.cn)</a></p><p><a href="https://blog.csdn.net/changjiale110/article/details/79108447">(19条消息) STL中的set使用方法详细！！！！_知足–常乐的博客-CSDN博客_set stl</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
      <tag>Set</tag>
      
      <tag>团体程序设计天梯赛</tag>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的STL中字符串string自带方法find查找</title>
    <link href="/2022/04/08/Algorithm015/"/>
    <url>/2022/04/08/Algorithm015/</url>
    
    <content type="html"><![CDATA[<h1 id="C-的STL中字符串string自带方法find查找"><a href="#C-的STL中字符串string自带方法find查找" class="headerlink" title="C++的STL中字符串string自带方法find查找"></a>C++的STL中字符串string自带方法find查找</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code class="c++">string str = &quot;abcd&quot;;    cout &lt;&lt; str.find(&#39;a&#39;);    //返回的是下标的值而不是指针或是迭代器</code></pre><pre><code class="c++">string str = &quot;abcd&quot;string sub = &quot;cd&quot;if(str.find(sub)!=string::npos)&#123;    cout&lt;&lt;&quot;找到了&quot;&lt;&lt;endl;&#125;else&#123;    cout&lt;&lt;&quot;没有找到&quot;&lt;&lt;endl;&#125;</code></pre><p>要是没有找到，返回的是str::npos<br>注意，只有string的find方法是返回的下标，因为string是顺序索引，set,map,multiset,multimap都不是顺序索引的数据结构，所以返回的是迭代器。</p><h2 id="样例一-L1-070-吃火锅-15-分"><a href="#样例一-L1-070-吃火锅-15-分" class="headerlink" title="样例一:L1-070 吃火锅 (15 分)"></a>样例一:<strong>L1-070 吃火锅 (15 分)</strong></h2><p><strong>题目链接：</strong></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053</a></p><p><img src="/2022/04/08/Algorithm015/68518b64-f2f7-4694-aaeb-d32afe657f7b.jpg" alt="chg.jpg"></p><p>以上图片来自微信朋友圈：这种天气你有什么破事打电话给我基本没用。但是如果你说“吃火锅”，那就厉害了，我们的故事就开始了。</p><p>本题要求你实现一个程序，自动检查你朋友给你发来的信息里有没有 <code>chi1 huo3 guo1</code>。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入每行给出一句不超过 80 个字符的、以回车结尾的朋友信息，信息为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。当读到某一行只有一个英文句点 <code>.</code> 时，输入结束，此行不算在朋友信息里。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出朋友信息的总条数。然后对朋友的每一行信息，检查其中是否包含 <code>chi1 huo3 guo1</code>，并且统计这样厉害的信息有多少条。在第二行中首先输出第一次出现 <code>chi1 huo3 guo1</code> 的信息是第几条（从 1 开始计数），然后输出这类信息的总条数，其间以一个空格分隔。题目保证输出的所有数字不超过 100。</p><p>如果朋友从头到尾都没提 <code>chi1 huo3 guo1</code> 这个关键词，则在第二行输出一个表情 <code>-_-#</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre><code class="in">Hello!are you there?wantta chi1 huo3 guo1?that&#39;s so li hai leour story begins from chi1 huo3 guo1 le.</code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre><code class="out">53 2</code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre><code class="in">Hello!are you there?wantta qi huo3 guo1 chi1huo3guo1?that&#39;s so li hai leour story begins from ci1 huo4 guo2 le.</code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre><code class="out">5-_-#</code></pre><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int flag=0;//用来判断是否是第一次找到吃火锅    int cnt=0;//用来记录总行数    int count=0;//用来记录有多少个吃火锅    int firstp=0;//用来记录第一次出现吃火锅的位置    string cmp=&quot;chi1 huo3 guo1&quot;;    while (true)    &#123;        string s;        s.clear();        getline(cin,s);        if(s.size()==1&amp;&amp;s==&quot;.&quot;)&#123;            break;        &#125;        string tmp =s;        if(tmp.find(cmp)!=string::npos)&#123;            if(flag==0) &#123;                flag =1;                firstp = cnt+1;            &#125;            count=count+1;        &#125;        cnt=cnt+1;    &#125;    if(count==0)&#123;        cout&lt;&lt;cnt&lt;&lt;endl;        cout&lt;&lt;&quot;-_-#&quot;&lt;&lt;endl;    &#125; else&#123;        cout&lt;&lt;cnt&lt;&lt;endl;        cout&lt;&lt;firstp&lt;&lt;&quot; &quot;&lt;&lt;count&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_50675813/article/details/113313343">(18条消息) c++STL中的find()函数 有两种使用方法_我们不生产代码，只是代码的搬运工的博客-CSDN博客_c++中find函数的使用方法</a></p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>Find</tag>
      
      <tag>STL</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由遍历顺序构建二叉树(前序+中序;后序+中序)</title>
    <link href="/2022/04/07/Algorithm014/"/>
    <url>/2022/04/07/Algorithm014/</url>
    
    <content type="html"><![CDATA[<h1 id="由遍历顺序构建二叉树-前序-中序-后序-中序"><a href="#由遍历顺序构建二叉树-前序-中序-后序-中序" class="headerlink" title="由遍历顺序构建二叉树(前序+中序;后序+中序)"></a>由遍历顺序构建二叉树(前序+中序;后序+中序)</h1><h2 id="前序-中序"><a href="#前序-中序" class="headerlink" title="前序+中序"></a>前序+中序</h2><pre><code class="c++">BiTree PreAndInCreateTree(int prel,int prer, int inl,int inr)&#123;    if(prel&gt;prer)&#123;        return NULL;    &#125;    BiTNode *root;    int index=0;    root=(BiTNode*)malloc(sizeof(BiTNode));//记住分配空间    root-&gt;data=preF[prel];//前序遍历的第一个结点是根结点    int i;    for(i=inl;i&lt;=inr;i++)    &#123;        if(preF[prel]==inF[i])&#123;            index=i;            break;            //找到了根结点，目的是在中序遍历中划分左右子树        &#125;    &#125;    //则其左子树节点个数为index-inl    //前序遍历的第一个结点是根结点,所以新的递归区间是prel+1,到prel+index-inl,    //中序遍历是左根右，所以新的递归区间是inl,index-1    root-&gt;lchild=PreAndInCreateTree(prel+1,prel+index-inl,inl,index-1);    //前序遍历是根左右，所以新的递归区间是prel+index-inl+1,prep    //中序遍历是左根右，所以新的递归区间是index+1,inr    root-&gt;rchild=PreAndInCreateTree(prel+index-inl+1,prer,index+1,inr);    return root;&#125;</code></pre><h2 id="后序-中序"><a href="#后序-中序" class="headerlink" title="后序+中序"></a>后序+中序</h2><pre><code class="c++">BiTree PostAndInCreateTree(int postl,int postr, int inl,int inr)&#123;    if(postl&gt;postr)&#123;        return NULL;    &#125;    BiTNode *root;    int index=0;    root=(BiTNode*)malloc(sizeof(BiTNode));    root-&gt;data=posts[postr];//后序遍历的最后一个结点是根结点    for (int i = inl; i &lt;=inr ; ++i) &#123;        if(posts[postr]==ins[i])        &#123;            index =i;            break;            //找到了根结点，目的是在中序遍历中划分左右子树        &#125;    &#125;//则其左子树节点个数为index-inl    //后续遍历的最后一个结点是根节点，所以新的递归区间是，postl,postl+index-inl-1    //中序遍历是左根右，所以新的递归区间是inl,index-1    root-&gt;lchild=PostAndInCreateTree(postl,postl+index-inl-1,inl,index-1);    //后序遍历是左右根，所以新的递归区间是postl+index-inl,postr-1    //中序遍历是左根右，所以新的递归区间是index+1,inr    root-&gt;rchild=PostAndInCreateTree(postl+index-inl,postr-1,index+1,inr);    return root;&#125;</code></pre><h2 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h2><p><strong>前序+中序；后序+中序。递归调用可视化查看：(有助于理解递归调用过程)</strong></p><p><a href="https://pythontutor.com/">Python Tutor - Visualize Python, Java, C, C++, JavaScript, TypeScript, and Ruby code execution</a></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct BiTNode&#123;    int data;//数据域    struct BiTNode *lchild,*rchild;//左右孩子指针&#125;BiTNode,*BiTree;//treeint preF[6]=&#123;4,2,1,3,5,6&#125;;//前序遍历int inF[6]=&#123;1,2,3,4,6,5&#125;;//中序遍历//treesint posts[7]=&#123;2,3,1,5,7,6,4&#125;;//后序遍历int ins[7]=&#123;1,2,3,4,5,6,7&#125;;//中序遍历BiTree PreAndInCreateTree(int prel,int prer, int inl,int inr)&#123;    if(prel&gt;prer)&#123;        return NULL;    &#125;    BiTNode *root;    int index=0;    root=(BiTNode*)malloc(sizeof(BiTNode));//记住分配空间    root-&gt;data=preF[prel];//前序遍历的第一个结点是根结点    int i;    for(i=inl;i&lt;=inr;i++)    &#123;        if(preF[prel]==inF[i])&#123;            index=i;            break;            //找到了根结点，目的是在中序遍历中划分左右子树        &#125;    &#125;    //则其左子树节点个数为index-inl    //前序遍历的第一个结点是根结点,所以新的递归区间是prel+1,到prel+index-inl,    //中序遍历是左根右，所以新的递归区间是inl,index-1    root-&gt;lchild=PreAndInCreateTree(prel+1,prel+index-inl,inl,index-1);    //前序遍历是根左右，所以新的递归区间是prel+index-inl+1,prep    //中序遍历是左根右，所以新的递归区间是index+1,inr    root-&gt;rchild=PreAndInCreateTree(prel+index-inl+1,prer,index+1,inr);    return root;&#125;BiTree PostAndInCreateTree(int postl,int postr, int inl,int inr)&#123;    if(postl&gt;postr)&#123;        return NULL;    &#125;    BiTNode *root;    int index=0;    root=(BiTNode*)malloc(sizeof(BiTNode));    root-&gt;data=posts[postr];//后序遍历的最后一个结点是根结点    for (int i = inl; i &lt;=inr ; ++i) &#123;        if(posts[postr]==ins[i])        &#123;            index =i;            break;            //找到了根结点，目的是在中序遍历中划分左右子树        &#125;    &#125;//则其左子树节点个数为index-inl    //后续遍历的最后一个结点是根节点，所以新的递归区间是，postl,postl+index-inl-1    //中序遍历是左根右，所以新的递归区间是inl,index-1    root-&gt;lchild=PostAndInCreateTree(postl,postl+index-inl-1,inl,index-1);    //后序遍历是左右根，所以新的递归区间是postl+index-inl,postr-1    //中序遍历是左根右，所以新的递归区间是index+1,inr    root-&gt;rchild=PostAndInCreateTree(postl+index-inl,postr-1,index+1,inr);    return root;&#125;void LevelOrder(BiTree T)&#123;    queue&lt;BiTree&gt; q;    q.push(T);    while (!q.empty())&#123;        BiTNode *tmp =q.front();        q.pop();        cout&lt;&lt;tmp-&gt;data;        if(tmp-&gt;lchild!=NULL)&#123;            q.push(tmp-&gt;lchild);        &#125;        if(tmp-&gt;rchild!=NULL)&#123;            q.push(tmp-&gt;rchild);        &#125;    &#125;&#125;int main()&#123;    BiTree tree;    tree=NULL;    tree=PreAndInCreateTree(0,5,0,5);    cout&lt;&lt;&quot;输入为前序加中序遍历，输出他的层序遍历：&quot;&lt;&lt;endl;    LevelOrder(tree);    cout&lt;&lt;endl;    BiTree trees;    trees=NULL;    cout&lt;&lt;&quot;输入为后序加中序遍历，输出他的层序遍历：&quot;&lt;&lt;endl;    trees=PostAndInCreateTree(0,6,0,6);    LevelOrder(trees);    return 0;&#125;</code></pre><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><pre><code class="c++">输入为前序加中序遍历，输出他的层序遍历：425136输入为后序加中序遍历，输出他的层序遍历：4163572</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的前、中、后、层序遍历</title>
    <link href="/2022/04/07/Algorithm013/"/>
    <url>/2022/04/07/Algorithm013/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的前、中、后、层序遍历"><a href="#二叉树的前、中、后、层序遍历" class="headerlink" title="二叉树的前、中、后、层序遍历"></a>二叉树的前、中、后、层序遍历</h1><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="前序遍历建树"><a href="#前序遍历建树" class="headerlink" title="前序遍历建树"></a>前序遍历建树</h3><pre><code class="c++">BiTree PreCreateTree(BiTree tree)&#123;    char ch;    cin&gt;&gt;ch;    if(ch==&#39;#&#39;) return NULL;    else&#123;        tree=(BiTree)malloc(sizeof(BiTNode));        tree-&gt;data=ch;        tree-&gt;lchild=PreCreateTree(tree-&gt;lchild);        tree-&gt;rchild=PreCreateTree(tree-&gt;rchild);        return tree;    &#125;&#125;</code></pre><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><pre><code class="c++">void PreOrder(BiTree root)//先序遍历 &#123;     if (root != NULL)     &#123;         printf(&quot;%c&quot;, root-&gt;data);         PreOrder(root-&gt;lchild);         PreOrder(root-&gt;rchild);     &#125; &#125;</code></pre><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><pre><code class="c++">void InOrder(BiTree root)//中序遍历&#123;    if (root != NULL)    &#123;        InOrder(root-&gt;lchild);        printf(&quot;%c&quot;, root-&gt;data);        InOrder(root-&gt;rchild);    &#125;&#125;</code></pre><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><pre><code class="c++">void PostOrder(BiTree root)//后序遍历&#123;    if (root != NULL)    &#123;        PostOrder(root-&gt;lchild);        PostOrder(root-&gt;rchild);        printf(&quot;%c&quot;, root-&gt;data);    &#125;&#125;</code></pre><h3 id="层序遍历-借助STL-queue-实现"><a href="#层序遍历-借助STL-queue-实现" class="headerlink" title="层序遍历(借助STL:queue)实现"></a>层序遍历(借助STL:queue)实现</h3><pre><code class="c++">void LevelOrder(BiTree T)&#123;    queue&lt;BiTree&gt; q;    q.push(T);    while (!q.empty())&#123;        BiTNode *tmp =q.front();        q.pop();        cout&lt;&lt;tmp-&gt;data;        if(tmp-&gt;lchild!=NULL)&#123;            q.push(tmp-&gt;lchild);        &#125;        if(tmp-&gt;rchild!=NULL)&#123;            q.push(tmp-&gt;rchild);        &#125;    &#125;&#125;</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef char ElemType;typedef struct BiTNode&#123;    ElemType data;//数据域    struct BiTNode *lchild,*rchild;//左右孩子指针&#125;BiTNode,*BiTree;BiTree PreCreateTree(BiTree tree)&#123;    char ch;    cin&gt;&gt;ch;    if(ch==&#39;#&#39;) return NULL;    else&#123;        tree=(BiTree)malloc(sizeof(BiTNode));        tree-&gt;data=ch;        tree-&gt;lchild=PreCreateTree(tree-&gt;lchild);        tree-&gt;rchild=PreCreateTree(tree-&gt;rchild);        return tree;    &#125;&#125;void PreOrder(BiTree root)//先序遍历 &#123;     if (root != NULL)     &#123;         printf(&quot;%c&quot;, root-&gt;data);         PreOrder(root-&gt;lchild);         PreOrder(root-&gt;rchild);     &#125; &#125;void InOrder(BiTree root)//中序遍历&#123;    if (root != NULL)    &#123;        InOrder(root-&gt;lchild);        printf(&quot;%c&quot;, root-&gt;data);        InOrder(root-&gt;rchild);    &#125;&#125;void PostOrder(BiTree root)//后序遍历&#123;    if (root != NULL)    &#123;        PostOrder(root-&gt;lchild);        PostOrder(root-&gt;rchild);        printf(&quot;%c&quot;, root-&gt;data);    &#125;&#125;void LevelOrder(BiTree T)&#123;    queue&lt;BiTree&gt; q;    q.push(T);    while (!q.empty())&#123;        BiTNode *tmp =q.front();        q.pop();        cout&lt;&lt;tmp-&gt;data;        if(tmp-&gt;lchild!=NULL)&#123;            q.push(tmp-&gt;lchild);        &#125;        if(tmp-&gt;rchild!=NULL)&#123;            q.push(tmp-&gt;rchild);        &#125;    &#125;&#125;int main()&#123;    BiTree tree;    tree=NULL;    //按先序的方式输入二叉树的结点元素（注：输入#表示节点为空）    //例如这棵树为:ABC##DE#G##F###    tree=PreCreateTree(tree);    cout&lt;&lt;&quot;前序遍历&quot;&lt;&lt;endl;    PreOrder(tree);    cout&lt;&lt;endl;    cout&lt;&lt;&quot;中序遍历&quot;&lt;&lt;endl;    InOrder(tree);    cout&lt;&lt;endl;    cout&lt;&lt;&quot;后序遍历&quot;&lt;&lt;endl;    PostOrder(tree);    cout&lt;&lt;endl;    cout&lt;&lt;&quot;层序遍历&quot;&lt;&lt;endl;    LevelOrder(tree);    return 0;&#125;</code></pre><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><pre><code class="c++">前序遍历ABCDEGF中序遍历CBEGDFA后序遍历CGEFDBA层序遍历ABCDEFG</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的存储结构</title>
    <link href="/2022/04/06/Algorithm012/"/>
    <url>/2022/04/06/Algorithm012/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h2 id="1-顺序存储方式"><a href="#1-顺序存储方式" class="headerlink" title="1.顺序存储方式"></a>1.顺序存储方式</h2><pre><code class="c++">#define MaxSize 100struct TreeNode&#123;    ElemType value;//结点中的数据元素    bool isEmpty;//结点是否为空&#125;;TreeNode t[MaxSize];</code></pre><h2 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="2.链式存储结构"></a>2.链式存储结构</h2><pre><code class="c++">typedef struct BiTNode&#123;    ElemType data;//数据域    struct BiTNode *lchild,*rchild;//左右孩子指针&#125;BiTNode,*BiTree;</code></pre><h2 id="3-三叉链表"><a href="#3-三叉链表" class="headerlink" title="3.三叉链表"></a>3.三叉链表</h2><p>三叉链表—方便找父节点</p><pre><code class="c++">typedef struct BiTNode&#123;    ElemType data;//数据域    struct BiTNode *lchild,*rchild;//左右孩子指针    struct BiTNode *parent;//父结点指针&#125;BiTNode,*BiTree;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串的存储结构</title>
    <link href="/2022/04/06/Algorithm011/"/>
    <url>/2022/04/06/Algorithm011/</url>
    
    <content type="html"><![CDATA[<h1 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h1><h2 id="1-定长顺序存储表示"><a href="#1-定长顺序存储表示" class="headerlink" title="1.定长顺序存储表示"></a>1.定长顺序存储表示</h2><pre><code class="c++">#define MAXLEN 255//预定义最大串长typedef struct&#123;    char ch[MAXLEN];//每个分量存储一个字符    int length;//串的实际长度&#125;SSting;</code></pre><h2 id="2-堆分配存储表示"><a href="#2-堆分配存储表示" class="headerlink" title="2.堆分配存储表示"></a>2.堆分配存储表示</h2><pre><code class="c++">typedef struct&#123;    char *ch;//按串长分配存储区，ch指向串的基地址    int length;//串的长度&#125;HString;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(六)-两个矩阵相加MPI版本</title>
    <link href="/2022/04/02/mpi006/"/>
    <url>/2022/04/02/mpi006/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI学习-六-两个矩阵相加MPI版本"><a href="#MPI学习-六-两个矩阵相加MPI版本" class="headerlink" title="MPI学习(六)-两个矩阵相加MPI版本"></a>MPI学习(六)-两个矩阵相加MPI版本</h1><p>这里，我们演示了两个简单的程序，一个是矩阵相加串行版本，一个是矩阵相加MPI版本</p><h2 id="串行版本"><a href="#串行版本" class="headerlink" title="串行版本"></a>串行版本</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;    int a[4][4]=&#123;1,2,3,4,                5,6,7,8,                9,10,11,12,                13,14,15,16&#125;;    int b[4][4]=&#123;4,2,5,7,                1,3,8,9,                11,12,17,5,                15,14,20,3&#125;;    int c[4][4];    memset(c,0,sizeof(c));     for(int i=0;i&lt;4;i++)    &#123;        for(int j=0;j&lt;4;j++)        &#123;            c[i][j]=a[i][j]+b[i][j];        &#125;    &#125;    for(int i=0;i&lt;4;i++)    &#123;        for(int j=0;j&lt;4;j++)        &#123;            printf(&quot;%d &quot;,c[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><pre><code class="c++">5 4 8 116 9 15 1720 22 28 1728 28 35 19</code></pre><h2 id="MPI版本"><a href="#MPI版本" class="headerlink" title="MPI版本"></a>MPI版本</h2><h3 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h3><p>北京超级云计算中心A3分区</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>mpi&#x2F;intel&#x2F;2017.5</p><h3 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h3><p>mpicxx mpi006.c -o mpi006</p><h3 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h3><p>srun -p amd_256 -N 1 -n  5  .&#x2F;mpi006(使用SLURM任务调度系统)</p><p>1个分区，核数为5</p><h3 id="程序源代码-1"><a href="#程序源代码-1" class="headerlink" title="程序源代码"></a>程序源代码</h3><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;mpi.h&gt;int main(int argc ,char **argv)&#123;    int a[4][4]=&#123;1,2,3,4,                5,6,7,8,                9,10,11,12,                13,14,15,16&#125;;    int b[4][4]=&#123;4,2,5,7,                1,3,8,9,                11,12,17,5,                15,14,20,3&#125;;    int c[4][4];    int tmp[4];    memset(c,0,sizeof(c));    int myid, numprocs;    MPI_Status status;    MPI_Request request;    MPI_Init(&amp;argc,&amp;argv);    MPI_Comm_size(MPI_COMM_WORLD,&amp;numprocs);    MPI_Comm_rank(MPI_COMM_WORLD,&amp;myid);    if(myid == 0)//0号进程接受来自其他进程的消息    &#123;        for(int i=1;i&lt;numprocs;i++)        &#123;            MPI_Irecv(&amp;c[i-1][0],4,MPI_INT,i,0,MPI_COMM_WORLD,&amp;request);//采用非阻塞接受            MPI_Wait(&amp;request,&amp;status);        &#125;        for(int i=0;i&lt;4;i++)//打印矩阵        &#123;                        for(int j=0;j&lt;4;j++)            &#123;                printf(&quot;%d &quot;,c[i][j]);            &#125;            printf(&quot;\n&quot;);        &#125;    &#125;    if(myid != 0 )//当进程不是0号进程时，则向0号进程发送消息    &#123;        memset(tmp,0,sizeof(tmp));//初始化tmp数组        for(int i=0;i&lt;4;i++)        &#123;            tmp[i]=a[myid-1][i]+b[myid-1][i];//用tmp来临时存储相加结果，随后发送给0号进程                    &#125;        MPI_Isend(&amp;tmp,4,MPI_INT,0,0,MPI_COMM_WORLD,&amp;request);//采用非阻塞发送        MPI_Wait(&amp;request,&amp;status);    &#125;    MPI_Finalize();    return 0;&#125;</code></pre><h3 id="程序输出-1"><a href="#程序输出-1" class="headerlink" title="程序输出"></a>程序输出</h3><pre><code class="c++">5 4 8 11 6 9 15 17 20 22 28 17 28 28 35 19</code></pre>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2022/03/31/Algorithm010/"/>
    <url>/2022/03/31/Algorithm010/</url>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的顺序存储解构"><a href="#队列的顺序存储解构" class="headerlink" title="队列的顺序存储解构"></a>队列的顺序存储解构</h3><h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><p>队列的顺序存储类型可描述为</p><pre><code class="c++">#define MaxSize 50//定义队列中元素的最大个数typedef struct&#123;    ElemType data[MaxSize];//存放队列元素    int front,rear;//队头指针和队尾指针&#125;SqQueue;</code></pre><h4 id="循环队列的操作"><a href="#循环队列的操作" class="headerlink" title="循环队列的操作"></a>循环队列的操作</h4><p>(1)初始化</p><pre><code class="c++">void InitQueue(SqQueue &amp;Q)&#123;    Q.rear=Q.front=0;//初始化队首、队尾指针&#125;</code></pre><p>(2)判队空</p><pre><code class="c++">bool isEmpty(SqQueue Q)&#123;    if(Q.rear == Q.front) return true;//队空条件    else return false;&#125;</code></pre><p>(3)入队</p><pre><code class="c++">bool EnQueue(SqQueue &amp;Q,ElemType x)&#123;    if((Q.rear+1)%MaxSize==Q.front)    return false;//队满则报错    Q.data[Q.rear]=x;    Q.rear=(Q.rear+1)%MaxSize;//队尾指针加1取模    return true;&#125;</code></pre><p>(4)出队</p><pre><code class="c++">bool DeQueue(SqQueue &amp;Q,ElemType &amp;x)&#123;    if(Q.rear == Q.front)return false; //队列空则报错    x=Q.data[Q.front];    Q.front=(Q.front+1)%MaxSize;//队头指针加1取模    return true;&#125;</code></pre><h4 id="循环队列的完整操作"><a href="#循环队列的完整操作" class="headerlink" title="循环队列的完整操作"></a>循环队列的完整操作</h4><h5 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h5><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ElemType;#define MaxSize 50//定义队列中元素的最大个数typedef struct&#123;    ElemType data[MaxSize];//存放队列元素    int front,rear;//队头指针和队尾指针&#125;SqQueue;void InitQueue(SqQueue &amp;Q)&#123;    Q.rear=Q.front=0;//初始化队首、队尾指针&#125;bool isEmpty(SqQueue Q)&#123;    if(Q.rear == Q.front) return true;//队空条件    else return false;&#125;bool EnQueue(SqQueue &amp;Q,ElemType x)&#123;    if((Q.rear+1)%MaxSize==Q.front)    return false;//队满则报错    Q.data[Q.rear]=x;    Q.rear=(Q.rear+1)%MaxSize;//队尾指针加1取模    return true;&#125;bool DeQueue(SqQueue &amp;Q,ElemType &amp;x)&#123;    if(Q.rear == Q.front)return false; //队列空则报错    x=Q.data[Q.front];    Q.front=(Q.front+1)%MaxSize;//队头指针加1取模    return true;&#125;void PrintSqQueue(SqQueue Q)&#123;//遍历操作     int point = Q.front;    while(point!=Q.rear)//如果point指向Q.rear说明遍历结束     &#123;//也就是point指向了队尾元素的下一个位置         cout&lt;&lt;Q.data[point]&lt;&lt;&quot; &quot;;        point=(point+1)%MaxSize;    &#125;    cout&lt;&lt;endl;&#125;int main()&#123;    SqQueue Q;//声明了一个顺序队列     InitQueue(Q);//初始化这个队列     for(int i=0;i&lt;5;i++)    &#123;        EnQueue(Q,i);//入队操作     &#125;    PrintSqQueue(Q);//遍历     for(int i=1;i&lt;=5;i++)    &#123;        int x;        DeQueue(Q,x);//出队         cout&lt;&lt;&quot;这是第&quot;&lt;&lt;i&lt;&lt;&quot;次出队&quot;&lt;&lt;&quot;出队的元素是&quot; &lt;&lt;x&lt;&lt;endl;        if(!isEmpty(Q))//队列非空则遍历         &#123;            cout&lt;&lt;&quot;当前队列为：&quot;;            PrintSqQueue(Q);        &#125;else&#123;            cout&lt;&lt;&quot;此时的队列为空队列&quot;&lt;&lt;endl;        &#125;            &#125;     return 0;&#125; </code></pre><h5 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h5><pre><code class="c++">0 1 2 3 4这是第1次出队出队的元素是0当前队列为：1 2 3 4这是第2次出队出队的元素是1当前队列为：2 3 4这是第3次出队出队的元素是2当前队列为：3 4这是第4次出队出队的元素是3当前队列为：4这是第5次出队出队的元素是4此时的队列为空队列</code></pre><h3 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h3><h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><p>队列的链式存储类型可描述为</p><pre><code class="c++">typedef struct LinkNode&#123;//链式队列结点    ElemType data;    struct LinkNode *next;&#125;LinkNode;typedef struct&#123;//链式队列    LinkNode *front,*rear;//队列的对头和队尾指针&#125;LinkQueue;</code></pre><h4 id="链式队列的基本操作"><a href="#链式队列的基本操作" class="headerlink" title="链式队列的基本操作"></a>链式队列的基本操作</h4><p>(1)初始化</p><pre><code class="c++">void InitQueue(LinkQueue &amp;Q)&#123;    Q.front = Q.rear=(LinkNode*)malloc(sizeof(LinkNode));//建立头结点    Q.front-&gt;next=NULL;//初始为空&#125;</code></pre><p>(2判队空</p><pre><code class="c++">bool IsEmpty(LinkQueue Q)&#123;    if(Q.front==Q.rear)return true;    else return false;&#125;</code></pre><p>(3)入队</p><pre><code class="c++">void EnQueue(LinkQueue &amp;Q,ElemType x)&#123;    LinkNode *s =(LinkNode*)malloc(sizeof(LinkNode));    s-&gt;data=x;//创建新结点，插入到链尾    s-&gt;next=NULL;    Q.rear-&gt;next=s;    Q.rear=s;&#125;</code></pre><p>(4)出队</p><pre><code class="c++">bool DeQueue(LinkQueue &amp;Q,ElemType &amp;x)&#123;    if(Q.front == Q.rear)return false;//空队    LinkNode *p =Q.front-&gt;next;    x=p-&gt;data;    Q.front-&gt;next=p-&gt;next;    if(Q.rear==p)&#123;        Q.rear = Q.front;//若原队列中只有一个结点，删除后变空    &#125;    free(p);    return true;&#125;</code></pre><h4 id="链式队列的完整操作"><a href="#链式队列的完整操作" class="headerlink" title="链式队列的完整操作"></a>链式队列的完整操作</h4><h5 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h5><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std; typedef struct LinkNode&#123;//链式队列结点    int data;    struct LinkNode *next;&#125;LinkNode;typedef struct&#123;//链式队列    LinkNode *front,*rear;//队列的对头和队尾指针&#125;LinkQueue;void InitQueue(LinkQueue &amp;Q)&#123;    Q.front = Q.rear=(LinkNode*)malloc(sizeof(LinkNode));//建立头结点    Q.front-&gt;next=NULL;//初始为空&#125;bool IsEmpty(LinkQueue Q)&#123;    if(Q.front==Q.rear)return true;    else return false;&#125;void EnQueue(LinkQueue &amp;Q,int x)&#123;    LinkNode *s =(LinkNode*)malloc(sizeof(LinkNode));    s-&gt;data=x;//创建新结点，插入到链尾    s-&gt;next=NULL;    Q.rear-&gt;next=s;    Q.rear=s;&#125;bool DeQueue(LinkQueue &amp;Q,int &amp;x)&#123;    if(Q.front == Q.rear)return false;//空队    LinkNode *p =Q.front-&gt;next;    x=p-&gt;data;    Q.front-&gt;next=p-&gt;next;    if(Q.rear==p)&#123;        Q.rear = Q.front;//若原队列中只有一个结点，删除后变空    &#125;    free(p);    return true;&#125;void PrintQueue(LinkQueue Q)//遍历队列 &#123;    LinkNode *tmp=Q.front-&gt;next;//声明一个结点用于遍历    while(tmp!=NULL)//如果这个结点为空则停止遍历    &#123;//这里即tmp已经指向最后一个元素的-&gt;next        cout&lt;&lt;tmp-&gt;data&lt;&lt;&quot; &quot;;//因为在初始化时已经置最后一个元素的-&gt;next=NULL        tmp=tmp-&gt;next;//所以说这里只需要判断tmp为空即可    &#125;    cout&lt;&lt;endl;    &#125;int main()&#123;    LinkQueue Q;//声明链式一个队列     InitQueue(Q);//初始化队列     for(int i=5;i&gt;0;i--)     //创建队列     &#123;        EnQueue(Q,i);    &#125;    PrintQueue(Q);      //遍历     for(int i=1;i&lt;=5;i++)    &#123;        int x;        DeQueue(Q,x);//出队         cout&lt;&lt;&quot;这是第&quot;&lt;&lt;i&lt;&lt;&quot;次出队&quot;&lt;&lt;&quot;出队的元素是&quot; &lt;&lt;x&lt;&lt;endl;        if(!IsEmpty(Q))//队列非空则遍历         &#123;            cout&lt;&lt;&quot;当前队列为：&quot;;            PrintQueue(Q);        &#125;else&#123;            cout&lt;&lt;&quot;此时的队列为空队列&quot;&lt;&lt;endl;        &#125;            &#125;    return 0;&#125;</code></pre><h5 id="程序输出：-1"><a href="#程序输出：-1" class="headerlink" title="程序输出："></a>程序输出：</h5><pre><code class="c++">5 4 3 2 1这是第1次出队出队的元素是5当前队列为：4 3 2 1这是第2次出队出队的元素是4当前队列为：3 2 1这是第3次出队出队的元素是3当前队列为：2 1这是第4次出队出队的元素是2当前队列为：1这是第5次出队出队的元素是1此时的队列为空队列</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2022/03/30/Algorithm009/"/>
    <url>/2022/03/30/Algorithm009/</url>
    
    <content type="html"><![CDATA[<h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><h3 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h3><p>栈的顺序存储类型可描述为：</p><pre><code class="c++">#define MaxSize 50//定义栈中元素的最大个数typedef struct&#123;    ElemType data[MaxSize];//存放栈中元素    int top;//栈顶指针&#125;SqStack;</code></pre><h3 id="顺序栈的基本运算"><a href="#顺序栈的基本运算" class="headerlink" title="顺序栈的基本运算"></a>顺序栈的基本运算</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code class="c++">void InitStack(SqStack &amp;s)&#123;    s.top=-1;//初始化栈顶指针&#125;</code></pre><h4 id="判栈空"><a href="#判栈空" class="headerlink" title="判栈空"></a>判栈空</h4><pre><code class="c++">bool StackEmpty(SqStack S)&#123;    if(s.top == -1)//栈空        return true;    else//不空        return false;      &#125;</code></pre><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><pre><code class="c++">bool Push(SqStack &amp;s,ElemType x)&#123;    if(s.top == MaxSize-1)//栈满，报错        return false;    s.data[++s.top]=x;//指针先加1，在入栈    return true;&#125;</code></pre><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><pre><code class="c++">bool Pop(SqStack &amp;s,ElemType &amp;x)&#123;    if(s.top == -1)//栈空，报错        return false;    x=s.data[s.top--];//先出栈，指针再减1    return true;&#125;</code></pre><h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><pre><code class="c++">bool GetTop(SqStack s,ElemType &amp;x)&#123;    if(s.top == -1 )//栈空，报错        return false;       x=s.data[s.top];//x记录栈顶元素    return true;&#125;</code></pre><h3 id="顺序栈的完整操作"><a href="#顺序栈的完整操作" class="headerlink" title="顺序栈的完整操作"></a>顺序栈的完整操作</h3><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std; typedef int ElemType;#define MaxSize 50//定义栈中元素的最大个数typedef struct&#123;    ElemType data[MaxSize];//存放栈中元素    int top;//栈顶指针&#125;SqStack;void InitStack(SqStack &amp;s)&#123;    s.top=-1;//初始化栈顶指针&#125;bool StackEmpty(SqStack S)&#123;    if(S.top == -1)//栈空        return true;    else//不空        return false;      &#125;bool Push(SqStack &amp;s,ElemType x)&#123;    if(s.top == MaxSize-1)//栈满，报错        return false;    s.data[++s.top]=x;//指针先加1，在入栈    return true;&#125;bool Pop(SqStack &amp;s,ElemType &amp;x)&#123;    if(s.top == -1)//栈空，报错        return false;    x=s.data[s.top--];//先出栈，指针再减1    return true;&#125;bool GetTop(SqStack s,ElemType &amp;x)&#123;    if(s.top == -1 )//栈空，报错        return false;       x=s.data[s.top];//x记录栈顶元素    return true;&#125;void PrintSqStack(SqStack s)//遍历栈 &#123;    int tmp = s.top;    while(tmp!=-1)//如果tmp==-1说明遍历结束     &#123;         cout&lt;&lt;s.data[tmp--]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl; &#125;int main()&#123;    SqStack s;//声明一个顺序栈     InitStack(s);//初始化一个顺序栈     for(int i=1;i&lt;=5;i++)    &#123;        Push(s,i);//入栈     &#125;    PrintSqStack(s);//遍历     for(int i=1;i&lt;=5;i++)&#123;//为了对比GetTop和Pop操作         int x;         GetTop(s,x);//取栈顶元素         cout&lt;&lt;&quot;这是GetTop操作,栈顶元素为&quot;&lt;&lt;x&lt;&lt;endl;        cout&lt;&lt;&quot;这是GetTop操作后的栈遍历:&quot;;        PrintSqStack(s);         Pop(s,x);//出栈         cout&lt;&lt;&quot;这是Pop操作,出栈的元素为&quot;&lt;&lt;x&lt;&lt;endl;        if(!StackEmpty(s))        &#123;            cout&lt;&lt;&quot;这是Pop操作后的栈遍历:&quot;;            PrintSqStack(s);         &#125;else&#123;            cout&lt;&lt;&quot;此时栈空！&quot;&lt;&lt;endl;        &#125;            &#125;    return 0;&#125;</code></pre><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><pre><code class="c++">5 4 3 2 1这是GetTop操作,栈顶元素为5这是GetTop操作后的栈遍历:5 4 3 2 1这是Pop操作,出栈的元素为5这是Pop操作后的栈遍历:4 3 2 1这是GetTop操作,栈顶元素为4这是GetTop操作后的栈遍历:4 3 2 1这是Pop操作,出栈的元素为4这是Pop操作后的栈遍历:3 2 1这是GetTop操作,栈顶元素为3这是GetTop操作后的栈遍历:3 2 1这是Pop操作,出栈的元素为3这是Pop操作后的栈遍历:2 1这是GetTop操作,栈顶元素为2这是GetTop操作后的栈遍历:2 1这是Pop操作,出栈的元素为2这是Pop操作后的栈遍历:1这是GetTop操作,栈顶元素为1这是GetTop操作后的栈遍历:1这是Pop操作,出栈的元素为1此时栈空！</code></pre><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>栈的链式存储类型可描述为</p><pre><code class="c++">typedef struct Linknode&#123;    ElemType data;//数据域    struct Linknode *next;//指针域&#125;*Linknode;//栈类型操作</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双链表与静态链表</title>
    <link href="/2022/03/29/Algorithm008/"/>
    <url>/2022/03/29/Algorithm008/</url>
    
    <content type="html"><![CDATA[<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>双链表中结点类型的描述如下：</p><pre><code class="c++">typedef struct DNode&#123;//定义双链表结点类型    ElemType data;//数据域    struct DNode *prior,*next;//前驱和后继指针&#125;DNode,*DLinkList;</code></pre><h3 id="双链表的插入操作"><a href="#双链表的插入操作" class="headerlink" title="双链表的插入操作"></a>双链表的插入操作</h3><pre><code class="c++">//p所指结点是s所指结点的前驱结点s-&gt;next=p-&gt;next;           //将结点*s插入到结点*p之后p-&gt;next-&gt;prior=s;s-&gt;prior=p;p-&gt;next=s;</code></pre><h3 id="双链表的删除操作"><a href="#双链表的删除操作" class="headerlink" title="双链表的删除操作"></a>双链表的删除操作</h3><pre><code class="c++">//删除双链表中结点*p的后继结点*qp-&gt;next=q-&gt;next;q-&gt;next-&gt;prior=p;free(q);//释放节点空间</code></pre><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>静态链表结构类型的描述如下：</p><pre><code class="c++">#define MaxSize 50//静态链表的最大长度typedef struct&#123;//静态链表结构类型的定义    ElemType data;//储存数据元素    int next;//下一个元素的数组下标&#125;SLinkList[MaxSize];</code></pre><h3 id="对静态链表结构类型的定义的理解与猜想验证"><a href="#对静态链表结构类型的定义的理解与猜想验证" class="headerlink" title="对静态链表结构类型的定义的理解与猜想验证"></a>对静态链表结构类型的定义的理解与猜想验证</h3><p><img src="/2022/03/29/Algorithm008/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8-16485415016461.png" alt="静态链表"></p><p><img src="/2022/03/29/Algorithm008/123-16485415073922.png" alt="123"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表上的基本操作</title>
    <link href="/2022/03/28/Algorithm007/"/>
    <url>/2022/03/28/Algorithm007/</url>
    
    <content type="html"><![CDATA[<h2 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h2><p>单链表中结点类型的描述如下：</p><pre><code class="c++">typedef struct LNode&#123;//定义单链表结点类型    ElemType data;//数据域    struct LNode *next;//指针域&#125;LNode,*LinkList;</code></pre><h2 id="单链表上基本操作的实现"><a href="#单链表上基本操作的实现" class="headerlink" title="单链表上基本操作的实现"></a>单链表上基本操作的实现</h2><h3 id="1-采用头插法建立单链表"><a href="#1-采用头插法建立单链表" class="headerlink" title="1.采用头插法建立单链表"></a>1.采用头插法建立单链表</h3><pre><code class="c++">LinkList List_HeadInsert(LinkList &amp;L)&#123;//逆向建立单链表    LNode *s;    int x;    L=(LinkList)malloc(sizeof(LNode));//创建头结点    L-&gt;next = NULL;//初始化为空链表    scanf(&quot;%d&quot;,&amp;x);//输入结点的值    while(x!=9999)&#123;//输入9999表示结束        s = (LNode*)malloc(sizeof(LNode));//建立新结点        s-&gt;data = x;        s-&gt;next = L-&gt;next;        L-&gt;next = s;//将新结点插入表中，L为头指针        scanf(&quot;%d&quot;,&amp;x);    &#125;    return L;&#125;</code></pre><h3 id="2-采用尾插法建立单链表"><a href="#2-采用尾插法建立单链表" class="headerlink" title="2.采用尾插法建立单链表"></a>2.采用尾插法建立单链表</h3><pre><code class="c++">LinkList List_TailInsert(LinkList &amp;L)&#123;//正向建立单链表    int x;//设置元素类型为整型    L=(LinkList)malloc(sizeof(LNode));    LNode *s,*r=L;//r为表尾指针    scanf(&quot;%d&quot;,&amp;x);    while(x!=9999)&#123;        s = (LNode*)malloc(sizeof(LNode));        s-&gt;data=x;        r-&gt;next = s;        r = s;//r指向新的表尾结点        scanf(&quot;%d&quot;,&amp;x);            &#125;    r-&gt;next = NULL;    return L;&#125;</code></pre><h3 id="3-按序号查找结点值"><a href="#3-按序号查找结点值" class="headerlink" title="3.按序号查找结点值"></a>3.按序号查找结点值</h3><pre><code class="c++">LNode *GetElem(LinkList L,int i)&#123;    int j=1;//计数，初始为1    LNode *p = L-&gt;next;//第1个结点指针赋给p    if(i==0)        return L;//若i等于0，则返回头结点    if(i&lt;1)        return NULL;//若i无效，则返回NULL    while(p&amp;&amp;j&lt;i)//从第一个结点开始找，查找第i个结点    &#123;        p=p-&gt;next;        j++;    &#125;    return p;//返回第i个结点的指针，若i大于表长，则返回NULL&#125;</code></pre><h3 id="4-按值查找表结点"><a href="#4-按值查找表结点" class="headerlink" title="4.按值查找表结点"></a>4.按值查找表结点</h3><pre><code class="c++">LNode *LocateElem(LinkList L,ElemType e)&#123;    LNode *p = L-&gt;next;    while(p!=NULL&amp;&amp;p-&gt;data!=e)//从第i个结点开始查找data域为e的结点    &#123;        p=p-&gt;next;    &#125;    return p;//找到后返回该结点指针，否则返回NULL&#125;</code></pre><h3 id="5-插入结点操作"><a href="#5-插入结点操作" class="headerlink" title="5.插入结点操作"></a>5.插入结点操作</h3><pre><code class="c++">//p所指结点是s所指结点的前驱结点void Insert(LinkList &amp;L,int i,int x)&#123;    LNode *p;    LNode *s=(LNode*)malloc(sizeof(LNode));//一定要分配空间！！！！！    s-&gt;data=x;    s-&gt;next=NULL;     p=GetElem(L,i-1);    if(p!=NULL)&#123;        s-&gt;next =p-&gt;next;        p-&gt;next=s;    &#125;else&#123;        cout&lt;&lt;&quot;插入值非法&quot;&lt;&lt;endl;        return ;     &#125;    &#125;</code></pre><p>对某一结点进行前插操作</p><pre><code class="c++">//注意与插入结点相对比!!!!!!!!void Delect(LinkList &amp;L,int i)&#123;    //p所指结点是q所指结点的前驱结点    LNode *p;    LNode *q=(LNode*)malloc(sizeof(LNode));   //申请空间     p=GetElem(L,i-1);    //查找删除位置的前驱结点    if(p==NULL||p-&gt;next==NULL)          //p==NULL是i值不合法的情况     &#123;    //p-&gt;next==NUll是i-1号结点后已无其他结点         cout&lt;&lt;&quot;删除值非法&quot;&lt;&lt;endl;        free(q);        return ;    &#125;    q=p-&gt;next;//令q指向被删除的结点    p-&gt;next=q-&gt;next;//将*q结点从链中“断开”    free(q);                                &#125;</code></pre><h3 id="6-删除结点操作"><a href="#6-删除结点操作" class="headerlink" title="6.删除结点操作"></a>6.删除结点操作</h3><pre><code class="c++">//p所指结点是q所指结点的前驱结点p=GetElem(L,i-1)//查找删除位置的前驱结点q=p-&gt;next;//令q指向被删除的结点p-&gt;next=q-&gt;next;//将*q结点从链中“断开”free(q);//释放结点的储存空间</code></pre><p>拓展:删除结点*p</p><pre><code class="c++">q=p-&gt;next;//令q指向*p的后继节点p-&gt;data = p-&gt;next-&gt;data//和后继结点交换数据域p-&gt;next = q-&gt;next;//将*q结点从链中“断开”free(q);//释放后继结点的储存空间</code></pre><h2 id="单链表上基本操作的完整实现"><a href="#单链表上基本操作的完整实现" class="headerlink" title="单链表上基本操作的完整实现"></a>单链表上基本操作的完整实现</h2><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ElemType;typedef struct LNode&#123;//定义单链表结点类型    ElemType data;//数据域    struct LNode *next;//指针域&#125;LNode,*LinkList;LinkList List_HeadInsert(LinkList &amp;L)&#123;//逆向建立单链表    LNode *s;    int x;    L=(LinkList)malloc(sizeof(LNode));//创建头结点    L-&gt;next = NULL;//初始化为空链表    scanf(&quot;%d&quot;,&amp;x);//输入结点的值    while(x!=9999)&#123;//输入9999表示结束        s = (LNode*)malloc(sizeof(LNode));//建立新结点        s-&gt;data = x;        s-&gt;next = L-&gt;next;        L-&gt;next = s;//将新结点插入表中，L为头指针        scanf(&quot;%d&quot;,&amp;x);    &#125;    return L;&#125;LNode *GetElem(LinkList L,int i)&#123;    int j=1;//计数，初始为1    LNode *p = L-&gt;next;//第1个结点指针赋给p    if(i==0)        return L;//若i等于0，则返回头结点    if(i&lt;1)        return NULL;//若i无效，则返回NULL    while(p&amp;&amp;j&lt;i)//从第一个结点开始找，查找第i个结点    &#123;        p=p-&gt;next;        j++;    &#125;    return p;//返回第i个结点的指针，若i大于表长，则返回NULL&#125;LNode *LocateElem(LinkList L,ElemType e)&#123;    LNode *p = L-&gt;next;    while(p!=NULL&amp;&amp;p-&gt;data!=e)//从第i个结点开始查找data域为e的结点    &#123;        p=p-&gt;next;    &#125;    return p;//找到后返回该结点指针，否则返回NULL&#125;void PrintLinkList(LinkList L)&#123;        //这段代码根据链表表尾结点的 next 指针指向 NULL 来遍历整个链表。    LNode *tmp = L-&gt;next;    if(tmp==NULL)    &#123;        cout&lt;&lt;&quot;链表为空&quot;&lt;&lt;endl;        return ;     &#125;    while(tmp!=NULL)&#123;        cout&lt;&lt;tmp-&gt;data&lt;&lt;&quot; &quot;;        tmp=tmp-&gt;next;    &#125;    cout&lt;&lt;endl; &#125;void Insert(LinkList &amp;L,int i,int x)&#123;    LNode *p;    LNode *s=(LNode*)malloc(sizeof(LNode));//申请空间     s-&gt;data=x;    s-&gt;next=NULL;     p=GetElem(L,i-1);    if(p!=NULL)&#123;        s-&gt;next =p-&gt;next;        p-&gt;next=s;    &#125;else&#123;        cout&lt;&lt;&quot;插入值非法&quot;&lt;&lt;endl;        return ;     &#125;    &#125;//注意与插入结点相对比!!!!!!!!void Delect(LinkList &amp;L,int i)&#123;    //p所指结点是q所指结点的前驱结点    LNode *p;    LNode *q=(LNode*)malloc(sizeof(LNode));   //申请空间     p=GetElem(L,i-1);    //查找删除位置的前驱结点    if(p==NULL||p-&gt;next==NULL)          //p==NULL是i值不合法的情况     &#123;    //p-&gt;next==NUll是i-1号结点后已无其他结点         cout&lt;&lt;&quot;删除值非法&quot;&lt;&lt;endl;        free(q);        return ;    &#125;    q=p-&gt;next;//令q指向被删除的结点    p-&gt;next=q-&gt;next;//将*q结点从链中“断开”    free(q);                                &#125;int main()&#123;    LinkList L;//声明一个单链表     List_HeadInsert(L);//使用头插法插入4个元素，分别是1,2,3,4     PrintLinkList(L);//遍历这个单链表    LNode *tmp;    tmp=GetElem(L,2);//找到位置为2的元素     if(tmp!=NULL)&#123;        cout&lt;&lt;&quot;位置为2的元素是：&quot;&lt;&lt;tmp-&gt;data&lt;&lt;endl;    &#125;else&#123;        cout&lt;&lt;&quot;非法的位置&quot;&lt;&lt;endl;    &#125;    tmp=LocateElem(L,1);//找到值为1的元素    if(tmp!=NULL)&#123;        cout&lt;&lt;&quot;存在值为1的元素：&quot;&lt;&lt;tmp-&gt;data&lt;&lt;endl;    &#125;else&#123;        cout&lt;&lt;&quot;没有找到该值&quot;&lt;&lt;endl;    &#125;    PrintLinkList(L);//遍历这个单链表    Insert(L,5,110);//在5这个位置插入元素110    PrintLinkList(L);//遍历这个单链表    Delect(L,2);        //删除位序为2的元素    PrintLinkList(L);//遍历这个单链表    return 0;&#125; </code></pre><h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><pre><code class="c++">4 3 2 1位置为2的元素是：3存在值为1的元素：14 3 2 14 3 2 1 1104 2 1 110</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表的定义</title>
    <link href="/2022/03/28/Algorithm006/"/>
    <url>/2022/03/28/Algorithm006/</url>
    
    <content type="html"><![CDATA[<h1 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h1><h2 id="1-单链表的定义"><a href="#1-单链表的定义" class="headerlink" title="1.单链表的定义"></a>1.单链表的定义</h2><pre><code class="c++">typedef struct LNode&#123;      //定义单链表结点类型    ElemType data;         //每个结点存放一个数据元素    struct LNode *next;    //指针指向下一个节点&#125;LNode,*LinkList;</code></pre><pre><code class="c++">typedef struct LNode&#123;      //定义单链表结点类型    ElemType data;         //每个结点存放一个数据元素    struct LNode *next;    //指针指向下一个节点&#125;;typedef struct LNode LNode;typedef struct LNode *LinkList;</code></pre><p>这两种定义是一模一样的！</p><p>要表示一个单链表时，只需要声明一个头指针L，指向单链表的第一个结点。</p><pre><code class="c++">LNoode *L;      //声明一个指向单链表第一个结点的指针//或：LinkList L;     //声明一个指向单链表第一个结点的指针</code></pre><h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h2><pre><code class="c++">LNode *L；//和：LinkList L;//两者的区别就是强调不同</code></pre><p><img src="/2022/03/28/Algorithm006/%E6%BC%94%E7%A4%BA.png"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优先队列</title>
    <link href="/2022/03/11/Algorithm005/"/>
    <url>/2022/03/11/Algorithm005/</url>
    
    <content type="html"><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>定义：priority_queue&lt;Type, Container, Functional&gt;</p><p>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。</p><p>当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆。<br>一般是：</p><pre><code class="c++">//升序队列，小顶堆priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//降序队列，大顶堆priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</code></pre><h2 id="样例一P1090-NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G"><a href="#样例一P1090-NOIP2004-提高组-合并果子-x2F-USACO06NOV-Fence-Repair-G" class="headerlink" title="样例一P1090 [NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G"></a>样例一P1090 [NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p><p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p><p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p><p>例如有 33种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 、 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 &#x3D;3+12&#x3D;15 。可以证明 15为最小的体力耗费值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>共两行。<br>第一行是一个整数 n*(1≤<em>n</em>≤10000) ，表示果子的种类数。</p><p>第二行包含 <em>n</em> 个整数，用空格分隔，第 <em>i</em> 个整数 a<strong>i*(1≤*a</strong>i<em>≤20000) 是第 i</em> 种果子的数目。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^{31} 。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a><strong>输入 #1</strong></h4><pre><code class="c++">3 1 2 9 </code></pre><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a><strong>输出 #1</strong></h4><pre><code class="c++">15</code></pre><h3 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h3><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;int main()&#123;    int n;    cin&gt;&gt;n;    int ans;    for (int i = 0; i &lt;n ; ++i) &#123;        int num;        cin&gt;&gt;num;        q.push(num);    &#125;    for (int j = 0; j &lt;n-1 ; ++j) &#123;        int a=q.top();        q.pop();        int b=q.top();        q.pop();        ans+=a+b;        q.push(a+b);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/huashanqingzhu/p/11040390.html">c++优先队列(priority_queue)用法详解 - 华山青竹 - 博客园 (cnblogs.com)</a></p><p>[P1090 <a href="https://www.luogu.com.cn/problem/P1090">NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perf-系统级性能分析工具</title>
    <link href="/2022/01/19/tool003/"/>
    <url>/2022/01/19/tool003/</url>
    
    <content type="html"><![CDATA[<p>系统级性能优化通常包括两个阶段：性能剖析（performance profiling）和代码优化。</p><p>性能剖析的目标是寻找性能瓶颈，查找引发性能问题的原因及热点代码。</p><p>代码优化的目标是针对具体性能问题而优化代码或编译选项，以改善软件性能。</p><p>在性能剖析阶段，需要借助于现有的profiling工具，如perf等。在代码优化阶段往往需要借助开发者的经验，编写简洁高效的代码，甚至在汇编级别合理使用各种指令，合理安排各种指令的执行顺序。</p><p>perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。<br>通过perf，应用程序可以利用PMU、tracepoint和内核中的计数器来进行性能统计。它不但可以分析制定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用程序和内核，从而全面理解应用程序中的性能瓶颈。</p><p>使用perf，可以分析程序运行期间发生的硬件事件，比如instructions retired、processor clock cycles等；也可以分析软件时间，比如page fault和进程切换。</p><p>perf是一款综合性分析工具，大到系统全局性性能，再小到进程线程级别，甚至到函数及汇编级别。</p><p>perf提供了十八般武器，可以拿大刀大卸八块，也可以拿起手术刀细致分析。</p><h1 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1. 背景知识"></a>1. 背景知识</h1><h2 id="1-1-tracepoints"><a href="#1-1-tracepoints" class="headerlink" title="1.1 tracepoints"></a>1.1 tracepoints</h2><p>tracepoints是散落在内核源码中的一些hook，它们可以在特定的代码被执行到时触发，这一特定可以被各种trace&#x2F;debug工具所使用。</p><p>perf将tracepoint产生的时间记录下来，生成报告，通过分析这些报告，便可以了解程序运行期间内核的各种细节，对性能症状做出准确的诊断。</p><p>这些tracepint的对应的sysfs节点在&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events目录下。</p><h2 id="1-2-硬件特性之cache"><a href="#1-2-硬件特性之cache" class="headerlink" title="1.2 硬件特性之cache"></a>1.2 硬件特性之cache</h2><p>内存读写是很快的，但是还是无法和处理器指令执行速度相比。为了从内存中读取指令和数据，处理器需要等待，用处理器时间来衡量，这种等待非常漫长。cache是一种SRAM，读写速度非常快，能和处理器相匹配。因此将常用的数据保存在cache中，处理器便无需等待，从而提高性能。cache的尺寸一般都很小，充分利用cache是软件调优非常重要部分。</p><h1 id="2-主要关注点"><a href="#2-主要关注点" class="headerlink" title="2. 主要关注点"></a>2. 主要关注点</h1><p>基于性能分析，可以进行算法优化（空间复杂度和时间复杂度权衡）、代码优化（提高执行速度、减少内存占用）。</p><p>评估程序对硬件资源的使用情况，例如各级cache的访问次数、各级cache的丢失次数、流水线停顿周期、前端总线访问次数等。</p><p>评估程序对操作系统资源的使用情况，系统调用次数、上下文切换次数、任务迁移次数。</p><p>事件可以分为三种：</p><ol><li>Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。</li><li>Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如进程切换，tick数等。</li><li>Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。</li></ol><h1 id="3-perf的使用"><a href="#3-perf的使用" class="headerlink" title="3. perf的使用"></a>3. perf的使用</h1><p>perf –help后可以看到perf的二级命令</p><p><img src="/2022/01/19/tool003/image-20220119120817508.png"></p><h2 id="3-1perf-list"><a href="#3-1perf-list" class="headerlink" title="3.1perf list"></a>3.1perf list</h2><p>perf list查看支持的事件类型</p><p><img src="/2022/01/19/tool003/image-20220119121131231.png"></p><h2 id="3-2perf-top"><a href="#3-2perf-top" class="headerlink" title="3.2perf top"></a>3.2perf top</h2><p>即可以正常显示perf top如下：</p><p>第一列：符号引发的性能事件的比例，指占用的cpu周期比例。</p><p>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。</p><p>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库；[k]表述此符号属于内核或模块。</p><p>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p><p><img src="/2022/01/19/tool003/image-20220119121453395.png"></p><h2 id="3-3-perf-stat"><a href="#3-3-perf-stat" class="headerlink" title="3.3 perf stat"></a>3.3 perf stat</h2><p>perf stat用于运行指令，并分析其统计结果。虽然perf top也可以指定pid，但是必须先启动应用才能查看信息。</p><p>perf stat能完整统计应用整个生命周期的信息。</p><p>命令格式为：</p><blockquote><p>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] <command><br>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] — <command> [<options>]</options></EVENT></EVENT></p></blockquote><p><img src="/2022/01/19/tool003/image-20220119122351095.png" alt="image-20220119122351095"></p><p><img src="/2022/01/19/tool003/C2DDB2280E83453D6D8FE0D11A4380C3.png"></p><p>cpu-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized &#x3D; task-clock &#x2F; time elapsed，CPU的占用率。</p><p>context-switches：程序在运行过程中上下文的切换次数。</p><p>CPU-migrations：程序在运行过程中发生的处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。</p><p>CPU迁移和上下文切换：发生上下文切换不一定会发生CPU迁移，而发生CPU迁移时肯定会发生上下文切换。发生上下文切换有可能只是把上下文从当前CPU中换出，下一次调度器还是将进程安排在这个CPU上执行。</p><p>page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。</p><p>cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles &#x2F; task-clock算出。</p><p>stalled-cycles-frontend：指令读取或解码的质量步骤，未能按理想状态发挥并行左右，发生停滞的时钟周期。</p><p>stalled-cycles-backend：指令执行步骤，发生停滞的时钟周期。</p><p>instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。</p><p>branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p><h2 id="3-4-perf-record-amp-report"><a href="#3-4-perf-record-amp-report" class="headerlink" title="3.4 perf record &amp; report"></a>3.4 perf record &amp; report</h2><p>运行一个命令，并将其数据保存到perf.data中。随后，可以使用perf report进行分析。</p><p>perf record和perf report可以更精确的分析一个应用，perf record可以精确到函数级别。并且在函数里面混合显示汇编语言和代码。</p><p><img src="/2022/01/19/tool003/image-20220119123152290.png"></p><p>1.编译程序(这里以test.c为例子)</p><p><img src="/2022/01/19/tool003/image-20220119124049654.png"></p><p>2.perf record</p><p><img src="/2022/01/19/tool003/image-20220119124217563.png"></p><p>3.perf report</p><p><img src="/2022/01/19/tool003/image-20220119124149337.png"></p><p><img src="/2022/01/19/tool003/image-20220119124013315.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/arnoldlu/p/6241297.html">系统级性能分析工具perf的介绍与使用 - ArnoldLu - 博客园 (cnblogs.com)</a>-系统性能分析工具perf的介绍与使用</p><p><a href="https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=11304698501320722134&spm_id_from=333.337.0.0">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcov代码覆盖率测试</title>
    <link href="/2022/01/18/tool002/"/>
    <url>/2022/01/18/tool002/</url>
    
    <content type="html"><![CDATA[<h1 id="gcov代码覆盖率测试"><a href="#gcov代码覆盖率测试" class="headerlink" title="gcov代码覆盖率测试"></a>gcov代码覆盖率测试</h1><h2 id="gcov的简单介绍"><a href="#gcov的简单介绍" class="headerlink" title="gcov的简单介绍"></a>gcov的简单介绍</h2><p>1.gcov是一个测试代码覆盖率的工具。与GCC一起使用来分析程序，以帮助创建更高效、更快的运行代码，并发现程序的未测试部分<br>2.是一个命令行方式的控制台程序。需要结合lcov,gcovr等前端图形工具才能实现统计数据图形化<br>3.伴随GCC发布，不需要单独下载gcov工具。配合GCC共同实现对c&#x2F;c++文件的语句覆盖和分支覆盖测试<br>4.与程序概要分析工具（profiling tool，例如gprof）一起工作，可以估计程序中哪段代码最耗时</p><h2 id="gcov能做什么"><a href="#gcov能做什么" class="headerlink" title="gcov能做什么"></a>gcov能做什么</h2><p>使用像gcov或gprof这样的分析器，您可以找到一些基本的性能统计数据：</p><ul><li>每一行代码执行的频率是多少</li><li>实际执行了哪些行代码，配合测试用例达到满意的覆盖率和预期工作</li><li>每段代码使用了多少计算时间，从而找到热点优化代码</li><li>gcov创建一个sourcefile.gcov的日志文件，此文件标识源文件sourcefile.c每一行执行的次数,您可以与gprof一起使用这些日志文件来帮助优化程序的性能。gprof提供了您可以使用的时间信息以及从gcov获得的信息。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.通过将一些代码行合并到一个函数中，可能不会提供足够的信息来查找代码使用大量计算机时间的“热点”。同样地，由于gcov按行(在最低的分辨率下)积累统计数据，它最适合于只在每行上放置一个语句的编程风格。如果您使用扩展到循环或其他控制结构的复杂宏，那么统计信息就没有那么有用了——它们只报告出现宏调用的行。如果您的复杂宏的行为类似于函数，那么您可以用inline fu替换它们。<br>2.gcov只在使用GCC编译的代码上工作。它与任何其他概要或测试覆盖机制不兼容。</p><h2 id="使用gcov的3个阶段"><a href="#使用gcov的3个阶段" class="headerlink" title="使用gcov的3个阶段"></a>使用gcov的3个阶段</h2><h3 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1.编译阶段"></a>1.编译阶段</h3><p>要开启gcov功能，需要在源码编译参数中加入-fprofile-arcs -ftest-coverage</p><ul><li>-ftest-coverage：在编译的时候产生.gcno文件，它包含了重建基本块图和相应的块的源码的行号的信息。</li><li>-fprofile-arcs：在运行编译过的程序的时候，会产生.gcda文件，它包含了弧跳变的次数等信息。</li></ul><p>以下我们以test.c这个程序为例子，源码如下：</p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int n=4;    int i=0;    for(i=0;i&lt;n;i++)    &#123;       printf(&quot;Hello World!\n&quot;);    &#125;    int a =20220118;    printf(&quot;%d\n&quot;,a);    return 0;&#125;</code></pre><p><strong>编译阶段：</strong></p><p><img src="/2022/01/18/tool002/image-20220118145007919.png"></p><h3 id="2-gcov收集代码运行信息"><a href="#2-gcov收集代码运行信息" class="headerlink" title="2. gcov收集代码运行信息"></a>2. gcov收集代码运行信息</h3><ul><li>运行<code>./test</code>产生<code>test.gcda</code>文件，其中包含了代码基本块和狐跳变次数统计信息</li></ul><p><img src="/2022/01/18/tool002/image-20220118145103922.png"></p><h4 id="3-生成gcov代码覆盖率报告"><a href="#3-生成gcov代码覆盖率报告" class="headerlink" title="3. 生成gcov代码覆盖率报告"></a>3. 生成gcov代码覆盖率报告</h4><ul><li>再次运行<code>gcov test.c</code>产生的<code>test.c.gcov</code>中包含了代码覆盖率数据,其数据的来源为<code>test.gcda</code></li></ul><p><img src="/2022/01/18/tool002/image-20220118145303290.png"></p><h3 id="4-查看生成gcov代码覆盖率报告"><a href="#4-查看生成gcov代码覆盖率报告" class="headerlink" title="4.查看生成gcov代码覆盖率报告"></a>4.查看生成gcov代码覆盖率报告</h3><p><img src="/2022/01/18/tool002/image-20220118145514099.png"></p><p>可以看到以下结果：</p><ul><li>其中<code>#####</code>表示未运行的行</li><li>每行前面的数字表示行运行的次数</li><li>—代表不必执行</li></ul><pre><code class="c">        -:    0:Source:test.c        -:    0:Graph:test.gcno        -:    0:Data:test.gcda        -:    0:Runs:1        -:    0:Programs:1        -:    1:#include&lt;stdio.h&gt;        1:    2:int main()        -:    3:&#123;        1:    4:        int n=4;        1:    5:        int i=0;        5:    6:        for(i=0;i&lt;n;i++)        -:    7:        &#123;        4:    8:           printf(&quot;Hello World!\n&quot;);        -:    9:        &#125;        1:   10:        int a =20220118;        1:   11:        printf(&quot;%d\n&quot;,a);        1:   12:        return 0;        -:   13:&#125;</code></pre><h2 id="配合lcov使用，图形化显示"><a href="#配合lcov使用，图形化显示" class="headerlink" title="配合lcov使用，图形化显示"></a>配合lcov使用，图形化显示</h2><p><strong>1.centos安装lcov:</strong></p><pre><code class="c++">yum install lcov</code></pre><p><strong>2.运行lcov，生成相应信息</strong></p><p><img src="/2022/01/18/tool002/image-20220118151526665.png"></p><p>运行结果：</p><p><img src="/2022/01/18/tool002/image-20220118151553801.png"></p><p><strong>3.生成web可视化信息</strong></p><p><img src="/2022/01/18/tool002/image-20220118151821325.png"></p><p>运行结果：</p><p><img src="/2022/01/18/tool002/image-20220118151853477.png"></p><p><strong>4.打包result文件</strong></p><p><img src="/2022/01/18/tool002/image-20220118152629648.png"></p><p><strong>5.从服务器下载到本地</strong></p><p><img src="/2022/01/18/tool002/image-20220118152705023.png"></p><p><strong>6.查看web</strong></p><p>​1）查看index.html：</p><p><img src="/2022/01/18/tool002/image-20220118152825105.png"></p><p>​2）详细信息：</p><p><img src="/2022/01/18/tool002/image-20220118152908078.png"></p><p>上述界面包含：</p><ul><li>函数覆盖率（执行率）</li><li>代码行数覆盖率（执行率）</li><li>语句执行次数</li><li>源码级的详细信息</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/yanxiangyfg/article/details/80989680">(6条消息) gcov代码覆盖率测试-原理和实践总结_yanxiangyfg的专栏-CSDN博客_gcov代码覆盖率</a>-gcov代码覆盖率测试-原理和实践总结</p><p><a href="https://blog.csdn.net/u012247418/article/details/90137291">(6条消息) 代码覆盖率测试工具：gcov和lcov的使用_ARM-Linux-CSDN博客</a>-代码覆盖率测试工具：gcov和lcov的使用</p><p><a href="https://www.cnblogs.com/haoshine/p/5777735.html">linux文件夹打包命令 - 小作一个 - 博客园 (cnblogs.com)</a>-Linux文件打包命令</p><p><a href="https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=16561916178807634748&spm_id_from=333.337.0.0">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(五)-INT型数组相加操作</title>
    <link href="/2022/01/17/AVX005/"/>
    <url>/2022/01/17/AVX005/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX向量化学习-五-INT型数组相加操作"><a href="#AVX向量化学习-五-INT型数组相加操作" class="headerlink" title="AVX向量化学习(五)-INT型数组相加操作"></a>AVX向量化学习(五)-INT型数组相加操作</h1><p>使用AVX指令集进行2个INT型的数组相加操作</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><pre><code class="c++">__m256i _mm256_loadu_si256 (__m256i const * mem_addr)</code></pre><p><strong>Synopsis</strong></p><p>m256i _mm256_loadu_si256 (m256i const * mem_addr)<br>#include &lt;immintrin.h&gt;<br>Instruction: vmovdqu ymm, m256<br>CPUID Flags: AVX</p><p><strong>Description</strong></p><p>Load 256-bits of integer data from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p><p><strong>Operation</strong></p><pre><code class="c++">dst[255:0] := MEM[mem_addr+255:mem_addr] dst[MAX:256] := 0</code></pre><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">7</td><td align="center">0.5</td></tr><tr><td align="left">Skylake</td><td align="center">7</td><td align="center">0.5</td></tr><tr><td align="left">Broadwell</td><td align="center">1</td><td align="center">0.25</td></tr><tr><td align="left">Haswell</td><td align="center">1</td><td align="center">0.25</td></tr><tr><td align="left">Ivy Bridge</td><td align="center">1</td><td align="center">0.5</td></tr></tbody></table><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><pre><code class="c++">__m256i _mm256_add_epi32 (__m256i a, __m256i b)</code></pre><p><strong>Synopsis</strong></p><p>m256i _mm256_add_epi32 (m256i a, __m256i b)<br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd ymm, ymm, ymm<br>CPUID Flags: AVX2</p><p><strong>Description</strong></p><p>Add packed 32-bit integers in a and b, and store the results in dst.</p><p><strong>Operation</strong></p><pre><code>FOR j := 0 to 7          i := j*32          dst[i+31:i] := a[i+31:i] + b[i+31:i] ENDFOR dst[MAX:256] := 0</code></pre><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">1</td><td align="center">0.33</td></tr><tr><td align="left">Skylake</td><td align="center">1</td><td align="center">0.33</td></tr><tr><td align="left">Broadwell</td><td align="center">1</td><td align="center">0.5</td></tr><tr><td align="left">Haswell</td><td align="center">1</td><td align="center">0.5</td></tr></tbody></table><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><pre><code class="c++">#include&lt;stdio.h&gt;#include &lt;immintrin.h&gt;int main()&#123;    int a[40];    int b[40];    int i=0;    int ans1[40];    //记录串行结果     int ans2[40]; //记录AVX向量化后的结果    for (i=0;i&lt;40;i++)    &#123;        a[i]=i;        b[i]=2*i;    &#125;    for (i=0;i&lt;40;i++)    &#123;        ans1[i]=a[i]+b[i];    &#125;    printf(&quot;串行计算结果：\n&quot;);    for (i=0;i&lt;40;i++)    &#123;        printf(&quot;%d &quot;,ans1[i]);    &#125;    printf(&quot;\n&quot;);    __m256i v0;    __m256i v1;    __m256i v2;    for (i=0;i&lt;40-8;i+=8)    &#123;        v0 = _mm256_loadu_si256((const __m256i*)(a+i)); //强制类型转换        v1 = _mm256_loadu_si256((const __m256i*)(b+i)); //强制类型转化        v2 = _mm256_add_epi32(v0,v1);     //v0+v1        _mm256_storeu_si256((__m256i*)(ans2+i),v2);            &#125;//边界处理    for (;i&lt;40;i++)    &#123;        ans2[i]=a[i]+b[i];    &#125;    printf(&quot;并行计算结果：\n&quot;);    for (i=0;i&lt;40;i++)    &#123;        printf(&quot;%d &quot;,ans2[i]);    &#125;    return 0; &#125;</code></pre><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><pre><code class="c++">串行计算结果：0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117并行计算结果：0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117</code></pre><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(四)-INT类型转化成DOUBLE类型</title>
    <link href="/2022/01/17/AVX004/"/>
    <url>/2022/01/17/AVX004/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX向量化学习-四-INT类型转化成DOUBLE类型"><a href="#AVX向量化学习-四-INT类型转化成DOUBLE类型" class="headerlink" title="AVX向量化学习(四)-INT类型转化成DOUBLE类型"></a>AVX向量化学习(四)-INT类型转化成DOUBLE类型</h1><p>使用AVX指令集把INT类型转化为DOUBLE类型</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><pre><code class="c++">__m128i _mm_setr_epi32 (int e3, int e2, int e1, int e0)</code></pre><p><strong>Synopsis</strong></p><p>__m128i _mm_setr_epi32 (int e3, int e2, int e1, int e0)<br>#include &lt;emmintrin.h&gt;<br>Instruction: <strong>Sequence</strong><br>CPUID Flags: SSE2</p><p><strong>Description</strong></p><p>Set packed 32-bit integers in dst with the supplied values in reverse order.</p><p><strong>Operation</strong></p><pre><code class="c++">dst[31:0] := e3 dst[63:32] := e2 dst[95:64] := e1 dst[127:96] := e0</code></pre><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><pre><code class="c++">__m256d _mm256_cvtepi32_pd (__m128i a)</code></pre><p><strong>Synopsis</strong></p><p>m256d _mm256_cvtepi32_pd (m128i a)<br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtdq2pd ymm, xmm<br>CPUID Flags: AVX</p><p><strong>Description</strong></p><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p><p><strong>Operation</strong></p><pre><code class="c++">FOR j := 0 to 3     i := j*32     m := j*64     dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i]) ENDFOR dst[MAX:256] := 0</code></pre><p><strong>Performance</strong></p><table><thead><tr><th align="left">Architecture</th><th align="center">Latency</th><th align="center">Throughput (CPI)</th></tr></thead><tbody><tr><td align="left">Icelake</td><td align="center">7</td><td align="center">1</td></tr><tr><td align="left">Skylake</td><td align="center">7</td><td align="center">1</td></tr><tr><td align="left">Broadwell</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="left">Haswell</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="left">Ivy Bridge</td><td align="center">4</td><td align="center">1</td></tr></tbody></table><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>g++ int_to_double.cpp -msse2 -mavx -o test01</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>.&#x2F;test01</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><pre><code class="c++">#include &lt;iostream&gt;#include &lt;immintrin.h&gt;using namespace std;int main()&#123;    int a[4]=&#123;1,2,3,4&#125;;    double b[9]=&#123;0&#125;;    __m128i x = _mm_setr_epi32(a[0], a[1], a[2],a[3]);   //load     __m256d v5=_mm256_cvtepi32_pd(x);       //convert    _mm256_storeu_pd(b,v5);    for(int i=0;i&lt;9;i++)    &#123;        cout&lt;&lt;b[i]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><pre><code class="c++">123400000</code></pre><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gprof、gprof2dot.py、dot使用方法简介</title>
    <link href="/2022/01/09/tool001/"/>
    <url>/2022/01/09/tool001/</url>
    
    <content type="html"><![CDATA[<h1 id="gprof、gprof2dot-py、dot使用方法简介"><a href="#gprof、gprof2dot-py、dot使用方法简介" class="headerlink" title="gprof、gprof2dot.py、dot使用方法简介"></a>gprof、gprof2dot.py、dot使用方法简介</h1><h2 id="1-：gprof使用步骤如下，以SLIC为例："><a href="#1-：gprof使用步骤如下，以SLIC为例：" class="headerlink" title="(1)：gprof使用步骤如下，以SLIC为例："></a>(1)：gprof使用步骤如下，以SLIC为例：</h2><h3 id="1-在编译过程中添加-pg选项，命令如下："><a href="#1-在编译过程中添加-pg选项，命令如下：" class="headerlink" title="1 在编译过程中添加-pg选项，命令如下："></a>1 在编译过程中添加-pg选项，命令如下：</h3><pre><code class="c++">gcc -pg SLIC.cpp -o SLIC</code></pre><h3 id="2-运行程序，运行结束之后会形成文件gmon-out，命令如下"><a href="#2-运行程序，运行结束之后会形成文件gmon-out，命令如下" class="headerlink" title="2 运行程序，运行结束之后会形成文件gmon.out，命令如下:"></a>2 运行程序，运行结束之后会形成文件gmon.out，命令如下:</h3><pre><code>./SLIC</code></pre><h3 id="3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下："><a href="#3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下：" class="headerlink" title="3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下："></a>3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下：</h3><pre><code>gprof ./SLIC &gt; prof.log</code></pre><p>分析prof.log就可以获得程序的调用关系、函数执行时间等信息。对gprof的分析方法见以下blog</p><p><a href="http://blog.csdn.net/macky0668/article/details/6839517">http://blog.csdn.net/macky0668/article/details/6839517</a></p><h2 id="2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台"><a href="#2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台" class="headerlink" title="(2)：配合gprof2dot.py与dot工具的使用(我是安装在了Win10平台)"></a>(2)：配合<em>gprof2dot.py</em>与dot工具的使用(我是安装在了Win10平台)</h2><p>以上方法仍然存在一个问题就是分析结果不够直观，特别是函数的调用关系。因此为解决以上问题，可以配合<em>gprof2dot.py</em>与dot工具的使用。</p><h3 id="1-安装gprof2dot-py与dot"><a href="#1-安装gprof2dot-py与dot" class="headerlink" title="1.安装gprof2dot.py与dot"></a>1.安装<em>gprof2dot.py</em>与dot</h3><p><a href="https://github.com/jrfonseca/gprof2dot">GitHub - jrfonseca&#x2F;gprof2dot: Converts profiling output to a dot graph.</a></p><h3 id="2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具"><a href="#2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具" class="headerlink" title="2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具"></a>2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具</h3><p><a href="https://graphviz.org/download/source/">Source Code | Graphviz</a></p><p>在使用上述工具前，还需要先产生prof.log文件，prof.log文件的产生方法见上文。</p><h3 id="3-首先通过命令行进入你安装gprof2dot-py的根目录："><a href="#3-首先通过命令行进入你安装gprof2dot-py的根目录：" class="headerlink" title="3.首先通过命令行进入你安装gprof2dot.py的根目录："></a>3.首先通过命令行进入你安装gprof2dot.py的根目录：</h3><p><img src="/2022/01/09/tool001/image-20220109165659998.png"></p><h3 id="4-通过以下命令即可得到函数调用图："><a href="#4-通过以下命令即可得到函数调用图：" class="headerlink" title="4.通过以下命令即可得到函数调用图："></a>4.通过以下命令即可得到函数调用图：</h3><p><img src="/2022/01/09/tool001/image-20220109170212157.png"></p><h3 id="5-结果如下："><a href="#5-结果如下：" class="headerlink" title="5.结果如下："></a>5.结果如下：</h3><p><img src="/2022/01/09/tool001/image-20220109170315471.png"></p><h2 id="3-：接上文补充几点可能无法产生gmon-out文件的情况："><a href="#3-：接上文补充几点可能无法产生gmon-out文件的情况：" class="headerlink" title="(3)：接上文补充几点可能无法产生gmon.out文件的情况："></a>(3)：接上文补充几点可能无法产生gmon.out文件的情况：</h2><p>  1.程序不是从main return或exit()退出，则可能不生成gmon.out。<br>  2.程序如果崩溃，可能不生成gmon.out。<br>  3.测试发现在虚拟机上运行，可能不生成gmon.out。<br>  4.程序忽略SIGPROF信号！一定不能捕获、忽略SIGPROF信号。man手册对SIGPROF的解释是：profiling timer expired. 如果忽略这个信号，gprof的输出则是：Each sample counts as 0.01 seconds. no time accumulated.<br>  5.如果程序运行时间非常短，则gprof可能无效</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://blog.csdn.net/u012927281/article/details/51132064">(4条消息) gprof、gprof2dot.py、dot使用方法简介_Andy.Wang的博客-CSDN博客_gprof2dot</a></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/01/04/Algorithm004/"/>
    <url>/2022/01/04/Algorithm004/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集（Disjoint Set）是一种非常精巧而实用的数据结构。用于处理不相交集合的合并问题。</p><p>并查集用来管理元素分组情况。并查集可以高效地进行如下操作。</p><p>1.查询元素 a和元素 b是否属于同一组。<br>2.合并元素 a和元素 b所在的组。<br><img src="/2022/01/04/Algorithm004/20191114081139557.png"></p><p><img src="/2022/01/04/Algorithm004/20191114081642983-16413015433853.png"></p><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><p>我们准备 n个节点来表示 n个元素。最开始时没有边。</p><p><img src="/2022/01/04/Algorithm004/20191114081846480.png"></p><h2 id="2-查询"><a href="#2-查询" class="headerlink" title="2.查询"></a>2.查询</h2><p>为了查询两个节点是否属于同一组，我们需要沿着树向上走，来查询包含这个元素的树的根是谁。如果两个节点走到了同一个根，那么就可以知道它们属于同一组。</p><p>在下图中，元素 2 和元素 5都走到了元素 1，因此它们属于同一组。另一方面，由于元素 7 走到的是元素 6，因此同元素 2或元素 5 属于不同组。</p><p><img src="/2022/01/04/Algorithm004/20191114082935860.png"></p><h2 id="3-合并"><a href="#3-合并" class="headerlink" title="3.合并"></a>3.合并</h2><p>像下图一样，从一个组的根向另一个组的根连边，这样两棵树就变成了一棵树， 也就把两个组合并为一个组了。</p><p><img src="/2022/01/04/Algorithm004/20191114082505100.png"></p><h2 id="4-路径压缩"><a href="#4-路径压缩" class="headerlink" title="4.路径压缩"></a>4.路径压缩</h2><p>上面的查询程序 find() 沿着搜索路径找到根结点，这条路径可能很长。</p><p>优化：沿路径返回时，顺便把 i 所属的集改成根结点。下次再搜，复杂度是 O(1)。</p><p>这种方法称为路径压缩，在递归过程中，整个搜索路径上的元素所属的集都被改为根结点。</p><p>路径压缩的思想是，我们只关心每个结点的父结点，而并不太关心树的真正的结构。路径压缩不仅优化了下次查询，而且也优化了合并，因为合并时也用到了查询。<br><img src="/2022/01/04/Algorithm004/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODE1MTg4,size_16,color_FFFFFF,t_70.png"><img src="/2022/01/04/Algorithm004/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODE1MTg4,size_16,color_FFFFFF,t_70-16413019286669.png"></p><h2 id="5-按秩合并"><a href="#5-按秩合并" class="headerlink" title="5.按秩合并"></a>5.按秩合并</h2><p>合并元素 x 和 y 时，先搜到它们的根结点；<br>合并这两个根结点：把一个根结点的集改成另一个根结点。<br>这两个根结点的高度不同，把高度较小的集合并到较大的集上，能减少树的高度。</p><p><img src="/2022/01/04/Algorithm004/20191114090118888.png"></p><p>这样，在初始化时就要用一个数组定义元素 i的高度，在合并时更改。</p><p>下面代码加入了上述两个优化，我们用编号代表每个元素。数组 par[ ]表示的是父亲的编号，par[ x ] &#x3D; &#x3D; x  时，x 是所在的树的根。</p><pre><code class="c++">int par[N];   //父亲int rank[N];  //树的高度// 初始化n个元素void init(int n)&#123;    for(int i = 0; i &lt; n; i++)    &#123;        par[i] = i;        rank[i] = 0;    &#125;&#125;// 查询树的根（路径压缩）int find(int x)&#123;    if(par[x] == x)        return x;    else        return par[x] = find(par[x]);&#125;// 合并x和y所属的集合（按秩合并）void unite(int x, int y)&#123;    x = find(x);    y = find(y);    if(x == y)  return;        if(rank[x] &lt; rank[y])        par[x] = y;    else    &#123;        par[y] = x;        if(rank[x] == rank[y])rank[x]++;    &#125;&#125;</code></pre><h2 id="样题一：L2-024-部落-25-分"><a href="#样题一：L2-024-部落-25-分" class="headerlink" title="样题一：L2-024 部落 (25 分)"></a>样题一：<strong>L2-024 部落 (25 分)</strong></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查任意两个人是否属于同一个部落。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤104），是已知小圈子的个数。随后<em>N</em>行，每行按下列格式给出一个小圈子里的人：</p><p><em>K</em> <em>P</em>[1] <em>P</em>[2] ⋯ <em>P</em>[<em>K</em>]</p><p>其中<em>K</em>是小圈子里的人数，<em>P</em>[<em>i</em>]（<em>i</em>&#x3D;1,⋯,<em>K</em>）是小圈子里每个人的编号。这里所有人的编号从1开始连续编号，最大编号不会超过104。</p><p>之后一行给出一个非负整数<em>Q</em>（≤104），是查询次数。随后<em>Q</em>行，每行给出一对被查询的人的编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出<code>Y</code>，否则输出<code>N</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">43 10 1 22 3 44 1 5 7 83 9 6 4210 53 7结尾无空行</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">10 2YN结尾无空行</code></pre><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int  N=10005;int par[N];       //父亲int deep[N];      //树的高度int isroot[N];    //用来记录互不相交的部落的个数。如果同属于一个部落，那个这个部落的元素的根节点都是一样的。                  //所以只要统计有多少个根节点就可以知道有多少个互不相交的部落个数set&lt;int&gt; st;      //集合能很好的过滤到重复元素，可以很方便的用来统计不是重复元素的个数void init(int n)&#123;    for(int i=0;i&lt;n;i++)    &#123;        par[i] = i;        deep[i] =0;    &#125;&#125;int find(int x)&#123;    if(par[x] == x ) return x;    else return par[x] = find(par[x]);&#125;void unite(int x,int y)&#123;    x=find(x);    y=find(y);    if(x==y) return;    if(deep[x]&lt;deep[y])    &#123;        par[x]=y;    &#125;else&#123;        par[y]=x;        if(deep[x]==deep[y]) deep[x]++;    &#125;&#125;int main() &#123;    int n;    cin&gt;&gt;n;    init(10005);    memset(isroot,0,sizeof(isroot));    int ans=0;    for (int i = 0; i &lt;n ; ++i) &#123;        int num,first;        cin&gt;&gt;num&gt;&gt;first;        st.insert(first);        for (int j = 1; j &lt;num ; ++j) &#123;            int next;            cin&gt;&gt;next;            st.insert(next);            unite(first,next);        &#125;    &#125;    //寻找互不相交的部落    for (int l = 1; l &lt;=st.size() ; ++l) &#123;        isroot[find(l)]=1;    &#125;    for (int m = 1; m &lt;=st.size() ; ++m) &#123;        ans+=isroot[m];    &#125;    cout&lt;&lt;st.size()&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;    int time;    cin&gt;&gt;time;    for (int k = 0; k &lt;time ; ++k) &#123;        int a,b;        cin&gt;&gt;a&gt;&gt;b;        if(find(a)==find(b))        &#123;            cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl;        &#125;        else&#123;            cout&lt;&lt;&quot;N&quot;&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="相关资料："><a href="#相关资料：" class="headerlink" title="相关资料："></a>相关资料：</h2><p><a href="https://blog.csdn.net/qq_42815188/article/details/86769629">(3条消息) 并查集_早睡身体好hh-CSDN博客_并查集</a>：早睡身体好hh-并查集(CSDN)</p><h2 id="样题链接："><a href="#样题链接：" class="headerlink" title="样题链接："></a>样题链接：</h2><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805056736444416">题目详情 - L2-024 部落 (25 分) (pintia.cn)</a>：L2-024 部落 (25 分)</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径-Floyed和Dijkstra</title>
    <link href="/2022/01/03/Algorithm003/"/>
    <url>/2022/01/03/Algorithm003/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径-Floyed和Dijkstra"><a href="#最短路径-Floyed和Dijkstra" class="headerlink" title="最短路径-Floyed和Dijkstra"></a>最短路径-Floyed和Dijkstra</h1><h2 id="Floyed"><a href="#Floyed" class="headerlink" title="Floyed"></a>Floyed</h2><h3 id="样题一：P1364-医院设置"><a href="#样题一：P1364-医院设置" class="headerlink" title="样题一：P1364 医院设置"></a>样题一：P1364 医院设置</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设有一棵二叉树，如图：</p><p><img src="/2022/01/03/Algorithm003/166.png"></p><p>其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 11。如上图中，若医院建在1 处，则距离和 &#x3D;4+12+2\times20+2\times40&#x3D;136&#x3D;4+12+2×20+2×40&#x3D;136；若医院建在 33 处，则距离和 &#x3D;4\times2+13+20+40&#x3D;81&#x3D;4×2+13+20+40&#x3D;81。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>第一行一个整数 n<em>n</em>，表示树的结点数。</p><p>接下来的 n<em>n</em> 行每行描述了一个结点的状况，包含三个整数 w, u, v<em>w</em>,<em>u</em>,<em>v</em>，其中 w<em>w</em> 为居民人口数，u<em>u</em> 为左链接（为 00 表示无链接），v<em>v</em> 为右链接（为 00 表示无链接）。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>一个整数，表示最小距离和。</p><h4 id="输入输出样例："><a href="#输入输出样例：" class="headerlink" title="输入输出样例："></a>输入输出样例：</h4><pre><code>513 2 34 0 012 4 520 0 040 0 0</code></pre><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><pre><code>81</code></pre><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int tree[1000][1000];   //tree的作用邻接矩阵建树int w[1000],l,r;  //w每个结点的居民人口数int mindis;       //最小记录和int main() &#123;    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            tree[i][j]=0X3FFFFFFF;    //初始化邻接矩阵        &#125;    &#125;    for (int i = 1; i &lt;=n ; ++i) &#123;        tree[i][i]=0;    //初始化        cin&gt;&gt;w[i]&gt;&gt;l&gt;&gt;r;  //读入数据        if(l&gt;0) tree[i][l]=tree[l][i]=1;        if(r&gt;0) tree[i][r]=tree[r][i]=1;    &#125;    for (int k = 1; k &lt;=n ; ++k) //用Floyed求任意两结点之间的最短路径    &#123;        for (int i = 1; i &lt;=n ; ++i) &#123;            if(i!=k)            &#123;                for (int j = 1; j &lt;=n ; ++j) &#123;                    if(i!=j&amp;&amp;j!=k&amp;&amp;tree[i][k]+tree[k][j]&lt;tree[i][j])                    &#123;                        tree[i][j]=tree[i][k]+tree[k][j];                    &#125;                &#125;            &#125;        &#125;    &#125;    mindis=INT_MAX;    for(int i=1;i&lt;=n;i++) //穷举医院建在N个结点，找出最短距离    &#123;        int sum =0;        for(int j=1;j&lt;=n;j++)        &#123;            sum+=tree[i][j]*w[j];        &#125;        if(sum&lt;mindis) mindis=sum;    &#125;    cout&lt;&lt;mindis&lt;&lt;endl;    return 0;&#125;</code></pre><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="样题二："><a href="#样题二：" class="headerlink" title="样题二："></a>样题二：</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p><img src="/2022/01/03/Algorithm003/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x5bm5fbWc=,size_16,color_FFFFFF,t_70.png"></p><p>输入n和m，代表n个节点，m条边，然后是m行输入，每行有x,y,z，代表x到y的路距离为z。<br>问题：从1出发到各点的最短路径</p><h4 id="测试样例："><a href="#测试样例：" class="headerlink" title="测试样例："></a>测试样例：</h4><pre><code class="c++">7 121 2 201 3 501 4 302 3 252 6 703 4 403 6 503 5 254 5 555 6 105 7 706 7 505</code></pre><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><pre><code>1-&gt;2-&gt;3-&gt;570</code></pre><h4 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h4><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100;int mapdis[maxn][maxn];  //表示x-&gt;y的距离(有向)int dis[maxn];  //代表最短路径长int path[maxn];  //记录前驱节点int vis[maxn]; //用来记录该点是否已经是最短路径的点int n,m;void Dijkstra(int s)&#123;    //初始化    memset(dis,0x3f,sizeof(dis));    memset(path,-1,sizeof(path));    memset(vis,0,sizeof(vis));        dis[s]=0;   //自身到自身的距离是0    while(1)    &#123;        int k=0; //用来记录当轮的起始点        for (int i = 1; i &lt;=n; ++i) &#123;            if(!vis[i]&amp;&amp;dis[i]&lt;dis[k])     //如果这个点还不为最短路径的点，并且这个点的路径是现在所有点中最小的            &#123;                k=i;      //那么就记录这个点为当轮的起始点                          //特殊的这里第一次找到的是起点，及s=1。            &#125;        &#125;        if(!k) return;  //所有点已经为最短路径的点，则返回        vis[k]=1;       //标记该点为最短路径的点        //松弛操作        for (int j = 1; j &lt;=n ; ++j) &#123;               //第一次循环只有起点的邻接点的距离被更新            //每次都更新找到，新找到的点的邻接点(新找到的点也就是当轮的起始点)            if(dis[j]&gt;dis[k]+mapdis[k][j])  //最短路是由最短路+某一条固定路组成            &#123;                dis[j]=dis[k]+mapdis[k][j];//路径被改变                path[j]=k;//重新记录前驱，最短路是由最短路+某一条固定路组成，所以前驱是有效的            &#125;        &#125;    &#125;&#125;void print(int x) //递归打印&#123;    if(x == -1) return;    print(path[x]);    cout&lt;&lt;x&lt;&lt;&quot;-&gt;&quot;;&#125;int main() &#123;    n,m;    cin&gt;&gt;n&gt;&gt;m;    //初始化    memset(mapdis,0x3f,sizeof(mapdis));    for (int i = 0; i &lt;m ; ++i) &#123;        int x,y,z;        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;        //记录x-&gt;y的距离        mapdis[x][y]=z;    &#125;    Dijkstra(1);  //求1出发到各点的最短路径    int order;    //读入终点    cin&gt;&gt;order;    print(path[order]);  //打印最短路径    cout&lt;&lt;order&lt;&lt;endl;    cout&lt;&lt;dis[order];    //最短路径长    return 0;&#125;</code></pre><h3 id="样题三：L2-001-紧急救援-25-分"><a href="#样题三：L2-001-紧急救援-25-分" class="headerlink" title="样题三：L2-001 紧急救援 (25 分)"></a>样题三：<strong>L2-001 紧急救援 (25 分)</strong></h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h4><p>输入第一行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0 ~ (<em>N</em>−1)；<em>M</em>是快速道路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。</p><p>第二行给出<em>N</em>个正整数，其中第<em>i</em>个数是第<em>i</em>个城市的救援队的数目，数字间以空格分隔。随后的<em>M</em>行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h4><p>第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从<em>S</em>到<em>D</em>的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h4><pre><code class="c++">4 5 0 320 30 40 100 1 11 3 20 3 30 2 22 3 2结尾无空行</code></pre><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h4><pre><code class="c++">2 600 1 3结尾无空行</code></pre><h4 id="最短路径条数："><a href="#最短路径条数：" class="headerlink" title="最短路径条数："></a>最短路径条数：</h4><p>如果通过 <strong>index</strong> 点能把最短路径更新，那么最短路径条数就是从起点到<strong>index</strong>的最短路径条数。</p><p><img src="/2022/01/03/Algorithm003/134d3eff026ab567e3a337c45dda5d61.png"></p><p>例如这张图，如果<strong>index</strong>可以更新当前的最短路径，并且s通过1和2到达index点的距离都相等，那么从s到d的最短路径条数其实就是从s到index的最短路径条数，由此可以得到第一个式子</p><pre><code class="c++">num[i]=num[index];</code></pre><p>如果通过index点的周转，距离不变（依然是最小值），这说明通过index周转使得最短路径条数又多出了一部分，只需要用之前得到的最短路径条数加上num[index]即可，由此得出第二个式子</p><pre><code class="c++">num[i]+=num[index];</code></pre><h4 id="程序源代码：-2"><a href="#程序源代码：-2" class="headerlink" title="程序源代码："></a>程序源代码：</h4><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,s,d;const int maxn=505;int arr[maxn];   //记录每个城市的援兵数int dismap[maxn][maxn];    //储存X-Y的长度int path[maxn];    //前驱节点int dis[maxn];     //最短路径int cost[maxn];    //最大救援队数量int vis[maxn];     //用来记录该点是否已经是最短路径的点int num[maxn];     //最短路径的条数void dijk(int s)&#123;    memset(path,-1,sizeof(path));    memset(dis,0x3f,sizeof(dis));    memset(cost,0,sizeof(cost));    memset(vis,0,sizeof(vis));    memset(num,0,sizeof(num));    dis[s]=0;    cost[s]=arr[s];   //此时救援队数量等于出发点的救援队数量    num[s]=1;         //一条最短路径    while(true)    &#123;        int k=-1;        int maxt =0x3f;        for (int i = 0; i &lt; n; ++i) &#123;            if(!vis[i]&amp;&amp;dis[i]&lt;maxt)            &#123;                k=i;                maxt=dis[i];            &#125;        &#125;        vis[k]=1;        if(k==-1) return;        for (int j = 0; j &lt; n; ++j) &#123;            if(!vis[j]&amp;&amp;dis[j]&gt;dis[k]+dismap[k][j])&#123;                dis[j]=dis[k]+dismap[k][j];                path[j]=k;                num[j]=num[k];   //如果能更新，说明产生了新的最短路径，num[i]变为从s到k的路径条数                cost[j] = cost[k]+arr[j];  //产生了新的最短路径,人数为cost[k]+arr[j]            &#125;            else if (!vis[j]&amp;&amp;dis[j]==dis[k]+dismap[k][j])&#123; //存在新的最短路径                num[j]+=num[k];   //最短路径条数更新                //无论援兵量是否能更新，既然已经有了另一条路与当前最短路长度相同                //就说明多了一些最短路条数                if(cost[j]&lt;cost[k]+arr[j])   //援兵量能更新                &#123;                    cost[j]=cost[k]+arr[j];                    path[j]=k;                &#125;            &#125;        &#125;    &#125;&#125;void print(int x)&#123;    if(x==-1) return;    print(path[x]);    cout&lt;&lt;x&lt;&lt;&quot; &quot;;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d;    memset(arr,0,sizeof(arr));    memset(dismap,0x3f,sizeof(dismap));    for (int j = 0; j &lt;n ; ++j) &#123;        cin&gt;&gt;arr[j];    &#125;    for (int i = 0; i &lt;m ; ++i) &#123;        int x,y,z;        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;        //此题是无向图        dismap[x][y]=z;        dismap[y][x]=z;    &#125;    dijk(s);    cout&lt;&lt;num[d]&lt;&lt;&quot; &quot;&lt;&lt;cost[d]&lt;&lt;endl;//打印最短路径条数和最大援兵数    print(path[d]);    cout&lt;&lt;d&lt;&lt;endl;    return 0;&#125;</code></pre><h2 id="相关题目链接："><a href="#相关题目链接：" class="headerlink" title="相关题目链接："></a>相关题目链接：</h2><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://www.luogu.com.cn/problem/P1364">P1364 医院设置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></a>]: “ 样题一：P1364 医院设置”</p><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805073643683840">题目详情 - L2-001 紧急救援 (25 分) (pintia.cn)</a> ：样题三：L2-001 紧急救援 (25 分)</p><p><a href="https://www.freesion.com/article/8556971489/">L2-001 紧急救援 (25 分)&amp;&amp;dijkstra - 灰信网（软件开发博客聚合） (freesion.com)</a>：样题三参考资料</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(五)-环形拓扑上利用MPI进行通信</title>
    <link href="/2022/01/01/mpi005/"/>
    <url>/2022/01/01/mpi005/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI学习-五-环形拓扑上利用MPI进行通信"><a href="#MPI学习-五-环形拓扑上利用MPI进行通信" class="headerlink" title="MPI学习(五)-环形拓扑上利用MPI进行通信"></a>MPI学习(五)-环形拓扑上利用MPI进行通信</h1><p>这里，我们演示了一个简单的MPI程序，它使用阻塞通信原语send和receive来进行广播操作：</p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpic++ mpi005.cpp -o mpi005</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>srun -p amd_256 -N 1 -n  4   .&#x2F;mpi005(使用SLURM任务调度系统)</p><p>1个分区，核数为4</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;mpi.h&gt;int main(int argc,char *argv[])&#123;    int rank, value, size;    MPI_Status status;    MPI_Init(&amp;argc, &amp;argv);    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);        if(rank == 0) &#123;scanf(&quot;%d&quot;, &amp;value );    /*Master node sends out the value*/    MPI_Send(&amp;value, 1, MPI_INT, rank + 1, 0, MPI_COMM_WORLD);&#125;//    else    &#123;            /*Slave nodes block on receive the send on the value*/        //接受上一个进程发送的消息        MPI_Recv(&amp;value, 1, MPI_INT, rank - 1, 0,MPI_COMM_WORLD, &amp;status);                    if(rank &lt; size-1)        &#123;            //向下一个进程发送消息            MPI_Send(&amp;value, 1, MPI_INT, rank + 1, 0, MPI_COMM_WORLD);        &#125;        printf(&quot;process %d got %d\n&quot;, rank, value);    &#125;    MPI_Finalize();    return 0; &#125; </code></pre><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><pre><code class="c++">//5 5为读入的value值process 1 got 5process 2 got 5process 3 got 5</code></pre>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graph-Data Structure</title>
    <link href="/2021/12/22/algorithm002/"/>
    <url>/2021/12/22/algorithm002/</url>
    
    <content type="html"><![CDATA[<h1 id="Graph-Data-Structure"><a href="#Graph-Data-Structure" class="headerlink" title="Graph-Data Structure"></a>Graph-Data Structure</h1><h2 id="1-邻接表的应用"><a href="#1-邻接表的应用" class="headerlink" title="1.邻接表的应用"></a>1.邻接表的应用</h2><h3 id="样题一：L2-025-分而治之-25-分"><a href="#样题一：L2-025-分而治之-25-分" class="headerlink" title="样题一：L2-025 分而治之 (25 分)"></a>样题一：L2-025 分而治之 (25 分)</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：</p><pre><code>Np v[1] v[2] ... v[Np]</code></pre><p>其中 <code>Np</code> 是该方案中计划攻下的城市数量，后面的系列 <code>v[i]</code> 是计划攻下的城市编号。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>对每一套方案，如果可行就输出<code>YES</code>，否则输出<code>NO</code>。</p><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123;    vector&lt;int&gt; v[10005]; //声明邻接表    int n,num;    cin&gt;&gt;n&gt;&gt;num;    for (int i = 0; i &lt;num ; ++i) &#123;        int start,end;        cin&gt;&gt;start&gt;&gt;end;        //创建邻接表        v[start].push_back(end);         v[end].push_back(start);    &#125;        int k;    cin&gt;&gt;k;        for (int j = 0; j &lt;k ; ++j) &#123;        int np;        cin&gt;&gt;np;        int flag=1;        int book[10005]=&#123;0&#125;;//每轮炸毁城市初始化                for (int i = 1; i &lt;=np ; ++i) &#123;            int dead;            cin&gt;&gt;dead;            book[dead]=1; //被炸毁的城市标记为1        &#125;                for (int l = 1; l &lt;=n ; ++l) &#123;                        if(book[l]==0)//没有被炸毁的城市            &#123;                for (int i = 0; i &lt;v[l].size() ; ++i) &#123; //遍历该城市的邻接表                                        if(book[v[l][i]]==0) //存在着还连通的城市                    &#123;                        flag=0;//说明方案不可行                        break;                    &#125;                &#125;            &#125;        &#125;        if(flag==1)        &#123;            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        &#125;        else&#123;            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;</code></pre><h4 id="程序输入："><a href="#程序输入：" class="headerlink" title="程序输入："></a>程序输入：</h4><pre><code class="c++">10 118 76 84 58 48 11 21 49 89 11 102 454 10 3 8 46 6 1 7 5 4 93 1 8 42 2 87 9 8 7 6 5 4 2</code></pre><h4 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h4><pre><code class="c++">NOYESYESNONO</code></pre><h2 id="题目相关链接："><a href="#题目相关链接：" class="headerlink" title="题目相关链接："></a>题目相关链接：</h2><p>[<a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]">https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]</a>: “样例一:L2-025 分而治之 (25 分)”</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS-深度优先搜索</title>
    <link href="/2021/12/21/algorithm001/"/>
    <url>/2021/12/21/algorithm001/</url>
    
    <content type="html"><![CDATA[<h1 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS-深度优先搜索"></a>DFS-深度优先搜索</h1><h2 id="样题1-全排列"><a href="#样题1-全排列" class="headerlink" title="样题1-全排列"></a>样题1-全排列</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>输入一个数n，输出n的全排列</p><h3 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h3><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int n;int a[100];int book[100];void dfs(int step)&#123;    int i;    if(step==n+1)  //这里表示dfs结束,没有可以排的数字了    &#123;        for (i = 1;  i&lt;=n ; i++) &#123;            cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;        return ;    &#125;    for(int i=1;i&lt;=n;i++)    &#123;        if(book[i]==0)  //说明数字i还没有被使用,可以用来排列        &#123;            a[step]=i;//排列数字i            book[i]=1;//标记数字i为已使用            dfs(step+1);            //继续排列没有使用的数字            book[i]=0;            //这里表示dfs调用结束了,意思是数字i已经全部排列完了，但还需要            //按照顺序将数字i收回，重新排列。        &#125;    &#125;    return;&#125;int main() &#123;    cin&gt;&gt;n;    dfs(1); //dfs函数的开始    return 0;&#125;</code></pre><h3 id="程序输入："><a href="#程序输入：" class="headerlink" title="程序输入："></a>程序输入：</h3><pre><code class="c++">3</code></pre><h3 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h3><pre><code class="c++">1 2 31 3 22 1 32 3 13 1 23 2 1</code></pre><h2 id="样题二-自然数的拆分问题"><a href="#样题二-自然数的拆分问题" class="headerlink" title="样题二-自然数的拆分问题"></a>样题二-自然数的拆分问题</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。现在给你一个自然数n，要求你求出n的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。</p><h3 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h3><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int num;int a[100000]=&#123;1&#125;;void dfs(int n,int t)&#123;    if(n==0)    &#123;        for(int i=1;i&lt;=t-1;i++)//输出一种拆分方案            if(i!=t-1) cout&lt;&lt;a[i]&lt;&lt;&quot;+&quot;;            else cout&lt;&lt;a[i];        cout&lt;&lt;endl;        return ;    &#125;    for (int i=a[t-1];i&lt;=n;i++) &#123;        if(i&lt;num)//当前数i要大于等于前一位数，且不超过n        &#123;            a[t]=i;//保存当前拆分的数i            n-=i;//n减去数i，n的值将继续拆分            dfs(n,t+1);            n+=i;//回溯：加上拆分的数，以便产生所有可能的拆分        &#125;    &#125;    return ;&#125;int main()&#123;    cin&gt;&gt;num;    dfs(num,1);    return 0;&#125;</code></pre><h3 id="程序输入：-1"><a href="#程序输入：-1" class="headerlink" title="程序输入："></a>程序输入：</h3><pre><code class="c++">7</code></pre><h3 id="程序输出：-1"><a href="#程序输出：-1" class="headerlink" title="程序输出："></a>程序输出：</h3><pre><code class="c++">1+1+1+1+1+1+11+1+1+1+1+21+1+1+1+31+1+1+2+21+1+1+41+1+2+31+1+51+2+2+21+2+41+3+31+62+2+32+53+4</code></pre><h2 id="样例三：L2-038-病毒溯源-25-分"><a href="#样例三：L2-038-病毒溯源-25-分" class="headerlink" title="样例三：L2-038 病毒溯源 (25 分)"></a>样例三：<strong>L2-038 病毒溯源 (25 分)</strong></h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>病毒容易发生变异。某种病毒可以通过突变产生若干变异的毒株，而这些变异的病毒又可能被诱发突变产生第二代变异，如此继续不断变化。</p><p>现给定一些病毒之间的变异关系，要求你找出其中最长的一条变异链。</p><p>在此假设给出的变异都是由突变引起的，不考虑复杂的基因重组变异问题 —— 即每一种病毒都是由唯一的一种病毒突变而来，并且不存在循环变异的情况。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出一个正整数 <em>N</em>（≤104），即病毒种类的总数。于是我们将所有病毒从 0 到 <em>N</em>−1 进行编号。</p><p>随后 <em>N</em> 行，每行按以下格式描述一种病毒的变异情况：</p><pre><code>k 变异株1 …… 变异株k</code></pre><p>其中 <code>k</code> 是该病毒产生的变异毒株的种类数，后面跟着每种变异株的编号。第 <em>i</em> 行对应编号为 <em>i</em> 的病毒（0≤<em>i</em>&lt;<em>N</em>）。题目保证病毒源头有且仅有一个。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先输出从源头开始最长变异链的长度。</p><p>在第二行中输出从源头开始最长的一条变异链，编号间以 1 个空格分隔，行首尾不得有多余空格。如果最长链不唯一，则输出最小序列。</p><p>注：我们称序列 { <em>a</em>1,⋯,<em>a**n</em> } 比序列 { <em>b</em>1,⋯,<em>b**n</em> } “小”，如果存在 1≤<em>k</em>≤<em>n</em> 满足 <em>a**i</em>&#x3D;<em>b**i</em> 对所有 <em>i</em>&lt;<em>k</em> 成立，且 <em>a**k</em>&lt;<em>b**k</em>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">103 6 4 80002 5 901 71 202 3 1结尾无空行</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">40 4 9 1结尾无空行</code></pre><h3 id="程序源代码：-2"><a href="#程序源代码：-2" class="headerlink" title="程序源代码："></a>程序源代码：</h3><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; ans, tmp;bool a[10005][10005];bool book[10005];int maxn;int n;void dfs(int root,int len)&#123;    if(len&gt;maxn)    &#123;        maxn =len;        ans = tmp;    &#125;    else if(len == maxn &amp;&amp; tmp &lt; ans)    &#123;        ans = tmp;    &#125;    for (int i = 0; i &lt;n ; ++i)    &#123;        if(a[root][i]) //连通        &#123;            tmp.push_back(i);            dfs(i,len+1);            tmp.pop_back();        &#125;    &#125;    return ;&#125;int main() &#123;    cin&gt;&gt;n;    int root=0;    for (int i = 0; i &lt;n ; ++i) &#123;        int k;        cin&gt;&gt;k;        for (int j = 0; j &lt;k ; ++j) &#123;            int x;            cin&gt;&gt;x;            book[x]=true;    //用来判断谁是病毒源头，题目给出病毒源头有且仅有一个            a[i][x]=true;    //使用邻接矩阵来储存图，连通为true，否则为false        &#125;    &#125;    while(book[root]) root++;  //寻找病毒源头    tmp.push_back(root);    dfs(root,1); //从病毒源头开始dfs    cout&lt;&lt;ans.size()&lt;&lt;endl;    //输出格式控制    for(int i=0; i &lt; ans.size(); i++)&#123;       if(i!=ans.size()-1)       &#123;           cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;       &#125;       else       &#123;           cout&lt;&lt;ans[i];       &#125;            &#125;    return 0;&#125;</code></pre><h2 id="样题四：L2-020-功夫传人-25-分"><a href="#样题四：L2-020-功夫传人-25-分" class="headerlink" title="样题四：L2-020 功夫传人 (25 分)"></a>样题四：<strong>L2-020 功夫传人 (25 分)</strong></h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。</p><p>这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第<code>i</code>代传人只能在第<code>i-1</code>代传人中拜1个师傅。我们假设已知祖师爷的功力值为<code>Z</code>，每向下传承一代，就会减弱<code>r%</code>，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。</p><h3 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出3个正整数，分别是：<em>N</em>（≤105）——整个师门的总人数（于是每个人从0到<em>N</em>−1编号，祖师爷的编号为0）；<em>Z</em>——祖师爷的功力值（不一定是整数，但起码是正数）；<em>r</em> ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有<em>N</em>行，第<em>i</em>行（<em>i</em>&#x3D;0,⋯,<em>N</em>−1）描述编号为<em>i</em>的人所传的徒弟，格式为：</p><p><em>K**i</em> ID[1] ID[2] ⋯ ID[<em>K**i</em>]</p><p>其中<em>K**i</em>是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。<em>K**i</em>为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。</p><h3 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过1010。</p><h3 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">10 18.0 1.003 2 3 51 91 41 70 72 6 11 80 90 40 3结尾无空行</code></pre><h3 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">404结尾无空行</code></pre><h3 id="程序源代码：-3"><a href="#程序源代码：-3" class="headerlink" title="程序源代码："></a>程序源代码：</h3><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; tree[100000];  //用于邻接表建树int book[100000];double sum;double r;void dfs(int index,double power)&#123;    if(book[index]) //是得道者就乘他的倍数     &#123;        sum += power * book[index];        return ;    &#125;    for(int i=0;i&lt;tree[index].size();i++)  //遍历整个树    &#123;        dfs(tree[index][i],power*r);    &#125;&#125;int main() &#123;    int n;    double z;    cin&gt;&gt;n&gt;&gt;z&gt;&gt;r;    r=(100-r)/100.0;    for(int i=0;i&lt;n;i++)    &#123;        int k;        cin&gt;&gt;k;        if(k==0)   //这个弟子是否为得道者        &#123;            int power;            cin&gt;&gt;power;            book[i]=power;   //记录得道者放大倍数        &#125;        else&#123;            for(int j=0;j&lt;k;j++)            &#123;                int id;                cin&gt;&gt;id;                tree[i].push_back(id);      //使用邻接表建树            &#125;        &#125;    &#125;    dfs(0,z);    cout&lt;&lt;(int)sum&lt;&lt;endl;    return 0;&#125;</code></pre><h2 id="题目相关链接："><a href="#题目相关链接：" class="headerlink" title="题目相关链接："></a>题目相关链接：</h2><p>[<a href="https://www.luogu.com.cn/problem/P2404">P2404 自然数的拆分问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>]: “ 样例二-自然数的拆分问题”</p><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652361">题目详情 - L2-038 病毒溯源 (25 分) (pintia.cn)</a></a>]: “ 样例三-L2-038 病毒溯源 (25 分)”</p><p>[<a href="https://www.luogu.com.cn/problem/P2404"><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805059118809088">题目详情 - L2-020 功夫传人 (25 分) (pintia.cn)</a></a>]: “ 样例四-L2-020 功夫传人 (25 分)”</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning(一) 一个神经元网络-线性函数</title>
    <link href="/2021/12/09/tensorflow001/"/>
    <url>/2021/12/09/tensorflow001/</url>
    
    <content type="html"><![CDATA[<h1 id="一个神经元的网络-线性函数"><a href="#一个神经元的网络-线性函数" class="headerlink" title="一个神经元的网络(线性函数)"></a>一个神经元的网络(线性函数)</h1><p>线性函数 y &#x3D; 2 * x -1 </p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><pre><code class="python">from tensorflow import kerasimport numpy as np#构建模型model = keras.Sequential([keras.layers.Dense(units=1,input_shape=[1])])model.compile(optimizer=&#39;sgd&#39;,loss=&#39;mean_squared_error&#39;)#准备训练数据xs=np.array([-1.0,0.0,1.0,2.0,3.0,4.0], dtype = float)ys=np.array([-3.0,-1.0,1.0,3.0,5.0,7.0], dtype = float)#训练模型model.fit(xs,ys,epochs=500)</code></pre><h2 id="训练模型过程-截取"><a href="#训练模型过程-截取" class="headerlink" title="训练模型过程(截取)"></a>训练模型过程(截取)</h2><pre><code class="python">Epoch 1/5001/1 [==============================] - 0s 388ms/step - loss: 3.4976Epoch 2/5001/1 [==============================] - 0s 3ms/step - loss: 2.9127Epoch 3/5001/1 [==============================] - 0s 3ms/step - loss: 2.4493Epoch 4/5001/1 [==============================] - 0s 3ms/step - loss: 2.0814Epoch 5/5001/1 [==============================] - 0s 4ms/step - loss: 1.7888Epoch 6/5001/1 [==============================] - 0s 4ms/step - loss: 1.5555Epoch 7/5001/1 [==============================] - 0s 4ms/step - loss: 1.3689Epoch 8/5001/1 [==============================] - 0s 4ms/step - loss: 1.2191Epoch 9/5001/1 [==============================] - 0s 3ms/step - loss: 1.0983Epoch 10/5001/1 [==============================] - 0s 4ms/step - loss: 1.0005Epoch 11/5001/1 [==============================] - 0s 4ms/step - loss: 0.9207Epoch 12/5001/1 [==============================] - 0s 2ms/step - loss: 0.8551Epoch 13/5001/1 [==============================] - 0s 5ms/step - loss: 0.8009</code></pre><h2 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h2><pre><code class="python">#使用模型(输入)print(model.predict([2021]))</code></pre><pre><code class="python">#输出[[4036.6035]]</code></pre><pre><code class="python">#输入model.predict([10.0])</code></pre><pre><code class="python">#输出array([[18.984968]], dtype=float32)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tensorflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(四)-广播、散播、收集、归约和全归约的MPI语法</title>
    <link href="/2021/11/27/mpi004/"/>
    <url>/2021/11/27/mpi004/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-广播、散播、收集、归约和全归约的MPI语法"><a href="#MPI-广播、散播、收集、归约和全归约的MPI语法" class="headerlink" title="MPI-广播、散播、收集、归约和全归约的MPI语法"></a>MPI-广播、散播、收集、归约和全归约的MPI语法</h1><h2 id="广播：MPI-Bcast"><a href="#广播：MPI-Bcast" class="headerlink" title="广播：MPI_Bcast"></a>广播：MPI_Bcast</h2><pre><code class="c++">int MPI_Bcast(void *buffer, int count, MPI_Datatype datatype, int root, MPI_Comm comm)//int root 广播数据的根进程的标识号(整型)</code></pre><p><img src="/2021/11/27/mpi004/mpi001.png"></p><h2 id="散播：MPI-Scatter"><a href="#散播：MPI-Scatter" class="headerlink" title="散播：MPI_Scatter"></a>散播：MPI_Scatter</h2><pre><code class="c++">int MPI_Scatter(void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int root, MPI_Comm comm)//void *sendbuf 发送消息缓冲区的起始地址(可选数据类型)//void *recvbuf 接收消息缓冲区的起始地址(可选数据类型)</code></pre><p><img src="/2021/11/27/mpi004/mpi002.png"></p><h2 id="收集：MPI-Gather"><a href="#收集：MPI-Gather" class="headerlink" title="收集：MPI_Gather"></a>收集：MPI_Gather</h2><pre><code class="c++">int MPI_Gather(void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm)</code></pre><p><img src="/2021/11/27/mpi004/mpi003.png"></p><h2 id="归约：MPI-Reduce"><a href="#归约：MPI-Reduce" class="headerlink" title="归约：MPI_Reduce"></a>归约：MPI_Reduce</h2><pre><code class="c++">int MPI_Reduce(void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, int root,  MPI_Comm comm)//MPI_Op op  归约操作符(句柄)</code></pre><p><img src="/2021/11/27/mpi004/mpi004.png"></p><p><img src="/2021/11/27/mpi004/mpi005.png"></p><h2 id="全归约：MPI-Allreduce"><a href="#全归约：MPI-Allreduce" class="headerlink" title="全归约：MPI_Allreduce"></a>全归约：MPI_Allreduce</h2><pre><code class="c++">int MPI_Allreduce(void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)</code></pre><p><img src="/2021/11/27/mpi004/mpi006.png"></p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(三)-通过OpenmMP使用MPI</title>
    <link href="/2021/11/26/mpi003/"/>
    <url>/2021/11/26/mpi003/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-通过OpenMP使用MPI"><a href="#MPI-通过OpenMP使用MPI" class="headerlink" title="MPI-通过OpenMP使用MPI"></a>MPI-通过OpenMP使用MPI</h1><p>OpenMP是另一种为基于共享内存的并行编程提供的应用编程接口。当人们想使用多核处理器时，通常使用OpenMP。下面是一个“Hello World”程序，使用了MPI和OpenMP的API。</p><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpic++    -fopenmp  mpi003.cpp -o mpi003</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>srun -p amd_256 -N 2 -n  2   .&#x2F;mpi003(使用SLURM任务调度系统)</p><p>2个分区，核数为2</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><pre><code class="c++">#include &lt;math.h&gt;#include &lt;omp.h&gt;  //OpenMP所需要的头文件#include &lt;mpi.h&gt;int  main(int argc,char **argv)&#123;        int myid, numprocs;        int namelen;        int thread_id , nthreads;        char processor_name[MPI_MAX_PROCESSOR_NAME];        MPI_Init(&amp;argc, &amp;argv);        MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);        MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);        MPI_Get_processor_name(processor_name, &amp;namelen);        //构造并行区        #pragma omp parallel private(thread_id, nthreads) num_threads(8) //设置线程数为8        &#123;            thread_id = omp_get_thread_num();  //获得当前线程的id            nthreads = omp_get_num_threads();  //获得总的线程数            printf(&quot;Thread number %d (on %d) for the MPI process number %d (on %d) [%s]\n&quot;,            thread_id, nthreads, myid, numprocs, processor_name);        &#125;         MPI_Finalize();        return 0;&#125;</code></pre><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><pre><code class="c++">Thread number 0 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]Thread number 4 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]Thread number 3 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]Thread number 5 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]Thread number 2 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]Thread number 6 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]Thread number 0 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]Thread number 1 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]Thread number 2 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]Thread number 5 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]Thread number 1 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]Thread number 7 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]Thread number 3 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]Thread number 4 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]Thread number 6 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]Thread number 7 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]</code></pre>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPI学习(二)-非阻塞通信程序(无缓冲)</title>
    <link href="/2021/11/26/mpi002/"/>
    <url>/2021/11/26/mpi002/</url>
    
    <content type="html"><![CDATA[<h1 id="MPI-非阻塞通信程序-无缓冲"><a href="#MPI-非阻塞通信程序-无缓冲" class="headerlink" title="MPI-非阻塞通信程序(无缓冲)"></a>MPI-非阻塞通信程序(无缓冲)</h1><p>非阻塞通信程序(无缓冲)是由MPI中的Isend和Ireceive来表示的，即异步通信。在这种情况下，发送进程发布一条“发送授权请求”(挂起的消息)的消息，并继续其程序的执行。当接收进程发布一个“同意发送”许可指令时，数据传输就启动了。所有的这些机制都是通过操作系统的信号进行内部管理的。当数据传输完成时，检查状态并指示进程是否可以安全地进行读&#x2F;写数据。                                                                      需要注意的是原语MPI_Wait(&amp;request,&amp;status)等到数据传输完成(或中断后)，使用一个成为status的状态变量来指示数据传输是否已经成功。</p><h2 id="相关的MPI原语"><a href="#相关的MPI原语" class="headerlink" title="相关的MPI原语"></a>相关的MPI原语</h2><pre><code class="c++">int MPI_Isend(void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_comm comm, MPI_Request *req)int MPI_Irecv(void *buf, int count, MPI_Datatype datatype, int src, int tag, MPI_Comm comm, MPI_Request *req)</code></pre><p>MPI_Request结构中经常使用的：当*req操作完成时返回 *flag &#x3D; 1,否则返回 0。</p><p>原语MPI_Wait一直等到*req所执行的操作完成。</p><pre><code class="c++">int MPI_Wait(MPI_Request *req, MPI_Status *status)</code></pre><h2 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>mpicc  mpi002.cpp -o mpi002</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p>mpirun -np 10   .&#x2F;mpi002(本地提交,采取10个进程)</p><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;mpi.h&gt;#include &lt;math.h&gt;int main(int argc,char **argv)&#123;    int myid, numprocs;    int tag,source,destination,count;    int buffer;    MPI_Status status;    MPI_Request request;    MPI_Init(&amp;argc,&amp;argv);    MPI_Comm_size(MPI_COMM_WORLD,&amp;numprocs);    MPI_Comm_rank(MPI_COMM_WORLD,&amp;myid);    tag =2021; /* any integer to tag messages */    source = 0;    count = 1;    if(myid != source )    &#123;        buffer =2077;        //其他进程向0号进程发送消息        MPI_Isend(&amp;buffer,count,MPI_INT,source,tag,MPI_COMM_WORLD,&amp;request);        MPI_Wait(&amp;request,&amp;status);        printf(&quot;processor %d send %d to processor %d\n&quot;,myid,buffer,source);    &#125;    if(myid == source )    &#123;        //0号进程接收来自其他进程的消息        for(int i=1;i&lt;numprocs;i++)        &#123;            MPI_Irecv(&amp;buffer,count,MPI_INT,i,tag,MPI_COMM_WORLD,&amp;request);            MPI_Wait(&amp;request,&amp;status);            printf(&quot;processor %d received %d from processor %d \n&quot;,myid,buffer,i);        &#125;            &#125;    MPI_Finalize();    return 0;&#125;</code></pre><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><pre><code class="c++">processor 2 send 2077 to processor 0processor 3 send 2077 to processor 0processor 5 send 2077 to processor 0processor 6 send 2077 to processor 0processor 7 send 2077 to processor 0processor 8 send 2077 to processor 0processor 9 send 2077 to processor 0processor 4 send 2077 to processor 0processor 1 send 2077 to processor 0processor 0 received 2077 from processor 1 processor 0 received 2077 from processor 2 processor 0 received 2077 from processor 3 processor 0 received 2077 from processor 4 processor 0 received 2077 from processor 5 processor 0 received 2077 from processor 6 processor 0 received 2077 from processor 7 processor 0 received 2077 from processor 8 processor 0 received 2077 from processor 9 </code></pre>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVX向量化学习(三)-if判断的处理</title>
    <link href="/2021/11/24/AVX003/"/>
    <url>/2021/11/24/AVX003/</url>
    
    <content type="html"><![CDATA[<h1 id="AVX-if判断的处理"><a href="#AVX-if判断的处理" class="headerlink" title="AVX-if判断的处理"></a>AVX-if判断的处理</h1><p>使用AVX指令集对if判断进行处理</p><h2 id="使用到的AVX函数介绍"><a href="#使用到的AVX函数介绍" class="headerlink" title="使用到的AVX函数介绍"></a>使用到的AVX函数介绍</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><pre><code class="c++">__m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)</code></pre><p><strong>Description</strong></p><p>Blend packed double-precision (64-bit) floating-point elements from a and b using mask, and store the results in dst.</p><p><strong>Operation</strong></p><pre><code class="c++">FOR j := 0 to 3    i := j*64    IF mask[i+63]        dst[i+63:i] := b[i+63:i]    ELSE        dst[i+63:i] := a[i+63:i]    FIENDFORdst[MAX:256] := 0</code></pre><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><pre><code class="c++">__m256d _mm256_cmp_pd (__m256d a, __m256d b, const int imm8)</code></pre><p><strong>Description</strong></p><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in dst.</p><p><strong>Operation</strong></p><pre><code class="c++">CASE (imm8[4:0]) OF0: OP := _CMP_EQ_OQ1: OP := _CMP_LT_OS2: OP := _CMP_LE_OS3: OP := _CMP_UNORD_Q 4: OP := _CMP_NEQ_UQ5: OP := _CMP_NLT_US6: OP := _CMP_NLE_US7: OP := _CMP_ORD_Q8: OP := _CMP_EQ_UQ9: OP := _CMP_NGE_US10: OP := _CMP_NGT_US11: OP := _CMP_FALSE_OQ12: OP := _CMP_NEQ_OQ13: OP := _CMP_GE_OS14: OP := _CMP_GT_OS15: OP := _CMP_TRUE_UQ16: OP := _CMP_EQ_OS17: OP := _CMP_LT_OQ18: OP := _CMP_LE_OQ19: OP := _CMP_UNORD_S20: OP := _CMP_NEQ_US21: OP := _CMP_NLT_UQ22: OP := _CMP_NLE_UQ23: OP := _CMP_ORD_S24: OP := _CMP_EQ_US25: OP := _CMP_NGE_UQ 26: OP := _CMP_NGT_UQ 27: OP := _CMP_FALSE_OS 28: OP := _CMP_NEQ_OS 29: OP := _CMP_GE_OQ30: OP := _CMP_GT_OQ31: OP := _CMP_TRUE_USESACFOR j := 0 to 3    i := j*64    dst[i+63:i] := ( a[i+63:i] OP b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0ENDFORdst[MAX:256] := 0</code></pre><h2 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h2><pre><code class="c++">#include&lt;stdio.h&gt;#include &lt;immintrin.h&gt;int main()&#123;    double a[9]=&#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;    double b[9]=&#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;    double d[9]=&#123;0&#125;;     //记录原始if判断后的值    double e[9]=&#123;0&#125;;     //记录AVX-if判断后的值        __m256d v0;    __m256d v1;    __m256d v2,v3;    __m256d v4;        for(int i=0;i&lt;9;i++)    &#123;        if(a[i]&gt;b[i])        &#123;            d[i] = a[i];        &#125;        else        &#123;            d[i]=b[i];        &#125;    &#125;    int i=0;        for(;i&lt;9-4;i+=4)    &#123;            v0 = _mm256_loadu_pd(a+i);            v1 = _mm256_loadu_pd(b+i);            v2=_mm256_add_pd(v0,v1);            v3 =_mm256_blendv_pd(v0,v1,_mm256_cmp_pd(v0,v1,_CMP_LE_OQ));            _mm256_storeu_pd(e+i,v3);                &#125;        for(;i&lt;9;i++)    &#123;        if(a[i]&gt;b[i])        &#123;            e[i] = a[i];        &#125;        else        &#123;            e[i]=b[i];        &#125;    &#125;        printf(&quot;this is d.\n&quot;);        for(int i=0;i&lt;9;i++)    &#123;        printf(&quot;%lf\n&quot;,d[i]);    &#125;        printf(&quot;this is e with AVX.\n&quot;);        for(int i=0;i&lt;9;i++)    &#123;        printf(&quot;%lf\n&quot;,e[i]);    &#125;    return 0; &#125; </code></pre><h2 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h2><pre><code class="c++">this is d.2.1000003.2000006.4000008.6000005.5000009.9000007.7000008.8000006.600000this is e with AVX.2.1000003.2000006.4000008.6000005.5000009.9000007.7000008.8000006.600000</code></pre><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>[<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/]">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: “ Intel® Intrinsics Guide”</p><p>[<a href="https://stackoverflow.com/questions/16988199/how-to-choose-avx-compare-predicate-variants">simd - How to choose AVX compare predicate variants - Stack Overflow</a>]: “Stack Overflow”</p><p>[<a href="https://www.officedaytime.com/simd512e/simdimg/si.php?f=blendvpd">blendvpd (officedaytime.com)</a>]: “_mm256_Blendv_pd()原理解释”</p>]]></content>
    
    
    <categories>
      
      <category>HPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AVX</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
