<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sun, 12 Jun 2022 15:11:29 +0800</pubDate>
        <lastBuildDate>Sun, 12 Jun 2022 15:11:29 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>并查集</category>
        <category>Map</category>
        <category>Pair</category>
        <category>KMP</category>
        <category>线索二叉树</category>
        <category>Tree</category>
        <category>森林</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Numactl</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
            <title>内存对齐</title>
            <link>http://example.com/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
            <pubDate>Sun, 12 Jun 2022 15:11:29 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;内存对齐&#34;&gt;&lt;a href=&#34;#内存对齐&#34; class=&#34;headerlink&#34; title=&#34;内存对齐&#34;&gt;&lt;/a&gt;内存对齐&lt;/h1&gt;&lt;h2 id=&#34;CPU读取内存的方式&#34;&gt;&lt;a href=&#34;#CPU读取内存的方式&#34; class=&#34;headerlink&#34; title=&#34;CPU读取内存的方式&#34;&gt;&lt;/a&gt;CPU读取内存的方式&lt;/h2&gt;&lt;p&gt;CPU读取内存的方式其实非常复杂，为了更进一步的了解相关的原理，需要对计算机组成原理进行深度学习。&lt;/p&gt;
&lt;h3 id=&#34;Memory-access-granularity-内存读取粒度&#34;&gt;&lt;a href=&#34;#Memory-access-granularity-内存读取粒度&#34; class=&#34;headerlink&#34; title=&#34;Memory access granularity(内存读取粒度)&#34;&gt;&lt;/a&gt;Memory access granularity(内存读取粒度)&lt;/h3&gt;&lt;p&gt;However, your computer’s processor does not read from and write to memory in byte-sized chunks. Instead, it accesses memory in two-, four-, eight- 16- or even 32-byte chunks. We’ll call the size in which a processor accesses memory its memory access granularity.&lt;/p&gt;
&lt;p&gt;CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为&lt;em&gt;memory access granularity（粒度）&lt;/em&gt; 本人把它翻译为“内存读取粒度” 。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/feng9exe/p/10059543.html&#34;&gt;https://www.cnblogs.com/feng9exe/p/10059543.html&lt;/a&gt; ”内存对齐“&lt;/p&gt;
&lt;h2 id=&#34;内存对齐举例&#34;&gt;&lt;a href=&#34;#内存对齐举例&#34; class=&#34;headerlink&#34; title=&#34;内存对齐举例&#34;&gt;&lt;/a&gt;内存对齐举例&lt;/h2&gt;&lt;p&gt;假设此计算机的内存读取粒度是4。&lt;/p&gt;
&lt;h3 id=&#34;如果内存对齐时&#34;&gt;&lt;a href=&#34;#如果内存对齐时&#34; class=&#34;headerlink&#34; title=&#34;如果内存对齐时&#34;&gt;&lt;/a&gt;如果内存对齐时&lt;/h3&gt;&lt;p&gt;前提知识：&lt;/p&gt;
&lt;p&gt;1 Byte &amp;#x3D; 8bit &lt;/p&gt;
&lt;p&gt;1 int8 占用 1 Byte&lt;/p&gt;
&lt;p&gt;1 int16 占用 2 Byte&lt;/p&gt;
&lt;p&gt;1 int32 占用 4 Byte&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;//一个结构体的定义如下
struct S
&amp;#123;
    int8 a;
    int32 b;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;int8 a&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int32 b&lt;/td&gt;
&lt;td&gt;int32 b&lt;/td&gt;
&lt;td&gt;int32 b&lt;/td&gt;
&lt;td&gt;int32 b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;我们可以发现int8 a储存在0号内存上，占用1个Byte，1-3号内存空下了3个Byte。int32 b储存在了4-7号内存，一共4个Byte。&lt;/p&gt;
&lt;p&gt;由于此计算机的内存读取粒度时是4&lt;/p&gt;
&lt;p&gt;当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。&lt;/p&gt;
&lt;p&gt;当需要读取b(4-7号内存时)，计算机会读取4-7号内存，访问次数1次。&lt;/p&gt;
&lt;h3 id=&#34;如果内存没有对齐时&#34;&gt;&lt;a href=&#34;#如果内存没有对齐时&#34; class=&#34;headerlink&#34; title=&#34;如果内存没有对齐时&#34;&gt;&lt;/a&gt;如果内存没有对齐时&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;int8 a&lt;/td&gt;
&lt;td&gt;int32 b&lt;/td&gt;
&lt;td&gt;int32 b&lt;/td&gt;
&lt;td&gt;int32 b&lt;/td&gt;
&lt;td&gt;int32 b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;我们可以发现int8 a储存在0号内存上，占用了1个Byte。int32 b储存在1-4号内存上，一共4个Byte。&lt;/p&gt;
&lt;p&gt;由于此计算机的内存读取粒度时是4&lt;/p&gt;
&lt;p&gt;当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。&lt;/p&gt;
&lt;p&gt;当需要读取b(1-4号内存)时，计算机会先读取0-3号一组内存，去掉0号内存，再读取4-7号一组内存，去掉5-7号内存，随后再拼接1-3号内存和4号内存组成完整的b。访问次数2次。&lt;/p&gt;
&lt;h2 id=&#34;内存对齐的目的&#34;&gt;&lt;a href=&#34;#内存对齐的目的&#34; class=&#34;headerlink&#34; title=&#34;内存对齐的目的&#34;&gt;&lt;/a&gt;内存对齐的目的&lt;/h2&gt;&lt;p&gt;合理的内存对齐可以高效的利用硬件性能，减少处理器内存访问次数。&lt;/p&gt;
&lt;h2 id=&#34;相关链接&#34;&gt;&lt;a href=&#34;#相关链接&#34; class=&#34;headerlink&#34; title=&#34;相关链接&#34;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;amp;seid=13964421962700904405&amp;amp;amp;spm_id_from=333.337.0.0&#34;&gt;https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;amp;seid=13964421962700904405&amp;amp;amp;spm_id_from=333.337.0.0&lt;/a&gt; “内存对齐”&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0&#34;&gt;https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0&lt;/a&gt; “内存对齐对程序性能的影响”&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/</guid>
            <title>MPI学习(一)-简单的发送接收</title>
            <link>http://example.com/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/</link>
            <category>MPI</category>
            <pubDate>Sun, 12 Jun 2022 15:11:29 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;MPI-简单的发送接收&#34;&gt;&lt;a href=&#34;#MPI-简单的发送接收&#34; class=&#34;headerlink&#34; title=&#34;MPI-简单的发送接收&#34;&gt;&lt;/a&gt;MPI-简单的发送接收&lt;/h1&gt;&lt;p&gt;打印来自进程问候语句的MPI程序&lt;/p&gt;
&lt;h2 id=&#34;所使用的MPI原语&#34;&gt;&lt;a href=&#34;#所使用的MPI原语&#34; class=&#34;headerlink&#34; title=&#34;所使用的MPI原语&#34;&gt;&lt;/a&gt;所使用的MPI原语&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi001.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi002.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;程序运行平台&#34;&gt;&lt;a href=&#34;#程序运行平台&#34; class=&#34;headerlink&#34; title=&#34;程序运行平台&#34;&gt;&lt;/a&gt;程序运行平台&lt;/h2&gt;&lt;p&gt;北京超级云计算中心A3分区&lt;/p&gt;
&lt;h2 id=&#34;环境变量&#34;&gt;&lt;a href=&#34;#环境变量&#34; class=&#34;headerlink&#34; title=&#34;环境变量&#34;&gt;&lt;/a&gt;环境变量&lt;/h2&gt;&lt;p&gt;mpi&amp;#x2F;intel&amp;#x2F;2017.5&lt;/p&gt;
&lt;h2 id=&#34;编译指令&#34;&gt;&lt;a href=&#34;#编译指令&#34; class=&#34;headerlink&#34; title=&#34;编译指令&#34;&gt;&lt;/a&gt;编译指令&lt;/h2&gt;&lt;p&gt;mpicc  3.1.cpp -o 3.1&lt;/p&gt;
&lt;h2 id=&#34;运行指令&#34;&gt;&lt;a href=&#34;#运行指令&#34; class=&#34;headerlink&#34; title=&#34;运行指令&#34;&gt;&lt;/a&gt;运行指令&lt;/h2&gt;&lt;p&gt;mpirun -np 4 .&amp;#x2F;3.1(本地提交,采取4个进程)&lt;/p&gt;
&lt;h2 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;mpi.h&amp;gt;   //头文件

const int MAX_STRING = 100 ;

int main(int argc,char **argv)
&amp;#123;
    char greeting[MAX_STRING];
    int comm_sz;
    int my_rank;
    MPI_Status status;

    MPI_Init(&amp;amp;argc,&amp;amp;argv);

    MPI_Comm_size(MPI_COMM_WORLD,&amp;amp;comm_sz);
    MPI_Comm_rank(MPI_COMM_WORLD,&amp;amp;my_rank);
    
    if(my_rank != 0)
    &amp;#123;
        //其他进程向0号进程发消息
        sprintf(greeting,&amp;quot;Greetings from process %d of %d!&amp;quot;,my_rank,comm_sz);
        MPI_Send(greeting,strlen(greeting)+1,MPI_CHAR,0,0,MPI_COMM_WORLD); 
    &amp;#125;
    else
    &amp;#123;
        printf(&amp;quot;Greetings from process %d of %d!\n&amp;quot;,my_rank,comm_sz);
        //0号进程接受来自其他进程的消息并输出
        for(int q=1;q&amp;lt;comm_sz;q++)
        &amp;#123;
            MPI_Recv(greeting,MAX_STRING,MPI_CHAR,q,0,MPI_COMM_WORLD,&amp;amp;status);
            printf(&amp;quot;%s\n&amp;quot;,greeting);
        &amp;#125;
    &amp;#125;
    MPI_Finalize();
    
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;程序运行结果&#34;&gt;&lt;a href=&#34;#程序运行结果&#34; class=&#34;headerlink&#34; title=&#34;程序运行结果&#34;&gt;&lt;/a&gt;程序运行结果&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;Greetings from process 0 of 4!
Greetings from process 1 of 4!
Greetings from process 2 of 4!
Greetings from process 3 of 4!
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
            <title>AVX向量化学习(二)-内存对齐的应用</title>
            <link>http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/</link>
            <category>AVX</category>
            <pubDate>Sun, 12 Jun 2022 15:11:29 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;AVX指令集的简单操作-内存对齐版&#34;&gt;&lt;a href=&#34;#AVX指令集的简单操作-内存对齐版&#34; class=&#34;headerlink&#34; title=&#34;AVX指令集的简单操作(内存对齐版)&#34;&gt;&lt;/a&gt;AVX指令集的简单操作(内存对齐版)&lt;/h1&gt;&lt;p&gt;使用AVX指令集进行2个double型的数组相加操作&lt;/p&gt;
&lt;h2 id=&#34;常用的内存对齐函数&#34;&gt;&lt;a href=&#34;#常用的内存对齐函数&#34; class=&#34;headerlink&#34; title=&#34;常用的内存对齐函数&#34;&gt;&lt;/a&gt;常用的内存对齐函数&lt;/h2&gt;&lt;p&gt;因为AVX中要求mem__addr必须在32字节边界上对齐，否则可能会产生通用保护异常。  &lt;/p&gt;
&lt;h3 id=&#34;1&#34;&gt;&lt;a href=&#34;#1&#34; class=&#34;headerlink&#34; title=&#34;1.&#34;&gt;&lt;/a&gt;1.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;double*	a =(double*)memalign(32,9*sizeof(double));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2&#34;&gt;&lt;a href=&#34;#2&#34; class=&#34;headerlink&#34; title=&#34;2.&#34;&gt;&lt;/a&gt;2.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;double*	a =(double*)_mm_malloc(9*sizeof(double),32);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3&#34;&gt;&lt;a href=&#34;#3&#34; class=&#34;headerlink&#34; title=&#34;3.&#34;&gt;&lt;/a&gt;3.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;double*	a =(double*)aligned_alloc(32,9*sizeof(double));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4&#34;&gt;&lt;a href=&#34;#4&#34; class=&#34;headerlink&#34; title=&#34;4.&#34;&gt;&lt;/a&gt;4.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__attribute__ ((aligned(32)))double a[9]  =&amp;#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用到的AVX函数介绍&#34;&gt;&lt;a href=&#34;#使用到的AVX函数介绍&#34; class=&#34;headerlink&#34; title=&#34;使用到的AVX函数介绍&#34;&gt;&lt;/a&gt;使用到的AVX函数介绍&lt;/h2&gt;&lt;h3 id=&#34;1-1&#34;&gt;&lt;a href=&#34;#1-1&#34; class=&#34;headerlink&#34; title=&#34;1.&#34;&gt;&lt;/a&gt;1.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256d _mm256_load_pd (double const * mem_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-1&#34;&gt;&lt;a href=&#34;#2-1&#34; class=&#34;headerlink&#34; title=&#34;2.&#34;&gt;&lt;/a&gt;2.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256 _mm256_add_ps (__m256 a, __m256 b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FOR j := 0 to 7
    i := j*32
    dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-stream的作用：绕过缓存直接写入内存&#34;&gt;&lt;a href=&#34;#3-stream的作用：绕过缓存直接写入内存&#34; class=&#34;headerlink&#34; title=&#34;3.stream的作用：绕过缓存直接写入内存&#34;&gt;&lt;/a&gt;3.stream的作用：绕过缓存直接写入内存&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void _mm256_stream_pd (double * mem_addr, __m256d a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;MEM[mem_addr+255:mem_addr] := a[255:0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;样例程序举例：&#34;&gt;&lt;a href=&#34;#样例程序举例：&#34; class=&#34;headerlink&#34; title=&#34;样例程序举例：&#34;&gt;&lt;/a&gt;样例程序举例：&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;malloc.h&amp;gt;
#include &amp;lt;immintrin.h&amp;gt;
int main()
&amp;#123;
    double*	a =(double*)memalign(32,9*sizeof(double));
    double*	b =(double*)memalign(32,4*sizeof(double));
    double af[9]=&amp;#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&amp;#125; ;
    double bf[9]=&amp;#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&amp;#125;;
    double*	c =(double*)memalign(32,4*sizeof(double));
    for(int i =0;i&amp;lt;9;i++)
    &amp;#123;
        a[i]=af[i];
        b[i]=bf[i];
    &amp;#125;
    int i=0;
    __m256d v0;
    __m256d v1;
    __m256d v2;
    for(;i&amp;lt;9-4;i+=4)
    &amp;#123;	
            v0 = _mm256_load_pd(a+i);
            v1 = _mm256_load_pd(b+i);
            v2=_mm256_add_pd(v0,v1);
         	_mm256_stream_pd(c+i,v2);
            
    &amp;#125;
    for(;i&amp;lt;9;i++)
    &amp;#123;
        c[i]=a[i]+b[i];
    
    &amp;#125;
    printf(&amp;quot;this is c.\n&amp;quot;);
        for(int i=0;i&amp;lt;9;i++)
    &amp;#123;
        printf(&amp;quot;%lf\n&amp;quot;,c[i]);
    &amp;#125;
    return 0;
 &amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;样例程序输出：&#34;&gt;&lt;a href=&#34;#样例程序输出：&#34; class=&#34;headerlink&#34; title=&#34;样例程序输出：&#34;&gt;&lt;/a&gt;样例程序输出：&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;this is c.
3.200000
5.400000
9.700000
13.000000
9.200000
16.500000
12.800000
13.000000
8.700000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;相关链接&#34;&gt;&lt;a href=&#34;#相关链接&#34; class=&#34;headerlink&#34; title=&#34;相关链接&#34;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;p&gt;[&lt;a href=&#34;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&#34;&gt;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&lt;/a&gt;: 	“Intel® Intrinsics Guide”&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</guid>
            <title>AVX向量化学习(一)</title>
            <link>http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</link>
            <category>AVX</category>
            <pubDate>Sun, 12 Jun 2022 15:11:29 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;AVX指令集的简单操作&#34;&gt;&lt;a href=&#34;#AVX指令集的简单操作&#34; class=&#34;headerlink&#34; title=&#34;AVX指令集的简单操作&#34;&gt;&lt;/a&gt;AVX指令集的简单操作&lt;/h1&gt;&lt;p&gt;使用AVX指令集进行2个double型的数组相加操作&lt;/p&gt;
&lt;h2 id=&#34;使用到的AVX函数介绍&#34;&gt;&lt;a href=&#34;#使用到的AVX函数介绍&#34; class=&#34;headerlink&#34; title=&#34;使用到的AVX函数介绍&#34;&gt;&lt;/a&gt;使用到的AVX函数介绍&lt;/h2&gt;&lt;h3 id=&#34;1&#34;&gt;&lt;a href=&#34;#1&#34; class=&#34;headerlink&#34; title=&#34;1.&#34;&gt;&lt;/a&gt;1.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256 _mm256_loadu_ps (float const * mem_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Description&#34;&gt;&lt;a href=&#34;#Description&#34; class=&#34;headerlink&#34; title=&#34;Description&#34;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr does not need to be aligned on any particular boundary.&lt;/p&gt;
&lt;h3 id=&#34;Operation&#34;&gt;&lt;a href=&#34;#Operation&#34; class=&#34;headerlink&#34; title=&#34;Operation&#34;&gt;&lt;/a&gt;Operation&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2&#34;&gt;&lt;a href=&#34;#2&#34; class=&#34;headerlink&#34; title=&#34;2.&#34;&gt;&lt;/a&gt;2.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256d _mm256_add_pd (__m256d a, __m256d b)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Description-1&#34;&gt;&lt;a href=&#34;#Description-1&#34; class=&#34;headerlink&#34; title=&#34;Description&#34;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.&lt;/p&gt;
&lt;h3 id=&#34;Operation-1&#34;&gt;&lt;a href=&#34;#Operation-1&#34; class=&#34;headerlink&#34; title=&#34;Operation&#34;&gt;&lt;/a&gt;Operation&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;FOR j := 0 to 3
    i := j*64
    dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3&#34;&gt;&lt;a href=&#34;#3&#34; class=&#34;headerlink&#34; title=&#34;3.&#34;&gt;&lt;/a&gt;3.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void _mm256_storeu_pd (double * mem_addr, __m256d a)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Description-2&#34;&gt;&lt;a href=&#34;#Description-2&#34; class=&#34;headerlink&#34; title=&#34;Description&#34;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr does not need to be aligned on any particular boundary.&lt;/p&gt;
&lt;h3 id=&#34;Operation-2&#34;&gt;&lt;a href=&#34;#Operation-2&#34; class=&#34;headerlink&#34; title=&#34;Operation&#34;&gt;&lt;/a&gt;Operation&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;MEM[mem_addr+255:mem_addr] := a[255:0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;未进行AVX向量化的情况&#34;&gt;&lt;a href=&#34;#未进行AVX向量化的情况&#34; class=&#34;headerlink&#34; title=&#34;未进行AVX向量化的情况&#34;&gt;&lt;/a&gt;未进行AVX向量化的情况&lt;/h2&gt;&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
int main()
&amp;#123;
    double a[9] = &amp;#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&amp;#125;;
    double b[9] = &amp;#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&amp;#125;;
    double c[9] = &amp;#123;0&amp;#125;;
    
    for(int i=0 ;i&amp;lt;9;i++)	
    &amp;#123;
        c[i]=a[i]+b[i];
        
    &amp;#125;
    
    printf(&amp;quot;this is c.\n&amp;quot;);
    for(int i=0;i&amp;lt;9;i++)
    &amp;#123;
        printf(&amp;quot;%lf\n&amp;quot;,c[i]);
    &amp;#125;
    
    return 0;
 &amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出&#34;&gt;&lt;a href=&#34;#程序输出&#34; class=&#34;headerlink&#34; title=&#34;程序输出&#34;&gt;&lt;/a&gt;程序输出&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;this is c.
3.200000
5.400000
9.700000
13.000000
9.200000
16.500000
12.800000
13.000000
8.700000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;进行AVX向量化的情况&#34;&gt;&lt;a href=&#34;#进行AVX向量化的情况&#34; class=&#34;headerlink&#34; title=&#34;进行AVX向量化的情况&#34;&gt;&lt;/a&gt;进行AVX向量化的情况&lt;/h2&gt;&lt;h3 id=&#34;程序源代码-1&#34;&gt;&lt;a href=&#34;#程序源代码-1&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include &amp;lt;immintrin.h&amp;gt;
int main()
&amp;#123;
    double a[9] = &amp;#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&amp;#125;;
    double b[9] = &amp;#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&amp;#125;;
    double c[9] = &amp;#123;0&amp;#125;;
    __m256d v0;
    __m256d v1;
    __m256d v2;
    int i=0;
    for(;i&amp;lt;9-4;i+=4)
    &amp;#123;	
            v0 = _mm256_loadu_pd(a+i);
            v1 = _mm256_loadu_pd(b+i);
            v2=_mm256_add_pd(v0,v1);
         	_mm256_storeu_pd(c+i,v2);
            
    &amp;#125;
    for(;i&amp;lt;9;i++)
    &amp;#123;
        c[i]=a[i]+b[i];
    
    &amp;#125;
    printf(&amp;quot;this is c with AVX.\n&amp;quot;);
        for(int i=0;i&amp;lt;9;i++)
    &amp;#123;
        printf(&amp;quot;%lf\n&amp;quot;,c[i]);
    &amp;#125;

    return 0;
 &amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出-1&#34;&gt;&lt;a href=&#34;#程序输出-1&#34; class=&#34;headerlink&#34; title=&#34;程序输出&#34;&gt;&lt;/a&gt;程序输出&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;this is c with AVX.
3.200000
5.400000
9.700000
13.000000
9.200000
16.500000
12.800000
13.000000
8.700000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;相关链接&#34;&gt;&lt;a href=&#34;#相关链接&#34; class=&#34;headerlink&#34; title=&#34;相关链接&#34;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;p&gt;[&lt;a href=&#34;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&#34;&gt;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&lt;/a&gt;: 	“ Intel® Intrinsics Guide”&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/05/20/slurm001/</guid>
            <title>Slurm</title>
            <link>http://example.com/2022/05/20/slurm001/</link>
            <category>Linux</category>
            <category>Slurm</category>
            <pubDate>Fri, 20 May 2022 17:43:02 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Slurm&#34;&gt;&lt;a href=&#34;#Slurm&#34; class=&#34;headerlink&#34; title=&#34;Slurm&#34;&gt;&lt;/a&gt;Slurm&lt;/h2&gt;&lt;h4 id=&#34;1-sstat-查看RUNNING作业&#34;&gt;&lt;a href=&#34;#1-sstat-查看RUNNING作业&#34; class=&#34;headerlink&#34; title=&#34;1.sstat 查看RUNNING作业&#34;&gt;&lt;/a&gt;1.sstat 查看RUNNING作业&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;sstat -e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/slurm001/image-20220520174453969.png&#34; alt=&#34;image-20220520174453969&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用举例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;sstat -a --format=&amp;quot;JobId,Pids,AveCPU,AveRSS,MaxRSS&amp;quot;  1755818
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/slurm001/image-20220520175001331.png&#34; alt=&#34;image-20220520175001331&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-sacct-查看FINISHED作业&#34;&gt;&lt;a href=&#34;#2-sacct-查看FINISHED作业&#34; class=&#34;headerlink&#34; title=&#34;2.sacct 查看FINISHED作业&#34;&gt;&lt;/a&gt;2.sacct 查看FINISHED作业&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;sacct -e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/slurm001/image-20220520174622868.png&#34; alt=&#34;image-20220520174622868&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用举例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;sacct --format=&amp;quot;JobId,Elapsed,CPUTime,CPUTimeRAW,AveCPU,TotalCPU,UserCPU,SystemCPU,AveRSS,MaxRSS&amp;quot; -j 1754217
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/slurm001/image-20220520174807162.png&#34; alt=&#34;image-20220520174807162&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h4&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/kongxx/article/details/52556943&#34;&gt;(28条消息) Slurm查看作业CPU和MEM_kongxx的博客-CSDN博客_slurm 查看节点&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/05/20/numactl001/</guid>
            <title>numactl</title>
            <link>http://example.com/2022/05/20/numactl001/</link>
            <category>Linux</category>
            <category>Numactl</category>
            <pubDate>Fri, 20 May 2022 17:35:59 +0800</pubDate>
            <description><![CDATA[ &lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;numactl --hardware
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/numactl001/image-20220520173911653.png&#34; alt=&#34;image-20220520173911653&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;shelll&#34;&gt;numastat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/numactl001/image-20220520174030171.png&#34; alt=&#34;image-20220520174030171&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;numactl --show
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/numactl001/image-20220520174148487.png&#34; alt=&#34;image-20220520174148487&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h5&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qccz123456/article/details/81979819&#34;&gt;(28条消息) Linux工具之numactl_qccz123456的博客-CSDN博客_numactl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://baijiahao.baidu.com/s?id=1699088343604813491&amp;wfr=spider&amp;for=pc&amp;searchword=numactl&#34;&gt;宋宝华：为什么numactl内存绑定对代码段不起作用 (baidu.com)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/05/20/Linux002/</guid>
            <title>linux的jobs,fg,bg命令</title>
            <link>http://example.com/2022/05/20/Linux002/</link>
            <category>Linux</category>
            <pubDate>Fri, 20 May 2022 17:13:08 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;linux让前台程序脱离终端运行&#34;&gt;&lt;a href=&#34;#linux让前台程序脱离终端运行&#34; class=&#34;headerlink&#34; title=&#34;linux让前台程序脱离终端运行&#34;&gt;&lt;/a&gt;linux让前台程序脱离终端运行&lt;/h3&gt;&lt;p&gt;1.首先运行你的程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/Linux002/image-20220520171436032.png&#34; alt=&#34;image-20220520171436032&#34;&gt;&lt;/p&gt;
&lt;p&gt;2.随后使用Ctrl + z，挂起你的进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/Linux002/image-20220520171510946.png&#34; alt=&#34;image-20220520171510946&#34;&gt;&lt;/p&gt;
&lt;p&gt;3.然后使用jobs查看所有的进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/Linux002/image-20220520171913979.png&#34; alt=&#34;image-20220520171913979&#34;&gt;&lt;/p&gt;
&lt;p&gt;4.随后使用bg+id，表示该任务为后台1号任务&lt;/p&gt;
&lt;p&gt;bg命令用于将作业放到后台运行，使前台可以执行其他任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/Linux002/image-20220520172110992.png&#34; alt=&#34;image-20220520172110992&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;linux让后台程序移动到前台终端&#34;&gt;&lt;a href=&#34;#linux让后台程序移动到前台终端&#34; class=&#34;headerlink&#34; title=&#34;linux让后台程序移动到前台终端&#34;&gt;&lt;/a&gt;linux让后台程序移动到前台终端&lt;/h3&gt;&lt;p&gt;Linux常用命令fg主要用于将后台作业移动到前台终端运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/Linux002/image-20220520172358345.png&#34; alt=&#34;image-20220520172358345&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/05/20/Linux001/</guid>
            <title>Linux常用指令</title>
            <link>http://example.com/2022/05/20/Linux001/</link>
            <category>Linux</category>
            <pubDate>Fri, 20 May 2022 17:08:45 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Linux常用指令&#34;&gt;&lt;a href=&#34;#Linux常用指令&#34; class=&#34;headerlink&#34; title=&#34;Linux常用指令&#34;&gt;&lt;/a&gt;Linux常用指令&lt;/h2&gt;&lt;h4 id=&#34;杀死进程&#34;&gt;&lt;a href=&#34;#杀死进程&#34; class=&#34;headerlink&#34; title=&#34;杀死进程&#34;&gt;&lt;/a&gt;杀死进程&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;kill -9 id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2022/05/20/Linux001/image-20220520171246860.png&#34; alt=&#34;image-20220520171246860&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/05/08/tool004/</guid>
            <title>gcov代码覆盖率测试-完整样例-SLIC</title>
            <link>http://example.com/2022/05/08/tool004/</link>
            <category>性能分析工具</category>
            <category>gcov</category>
            <pubDate>Sun, 08 May 2022 10:34:59 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;gcov代码覆盖率测试-完整样例-SLIC&#34;&gt;&lt;a href=&#34;#gcov代码覆盖率测试-完整样例-SLIC&#34; class=&#34;headerlink&#34; title=&#34;gcov代码覆盖率测试-完整样例-SLIC&#34;&gt;&lt;/a&gt;gcov代码覆盖率测试-完整样例-SLIC&lt;/h2&gt;&lt;h3 id=&#34;gcov代码覆盖率测试介绍：&#34;&gt;&lt;a href=&#34;#gcov代码覆盖率测试介绍：&#34; class=&#34;headerlink&#34; title=&#34;gcov代码覆盖率测试介绍：&#34;&gt;&lt;/a&gt;gcov代码覆盖率测试介绍：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/01/18/tool002/&#34;&gt;gcov代码覆盖率测试 - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;完整样例-SLIC：&#34;&gt;&lt;a href=&#34;#完整样例-SLIC：&#34; class=&#34;headerlink&#34; title=&#34;完整样例-SLIC：&#34;&gt;&lt;/a&gt;完整样例-SLIC：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/05/08/tool004/result.zip&#34;&gt;https://xingyuanjie.top/2022/05/08/tool004/result.zip&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/05/06/Algorithm037/</guid>
            <title>图的存储</title>
            <link>http://example.com/2022/05/06/Algorithm037/</link>
            <category>Data Structure</category>
            <category>Graph</category>
            <pubDate>Fri, 06 May 2022 16:38:38 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;图的存储&#34;&gt;&lt;a href=&#34;#图的存储&#34; class=&#34;headerlink&#34; title=&#34;图的存储&#34;&gt;&lt;/a&gt;图的存储&lt;/h2&gt;&lt;h3 id=&#34;邻接矩阵法&#34;&gt;&lt;a href=&#34;#邻接矩阵法&#34; class=&#34;headerlink&#34; title=&#34;邻接矩阵法&#34;&gt;&lt;/a&gt;邻接矩阵法&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#define MaxVertexNum 100									//顶点数目的最大值
typedef char VertexType;									//顶点的数据类型
typedef int EdgeType;										//带权图中边上权值的数据类型
typedef struct&amp;#123;
    VertexType Vex[MaxVertexNum];							//顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];				//邻接矩阵，边表
    int vexnum,arcnum;										//图中当前顶点数和弧数
&amp;#125;MGraph;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;邻接表法&#34;&gt;&lt;a href=&#34;#邻接表法&#34; class=&#34;headerlink&#34; title=&#34;邻接表法&#34;&gt;&lt;/a&gt;邻接表法&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#define MaxVertexNum 100									//图中顶点数目的最大值
typedef struct ArcNode&amp;#123;										//边表结点
    int adjvex;												//该弧所指向的顶点的位置
    struct ArcNode *next;									//指向下一条弧的指针
    //InfoType infp;										//网的边权值
&amp;#125;ArcNode;
typedef struct VNode&amp;#123;										//顶点表结点
    VertexType data;										//顶点信息
    ArcNode *first;											//指向第一条依附该顶点的弧的指针
&amp;#125;VNode,AdjList[MaxVertexNum];
typedef struct&amp;#123;
    AdjList vertices;										//邻接表
    int vexnum,arcnum;										//图的顶点数和弧数
&amp;#125;ALGraph;													//ALGraph是以邻接表存储的图的类型
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/05/05/Algorithm036/</guid>
            <title>树、森林</title>
            <link>http://example.com/2022/05/05/Algorithm036/</link>
            <category>Data Structure</category>
            <category>Tree</category>
            <category>森林</category>
            <pubDate>Thu, 05 May 2022 16:58:34 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;树、森林&#34;&gt;&lt;a href=&#34;#树、森林&#34; class=&#34;headerlink&#34; title=&#34;树、森林&#34;&gt;&lt;/a&gt;树、森林&lt;/h2&gt;&lt;h3 id=&#34;树的存储结构&#34;&gt;&lt;a href=&#34;#树的存储结构&#34; class=&#34;headerlink&#34; title=&#34;树的存储结构&#34;&gt;&lt;/a&gt;树的存储结构&lt;/h3&gt;&lt;h4 id=&#34;双亲表示法&#34;&gt;&lt;a href=&#34;#双亲表示法&#34; class=&#34;headerlink&#34; title=&#34;双亲表示法&#34;&gt;&lt;/a&gt;双亲表示法&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#define MAX_TREE_SIZE 100					//树中最多节点数	
typedef struct&amp;#123;								//树的结点定义
    ElemType data;							//数据元素	
    int parent;								//双亲位置域
&amp;#125;PTNode;
typedef struct&amp;#123;								//树的类型定义
    PTNode nodes[MAX_TREE_SIZE];			//双亲表示
    int n;									//节点数
&amp;#125;PTree;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;孩子兄弟法&#34;&gt;&lt;a href=&#34;#孩子兄弟法&#34; class=&#34;headerlink&#34; title=&#34;孩子兄弟法&#34;&gt;&lt;/a&gt;孩子兄弟法&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;typedef struct CSNode&amp;#123;
    ElemType data;											//数据域
    struct CSNode *firstchild,*nextsibling;					//第一个孩子和右兄弟指针
&amp;#125;CSNode,*CSTree;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/05/04/Algorithm035/</guid>
            <title>线索二叉树</title>
            <link>http://example.com/2022/05/04/Algorithm035/</link>
            <category>Data Structure</category>
            <category>Binary tree</category>
            <category>线索二叉树</category>
            <pubDate>Wed, 04 May 2022 20:05:19 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;线索二叉树&#34;&gt;&lt;a href=&#34;#线索二叉树&#34; class=&#34;headerlink&#34; title=&#34;线索二叉树&#34;&gt;&lt;/a&gt;线索二叉树&lt;/h2&gt;&lt;h3 id=&#34;线索二叉树的存储结构&#34;&gt;&lt;a href=&#34;#线索二叉树的存储结构&#34; class=&#34;headerlink&#34; title=&#34;线索二叉树的存储结构&#34;&gt;&lt;/a&gt;线索二叉树的存储结构&lt;/h3&gt;&lt;p&gt;线索二叉树的存储结构描述如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;ltag = 0 lchild域指示结点的左孩子
ltag = 1 lchild域指示结点的前驱
//
rtag = 0 rchild域指示结点的右孩子
rtag = 1 rchild域指示结点的后继
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;typedef struct ThreadNode&amp;#123;
    ElemType data;						//数据元素
    struct ThreadNode *lchild,*rchild;				//左右孩子指针
    int ltag,rtag;									//左右线索标志
&amp;#125;ThreadNode，*ThreadTree;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;中序线索二叉树的构造&#34;&gt;&lt;a href=&#34;#中序线索二叉树的构造&#34; class=&#34;headerlink&#34; title=&#34;中序线索二叉树的构造&#34;&gt;&lt;/a&gt;中序线索二叉树的构造&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void InThread(ThreadTree &amp;amp;p,ThreadNode &amp;amp;pre)&amp;#123;
    if(p!=NULL)&amp;#123;
        InThread(p-&amp;gt;lchild,pre);			//递归，线索化左子树
        &amp;#123;
            if(p-&amp;gt;lchild==NULL)&amp;#123;			//左子树为空，建立前驱线索
                p-&amp;gt;lchild=pre;
                p-&amp;gt;ltag=1;
            &amp;#125;
            if(pre!=NULL&amp;amp;&amp;amp;pre-&amp;gt;rchild==NULL)&amp;#123;
                pre-&amp;gt;rchild=p;				//建立前驱结点的后继线索
                pre-&amp;gt;rtag=1;
            &amp;#125;
            pre=p;							//标记当前结点成为刚刚访问过的结点
            InThread(p-&amp;gt;rchild,pre);		//递归，线索化右子树
        &amp;#125;//if(p!=NULL)
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void CreateInThread(ThreadTree T)&amp;#123;
    ThreadTree pre = NULL;
    if(T!=NULL)&amp;#123;						//非空二叉树。线索化
        InThread(T,pre);				//线索化二叉树
        pre-&amp;gt;rchild=NULL;				//处理遍历的最后一个结点
        pre-&amp;gt;rtag=1;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;中序线索二叉树的遍历&#34;&gt;&lt;a href=&#34;#中序线索二叉树的遍历&#34; class=&#34;headerlink&#34; title=&#34;中序线索二叉树的遍历&#34;&gt;&lt;/a&gt;中序线索二叉树的遍历&lt;/h3&gt;&lt;p&gt;1)求中序线索二叉树中中序序列下的第一个结点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;Thread *Firstnode(ThreadNode *p)&amp;#123;
    while(p-&amp;gt;ltag==0) p=p-&amp;gt;lchild;		//最左下结点（不一定是叶结点）
    return p;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2)求中序线索二叉树中结点p在中序序列下的后继&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;ThreadNode *Nextnode(ThreadNode *p)&amp;#123;
    if(p-&amp;gt;rtag==0) return Firstnode(p-&amp;gt;rchild);
    else return p-&amp;gt;rchild;			//rtag==1直接返回后继线索
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3)利用上面两个算法，可以写出不含头节点的中序线索二叉树的中序遍历算法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void Inorder(ThreadNode *T)&amp;#123;
    for(ThreadNode *p=Firstnode;p!=NULL;p=Nextnode(p))
        visit(p);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/27/Algorithm034/</guid>
            <title>串的模式匹配算法-KMP算法</title>
            <link>http://example.com/2022/04/27/Algorithm034/</link>
            <category>Data Structure</category>
            <category>String</category>
            <category>KMP</category>
            <pubDate>Wed, 27 Apr 2022 19:39:05 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;串的模式匹配算法-KMP算法&#34;&gt;&lt;a href=&#34;#串的模式匹配算法-KMP算法&#34; class=&#34;headerlink&#34; title=&#34;串的模式匹配算法-KMP算法&#34;&gt;&lt;/a&gt;串的模式匹配算法-KMP算法&lt;/h2&gt;&lt;h3 id=&#34;求next数组&#34;&gt;&lt;a href=&#34;#求next数组&#34; class=&#34;headerlink&#34; title=&#34;求next数组&#34;&gt;&lt;/a&gt;求next数组&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void get_next(SSting t,int next[])
&amp;#123;
    int i=1,j=0;
    next[1]=0;
    while(i&amp;lt;t.length)
    &amp;#123;
        if(j==0||t.ch[i]==t.ch[j])
        &amp;#123;
            i++;
            j++;
            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1
        &amp;#125;else&amp;#123;
            j=next[j];      //否则令j=next[j]，循环继续
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;KMP匹配算法&#34;&gt;&lt;a href=&#34;#KMP匹配算法&#34; class=&#34;headerlink&#34; title=&#34;KMP匹配算法&#34;&gt;&lt;/a&gt;KMP匹配算法&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;int Index_KMP(SSting s,SSting t,int next[])&amp;#123;
    int i=1,j=1;
    while (i&amp;lt;=s.length&amp;amp;&amp;amp;j&amp;lt;=t.length)&amp;#123;
        if(j==0||s.ch[i]==t.ch[j])
        &amp;#123;
            j++;                    //继续比较后续字符
            i++;
        &amp;#125;else&amp;#123;
            j=next[j];              //模式串向右移动
        &amp;#125;
    &amp;#125;
    if(j&amp;gt;t.length)
    &amp;#123;
        return i-t.length;          //匹配成功
    &amp;#125;else&amp;#123;
        return 0;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;完整代码：&#34;&gt;&lt;a href=&#34;#完整代码：&#34; class=&#34;headerlink&#34; title=&#34;完整代码：&#34;&gt;&lt;/a&gt;完整代码：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define MAXLEN 255					//预定义最大串长
typedef struct&amp;#123;
    char ch[MAXLEN];				//每个分量存储一个字符
    int length;						//串的实际长度
&amp;#125;SSting;
void get_next(SSting t,int next[])
&amp;#123;
    int i=1,j=0;
    next[1]=0;
    while(i&amp;lt;t.length)
    &amp;#123;
        if(j==0||t.ch[i]==t.ch[j])
        &amp;#123;
            i++;
            j++;
            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1
        &amp;#125;else&amp;#123;
            j=next[j];      //否则令j=next[j]，循环继续
        &amp;#125;
    &amp;#125;
&amp;#125;
int Index_KMP(SSting s,SSting t,int next[])&amp;#123;
    int i=1,j=1;
    while (i&amp;lt;=s.length&amp;amp;&amp;amp;j&amp;lt;=t.length)&amp;#123;
        if(j==0||s.ch[i]==t.ch[j])
        &amp;#123;
            j++;                    //继续比较后续字符
            i++;
        &amp;#125;else&amp;#123;
            j=next[j];              //模式串向右移动
        &amp;#125;
    &amp;#125;
    if(j&amp;gt;t.length)
    &amp;#123;
        return i-t.length;          //匹配成功
    &amp;#125;else&amp;#123;
        return 0;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    SSting a,b;
    string s1=&amp;quot;ababcabcacbab&amp;quot;;
    string s2=&amp;quot;abcac&amp;quot;;
    a.length=s1.size();
    b.length=s2.size();
    int next[s2.size()+1];
    get_next(b,next);
    for (int i = 0; i &amp;lt;s1.size(); ++i) &amp;#123;	//初始化
        a.ch[i+1]=s1[i];
    &amp;#125;
    for (int j = 0; j &amp;lt;s2.size() ; ++j) &amp;#123;	//初始化
        b.ch[j+1]=s2[j];
    &amp;#125;
    int x=Index_KMP(a,b,next);
    if(x!=0)
    &amp;#123;
        cout&amp;lt;&amp;lt;&amp;quot;找到了位置是：&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl;
    &amp;#125;else&amp;#123;
        cout&amp;lt;&amp;lt;&amp;quot;没有找到&amp;quot;&amp;lt;&amp;lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出：&#34;&gt;&lt;a href=&#34;#程序输出：&#34; class=&#34;headerlink&#34; title=&#34;程序输出：&#34;&gt;&lt;/a&gt;程序输出：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;找到了位置是：6
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/27/Algorithm033/</guid>
            <title>串-简单的模式匹配算法</title>
            <link>http://example.com/2022/04/27/Algorithm033/</link>
            <category>Data Structure</category>
            <category>String</category>
            <pubDate>Wed, 27 Apr 2022 17:11:18 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;串-简单的模式匹配算法&#34;&gt;&lt;a href=&#34;#串-简单的模式匹配算法&#34; class=&#34;headerlink&#34; title=&#34;串-简单的模式匹配算法&#34;&gt;&lt;/a&gt;串-简单的模式匹配算法&lt;/h2&gt;&lt;h3 id=&#34;简单的模式匹配算法&#34;&gt;&lt;a href=&#34;#简单的模式匹配算法&#34; class=&#34;headerlink&#34; title=&#34;简单的模式匹配算法&#34;&gt;&lt;/a&gt;简单的模式匹配算法&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;int Index(SSting s,SSting t)        //简单的模式匹配算法
&amp;#123;
    int i=1,j=1;
    while(i&amp;lt;=s.length &amp;amp;&amp;amp; j&amp;lt;= t.length)
    &amp;#123;
        if(s.ch[i]==t.ch[j])
        &amp;#123;
            i++;                      //继续比较后继字符
            j++;
        &amp;#125;else&amp;#123;                        //指针后退重新开始匹配
            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位
            j=1;
        &amp;#125;
    &amp;#125;
    if(j&amp;gt;t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号
    else return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;完整程序源代码&#34;&gt;&lt;a href=&#34;#完整程序源代码&#34; class=&#34;headerlink&#34; title=&#34;完整程序源代码&#34;&gt;&lt;/a&gt;完整程序源代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define MAXLEN 255					//预定义最大串长
typedef struct&amp;#123;
    char ch[MAXLEN];				//每个分量存储一个字符
    int length;						//串的实际长度
&amp;#125;SSting;
int Index(SSting s,SSting t)        //简单的模式匹配算法
&amp;#123;
    int i=1,j=1;
    while(i&amp;lt;=s.length &amp;amp;&amp;amp; j&amp;lt;= t.length)
    &amp;#123;
        if(s.ch[i]==t.ch[j])
        &amp;#123;
            i++;                      //继续比较后继字符
            j++;
        &amp;#125;else&amp;#123;                        //指针后退重新开始匹配
            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位
            j=1;
        &amp;#125;
    &amp;#125;
    if(j&amp;gt;t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号
    else return 0;
&amp;#125;
int main()
&amp;#123;
    SSting a,b;
    string s1=&amp;quot;ababcabcacbab&amp;quot;;
    string s2=&amp;quot;abcac&amp;quot;;
    a.length=s1.size();
    b.length=s2.size();
    for (int i = 0; i &amp;lt;s1.size(); ++i) &amp;#123;	//初始化
        a.ch[i+1]=s1[i];
    &amp;#125;
    for (int j = 0; j &amp;lt;s2.size() ; ++j) &amp;#123;	//初始化
        b.ch[j+1]=s2[j];
    &amp;#125;
    int x=Index(a,b);
    if(x!=0)
    &amp;#123;
        cout&amp;lt;&amp;lt;&amp;quot;找到了位置是：&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl;
    &amp;#125;else&amp;#123;
        cout&amp;lt;&amp;lt;&amp;quot;没有找到&amp;quot;&amp;lt;&amp;lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出&#34;&gt;&lt;a href=&#34;#程序输出&#34; class=&#34;headerlink&#34; title=&#34;程序输出&#34;&gt;&lt;/a&gt;程序输出&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;找到了位置是：6
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/23/Algorithm032/</guid>
            <title>L2-036 网红点打卡攻略 (25 分)</title>
            <link>http://example.com/2022/04/23/Algorithm032/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Graph</category>
            <category>邻接矩阵</category>
            <pubDate>Sat, 23 Apr 2022 21:50:27 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-036-网红点打卡攻略-25-分&#34;&gt;&lt;a href=&#34;#L2-036-网红点打卡攻略-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-036 网红点打卡攻略 (25 分)&#34;&gt;&lt;/a&gt;L2-036 网红点打卡攻略 (25 分)&lt;/h2&gt;&lt;p&gt;一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;首先第一行给出两个正整数：网红点的个数 &lt;em&gt;N&lt;/em&gt;（1&amp;lt;&lt;em&gt;N&lt;/em&gt;≤200）和网红点之间通路的条数 &lt;em&gt;M&lt;/em&gt;。随后 &lt;em&gt;M&lt;/em&gt; 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 &lt;em&gt;N&lt;/em&gt; 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再下一行给出一个正整数 &lt;em&gt;K&lt;/em&gt;，是待检验的攻略的数量。随后 &lt;em&gt;K&lt;/em&gt; 行，每行给出一条待检攻略，格式为：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;n&lt;/em&gt; &lt;em&gt;V&lt;/em&gt;1 &lt;em&gt;V&lt;/em&gt;2 ⋯ Vn&lt;/p&gt;
&lt;p&gt;其中 &lt;em&gt;n&lt;/em&gt;(≤200) 是攻略中的网红点数，&lt;em&gt;Vi&lt;/em&gt; 是路径上的网红点编号。这里假设你从家里出发，从 &lt;em&gt;V&lt;/em&gt;1 开始打卡，最后从 &lt;em&gt;Vn&lt;/em&gt; 回家。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在第一行输出满足要求的攻略的个数。&lt;/p&gt;
&lt;p&gt;在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。&lt;/p&gt;
&lt;p&gt;题目保证至少存在一个有效攻略，并且总路费不超过 109。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;6 13
0 5 2
6 2 2
6 0 1
3 4 2
1 5 2
2 5 1
3 1 1
4 1 2
1 6 1
6 3 2
1 2 1
4 5 3
2 0 2
7
6 5 1 4 3 6 2
6 5 2 1 6 3 4
8 6 2 1 6 3 4 5 2
3 2 1 5
6 6 1 3 4 5 2
7 6 2 1 3 4 5 2
6 5 2 1 4 3 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;3
5 11
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;样例说明：&#34;&gt;&lt;a href=&#34;#样例说明：&#34; class=&#34;headerlink&#34; title=&#34;样例说明：&#34;&gt;&lt;/a&gt;样例说明：&lt;/h3&gt;&lt;p&gt;第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。&lt;/p&gt;
&lt;p&gt;第 1 条攻略的总路费是：(0-&amp;gt;5) 2 + (5-&amp;gt;1) 2 + (1-&amp;gt;4) 2 + (4-&amp;gt;3) 2 + (3-&amp;gt;6) 2 + (6-&amp;gt;2) 2 + (2-&amp;gt;0) 2 &amp;#x3D; 14；&lt;/p&gt;
&lt;p&gt;第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &amp;#x3D; 11，是一条更省钱的攻略；&lt;/p&gt;
&lt;p&gt;第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &amp;#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。&lt;/p&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,m;
int g[205][205];
int minsize=INT_MAX;			//初始化为INT_MAX
int minid=0;
int main()
&amp;#123;
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    int cnt=0;
    memset(g,0,sizeof(g));
    for (int i = 0; i &amp;lt;m ; ++i) &amp;#123;
        int a,b,c;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
        g[a][b]=c;
        g[b][a]=c;
    &amp;#125;
    int time;
    cin&amp;gt;&amp;gt;time;
    for (int j = 0; j &amp;lt;time ; ++j) &amp;#123;
        int k;
        cin&amp;gt;&amp;gt;k;
        int roll[k+5];
        int has[k+5];
        memset(has,0,sizeof(has));
        roll[0]=roll[k+1]=0;					//起点和终点必定是家
        for (int i = 1; i &amp;lt;=k ; ++i) &amp;#123;
            cin&amp;gt;&amp;gt;roll[i];
            if(has[roll[i]]) has[0]=1;			//每个打卡点仅能打卡一次
            else has[roll[i]]=1;
        &amp;#125;
        int flag=1;
        int tmpsize=0;
        if(k!=n||has[0]) continue;
        for (int l = 1; l &amp;lt;=k+1 ; ++l) &amp;#123;
            if(g[roll[l-1]][roll[l]]==0)
            &amp;#123;
                flag=0;
                break;
            &amp;#125;
            tmpsize+=g[roll[l-1]][roll[l]];
        &amp;#125;
        if(flag==1)
        &amp;#123;
            if(tmpsize&amp;lt;minsize)&amp;#123;
                minsize=tmpsize;
                minid=j+1;

            &amp;#125;
            cnt++;
        &amp;#125;
    &amp;#125;
    cout&amp;lt;&amp;lt;cnt&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;minid&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;minsize&amp;lt;&amp;lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059&#34;&gt;题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/23/Algorithm031/</guid>
            <title>L2-039 清点代码库 (25 分)</title>
            <link>http://example.com/2022/04/23/Algorithm031/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Sort</category>
            <category>Vector</category>
            <category>Map</category>
            <category>Pair</category>
            <pubDate>Sat, 23 Apr 2022 21:44:47 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-039-清点代码库-25-分&#34;&gt;&lt;a href=&#34;#L2-039-清点代码库-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-039 清点代码库 (25 分)&#34;&gt;&lt;/a&gt;L2-039 清点代码库 (25 分)&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg&#34; alt=&#34;code.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”&lt;/p&gt;
&lt;p&gt;这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 &lt;strong&gt;int&lt;/strong&gt; 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行中给出 2 个正整数，依次为 &lt;em&gt;N&lt;/em&gt;（≤104）和 &lt;em&gt;M&lt;/em&gt;（≤102），对应功能模块的个数和系列测试输入的个数。&lt;/p&gt;
&lt;p&gt;随后 &lt;em&gt;N&lt;/em&gt; 行，每行给出一个功能模块的 &lt;em&gt;M&lt;/em&gt; 个对应输出，数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先在第一行输出不同功能的个数 &lt;em&gt;K&lt;/em&gt;。随后 &lt;em&gt;K&lt;/em&gt; 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。&lt;/p&gt;
&lt;p&gt;注：所谓数列 { &lt;em&gt;A&lt;/em&gt;1, …, &lt;em&gt;A&lt;/em&gt;M } 比 { &lt;em&gt;B&lt;/em&gt;1, …, &lt;em&gt;B&lt;/em&gt;M } 大，是指存在 1≤i&amp;lt;*M*，使得 *A*1&amp;#x3D;*B*1，…，*Ai*&amp;#x3D;*Bi* 成立，且 *Ai*+1&amp;gt;&lt;em&gt;B&lt;/em&gt;+1。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;7 3
35 28 74
-1 -1 22
28 74 35
-1 -1 22
11 66 0
35 28 74
35 28 74
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;4
3 35 28 74
2 -1 -1 22
1 11 66 0
1 28 74 35
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;利用map的映射关系&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
map&amp;lt;vector&amp;lt;int&amp;gt;,int&amp;gt; mp;   //key，value
vector&amp;lt;int&amp;gt; tmp;
int n,m;
bool cmp(pair&amp;lt;vector&amp;lt;int&amp;gt;,int&amp;gt; a,pair&amp;lt;vector&amp;lt;int&amp;gt;,int&amp;gt; b)
&amp;#123;
    if(a.second==b.second)
    &amp;#123;
        return a.first&amp;lt;b.first;
    &amp;#125;
    return a.second&amp;gt;b.second;

&amp;#125;
int main()
&amp;#123;
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    for (int i = 0; i &amp;lt;n ; ++i) &amp;#123;
        for (int j = 0; j &amp;lt; m; ++j) &amp;#123;
            int num;
            cin&amp;gt;&amp;gt;num;
            tmp.push_back(num);
        &amp;#125;
        mp[tmp]++;
        tmp.clear();
    &amp;#125;
    vector&amp;lt;pair&amp;lt;vector&amp;lt;int&amp;gt;,int&amp;gt;&amp;gt; v(mp.begin(),mp.end());		//把map类型转化成vector
    cout&amp;lt;&amp;lt;v.size()&amp;lt;&amp;lt;endl;
    sort(v.begin(),v.end(),cmp);								//sort排序，注意终点和起点
    for (int k = 0; k &amp;lt;v.size() ; ++k) &amp;#123;
        cout&amp;lt;&amp;lt;v[k].second&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        for (int i = 0; i &amp;lt;m ; ++i) &amp;#123;
            if(i!=m-1)&amp;#123;
                cout&amp;lt;&amp;lt;v[k].first[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
            &amp;#125; else&amp;#123;
                cout&amp;lt;&amp;lt;v[k].first[i]&amp;lt;&amp;lt;endl;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362&#34;&gt;题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/23/Algorithm030/</guid>
            <title>L2-005 集合相似度 (25 分)</title>
            <link>http://example.com/2022/04/23/Algorithm030/</link>
            <category>C++</category>
            <category>Set</category>
            <category>团体程序设计天梯赛</category>
            <category>模拟</category>
            <pubDate>Sat, 23 Apr 2022 21:39:53 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-005-集合相似度-25-分&#34;&gt;&lt;a href=&#34;#L2-005-集合相似度-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-005 集合相似度 (25 分)&#34;&gt;&lt;/a&gt;L2-005 集合相似度 (25 分)&lt;/h2&gt;&lt;p&gt;给定两个整数集合，它们的相似度定义为：Nc&amp;#x2F;Nt×100%。其中Nc是两个集合都有的不相等整数的个数，Nt是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出一个正整数&lt;em&gt;N&lt;/em&gt;（≤50），是集合的个数。随后&lt;em&gt;N&lt;/em&gt;行，每行对应一个集合。每个集合首先给出一个正整数&lt;em&gt;M&lt;/em&gt;（≤104），是集合中元素的个数；然后跟&lt;em&gt;M&lt;/em&gt;个[0,109]区间内的整数。&lt;/p&gt;
&lt;p&gt;之后一行给出一个正整数&lt;em&gt;K&lt;/em&gt;（≤2000），随后&lt;em&gt;K&lt;/em&gt;行，每行对应一对需要计算相似度的集合的编号（集合从1到&lt;em&gt;N&lt;/em&gt;编号）。数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;3
3 99 87 101
4 87 101 5 87
7 99 101 18 5 135 18 99
2
1 2
1 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;50.00%
33.33%
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;双set模拟&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main()
&amp;#123;
    int n;
    set&amp;lt;int&amp;gt; s[55];
    cin&amp;gt;&amp;gt;n;
    for (int i = 0; i &amp;lt;n ; ++i) &amp;#123;
        int time;
        cin&amp;gt;&amp;gt;time;
        for (int j = 0; j &amp;lt;time ; ++j) &amp;#123;
            int num;
            cin&amp;gt;&amp;gt;num;
            s[i].insert(num);
        &amp;#125;
    &amp;#125;
    int find;
    cin&amp;gt;&amp;gt;find;
    for (int l = 0; l &amp;lt;find ; ++l) &amp;#123;
        int a,b;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
        int sum=0;
        set&amp;lt;int&amp;gt;::iterator it;								//迭代器
        int cnt=0;
        for (it=s[a-1].begin(); it!=s[a-1].end() ; it++) &amp;#123;
            if(s[b-1].find(*it)!=s[b-1].end())&amp;#123;				//找到了
                cnt++;										//Nc
            &amp;#125;
        &amp;#125;
        sum=s[a-1].size()+s[b-1].size()-cnt;				//Nt=两个集合的总个数-相同个数
        double ans=double(double(cnt)/double(sum))*100.0;
        printf(&amp;quot;%.2lf%\n&amp;quot;,ans);

    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805070149828608&#34;&gt;题目详情 - L2-005 集合相似度 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/16/Algorithm029/</guid>
            <title>STL中map的使用</title>
            <link>http://example.com/2022/04/16/Algorithm029/</link>
            <category>STL</category>
            <category>Map</category>
            <pubDate>Sat, 16 Apr 2022 16:26:03 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;STL中map的使用&#34;&gt;&lt;a href=&#34;#STL中map的使用&#34; class=&#34;headerlink&#34; title=&#34;STL中map的使用&#34;&gt;&lt;/a&gt;STL中map的使用&lt;/h2&gt;&lt;h3 id=&#34;简介&#34;&gt;&lt;a href=&#34;#简介&#34; class=&#34;headerlink&#34; title=&#34;简介&#34;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;map 是 STL 的一个关联容器，它提供一对一的数据处理能力。&lt;/p&gt;
&lt;p&gt;map 对象是&lt;strong&gt;模板类&lt;/strong&gt;，需要&lt;strong&gt;关键字&lt;/strong&gt;和&lt;strong&gt;存储对象&lt;/strong&gt;两个模板参数：其中第一个参数称为关键字，每个关键字只能在 map 中出现一次；第二个参数称为该关键字的值。可以将关键字和存储对象理解为“{键，值}对”。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;map&amp;lt;int,string&amp;gt; mp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;map的数据插入操作&#34;&gt;&lt;a href=&#34;#map的数据插入操作&#34; class=&#34;headerlink&#34; title=&#34;map的数据插入操作&#34;&gt;&lt;/a&gt;map的数据插入操作&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;//使用insert函数插入pair数据
mp.insert(pair&amp;lt;int,string&amp;gt;(3,&amp;quot;xingyuanjie&amp;quot;));
//使用数组方式插入数据
mp[2]=&amp;quot;wangzhouyang&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：上面的两种方法是有区别的，用 insert 函数插入数据，涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能实现数据插入的；但是数组方式能够插入数据，插入的数据会覆盖该关键字之前对应的值。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;map中数据的遍历&#34;&gt;&lt;a href=&#34;#map中数据的遍历&#34; class=&#34;headerlink&#34; title=&#34;map中数据的遍历&#34;&gt;&lt;/a&gt;map中数据的遍历&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;map&amp;lt;int,string&amp;gt;::iterator it;					//迭代器
for (it=mp.begin();it!=mp.end();it++) &amp;#123;
    cout&amp;lt;&amp;lt;it-&amp;gt;first&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;it-&amp;gt;second&amp;lt;&amp;lt;endl;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;map中数据的查找&#34;&gt;&lt;a href=&#34;#map中数据的查找&#34; class=&#34;headerlink&#34; title=&#34;map中数据的查找&#34;&gt;&lt;/a&gt;map中数据的查找&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;map&amp;lt;int,string&amp;gt;::iterator it;					//迭代器
it=mp.find(1);
if(it!=mp.end())&amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;Find it, the relative value is: &amp;quot; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; endl;
&amp;#125;
else&amp;#123;
           cout &amp;lt;&amp;lt; &amp;quot;Can not find the relative value.&amp;quot; &amp;lt;&amp;lt; endl;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;map中数据的删除&#34;&gt;&lt;a href=&#34;#map中数据的删除&#34; class=&#34;headerlink&#34; title=&#34;map中数据的删除&#34;&gt;&lt;/a&gt;map中数据的删除&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;map&amp;lt;int,string&amp;gt;::iterator it;					//迭代器
it = mp.find(2);
mp.erase(it);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;map中数据的排序&#34;&gt;&lt;a href=&#34;#map中数据的排序&#34; class=&#34;headerlink&#34; title=&#34;map中数据的排序&#34;&gt;&lt;/a&gt;map中数据的排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;map 中的所有元素都会根据元素的键值，自动进行升序排序。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;完整操作&#34;&gt;&lt;a href=&#34;#完整操作&#34; class=&#34;headerlink&#34; title=&#34;完整操作&#34;&gt;&lt;/a&gt;完整操作&lt;/h3&gt;&lt;h4 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
map&amp;lt;int,string&amp;gt; mp;
int main()
&amp;#123;
    //使用insert函数插入pair数据
    mp.insert(pair&amp;lt;int,string&amp;gt;(3,&amp;quot;xingyuanjie&amp;quot;));
    mp.insert(pair&amp;lt;int,string&amp;gt;(1,&amp;quot;shicheng&amp;quot;));
    mp.insert(pair&amp;lt;int,string&amp;gt;(4,&amp;quot;tanghaipeng&amp;quot;));
    mp.insert(pair&amp;lt;int,string&amp;gt;(6,&amp;quot;zhouyuhao&amp;quot;));
    mp.insert(pair&amp;lt;int,string&amp;gt;(5,&amp;quot;heqichuan&amp;quot;));
    //使用数组方式插入数据
    mp[2]=&amp;quot;wangzhouyang&amp;quot;;
    //map的遍历
    map&amp;lt;int,string&amp;gt;::iterator it;
    for (it=mp.begin();it!=mp.end();it++) &amp;#123;
        cout&amp;lt;&amp;lt;it-&amp;gt;first&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;it-&amp;gt;second&amp;lt;&amp;lt;endl;
    &amp;#125;
    //查找操作
    it=mp.find(1);
    if(it!=mp.end())&amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;Find it, the relative value is: &amp;quot; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; endl;
    &amp;#125;
    else &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;Can not find the relative value.&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;
    //删除操作
    it = mp.find(2);
    mp.erase(it);
    for (it=mp.begin();it!=mp.end();it++) &amp;#123;
        cout&amp;lt;&amp;lt;it-&amp;gt;first&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;it-&amp;gt;second&amp;lt;&amp;lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;程序输出：&#34;&gt;&lt;a href=&#34;#程序输出：&#34; class=&#34;headerlink&#34; title=&#34;程序输出：&#34;&gt;&lt;/a&gt;程序输出：&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;1 shicheng
2 wangzhouyang
3 xingyuanjie
4 tanghaipeng
5 heqichuan
6 zhouyuhao
Find it, the relative value is: shicheng
1 shicheng
3 xingyuanjie
4 tanghaipeng
5 heqichuan
6 zhouyuhao
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/liitdar/article/details/80009712&#34;&gt;(20条消息) STL中map介绍_liitdar的博客-CSDN博客_stlmap&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/16/Algorithm028/</guid>
            <title>L2-010 排座位 (25 分)</title>
            <link>http://example.com/2022/04/16/Algorithm028/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Graph</category>
            <category>邻接矩阵</category>
            <category>并查集</category>
            <pubDate>Sat, 16 Apr 2022 14:57:46 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-010-排座位-25-分&#34;&gt;&lt;a href=&#34;#L2-010-排座位-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-010 排座位 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-010 排座位 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出3个正整数：&lt;code&gt;N&lt;/code&gt;（≤100），即前来参宴的宾客总人数，则这些人从1到&lt;code&gt;N&lt;/code&gt;编号；&lt;code&gt;M&lt;/code&gt;为已知两两宾客之间的关系数；&lt;code&gt;K&lt;/code&gt;为查询的条数。随后&lt;code&gt;M&lt;/code&gt;行，每行给出一对宾客之间的关系，格式为：&lt;code&gt;宾客1 宾客2 关系&lt;/code&gt;，其中&lt;code&gt;关系&lt;/code&gt;为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后&lt;code&gt;K&lt;/code&gt;行，每行给出一对需要查询的宾客编号。&lt;/p&gt;
&lt;p&gt;这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出&lt;code&gt;No problem&lt;/code&gt;；如果他们之间并不是朋友，但也不敌对，则输出&lt;code&gt;OK&lt;/code&gt;；如果他们之间有敌对，然而也有共同的朋友，则输出&lt;code&gt;OK but...&lt;/code&gt;；如果他们之间只有敌对关系，则输出&lt;code&gt;No way&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;7 8 4
5 6 1
2 7 -1
1 3 1
3 4 1
6 7 -1
1 2 1
1 4 1
2 3 -1
3 4
5 7
2 3
7 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;No problem
OK
OK but...
No way
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接矩阵 + 并查集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并查集具体链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/01/04/Algorithm004/&#34;&gt;并查集 - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int pre[100];				//父节点
int deep[100];				//深度
int g[101][101];			//邻接矩阵建图
void init(int n)&amp;#123;
    for (int i = 0; i &amp;lt;n ; ++i) &amp;#123;
        pre[i]=i;
        deep[i]=0;
    &amp;#125;
&amp;#125;
int find(int x)&amp;#123;
    if(pre[x]==x)&amp;#123;
        return x;
    &amp;#125; else&amp;#123;
        return pre[x]=find(pre[x]);
    &amp;#125;
&amp;#125;
void unit(int x,int y)&amp;#123;
    x=find(x);
    y=find(y);
    if(x==y) return;
    if(deep[x]&amp;lt;deep[y])&amp;#123;
        pre[x]=y;
    &amp;#125;else&amp;#123;
        pre[y]=x;
        if(deep[x]==deep[y])&amp;#123;
            deep[x]++;
        &amp;#125;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    int n,m,k;
    init(105);
    memset(g,0,sizeof(g));
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;k;
    for (int i = 0; i &amp;lt;m ; ++i) &amp;#123;
        int a,b,c;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
        g[a][b]=g[b][a]=c;
        if(c==1) unit(a,b);					//如果是朋友则合并
    &amp;#125;
    for (int j = 0; j &amp;lt;k ; ++j) &amp;#123;
        int a,b;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
        if(g[a][b]==1&amp;amp;&amp;amp;g[b][a]==1) cout&amp;lt;&amp;lt;&amp;quot;No problem&amp;quot;&amp;lt;&amp;lt;endl;
        else if(g[a][b]==0&amp;amp;&amp;amp;g[b][a]==0) cout&amp;lt;&amp;lt;&amp;quot;OK&amp;quot;&amp;lt;&amp;lt;endl;			//两人毫无关系
        else if(g[a][b]==-1&amp;amp;&amp;amp;g[b][a]==-1&amp;amp;&amp;amp;find(a)==find(b)) cout&amp;lt;&amp;lt;&amp;quot;OK but...&amp;quot;&amp;lt;&amp;lt;endl;	//敌对且有共同朋友
        else if(g[a][b]==-1&amp;amp;&amp;amp;g[b][a]==-1) cout&amp;lt;&amp;lt;&amp;quot;No way&amp;quot;&amp;lt;&amp;lt;endl;		//仅敌对
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_45260385/article/details/109752008&#34;&gt;(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680&#34;&gt;题目详情 - L2-010 排座位 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/16/Algorithm027/</guid>
            <title>L2-009 抢红包 (25 分)</title>
            <link>http://example.com/2022/04/16/Algorithm027/</link>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Sort</category>
            <category>结构体</category>
            <category>Double类型相等比较</category>
            <pubDate>Sat, 16 Apr 2022 14:57:38 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-009-抢红包-25-分&#34;&gt;&lt;a href=&#34;#L2-009-抢红包-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-009 抢红包 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-009 抢红包 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;没有人没抢过红包吧…… 这里给出&lt;em&gt;N&lt;/em&gt;个人之间互相发红包、抢红包的记录，请你统计一下他们抢红包的收获。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出一个正整数&lt;em&gt;N&lt;/em&gt;（≤104），即参与发红包和抢红包的总人数，则这些人从1到&lt;em&gt;N&lt;/em&gt;编号。随后&lt;em&gt;N&lt;/em&gt;行，第&lt;em&gt;i&lt;/em&gt;行给出编号为&lt;em&gt;i&lt;/em&gt;的人发红包的记录，格式如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;K     N&lt;/em&gt;1 &lt;em&gt;P&lt;/em&gt;1⋯ NK PK&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;K&lt;/em&gt;（0≤&lt;em&gt;K&lt;/em&gt;≤20）是发出去的红包个数，&lt;em&gt;N&lt;/em&gt;i&lt;em&gt;是抢到红包的人的编号，&lt;/em&gt;Pi（&amp;gt;0）是其抢到的红包金额（以分为单位）。注意：对于同一个人发出的红包，每人最多只能抢1次，不能重复抢。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;按照收入金额从高到低的递减顺序输出每个人的编号和收入金额（以元为单位，输出小数点后2位）。每个人的信息占一行，两数字间有1个空格。如果收入金额有并列，则按抢到红包的个数递减输出；如果还有并列，则按个人编号递增输出。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;10
3 2 22 10 58 8 125
5 1 345 3 211 5 233 7 13 8 101
1 7 8800
2 1 1000 2 1000
2 4 250 10 320
6 5 11 9 22 8 33 7 44 10 55 4 2
1 3 8800
2 1 23 2 123
1 8 250
4 2 121 4 516 7 112 9 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;1 11.63
2 3.63
8 3.63
3 2.11
7 1.69
6 -1.67
9 -2.18
10 -3.26
5 -3.26
4 -12.32
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;结构体 + Sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的就是double类型相等的比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，浮点数在计算机中并不能精确的表示，所以在判断两个double类型的数时需要其他的手段，而不是直接 a&amp;#x3D;&amp;#x3D; b&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
struct student&amp;#123;
    int id=0;
    double money=0;
    int cnt=0;
&amp;#125;;
double dis=1e-6;				//定义一个误差
bool cmp(student a,student b)&amp;#123;
    if(abs(a.money-b.money)&amp;lt;dis)&amp;#123;				//如果两个double型相减在误差的范围内，我们认定这两个double类型相等
        if(a.cnt==b.cnt)&amp;#123;
            return a.id&amp;lt;b.id;
        &amp;#125;else&amp;#123;
            return a.cnt&amp;gt;b.cnt;
        &amp;#125;
    &amp;#125;
    return a.money&amp;gt;b.money;
&amp;#125;
int main()
&amp;#123;
    int n;
    cin&amp;gt;&amp;gt;n;
    student st[n+5];
    for (int i = 0; i &amp;lt;n ; ++i) &amp;#123;
        int time;
        cin&amp;gt;&amp;gt;time;
        st[i].id=i+1;
        for (int j = 0; j &amp;lt;time ; ++j) &amp;#123;
            int p;
            double x;
            cin&amp;gt;&amp;gt;p&amp;gt;&amp;gt;x;
            st[p-1].money+=x/100;
            st[i].money-=x/100;
            st[p-1].cnt++;					//记录抢到的红包数
        &amp;#125;
    &amp;#125;
    sort(st,st+n,cmp);						//sort从数组下标0开始排序，左闭右开
    for (int k = 0; k &amp;lt;n ; ++k) &amp;#123;
        printf(&amp;quot;%d %.2lf\n&amp;quot;,st[k].id,st[k].money);
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/dingpiao190/article/details/73512811?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=1&#34;&gt;(20条消息) double类型是否相等的判断方法_dingpiao190的博客-CSDN博客_double判断相等&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/patrick_star_cowboy/article/details/82083392&#34;&gt;(20条消息) 如何判断两个double类型的数是否相等？_Patrick-Star的博客-CSDN博客_两个double怎么判断相等&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805066890854400&#34;&gt;题目详情 - L2-009 抢红包 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
