{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan",
    "description": "",
    "home_page_url": "https://xingyuanjie.top",
    "items": [
        {
            "id": "https://xingyuanjie.top/2023/03/01/leetcode724/",
            "url": "https://xingyuanjie.top/2023/03/01/leetcode724/",
            "title": "724.寻找数组的中心下标",
            "date_published": "2023-03-01T09:35:03.000Z",
            "content_html": "<h1 id=\"724-寻找数组的中心下标\"><a href=\"#724-寻找数组的中心下标\" class=\"headerlink\" title=\"724.寻找数组的中心下标\"></a>724.寻找数组的中心下标</h1><h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"https://leetcode.cn/problems/find-pivot-index/\">724. 寻找数组的中心下标 - 力扣（LeetCode）</a></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><img src=\"/2023/03/01/leetcode724/image-20230301173931031.png\" alt=\"image-20230301173931031\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">pivotIndex</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> total=<span class=\"hljs-built_in\">accumulate</span>(nums.<span class=\"hljs-built_in\">begin</span>(), nums.<span class=\"hljs-built_in\">end</span>(),<span class=\"hljs-number\">0</span>);\t<span class=\"hljs-comment\">//第三个形参是累加的初始值</span><br>        <span class=\"hljs-keyword\">int</span> sum=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>();i++)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">2</span>*sum+nums[i] == total)&#123;<br>                <span class=\"hljs-keyword\">return</span> i;<br>            &#125;<br>            sum+=nums[i];<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://leetcode.cn/problems/find-pivot-index/solution/xun-zhao-shu-zu-de-zhong-xin-suo-yin-by-gzjle/\">寻找数组的中心索引 - 寻找数组的中心下标 - 力扣（LeetCode）</a></p>\n",
            "tags": [
                "C++",
                "LeetCode",
                "前缀和"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/28/vectorbool/",
            "url": "https://xingyuanjie.top/2023/02/28/vectorbool/",
            "title": "vector<bool>与vector<T>",
            "date_published": "2023-02-28T12:59:01.000Z",
            "content_html": "<h1 id=\"vector-lt-bool-gt-与vector-lt-T-gt\"><a href=\"#vector-lt-bool-gt-与vector-lt-T-gt\" class=\"headerlink\" title=\"vector&lt;bool&gt;与vector&lt;T&gt;\"></a>vector&lt;bool&gt;与vector&lt;T&gt;</h1><p>vector&lt;bool&gt; 不像其他容器一样按Byte存储的，它是按bit存储的，也就是说一个正常的bool类型的空间可以存放vector&lt;bool&gt;中的8个，空间上确实优化了很多，然而，c++是不能直接取对bit操作的（因为C++的最小可寻址值通常以byte为单位），对其使用operator[]其实返回的不是bool的引用而是一个”proxy reference”是”std::vector&lt; bool&gt;:reference”类型的对象。</p>\n<p>正因为如此，vector&lt;bool&gt;通过代理对象进行存取访问时需要执行逐位处理，访问通常比int之类的普通类型操作要慢很多。</p>\n<p>因此，对vecotr&lt;bool&gt;的使用需慎重考虑以下几点：<br>(1)是否需要牺牲速度来获取空间上的优化<br>(2)算法中会否有对vecotr地址进行解引用操作的可能。</p>\n<p>如果不满足以上条件，建议使用deque&lt;bool&gt;来取代vector&lt;bool&gt;，功能基本相同，但deque&lt;bool&gt;未对其进行特殊处理。</p>\n<p>下面是vector&lt;bool&gt;与vector&lt;T&gt;简单的对比例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\tvector&lt;<span class=\"hljs-keyword\">char</span>&gt; ch;<br>\tvector&lt;<span class=\"hljs-keyword\">int</span>&gt; in;<br>\tvector&lt;<span class=\"hljs-keyword\">bool</span>&gt; bo;<br> <br>\t<span class=\"hljs-keyword\">int</span> m = <span class=\"hljs-number\">1e6</span>;<br>\t<span class=\"hljs-keyword\">clock_t</span> t1, t2, t3;<br> <br>\tt1 = <span class=\"hljs-built_in\">clock</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>\t\tch.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>\t&#125;<br>\tt1 = <span class=\"hljs-built_in\">clock</span>() - t1;<br> <br>\tt2 = <span class=\"hljs-built_in\">clock</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>\t\tin.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">0</span>);<br>\t&#125;<br>\tt2 = <span class=\"hljs-built_in\">clock</span>() - t2;<br> <br>\tt3 = <span class=\"hljs-built_in\">clock</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>\t\tbo.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br>\tt3 = <span class=\"hljs-built_in\">clock</span>() - t3;<br> <br>\tcout &lt;&lt;<span class=\"hljs-string\">&quot;vector&lt;char&gt; &quot;</span>&lt;&lt; t1 &lt;&lt; <span class=\"hljs-string\">&quot;\\n vector&lt;int&gt; &quot;</span> &lt;&lt; t2 &lt;&lt; <span class=\"hljs-string\">&quot;\\nvector&lt;bool&gt; &quot;</span> &lt;&lt; t3 &lt;&lt; endl;<br>\tcout &lt;&lt; endl;<br> <br>\t<span class=\"hljs-built_in\">system</span>(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs cpp\">vector&lt;<span class=\"hljs-keyword\">char</span>&gt; <span class=\"hljs-number\">216</span><br>vextor&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-number\">229</span><br>vector&lt;<span class=\"hljs-keyword\">bool</span>&gt; <span class=\"hljs-number\">16535</span><br></code></pre></div></td></tr></table></figure>\n\n<p>这里发现vector&lt;bool&gt;相较于其他vector&lt;T&gt;速度要慢的多！</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/qq_52134928/article/details/121066304?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121066304-blog-86603050.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121066304-blog-86603050.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1\">(65条消息) 【C++】vector＜bool＞的特别之处_小陶同学_的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/u013249689/article/details/25297657\">(65条消息) 不使用vector的原因和替代方法_jackycmu的博客-CSDN博客</a></p>\n",
            "tags": [
                "STL",
                "Vector",
                "C/C++",
                "bool"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/28/Linux004/",
            "url": "https://xingyuanjie.top/2023/02/28/Linux004/",
            "title": "C/C++关键字之restrict",
            "date_published": "2023-02-28T11:45:09.000Z",
            "content_html": "<h1 id=\"C-x2F-C-关键字之restrict\"><a href=\"#C-x2F-C-关键字之restrict\" class=\"headerlink\" title=\"C&#x2F;C++关键字之restrict\"></a>C&#x2F;C++关键字之restrict</h1><p>在C语言中，restrict关键字用于修饰指针（C99标准）。通过加上restrict关键字，程序员可提示编译器：在该指针的生命周期内，其指向的对象不会被别的指针所引用。</p>\n<p>需要注意的是，在C++中，并无明确统一的标准支持restrict关键字。但是很多编译器实现了功能相同的关键字，例如gcc和clang中的__restrict关键字。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>*a, <span class=\"hljs-keyword\">int</span>* b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    *a = <span class=\"hljs-number\">10</span>;<br>    *b = <span class=\"hljs-number\">12</span>;<br>    <span class=\"hljs-keyword\">return</span> *a + *b;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>add1函数的返回值会永远是10 + 12 &#x3D; 22吗？</p>\n<p>答案是不一定。在指针a和b的地址不同时，返回22没有问题。但是当指针a与b指向的是同一个int对象时，该对象先被赋值为10，后被赋值为12，因此a和b都返回12，因此add1函数最终返回24。</p>\n<p>下面是一个简单的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>* a, <span class=\"hljs-keyword\">int</span>* b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    *a = <span class=\"hljs-number\">10</span>;<br>    *b = <span class=\"hljs-number\">12</span>;<br>    <span class=\"hljs-keyword\">return</span> *a + *b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span>* c;<br>    <span class=\"hljs-keyword\">int</span>* d;<br>    d=(<span class=\"hljs-keyword\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">int</span>)*<span class=\"hljs-number\">1</span>);<br>    c=(<span class=\"hljs-keyword\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">int</span>)*<span class=\"hljs-number\">1</span>);<br>    *c=<span class=\"hljs-number\">10</span>;<br>    *d=<span class=\"hljs-number\">12</span>;<br>    *d=<span class=\"hljs-number\">12</span>;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;c:&quot;</span>&lt;&lt;*c&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;d:&quot;</span>&lt;&lt;*d&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;When Pointers a and b have different addresses&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-built_in\">add1</span>(c,d)&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;When Pointers a and b have the same address&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-built_in\">add1</span>(c,c)&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>程序输出：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">c:<span class=\"hljs-number\">10</span><br>d:<span class=\"hljs-number\">12</span><br>When Pointers a <span class=\"hljs-keyword\">and</span> b have different addresses<br><span class=\"hljs-number\">22</span><br>When Pointers a <span class=\"hljs-keyword\">and</span> b have the same address<br><span class=\"hljs-number\">24</span><br></code></pre></div></td></tr></table></figure>\n\n<p>开启-O3优化，add1对应的汇编代码如下:</p>\n<p>为了得到<code>*a</code>的值访问了1次内存，而不管在何种条件下(<code>a == b</code> or <code>a != b</code>)，<code>*b</code>的值都是12。因此编译器将<code>*a</code>的值载入<code>eax</code>寄存器后，直接加上立即数12，而无需再访问内存获取<code>*b</code>的值。在无法确定指针a和b是否相同的情况下，编译器只能帮你优化到这里了。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\"><span class=\"hljs-number\">0000000000400</span>a10 &lt;_Z4add1PiS_&gt;:<br>  <span class=\"hljs-number\">400</span>a10:   c7 <span class=\"hljs-number\">07</span> <span class=\"hljs-number\">0</span>a <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0</span>xa,(%rdi) ; *a = <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-number\">400</span>a16:   c7 <span class=\"hljs-number\">06</span> <span class=\"hljs-number\">0</span>c <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0</span>xc,(%rsi) ; *b = <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-number\">400</span>a1c:   <span class=\"hljs-number\">8</span>b <span class=\"hljs-number\">07</span>                   mov    (%rdi),%eax ; 结果 = *a<br>  <span class=\"hljs-number\">400</span>a1e:   <span class=\"hljs-number\">83</span> c0 <span class=\"hljs-number\">0</span>c                add    $<span class=\"hljs-number\">0</span>xc,%eax   ; 结果 += <span class=\"hljs-number\">12</span> <br>  <span class=\"hljs-number\">400</span>a21:   c3                      retq<br></code></pre></div></td></tr></table></figure>\n\n<p>加上了restrict关键字过后，同样开启-O3优化，add1对应的汇编代码如下：</p>\n<p>加上关键字restrict后，编译器能够确认指针a和b不可能指向同一个内存地址，因此在求*a + *b时，无虚访问内存，因为*a必然等于立即数10，*b必然等于立即数12。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>* __restrict  a, <span class=\"hljs-keyword\">int</span>* __restrict b)</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>    *a = <span class=\"hljs-number\">10</span>;<br>    *b = <span class=\"hljs-number\">12</span>;<br>    <span class=\"hljs-keyword\">return</span> *a + *b ;<br>&#125;<br><span class=\"hljs-number\">0000000000400</span>a30 &lt;_Z4add2PiS_&gt;:<br>  <span class=\"hljs-number\">400</span>a30:   c7 <span class=\"hljs-number\">07</span> <span class=\"hljs-number\">0</span>a <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0xa</span>,(%rdi) ; *a = <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-number\">400</span>a36:   b8 <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>          mov    $<span class=\"hljs-number\">0x16</span>,%eax  ; 结果 = <span class=\"hljs-number\">22</span><br>  <span class=\"hljs-number\">400</span>a3b:   c7 <span class=\"hljs-number\">06</span> <span class=\"hljs-number\">0</span>c <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0xc</span>,(%rsi) ; *b = <span class=\"hljs-number\">12</span><br>  <span class=\"hljs-number\">400</span>a41:   c3  <br></code></pre></div></td></tr></table></figure>\n\n<p>有无restrict关键字的两种情况下的汇编指令可看到，后者比前者少访问一次内存，且少执行一条指令。就是因为没加restruct关键字时，编译器不能确定别的地方是不是会修改此值，所以会去相应的地址查看。</p>\n<p><strong>这样当我们明确知道两个指针不可能指向同一个地址时，我们就可以通过使用restrict关键字来进行性能优化。</strong></p>\n<p>注意使用restrict的时候，程序员必须确保不会出现<strong>pointer aliasing</strong>，即同一块内存无法通过两个或以上的指针变量名访问。不满足这个条件强行指定restrict，将会出现<strong>underfined behavior</strong>。</p>\n<p>通常编写代码时会忽略pointer aliasing的问题。更常见是在性能分析时，通过反汇编看到很多冗余的读取指令，才会想到加入restrict关键字来提升性能。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zhuanlan.zhihu.com/p/349726808\">C&#x2F;C++关键字之restrict - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://github.com/ClickHouse/ClickHouse/pull/19946\">Improve performance of aggregate functions by alexey-milovidov · Pull Request #19946 · ClickHouse&#x2F;ClickHouse (github.com)</a></p>\n<p><a href=\"https://en.cppreference.com/w/c/language/restrict\">restrict type qualifier - cppreference.com</a></p>\n<p><a href=\"https://www.zhihu.com/question/41653775/answer/2535730128\">如何理解C语言关键字restrict？ - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://blog.csdn.net/qq_41822235/article/details/83479562\">(65条消息) 关键字_restrict___restrict_楚楚可薇的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qq_41950508/article/details/126619881?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-126619881-blog-102577325.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-126619881-blog-102577325.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1\">(65条消息) 【C++】关键字restrict的作用_restrict关键字的作用_不知所措的渣渣辉的博客-CSDN博客</a></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/26/intel001/",
            "url": "https://xingyuanjie.top/2023/02/26/intel001/",
            "title": "unroll_and_jam/nounroll_and_jam",
            "date_published": "2023-02-26T11:12:51.000Z",
            "content_html": "<h1 id=\"unroll-and-jam-x2F-nounroll-and-jam\"><a href=\"#unroll-and-jam-x2F-nounroll-and-jam\" class=\"headerlink\" title=\"unroll_and_jam&#x2F;nounroll_and_jam\"></a>unroll_and_jam&#x2F;nounroll_and_jam</h1><p>启用或禁用循环展开和阻塞。这些指令只能应用于迭代for循环。</p>\n<h2 id=\"Syntax\"><a href=\"#Syntax\" class=\"headerlink\" title=\"Syntax\"></a>Syntax</h2><p>#pragma unroll_and_jam\t#pragma unroll_and_jam (n)\t#pragma nounroll_and_jam</p>\n<h2 id=\"Arguments\"><a href=\"#Arguments\" class=\"headerlink\" title=\"Arguments\"></a>Arguments</h2><p>展开因子，表示展开循环的次数;必须是0到255之间的整数常数</p>\n<h2 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h2><p>unroll_and_jam指令部分展开套中比最内层循环更高的一个或多个循环，并将结果循环融合&#x2F;阻塞回一起。这种转换允许在循环中进行更多的重用。</p>\n<p>此pragma对最内层循环无效。确保紧随其后的循环不是编译器发起的交换完成后的最内层循环。</p>\n<p>指定此pragma是向编译器提示展开和阻塞序列是合法且有利可图的。编译器会在任何可能的情况下启用这种转换。</p>\n<p>对于它影响的每个for循环，unroll_and_jam指令必须在for语句之前。如果指定了n，优化器将展开循环n次。如果n被省略或超出允许的范围，优化器将分配展开循环的次数。编译器通过比较n和循环计数生成正确的代码。</p>\n<p>只有在设置了编译器选项O3时，才支持此pragma。unroll_and_jam指令将覆盖从命令行展开循环的任何设置。</p>\n<p>当展开循环会增加寄存器压力和代码大小时，可能需要防止展开嵌套循环或不完美的嵌套循环。在这种情况下，使用nounroll_and_jam编译指令。nounroll_and_jam pragma提示编译器不要展开指定的循环。</p>\n<p><strong>Examples</strong></p>\n<p><strong>Use the unroll_and_jam pragma:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> a[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10</span>]; <br><span class=\"hljs-keyword\">int</span> b[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10</span>]; <br><span class=\"hljs-keyword\">int</span> c[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10</span>]; <br><span class=\"hljs-keyword\">int</span> d[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10</span>]; <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">unroll</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> i,j,k;<br>    <span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> unroll_and_jam (6)</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">1</span>; i &lt; n; i++) &#123;<br>       <span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> unroll_and_jam (6)</span><br>       <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">1</span>; j &lt; n; j++) &#123;<br>          <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">1</span>; k &lt; n; k++)&#123;<br>            a[i][j] += b[i][k]*c[k][j];<br>            &#125;<br>       &#125;<br>    &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/pragmas/intel-specific-pragma-reference/unroll-and-jam-nounroll-and-jam.html\">unroll_and_jam nounroll_and_jam (intel.com)</a></p>\n",
            "tags": [
                "C++",
                "Intel"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/26/cache001/",
            "url": "https://xingyuanjie.top/2023/02/26/cache001/",
            "title": "Cache Blocking Techniques【个人翻译】",
            "date_published": "2023-02-26T10:02:29.000Z",
            "content_html": "<h2 id=\"Cache-Blocking-Techniques\"><a href=\"#Cache-Blocking-Techniques\" class=\"headerlink\" title=\"Cache Blocking Techniques\"></a>Cache Blocking Techniques</h2><p><strong>文章来源：</strong><a href=\"https://www.intel.cn/content/www/cn/zh/developer/articles/technical/cache-blocking-techniques.html\">Cache Blocking Techniques (intel.cn)</a></p>\n<p><strong>文章作者：</strong><a href=\"https://community.intel.com/cipcp26785/plugins/custom/intel/intel/custom.userprofile?id=3UpJu61CDTyShonSVJNwDw==&iv=8843887237217530\">Amanda K Sharp</a></p>\n<h3 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h3><p>一类重要的算法更改涉及分块数据结构以适应缓存。通过组织数据内存访问，可以用一个大得多的数据集的一个小子集加载缓存。接下来的想法是在缓存中处理这个数据块。通过在缓存中使用&#x2F;重用这些数据，我们减少了访问内存的需要(减少内存带宽压力)。</p>\n<h3 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h3><p>分块是一种著名的优化技术，可以帮助避免许多应用程序中的内存带宽瓶颈。分块背后的关键思想是利用应用程序中固有的数据重用，确保数据在多个用途之间保持在缓存中。分块可以在1-D、2-D或3-D空间数据结构上执行。一些迭代应用程序可以进一步受益于多次迭代的分块(通常称为时间分块)，以进一步缓解带宽瓶颈。就代码更改而言，分块通常涉及循环分割和交换的组合。在大多数应用程序代码中，通过对分块因子进行一些参数化，对源进行正确的更改，用户可以最好地执行分块。</p>\n<h3 id=\"Original-Source\"><a href=\"#Original-Source\" class=\"headerlink\" title=\"Original Source\"></a>Original Source</h3><figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\">for (body1 = <span class=\"hljs-number\">0</span>; body1 &lt; NBODIES; body1 ++) &#123;<br>   for (body2=<span class=\"hljs-number\">0</span>; body2 &lt; NBODIES; body2++) &#123;<br>     <span class=\"hljs-keyword\">OUT</span>[body1] += compute(body1, body2);<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在本例中，数据(body2)来自内存。假设NBODIES很大，我们将无法在缓存中重用。此应用程序受内存带宽限制。应用程序将以内存到CPU的速度运行，而不是最佳速度。</p>\n<p><strong>Modified Source (with 1-D blocking):</strong></p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\">for (body2 = <span class=\"hljs-number\">0</span>; body2 &lt; NBODIES; body2 += <span class=\"hljs-keyword\">BLOCK</span>) &#123;<br>   for (body1=<span class=\"hljs-number\">0</span>; body1 &lt; NBODIES; body1 ++) &#123;<br>      for (body22=<span class=\"hljs-number\">0</span>; body22 &lt; <span class=\"hljs-keyword\">BLOCK</span>; body22 ++) &#123;<br>         <span class=\"hljs-keyword\">OUT</span>[body1] += compute(body1, body2 + body22);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在修改后的代码中，数据(body22)在缓存中被保留和重用，从而获得更好的性能。</p>\n<p>例如，上面的代码片段显示了一个分块NBody代码的示例。有两个循环(body1和body2)遍历所有主体。顶部的原始代码流经内部循环中的整个主体集，并且必须在每次迭代中从内存中加载body2值。底部的分块代码是通过将body2循环分解为一个迭代多个BLOCK中的body的外部循环和一个迭代BLOCK中的元素的内部body22循环，并交织body1和body2循环来获得的。这段代码在body1循环的多次迭代中重用了一组BLOCK body2值。如果BLOCK被选中，使得这组值适合缓存，内存流量就会降低一个BLOCK的因子。</p>\n<p>以下是来自OpenMP*版本的NBody基准测试的相关代码片段(使用CHUNK_SIZE因子进行分块应用)。</p>\n<p>在这种情况下，循环展开-阻塞转换被表示为一个pragma，并由编译器完成。在这种情况下，研究-opt-report的输出可以确认编译器确实为你的循环执行了展开阻塞优化。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\">#define CHUNK_SIZE <span class=\"hljs-number\">8192</span><br><br>#pragma omp parallel <span class=\"hljs-keyword\">private</span>(body_start_index)<br>  for(body_start_index = <span class=\"hljs-number\">0</span>; body_start_index &lt; global_number_of_bodies; body_start_index += CHUNK_SIZE) &#123;<br>    <span class=\"hljs-built_in\">int</span> i;<br>    <span class=\"hljs-built_in\">int</span> body_end_index = body_start_index + CHUNK_SIZE;<br><br>    #pragma omp for <span class=\"hljs-keyword\">private</span>(i) schedule(guided)<br>    #pragma unroll_and_jam (<span class=\"hljs-number\">4</span>)<br>    for(i=starting_index; i&lt;ending_index; i++) &#123;<br>      <span class=\"hljs-built_in\">int</span> j;<br>      <span class=\"hljs-keyword\">TYPE</span> acc_x_0 = <span class=\"hljs-number\">0</span>, acc_y_0 = <span class=\"hljs-number\">0</span>, acc_z_0 = <span class=\"hljs-number\">0</span>;<br>      for(j=body_start_index; j&lt;body_end_index; j+=<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">TYPE</span> delta_x_0 = Input_Position_X[(j+<span class=\"hljs-number\">0</span>)] - Input_Position_X[i];<br>        <span class=\"hljs-keyword\">TYPE</span> delta_y_0 = Input_Position_Y[(j+<span class=\"hljs-number\">0</span>)] - Input_Position_Y[i];<br>        <span class=\"hljs-keyword\">TYPE</span> delta_z_0 = Input_Position_Z[(j+<span class=\"hljs-number\">0</span>)] - Input_Position_Z[i];<br><br>        <span class=\"hljs-keyword\">TYPE</span> gamma_0 = delta_x_0*delta_x_0 + delta_y_0*delta_y_0 + delta_z_0*delta_z_0 + epsilon_sqr;<br>        <span class=\"hljs-keyword\">TYPE</span> s_0 = Mass[j+<span class=\"hljs-number\">0</span>]/(gamma_0 * <span class=\"hljs-built_in\">SQRT</span>(gamma_0));<br>        acc_x_0 += s_0*delta_x_0;<br>        acc_y_0 += s_0*delta_y_0;<br>        acc_z_0 += s_0*delta_z_0;<br>      &#125;<br>      Output_Acceleration[<span class=\"hljs-number\">3</span>*(i+<span class=\"hljs-number\">0</span>)+<span class=\"hljs-number\">0</span>] += acc_x_0;<br>      Output_Acceleration[<span class=\"hljs-number\">3</span>*(i+<span class=\"hljs-number\">0</span>)+<span class=\"hljs-number\">1</span>] += acc_y_0;<br>      Output_Acceleration[<span class=\"hljs-number\">3</span>*(i+<span class=\"hljs-number\">0</span>)+<span class=\"hljs-number\">2</span>] += acc_z_0;<br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>下面是Fortran中的一个矩阵乘法代码示例，其中用户执行高级块展开-分块转换(在修改版本中)，涉及本地复制数组以获得最佳性能。</p>\n<p><strong>Fortran Source Example:</strong></p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\"><span class=\"hljs-keyword\">do</span> j=<span class=\"hljs-number\">1</span>,N<br>  <span class=\"hljs-keyword\">do</span> k = <span class=\"hljs-number\">1</span>,N<br>    <span class=\"hljs-keyword\">do</span> i = <span class=\"hljs-number\">1</span>,N<br>      c(i,j) = c(i,j) + a(i,k) * b(k,j)<br>    <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>  <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br><span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Modified Fortran Source:</strong></p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\"><span class=\"hljs-keyword\">do</span> JJ = <span class=\"hljs-number\">1</span>, N, TJ<br><br>       <span class=\"hljs-keyword\">do</span> KK = <span class=\"hljs-number\">1</span>, N, TK<br>         <span class=\"hljs-keyword\">do</span> jjj = <span class=\"hljs-number\">1</span>,<span class=\"hljs-built_in\">min</span>(tj,N-jj+<span class=\"hljs-number\">1</span>)                     <span class=\"hljs-comment\">! BCOPY - no transpose</span><br>           <span class=\"hljs-keyword\">do</span> kkk = <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">min</span>(tk,N-kk+<span class=\"hljs-number\">1</span>)<br>             p(kkk,jjj-<span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">1</span>) = B(kk+kkk-<span class=\"hljs-number\">1</span>, jj+jjj-<span class=\"hljs-number\">1</span>)<br>           <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>         <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>         <span class=\"hljs-keyword\">do</span> II = <span class=\"hljs-number\">1</span>, N, TI<br>           <span class=\"hljs-keyword\">do</span> iii = <span class=\"hljs-number\">1</span>,<br>             <span class=\"hljs-built_in\">min</span>(ti,N-ii+<span class=\"hljs-number\">1</span>)                   <span class=\"hljs-comment\">!ACOPY - transpose</span><br>             <span class=\"hljs-keyword\">do</span> kkk = <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">min</span>(tk,N-kk+<span class=\"hljs-number\">1</span>)<br>                Q(kkk,iii) = A(ii+iii-<span class=\"hljs-number\">1</span>, kk+kkk-<span class=\"hljs-number\">1</span>)<br>             <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>           <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>           <span class=\"hljs-keyword\">do</span> J = <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">min</span>(tj,N-jj+<span class=\"hljs-number\">1</span>), <span class=\"hljs-number\">4</span><br>             <span class=\"hljs-keyword\">do</span> I = <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">min</span>(ti,N-ii+<span class=\"hljs-number\">1</span>), <span class=\"hljs-number\">2</span><br>                t1 = <span class=\"hljs-number\">0</span> ; t2 = <span class=\"hljs-number\">0</span> ; t5 = <span class=\"hljs-number\">0</span> ; t6 = <span class=\"hljs-number\">0</span> ; t9 = <span class=\"hljs-number\">0</span> ; t10 = <span class=\"hljs-number\">0</span> ; t13 =<span class=\"hljs-number\">0</span> ; t14 = <span class=\"hljs-number\">0</span><br>                <span class=\"hljs-comment\">!DIR$ vector aligned                      !DIR$ unroll(2)</span><br>                <span class=\"hljs-keyword\">do</span> K = <span class=\"hljs-number\">1</span>,<span class=\"hljs-built_in\">min</span>(TK,N-kk+<span class=\"hljs-number\">1</span>)      <span class=\"hljs-comment\">! Innermost loop, vectorized and unrolled by 2 after that</span><br>                   qi = Q(K,I)           ;    qi1 = Q(K,I+<span class=\"hljs-number\">1</span>)  <br>                   t1 = t1+qi*P(K,J)     ;    t2 = t2+ qi1*P(K,J)<br>                   t5 = t5+ qi*P(K,J+<span class=\"hljs-number\">1</span>)  ;    t6 = t6+ qi1*P(K,J+<span class=\"hljs-number\">1</span>)<br>                   t9 = t9+ qi*P(K,J+<span class=\"hljs-number\">2</span>)  ;    t10 = t10+ qi1*P(K,J+<span class=\"hljs-number\">2</span>)<br>                   t13 = t13+ qi*P(K,J+<span class=\"hljs-number\">3</span>);    t14 = t14+qi1*P(K,J+<span class=\"hljs-number\">3</span>)<br>                <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>               c(i+ii-<span class=\"hljs-number\">1</span>,j+jj-<span class=\"hljs-number\">1</span>) = c(i+ii-<span class=\"hljs-number\">1</span>,j+jj-<span class=\"hljs-number\">1</span>) +t1          ; c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+jj-<span class=\"hljs-number\">1</span>) = c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+jj-<span class=\"hljs-number\">1</span>) + t2<br>               c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">1</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">1</span>+jj-<span class=\"hljs-number\">1</span>) + t5     ; c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">1</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">1</span>+jj-<span class=\"hljs-number\">1</span>) + t6<br>               c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">2</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">2</span>+jj-<span class=\"hljs-number\">1</span>) + t9     ; c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">2</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">2</span>+jj-<span class=\"hljs-number\">1</span>) + t10<br>               c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">3</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">3</span>+jj-<span class=\"hljs-number\">1</span>) + t13    ; c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">3</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">3</span>+jj-<span class=\"hljs-number\">1</span>) + t14<br>             <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>           <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>         <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>       <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>     <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"Take-Aways\"><a href=\"#Take-Aways\" class=\"headerlink\" title=\"Take Aways\"></a>Take Aways</h3><p>缓存分块是一种重新安排数据访问的技术，将数据子集(块)拉入缓存，并对这个块进行操作，以避免不得不重复从主存中获取数据。正如上面的示例所示，可以以这种方式手动分块循环数据以重用缓存。</p>\n<p>对于性能关键的循环，其中性能分析表明内存带宽限制，而-opt-report显示编译器没有以最佳方式分块循环，您可以考虑手动展开循环，以便更好地分块数据以实现缓存重用。</p>\n<h3 id=\"NEXT-STEPS\"><a href=\"#NEXT-STEPS\" class=\"headerlink\" title=\"NEXT STEPS\"></a>NEXT STEPS</h3><p>您必须从头到尾阅读本指南，使用内置的超链接来指导您在Intel®Xeon处理器上成功地移植和调优应用程序。本指南中提供的路径反映了获得最佳应用程序性能所需的步骤。</p>\n",
            "tags": [
                "Cache",
                "Blocking"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/26/openmp008/",
            "url": "https://xingyuanjie.top/2023/02/26/openmp008/",
            "title": "OpenMP:Internal Control Variables",
            "date_published": "2023-02-26T09:36:54.000Z",
            "content_html": "<h2 id=\"2-5-Internal-Control-Variables\"><a href=\"#2-5-Internal-Control-Variables\" class=\"headerlink\" title=\"2.5 Internal Control Variables\"></a>2.5 Internal Control Variables</h2><p>OpenMP实现必须像内部控制变量(icv)一样控制OpenMP程序的行为。这些icv存储的信息包括用于未来并行区域的线程数、用于工作共享循环的调度以及是否启用嵌套并行。在程序执行期间，icv在不同的时间被赋予值(如下所述)。它们是由实现本身初始化的，并且可以通过OpenMP环境变量和调用OpenMP API例程来赋值。程序只能通过OpenMP API例程检索这些icv的值。</p>\n<p>出于说明的目的，本文档使用特定的名称来引用icv，但是实现不需要使用这些名称，也不需要提供访问变量的任何方法，除非通过第<a href=\"https://www.openmp.org/spec-html/5.0/openmpsu31.html#x50-680002.5.2\">189</a>页第<a href=\"https://www.openmp.org/spec-html/5.0/openmpsu31.html#x50-680002.5.2\">2.5.2节</a>所示的方法。</p>\n<p>2.5.1 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu30.html#x49-670002.5.1\">ICV Descriptions</a></p>\n<p>2.5.2 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu31.html#x50-680002.5.2\">ICV Initialization</a></p>\n<p>2.5.3 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu32.html#x51-710002.5.3\">Modifying and Retrieving ICV Values</a></p>\n<p>2.5.4 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu33.html#x52-740002.5.4\">How ICVs are Scoped</a></p>\n<p>​\t\t 2.5.4.1 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu33.html#x52-760002.5.4.1\">How the Per-Data Environment ICVs Work</a></p>\n<p>2.5.5 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu34.html#x53-770002.5.5\">ICV Override Relationships</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.openmp.org/spec-html/5.0/openmpse13.html#x48-660002.5\">Internal Control Variables (openmp.org)</a></p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/26/openmp007/",
            "url": "https://xingyuanjie.top/2023/02/26/openmp007/",
            "title": "OpenMP线程绑定【未完结】",
            "date_published": "2023-02-26T09:06:59.000Z",
            "content_html": "<h2 id=\"OpenMP线程绑定\"><a href=\"#OpenMP线程绑定\" class=\"headerlink\" title=\"OpenMP线程绑定\"></a>OpenMP线程绑定</h2><h3 id=\"OpenMP相关环境变量与指令\"><a href=\"#OpenMP相关环境变量与指令\" class=\"headerlink\" title=\"OpenMP相关环境变量与指令\"></a>OpenMP相关环境变量与指令</h3><h4 id=\"OMP-PROC-BIND\"><a href=\"#OMP-PROC-BIND\" class=\"headerlink\" title=\"OMP_PROC_BIND\"></a>OMP_PROC_BIND</h4><p>OMP_PROC_BIND环境变量设置bind-var ICV的初始值。这个环境变量的值可以是true、false，或者用逗号分隔的master、close或spread列表。列表的值设置了对应嵌套级别的并行区域要使用的线程亲和策略。</p>\n<p>如果环境变量设置为false，则执行环境可能会在OpenMP位置之间移动OpenMP线程，线程相关性将被禁用，并行构造上的proc_bind子句将被忽略。</p>\n<p>否则，执行环境不应该在OpenMP位置之间移动OpenMP线程，线程亲和性被启用，并且初始线程被绑定到OpenMP位置列表中的第一个位置，先于第一个活动并行区域。</p>\n<p>如果OMP_PROC_BIND环境变量中的值不是true、false或master、close或spread的逗号分隔列表，则程序的行为是实现定义的。如果初始线程不能绑定到OpenMP位置列表中的第一个位置，则该行为也是实现定义的。</p>\n<p>例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">setenv OMP_PROC_BIND false<br>setenv OMP_PROC_BIND &quot;spread,\tspread, close&quot;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://harrychen.xyz/2022/05/08/numa-processor-and-cpu-binding/\">NUMA 处理器与进程绑定 - Harry Chen’s Blog</a></p>\n<p><a href=\"https://www.openmp.org/spec-html/5.0/openmpse52.html\">OMP_PROC_BIND (openmp.org)</a></p>\n<p><a href=\"https://www.openmp.org/spec-html/5.0/openmpsu36.html#x56-900002.6.2\">Controlling OpenMP Thread Affinity</a></p>\n<p><a href=\"https://www.openmp.org/spec-html/5.0/openmpse53.html\">OMP_PLACES (openmp.org)</a></p>\n<p><a href=\"https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/optimization-and-programming/openmp-support/openmp-library-support/thread-affinity-interface.html\">Thread Affinity Interface (intel.com)</a></p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/24/Linux003/",
            "url": "https://xingyuanjie.top/2023/02/24/Linux003/",
            "title": "基于GDB的程序调试",
            "date_published": "2023-02-24T08:50:20.000Z",
            "content_html": "<h2 id=\"基于GDB的程序调试\"><a href=\"#基于GDB的程序调试\" class=\"headerlink\" title=\"基于GDB的程序调试\"></a>基于GDB的程序调试</h2><h3 id=\"程序调试工具GDB\"><a href=\"#程序调试工具GDB\" class=\"headerlink\" title=\"程序调试工具GDB\"></a>程序调试工具GDB</h3><p>编译器GCC，项目构建工具Make（又称gmake），以及GDB。</p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224165344672.png\" alt=\"image-20230224165344672\"></p>\n<p><strong>GDB是什么？</strong></p>\n<p>GDB：GNU symbolic debugger是Linux下常用的程序调试器</p>\n<p><strong>GDB可以做什么？</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224165606636.png\" alt=\"image-20230224165606636\"></p>\n<p><strong>GDB官网：</strong><a href=\"https://www.sourceware.org/gdb/\">GDB: The GNU Project Debugger (sourceware.org)</a></p>\n<h3 id=\"调试案例一\"><a href=\"#调试案例一\" class=\"headerlink\" title=\"调试案例一\"></a>调试案例一</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">int</span> n,sum;<br>    n = <span class=\"hljs-number\">1</span>;<br>    sum = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>( n &lt;= <span class=\"hljs-number\">100</span>)<br>    &#123;<br>        sum = sum + n;<br>        n = n + <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在编译程序的时候，需要加调试选项： -g</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">gcc gdb001.c -g -o ex1<br></code></pre></div></td></tr></table></figure>\n\n<p>使用gdb启动程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">gdb ./ex1<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>进入gdb调试环境</strong>：</p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224170419171.png\" alt=\"image-20230224170419171\"></p>\n<p><strong>在调试环境中：使用l选项会显示带行号的源代码</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224170620617.png\" alt=\"image-20230224170620617\"></p>\n<p><strong>但是默认情况下，l选项只显示10行源代码，如果查看后续代码，在调试界面Enter回车即可</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224170804048.png\" alt=\"image-20230224170804048\"></p>\n<p><strong>在第7行源代码处打断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224171858691.png\" alt=\"image-20230224171858691\"></p>\n<p><strong>运行程序，遇到断点停止：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172105514.png\" alt=\"image-20230224172105514\"></p>\n<p><strong>查看代码中变量n的值</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172200662.png\" alt=\"image-20230224172200662\"></p>\n<p>当前n的值为1，$1表示该变量所在存储区的名称</p>\n<p><strong>在程序第12行处打断点</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172321002.png\" alt=\"image-20230224172321002\"></p>\n<p><strong>继续执行程序</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172356622.png\" alt=\"image-20230224172356622\"></p>\n<p><strong>查看当前n变量的值</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172422998.png\" alt=\"image-20230224172422998\"></p>\n<p>当前n的值为101</p>\n<p><strong>退出调试</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172456626.png\" alt=\"image-20230224172456626\"></p>\n<p><strong>查看调试环境所有断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172650422.png\" alt=\"image-20230224172650422\"></p>\n<p><strong>删除第7行的断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172745323.png\" alt=\"image-20230224172745323\"></p>\n<p><strong>禁用编号为2的断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172832507.png\" alt=\"image-20230224172832507\"></p>\n<p>注意断点状态Enb(enable)由y变成n，代表禁用</p>\n<p><strong>恢复编号为2的断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224173006975.png\" alt=\"image-20230224173006975\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>GDB有三种调试模式：</p>\n<p><strong>调试执行程序：</strong>（前面的案例），注意编译加调试信息(-g)</p>\n<p><strong>调试core文件   ：</strong>需要对系统设置的core文件大小作调整（ulimit - c unlimlited），否则可能无法\t\t\t\t\t\t\t  产生core文件</p>\n<p><strong>调试正在执行的程序（gdb attach） ：</strong>Top找到进程编号pid，Gdb attach pid</p>\n<p><strong>GDB结构组成：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224173613247.png\" alt=\"image-20230224173613247\"></p>\n<h3 id=\"常用调试指令：\"><a href=\"#常用调试指令：\" class=\"headerlink\" title=\"常用调试指令：\"></a>常用调试指令：</h3><h4 id=\"启动指令\"><a href=\"#启动指令\" class=\"headerlink\" title=\"启动指令\"></a>启动指令</h4><p>调试程序：gdb program</p>\n<p>根据core文件调试程序：gdb program corefile</p>\n<p>跟踪调试进程：gdb attach pid</p>\n<h4 id=\"程序运行\"><a href=\"#程序运行\" class=\"headerlink\" title=\"程序运行\"></a>程序运行</h4><p>run，该命令会运行至程序结束，除非遇到断点或报错</p>\n<h4 id=\"单步执行\"><a href=\"#单步执行\" class=\"headerlink\" title=\"单步执行\"></a>单步执行</h4><p>步进执行不进栈？next</p>\n<p>步进执行，进栈step</p>\n<h4 id=\"代码查看\"><a href=\"#代码查看\" class=\"headerlink\" title=\"代码查看\"></a>代码查看</h4><p>列出断点附近或程序所有代码list</p>\n<p>设置现实代码的行数 set listsize &lt;n&gt;</p>\n<h4 id=\"退出调试\"><a href=\"#退出调试\" class=\"headerlink\" title=\"退出调试\"></a>退出调试</h4><p>quit</p>\n<h4 id=\"查看栈信息\"><a href=\"#查看栈信息\" class=\"headerlink\" title=\"查看栈信息\"></a>查看栈信息</h4><p>bt\t打印当前的函数调用栈的所有信息</p>\n<p>bt &lt;n&gt;\tn是一个正整数，表示只打印栈顶上n层的栈信息</p>\n<p>bt &lt;-n&gt;\t表示只打印栈底下n层的栈信息</p>\n<h4 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h4><p><strong>代码断点：</strong></p>\n<ul>\n<li>break lineNumber | functionName</li>\n<li>break lineNumber | functionName if condition</li>\n<li>tbreak lineNumber | functionName  临时断点，仅能使用一次</li>\n</ul>\n<p><strong>内存断点（观察点）：</strong></p>\n<ul>\n<li>监控内存值改变 watch expr [if condition]</li>\n<li>监控内存值被读取 rwatch expr [if condition]</li>\n<li>监控内存值被读取和写入 awatch wxpr [if condition]</li>\n</ul>\n<p><strong>事件断点：</strong></p>\n<ul>\n<li>C++ exception，使用catch exception [name]</li>\n<li>Ada exception，使用catch handlers [name]</li>\n<li>exec事件，使用catch exec</li>\n<li>fork事件，使用catch fork 或者 catch vfork</li>\n<li>加载和卸载动态so事件，使用catch load|unload [regexp]</li>\n<li>监听系统信号，使用catch signal [signal]</li>\n<li>监听系统调用，使用catch syscall[name|number|group:groupname|g:groupname]…</li>\n</ul>\n<p><strong>打印变量：</strong></p>\n<ul>\n<li>Print [file | func]::variable 查看局部变量或全局变量</li>\n<li>Print *array@len  数组首地址@查看长度</li>\n<li>x&#x2F;[n | u] &lt;addr&gt;\tx命令查看内存地址钟的值，n：表示显示内存的长度，u：表示从当前地址往后请求的字节数</li>\n</ul>\n<p><strong>打印寄存器：</strong></p>\n<p>info register\t查看寄存器（除了浮点寄存器）</p>\n<p>all-registers\t查看所有寄存器</p>\n<p>info registers &lt;reg_name …&gt;查看所指定寄存器</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><strong>来源培训PPT 作者：Relax  邮箱：<a href=\"mailto:&#119;&#97;&#x6e;&#x67;&#119;&#49;&#x31;&#49;&#64;&#105;&#x63;&#x6c;&#x6f;&#x75;&#100;&#x2e;&#99;&#111;&#x6d;\">&#119;&#97;&#x6e;&#x67;&#119;&#49;&#x31;&#49;&#64;&#105;&#x63;&#x6c;&#x6f;&#x75;&#100;&#x2e;&#99;&#111;&#x6d;</a></strong></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/19/Matrix002/",
            "url": "https://xingyuanjie.top/2023/02/19/Matrix002/",
            "title": "矩阵乘法计算拆分展示",
            "date_published": "2023-02-19T09:04:23.000Z",
            "content_html": "<h2 id=\"矩阵乘法计算拆分展示\"><a href=\"#矩阵乘法计算拆分展示\" class=\"headerlink\" title=\"矩阵乘法计算拆分展示\"></a>矩阵乘法计算拆分展示</h2><h3 id=\"通用矩阵乘概念\"><a href=\"#通用矩阵乘概念\" class=\"headerlink\" title=\"通用矩阵乘概念\"></a>通用矩阵乘概念</h3><p><img src=\"/2023/02/19/Matrix002/image-20230219171156738.png\" alt=\"image-20230219171156738\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i行j列</span><br>        c[i][j] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>           C[i][j] += A[i][p] * B[p][j];\t\t<span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n\n\n<h3 id=\"计算拆分展示\"><a href=\"#计算拆分展示\" class=\"headerlink\" title=\"计算拆分展示\"></a>计算拆分展示</h3><p>图四将输出计算拆分为 <strong>1 × 4</strong> 的小块，即将 <strong>N</strong> 维度拆分为两部分。计算该块输出时，需要使用 <strong>A</strong> 矩阵的1行，和 <strong>B</strong> 矩阵的4列 。</p>\n<p><img src=\"/2023/02/19/Matrix002/image-20230219171904249.png\" alt=\"image-20230219171904249\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j +=<span class=\"hljs-number\">4</span>)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵j-j+3列</span><br>        c[i][j + <span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i][j + <span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i][j + <span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i][j + <span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>            <span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>           C[i][j + <span class=\"hljs-number\">0</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">0</span>];    <br>           C[i][j + <span class=\"hljs-number\">1</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">1</span>];<br>           C[i][j + <span class=\"hljs-number\">2</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">2</span>];<br>           C[i][j + <span class=\"hljs-number\">3</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>最内侧计算使用的矩阵<strong>A</strong>的元素是一致的。因此可以将**A[i][p]**读取到寄存器中，从而实现4次数据复用。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> temp = A[i][p];<br></code></pre></div></td></tr></table></figure>\n\n<p>一般将最内侧循环称作计算核(micro kernel)</p>\n<p>类似地，我们可以继续拆分输出<strong>M</strong>维度，从而在内测循环中计算 <strong>4 × 4</strong> 输出，如图五。</p>\n<p><img src=\"/2023/02/19/Matrix002/image-20230219174355047.png\" alt=\"image-20230219174355047\"></p>\n<p>同样的，将计算核心展开，可以得到下面的伪代码。这里我们将 <strong>1 × 4</strong> 中展示过的N维度的计算简化表示。这种拆分可看成是<strong>4 × 1 × 4</strong>，这样A和B的访存均可复用四次。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i-i+3行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j +=<span class=\"hljs-number\">4</span>)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵第j-j+3列</span><br>        c[i + <span class=\"hljs-number\">0</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">1</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">2</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>            <span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>           C[i + <span class=\"hljs-number\">0</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];    <br>           C[i + <span class=\"hljs-number\">1</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">1</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">2</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">2</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">3</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>到目前为止。我们都是在输出的两个维度上展开，而整个计算还包含一个规约(Reduction)维度K。图六展示了在计算<strong>4 × 4</strong>输出时，将维度K拆分，从而每次最内侧循环计算出输出矩阵C的<strong>4&#x2F;K</strong>的部分和。</p>\n<p><img src=\"/2023/02/19/Matrix002/image-20230219180147184.png\" alt=\"image-20230219180147184\"></p>\n<p>下面展示的是这部分计算的展开伪代码，其中维度M和N已经被简写。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i-i+3行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j +=<span class=\"hljs-number\">4</span>)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵第j-j+3列</span><br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p+=<span class=\"hljs-number\">4</span>)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">0</span>] * B[p + <span class=\"hljs-number\">0</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];    <br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">1</span>] * B[p + <span class=\"hljs-number\">1</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">2</span>] * B[p + <span class=\"hljs-number\">2</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">3</span>] * B[p + <span class=\"hljs-number\">3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在对M和N展开式，我们可以分别复用B和A的数据；在对K展开时，其局部使用的C的内存是一致的，那么K迭代时可以将部分和累加在寄存器中——最内层循环整个迭代一次写到C的内存中。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://zhenhuaw.me/blog/2019/gemm-optimization.html\">通用矩阵乘（GEMM）优化算法 | 黎明灰烬 博客 (zhenhuaw.me)</a></p>\n",
            "tags": [
                "Matrix",
                "GEMM"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/18/leetcode11/",
            "url": "https://xingyuanjie.top/2023/02/18/leetcode11/",
            "title": "11. 盛最多水的容器",
            "date_published": "2023-02-18T08:27:01.000Z",
            "content_html": "<h2 id=\"11-盛最多水的容器\"><a href=\"#11-盛最多水的容器\" class=\"headerlink\" title=\"11.盛最多水的容器\"></a>11.盛最多水的容器</h2><h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><h4 id=\"11-盛最多水的容器-1\"><a href=\"#11-盛最多水的容器-1\" class=\"headerlink\" title=\"11. 盛最多水的容器\"></a><a href=\"https://leetcode.cn/problems/container-with-most-water/\">11. 盛最多水的容器</a></h4><h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">maxArea</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class=\"hljs-comment\">//双指针；</span><br>        <span class=\"hljs-keyword\">int</span> ans =<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> right=height.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">while</span>(left&lt;right)&#123;<br>            <span class=\"hljs-keyword\">int</span> temp=<span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">if</span>(height[left]&lt;=height[right])&#123;<br>                temp = height[left]*(right-left);<br>                ans = std::<span class=\"hljs-built_in\">max</span>(ans,temp);<br>                left++;<br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                temp = height[right]*(right-left);<br>                ans = std::<span class=\"hljs-built_in\">max</span>(ans,temp);<br>                right--;<br>            &#125;<br>            <br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> ans;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://leetcode.cn/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/\">盛最多水的容器 - 盛最多水的容器 - 力扣（LeetCode）</a></p>\n",
            "tags": [
                "C++",
                "LeetCode",
                "双指针"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/17/leetcode001/",
            "url": "https://xingyuanjie.top/2023/02/17/leetcode001/",
            "title": "146.LRU cache",
            "date_published": "2023-02-17T06:31:45.000Z",
            "content_html": "<h2 id=\"146-LRU-cache\"><a href=\"#146-LRU-cache\" class=\"headerlink\" title=\"146.LRU cache\"></a>146.LRU cache</h2><h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"https://leetcode.cn/problems/lru-cache/\">146. LRU 缓存 - 力扣（LeetCode）</a></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LRUCache</span> &#123;</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">int</span> cap=<span class=\"hljs-number\">0</span>;<br>    list&lt;pair&lt;<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-keyword\">int</span>&gt;&gt; lru;   <span class=\"hljs-comment\">//真正的cache</span><br>    unordered_map&lt;<span class=\"hljs-keyword\">int</span>,list&lt;pair&lt;<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-keyword\">int</span>&gt;&gt;::iterator&gt; mp;   <span class=\"hljs-comment\">//主要用处就是查找</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LRUCache</span>(<span class=\"hljs-keyword\">int</span> capacity) &#123;<br>        cap = capacity;\t\t\t\t\t\t<span class=\"hljs-comment\">//容量</span><br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> key)</span> </span>&#123;\t\t\t\t\t\t<span class=\"hljs-comment\">//作为就是把最近访问的放在表头</span><br>        <span class=\"hljs-keyword\">if</span>(mp.<span class=\"hljs-built_in\">find</span>(key)!=mp.<span class=\"hljs-built_in\">end</span>())&#123;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//有这个元素</span><br>            lru.<span class=\"hljs-built_in\">splice</span>(lru.<span class=\"hljs-built_in\">begin</span>(),lru,mp[key]);\t\t\t<span class=\"hljs-comment\">//将一个 list 容器中的元素插入到另一个容器的指定位置</span><br>            <span class=\"hljs-keyword\">return</span> lru.<span class=\"hljs-built_in\">begin</span>()-&gt;second;\t\t\t\t<span class=\"hljs-comment\">//返回元素</span><br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//没有这个元素</span><br>        &#125;<br>    &#125;<br><br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> key, <span class=\"hljs-keyword\">int</span> value)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">get</span>(key)!=<span class=\"hljs-number\">-1</span>)&#123;\t\t\t\t<span class=\"hljs-comment\">//cache中有key，调用get后自动插入到表头【key存在】</span><br>            lru.<span class=\"hljs-built_in\">begin</span>()-&gt;second = value;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;\t\t\t<span class=\"hljs-comment\">//【key不存在】</span><br>            <span class=\"hljs-keyword\">if</span>(lru.<span class=\"hljs-built_in\">size</span>()==cap)&#123;\t\t\t<span class=\"hljs-comment\">//如果容量满了</span><br>                <span class=\"hljs-keyword\">int</span> delkey = lru.<span class=\"hljs-built_in\">back</span>().first;\t\t <span class=\"hljs-comment\">//记录最久未访问的key</span><br>                lru.<span class=\"hljs-built_in\">pop_back</span>();\t\t\t\t\t\t <span class=\"hljs-comment\">//pop掉，置换</span><br>                mp.<span class=\"hljs-built_in\">erase</span>(delkey);\t\t\t\t\t <span class=\"hljs-comment\">//查找表中也删除\t</span><br>            &#125;<br>            lru.<span class=\"hljs-built_in\">emplace_front</span>(key,value);\t\t\t<span class=\"hljs-comment\">//头部生成一个元素</span><br>            mp[key]=lru.<span class=\"hljs-built_in\">begin</span>();\t\t\t\t\t<span class=\"hljs-comment\">//加入查找表</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Your LRUCache object will be instantiated and called as such:</span><br><span class=\"hljs-comment\"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class=\"hljs-comment\"> * int param_1 = obj-&gt;get(key);</span><br><span class=\"hljs-comment\"> * obj-&gt;put(key,value);</span><br><span class=\"hljs-comment\"> */</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.jianshu.com/p/bbea4b2410e6\">C++实现LRU缓存——LeetCode146 - 简书 (jianshu.com)</a></p>\n",
            "tags": [
                "C++",
                "LeetCode"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/15/blislab003/",
            "url": "https://xingyuanjie.top/2023/02/15/blislab003/",
            "title": "BLISlab中C矩阵初始化速度测试",
            "date_published": "2023-02-15T03:48:16.000Z",
            "content_html": "<h2 id=\"BLISlab中C矩阵初始化速度测试\"><a href=\"#BLISlab中C矩阵初始化速度测试\" class=\"headerlink\" title=\"BLISlab中C矩阵初始化速度测试\"></a>BLISlab中C矩阵初始化速度测试</h2><p><strong>假设我们想把C中的所有元素都设为0。</strong></p>\n<p><strong>统一编译命令：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">g++  xxx.cpp -O0 -std=c++11 -o xxx<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本一：\"><a href=\"#版本一：\" class=\"headerlink\" title=\"版本一：\"></a>版本一：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\t\t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>    \t\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123; <br>        \t\t<span class=\"hljs-built_in\">C</span>(i,j) = <span class=\"hljs-number\">0.0</span>;<br>   \t\t \t&#125;<br>\t\t&#125;<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：\"><a href=\"#实测结果：\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">10776901341</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">10776901</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">10776</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">10</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本二：\"><a href=\"#版本二：\" class=\"headerlink\" title=\"版本二：\"></a>版本二：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\t<span class=\"hljs-keyword\">double</span> *cp;<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    \tcp = &amp;C[ j*ldc ];\t\t\t<span class=\"hljs-comment\">//point cp to top of ith column</span><br>    \t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>        \t*cp++ = <span class=\"hljs-number\">0.0</span>;\t\t<span class=\"hljs-comment\">//set element that cp points to to zero and</span><br>    \t&#125;\t\t<span class=\"hljs-comment\">//advance the pointer</span><br>\t&#125;<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：-1\"><a href=\"#实测结果：-1\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">3455968000</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">3455968</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">3455</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">3</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本三：\"><a href=\"#版本三：\" class=\"headerlink\" title=\"版本三：\"></a>版本三：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\t<span class=\"hljs-keyword\">double</span> *cp;<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    \tcp = &amp;C[ j * ldc ];<br>    \t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>       \t\t*(cp+<span class=\"hljs-number\">0</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \t*(cp+<span class=\"hljs-number\">1</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \t*(cp+<span class=\"hljs-number\">2</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \t*(cp+<span class=\"hljs-number\">3</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \tcp+=<span class=\"hljs-number\">4</span>;<br>   \t\t&#125;<br>\t&#125;\t<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：-2\"><a href=\"#实测结果：-2\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">2581347801</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">2581347</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">2581</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">2</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本四：\"><a href=\"#版本四：\" class=\"headerlink\" title=\"版本四：\"></a>版本四：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\t<span class=\"hljs-keyword\">double</span> *cp;<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>    <span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> c0 =<span class=\"hljs-number\">0.0</span>,c1=<span class=\"hljs-number\">0.0</span>,c2=<span class=\"hljs-number\">0.0</span>,c3=<span class=\"hljs-number\">0.0</span>;<br>\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    \tcp = &amp;C[ j * ldc ];<br>    \t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>        \t*(cp+<span class=\"hljs-number\">0</span>) = c0;<br>        \t*(cp+<span class=\"hljs-number\">1</span>) = c1;<br>        \t*(cp+<span class=\"hljs-number\">2</span>) = c2;<br>        \t*(cp+<span class=\"hljs-number\">3</span>) = c3;<br>        \tcp+=<span class=\"hljs-number\">4</span>;<br>   \t\t &#125;<br>\t&#125;<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：-3\"><a href=\"#实测结果：-3\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">2269606428</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">2269606</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">2269</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">2</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://gukaifeng.cn/posts/c-11-chrono-gao-jing-du-ji-shi-fang-fa/\">C++11 chrono 高精度计时方法 | GuKaifeng’s Blog</a></p>\n",
            "tags": [
                "Linux",
                "dgemm"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/12/blislib002/",
            "url": "https://xingyuanjie.top/2023/02/12/blislib002/",
            "title": "BLISlab tutoril阅读",
            "date_published": "2023-02-12T13:11:56.000Z",
            "content_html": "<h1 id=\"BLISlab-tutoril阅读\"><a href=\"#BLISlab-tutoril阅读\" class=\"headerlink\" title=\"BLISlab tutoril阅读\"></a>BLISlab tutoril阅读</h1><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><p><strong>Git地址：</strong><a href=\"https://github.com/flame/blislab\">https://github.com/flame/blislab</a> 【代码包包含tutoril.pdf】</p>\n<h2 id=\"BLISlab-A-Sandbox-for-Optimizing-GEMM\"><a href=\"#BLISlab-A-Sandbox-for-Optimizing-GEMM\" class=\"headerlink\" title=\"BLISlab: A Sandbox for Optimizing GEMM\"></a>BLISlab: A Sandbox for Optimizing GEMM</h2><h2 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h2><p>矩阵-矩阵乘法是科学计算中非常重要的基本运算，机器学习也越来越重要。这是一个非常简单的概念，可以在典型的高中代数课程中引入，但在实践中又非常重要，它在计算机上的实现仍然是一个活跃的研究主题。本笔记描述了一组使用该操作的练习，如何在具有分层内存(多个缓存)的现代cpu上获得高性能。它是基于blas类库实例化软件(BLIS)框架下的见解，通过公开一个模仿BLIS实现的简化“沙盒”来实现的。因此，它也成为BLIS优化的“众包”工具。</p>\n<h2 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1.Introduction\"></a>1.Introduction</h2><p>矩阵-矩阵乘法(Gemm)经常被用作一个简单的例子，以提高如何在现代处理器上优化代码的意识。原因是该操作描述简单，很难完全优化，而且具有实际意义。在本文档中，我们将带领读者了解目前CPU架构中最快实现的技术。</p>\n<h3 id=\"1-1-Basic-Linear-Algebra-Subprograms-BLAS\"><a href=\"#1-1-Basic-Linear-Algebra-Subprograms-BLAS\" class=\"headerlink\" title=\"1.1 Basic Linear Algebra Subprograms (BLAS)\"></a>1.1 Basic Linear Algebra Subprograms (BLAS)</h3><p>基本线性代数子程序(BLAS)[10,5,4,14]为一组线性代数操作形成了一个接口，在此基础上构建了更高级别的线性代数库，如LAPACK[2]和libflame[19]。其思想是，如果有人针对给定的体系结构优化BLAS，那么所有以调用BLAS的方式编写的应用程序和库都将受益于这种优化。</p>\n<p>BLAS被分为三组:一级BLAS(矢量-矢量操作)、二级BLAS(矩阵-矢量操作)和三级BLAS(矩阵-矩阵操作)。最后一组得益于这样一个事实:如果所有矩阵操作数的大小都是n × n，则O(n3)浮点运算对O(n)个数据执行，因此在内存层(主存、缓存和寄存器)之间移动数据的成本可以在很多次计算中平摊。因此，如果仔细执行这些操作，原则上可以实现高性能。</p>\n<h3 id=\"1-2-Matrix-matrix-multiplication\"><a href=\"#1-2-Matrix-matrix-multiplication\" class=\"headerlink\" title=\"1.2 Matrix-matrix multiplication\"></a>1.2 Matrix-matrix multiplication</h3><p>特别地，BLAS通过(Fortran)调用支持具有双精度浮点数的Gemm:</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\">dgemm( transa, transb, m, n, k alpha, A,lda, B, ldb, beta, C, ldc)<br></code></pre></div></td></tr></table></figure>\n\n<p>通过适当地选择转置a和转置b来计算:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230212215656711.png\" alt=\"image-20230212215656711\"></p>\n<p>这里C是m × n, k是“第三维”。参数dla, dlb和dlc将在本文档后面进行解释。</p>\n<p>在我们的练习中，我们考虑Gemm的简化版本:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230212215836596.png\" alt=\"image-20230212215836596\"></p>\n<p>其中C是m × n, A是m × k, B是k × n。如果了解如何优化dgemm的这种特殊情况，那么可以很容易地将此知识扩展到所有3级BLAS功能。</p>\n<h3 id=\"1-3-High-performance-implementation\"><a href=\"#1-3-High-performance-implementation\" class=\"headerlink\" title=\"1.3 High-performance implementation\"></a>1.3 High-performance implementation</h3><p>高性能实现的复杂性使得BLAS(尤其是Gemm)的实现通常都是由默默无闻的专家来完成的，这些专家为硬件供应商开发数字库，例如IBM的ESSL、Intel的MKL、Cray的LibSci和AMD的ACML库。这些库通常是用汇编代码编写的(至少是部分)，并且针对特定的处理器高度专门化。</p>\n<p>一篇关键论文[1]展示了“算法和体系结构”方法如何携手设计ar体系结构、编译器和算法，使BLAS能够用高级语言(Fortan)为IBM Power体系结构编写，并解释了在这些处理器上实现高性能的复杂性。便携式高性能ANSI C (PHiPAC)[3]项目随后提供了用C编写高性能代码的指南，并建议如何自动生成和优化以这种方式编写的Gemm。Au tomatatically tuning Linear Algebra Software (ATLAS)[17,18]建立在这些见解的基础上，使BLAS库的自动调优和自动生成成为主流。</p>\n<p>在本文档的一部分中，我们讨论了有关该主题的最新论文，包括引入了实施Gemm[6]的Goto方法和该方法[16]的BLIS重构的论文，以及其他更直接相关的论文。</p>\n<h3 id=\"1-4-Other-similar-exercises\"><a href=\"#1-4-Other-similar-exercises\" class=\"headerlink\" title=\"1.4 Other similar exercises\"></a>1.4 Other similar exercises</h3><p>还有一些人基于Gemm组合了练习。与本文相关的最新成果有:乌尔姆大学Michael Lehn所作的“优化微内核:从纯C到SSE”，以及我们自己整理的关于“优化微内核”的维基。</p>\n<h3 id=\"1-5-We-need-you\"><a href=\"#1-5-We-need-you\" class=\"headerlink\" title=\"1.5 We need you!\"></a>1.5 We need you!</h3><p>本文的目的是指导您实现Gemm的高性能实现。我们的别有用心是，用于实现BLAS的BLIS框架需要针对各种cpu高度优化的所谓微内核。在教你基本技巧的过程中，我们希望找到“那个人”将贡献最好的微内核。就把它当做我们版的高性能计算机达人秀吧。虽然我们在描述中关注的是Intel Haswell架构的优化，但是设置可以很容易地修改，从而帮助您(和我们)优化其他cpu。事实上，BLIS本身支持的体系结构包括AMD和Intel的x86处理器，IBM的Power处理器，ARM处理器和德州仪器的DSP处理器[15,12,8]。</p>\n<h2 id=\"2-Step-1-The-Basics\"><a href=\"#2-Step-1-The-Basics\" class=\"headerlink\" title=\"2 Step 1: The Basics\"></a>2 Step 1: The Basics</h2><h3 id=\"2-1-Simple-matrix-matrix-multiplication\"><a href=\"#2-1-Simple-matrix-matrix-multiplication\" class=\"headerlink\" title=\"2.1 Simple matrix-matrix multiplication\"></a>2.1 Simple matrix-matrix multiplication</h3><p>在我们的讨论中，我们将考虑计算：</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213165803939.png\" alt=\"image-20230213165803939\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213165826084.png\" alt=\"image-20230213165826084\"></p>\n<p>其中，A、B、C分别为m × k、k × n、m × n矩阵。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213165920897.png\" alt=\"image-20230213165920897\"></p>\n<p>如果A、B和C存储在二维数组A、B和C中，下面的伪代码计算C:&#x3D;<br>AB + C:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213170125083.png\" alt=\"image-20230213170125083\"></p>\n<p>分别计算乘法和加法，计算需要2mnk个浮点运算(flop)。</p>\n<h3 id=\"2-2-Setup\"><a href=\"#2-2-Setup\" class=\"headerlink\" title=\"2.2 Setup\"></a>2.2 Setup</h3><p>为了让您高效地学习如何高效地进行计算，您可以在启动项目时准备好大部分基础设施。我们已经构造了子目录step1，有点像实现真正库might的项目。对于我们的目的来说，这可能是多余的，但是如何构建软件项目是一项值得学习的有用技能。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214173819349.png\" alt=\"image-20230214173819349\"></p>\n<p>考虑图4，它演示了子目录step1的目录结构:</p>\n<p><strong>README</strong>是一个描述目录内容以及如何编译和执行代码的文件。</p>\n<p><strong>source .sh</strong>配置环境变量的文件。在那个文件中</p>\n<p><strong>BLISLAB USE INTEL</strong>设置是否使用INTEL编译器(true)或GNU编译器(false)。</p>\n<p><strong>BLISLAB USE BLAS</strong>指示您的参考dgemm是否使用外部BLAS库实现(如果您的机器上安装了这样的BLAS库，则为true)，还是简单的三重循环实现(false)。</p>\n<p><strong>COMPILER OPT LEVEL</strong>设置GNU或Intel编译器的优化级别(O0, O1, O2, O3)。<br>(请注意，例如，O3由大写字母“O”和数字“3”组成。)</p>\n<p><strong>OMP NUM THREADS</strong> and <strong>BLISLAB IC NT</strong>设置用于并行版本的线程数<br>代码。对于第1步，将它们都设置为1。</p>\n<p><strong>dgemm</strong>是实现dgemm的例程存在的子目录。在其中</p>\n<p><strong>bl_dgemm_ref.c</strong>包含例程<strong>dgemm ref</strong>，它是dgemm的一个简单实现，如果<strong>BLISLAB_use_BLAS &#x3D; false</strong>，您将使用它来检查实现的正确性。</p>\n<p><strong>my_dgemm.c</strong>包含例程<strong>dgemm</strong>，它最初是dgemm的一个简单实现，您将优化它作为掌握如何优化gemm的第一步的一部分。</p>\n<p><strong>Bl_dgemm_util.c</strong>包含稍后会派上用场的实用程序例程</p>\n<p><strong>include</strong>这个目录包含包含各种宏定义和其他头信息的文件。</p>\n<p><strong>lib</strong>此目录将保存由您实现的源文件(libblislab. lib)生成的库。libblislab.a)您还可以在此目录中安装参考库(例如OpenBLAS)以比较性能。</p>\n<p><strong>test</strong> 这个目录包含“测试驱动程序”和各种实现的正确性&#x2F;性能检查脚本。</p>\n<p><strong>test_bl_demm .c</strong>包含测试例程bl_demm的“测试驱动程序”。</p>\n<p><strong>test_bl_dgemm.x</strong>是<strong>test_bl_dgemm.c</strong>的可执行文件。</p>\n<p><strong>Run_bl_dgemm.sh</strong>包含一个bash脚本，用于收集性能结果。</p>\n<p><strong>tacc_run_bl_dgemm.sh</strong> contains a <strong>SLURM</strong> script for you to (optionally) submit the job to the Texas Advanced Computing Center (TACC) machines if you have an account there.</p>\n<h3 id=\"2-3-Getting-started\"><a href=\"#2-3-Getting-started\" class=\"headerlink\" title=\"2.3 Getting started\"></a>2.3 Getting started</h3><p>我们希望您从my_dgemm.c中的实现开始，并通过应用各种标准优化技术对其进行优化。该文件中的初始实现是具有图2中给出的三个循环的简单实现。首先要注意的是二维数组如何以所谓的列-主序映射到内存。这种选择的原因是最初的BLAS假定数组的列主存储，因为该接口首先是为Fortran用户提供的。检查</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214185803699.png\" alt=\"image-20230214185803699\"></p>\n<p>我们注意到，每个操作数都是一个宏。考虑文件的早期</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214185849594.png\" alt=\"image-20230214185849594\"></p>\n<p>地址C处的线性数组用于存储元素Ci,j，因此i,j元素被映射到位置j * ldc + i。查看它的方法是C的每一列都是连续存储的。但是，可以把矩阵C看作是嵌入在一个更大的数组中，该数组有ldc行，因此访问一行就意味着跨ldc遍历数组C。二维数组C的前维数通常是指这个较大数组的行维数，因此变量ldc (C的前维数)。下图说明了这三个矩阵:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214190409172.png\" alt=\"image-20230214190409172\"></p>\n<p>其中箭头表示列是连续存储的。</p>\n<h4 id=\"2-3-1-Configure-the-default-implementation\"><a href=\"#2-3-1-Configure-the-default-implementation\" class=\"headerlink\" title=\"2.3.1 Configure the default implementation\"></a>2.3.1 Configure the default implementation</h4><p>默认情况下，练习编译并链接到Intel的icc编译器，该编译器将对代码应用编译器优化(O3级)。您需要通过以下命令设置环境变量:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">source sourceme.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在终端中，您将看到输出:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL = TRUE<br>COMPILER_OPT_LEVEL = O3<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-3-2-Compile-execute-and-collect-results\"><a href=\"#2-3-2-Compile-execute-and-collect-results\" class=\"headerlink\" title=\"2.3.2 Compile, execute and collect results\"></a>2.3.2 Compile, execute and collect results</h4><p>如果您无法访问Intel的编译器(icc)，请阅读第2.3.2小节和2.3.3小节，并继续阅读第2.3.5小节。</p>\n<p>您可以编译、执行代码并通过执行收集性能结果</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">make clean<br>make<br>cd test<br>./run_bl_dgemm.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在子目录step1中。您将看到性能结果输出:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214231134260.png\" alt=\"image-20230214231134260\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214231142311.png\" alt=\"image-20230214231142311\"></p>\n<p>您可以在run_bl_dgemm.sh中更改采样块大小。请注意，如果代码中有错误，这些错误将被报告为，例如，</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214231406465.png\" alt=\"image-20230214231406465\"></p>\n<h4 id=\"2-3-3-Draw-the-performance-graph\"><a href=\"#2-3-3-Draw-the-performance-graph\" class=\"headerlink\" title=\"2.3.3 Draw the performance graph\"></a>2.3.3 Draw the performance graph</h4><p>最后，您可以使用<strong>MATLAB</strong>用我们的脚本绘制性能图。在<strong>test</strong>子目录下，执行后</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">./collect_result_step1<br></code></pre></div></td></tr></table></figure>\n\n<p>你会得到一个MATLAB文件“step1_result.m”，具有性能结果。然后你可以执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">bl_dgemm_plot.m<br></code></pre></div></td></tr></table></figure>\n\n<p>在MATLAB中，然后生成性能图。</p>\n<h4 id=\"2-3-4-Change-to-the-GNU-compiler\"><a href=\"#2-3-4-Change-to-the-GNU-compiler\" class=\"headerlink\" title=\"2.3.4 Change to the GNU compiler\"></a>2.3.4 Change to the GNU compiler</h4><p>由于我们希望您明确地了解什么样的技巧可以带来高性能，并且由于有些人可能无法访问Intel编译器，因此接下来应该改为使用GNU C编译器。为此，你必须编辑<strong>sourceme.sh</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL=false<br></code></pre></div></td></tr></table></figure>\n\n<p>然后，类似于默认设置，您需要通过执行以下命令来设置环境变量:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">source sourceme.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在终端，你会观察到:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL = false<br>COMILER_OPT_LEVEL = O3<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-3-5-Turn-off-optimization\"><a href=\"#2-3-5-Turn-off-optimization\" class=\"headerlink\" title=\"2.3.5 Turn off optimization\"></a>2.3.5 Turn off optimization</h4><p>接下来，我们希望您关闭编译器执行的优化。这有三个目的:首先，这意味着您将必须显式地执行优化，这将允许您了解架构和算法如何交互。其次，优化编译器很可能会试图“撤销”您显式试图完成的任务。第三，在代码中构建的技巧越多，编译器就越难找出优化的方法。</p>\n<p>你需要先编辑<strong>sourceme.sh:</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">COMILER_OPT_LEVEL = O0<br></code></pre></div></td></tr></table></figure>\n\n<p>然后，类似于默认设置，您需要通过执行以下命令来设置环境变量:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">source sourceme.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在终端中，您将看到输出:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL = false<br>COMILER_OPT_LEVEL =O0<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-3-6-Optional-Use-optimized-BLAS-library-as-reference-implementation\"><a href=\"#2-3-6-Optional-Use-optimized-BLAS-library-as-reference-implementation\" class=\"headerlink\" title=\"2.3.6 (Optional) Use optimized BLAS library as reference implementation\"></a>2.3.6 (Optional) Use optimized BLAS library as reference implementation</h4><p>默认情况下，您的参考Gemm实现是一个非常缓慢的三循环实现。如果你在测试机器上安装了BLAS库，你可以通过设置该库中的dgemm作为你的参考实现:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_BLAS=true<br></code></pre></div></td></tr></table></figure>\n\n<p>在sourceme.sh。如果使用Intel编译器，则不需要显式指定MKL的路径。但是，如果使用GNU编译器，则需要指定BLAS库的路径。例如，您可能希望从<a href=\"https://github.com/flame/blis%E5%AE%89%E8%A3%85%E6%88%91%E4%BB%AC%E7%9A%84BLIS%E5%BA%93%E5%88%B0/home/lib/blis%E7%9B%AE%E5%BD%95%E5%90%8C%E6%97%B6%E5%9C%A8sourceme\">https://github.com/flame/blis安装我们的BLIS库到/home/lib/blis目录同时在sourceme</a> .sh中设置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLAS_DIR=/home/lib/blis<br></code></pre></div></td></tr></table></figure>\n\n<p>执行**$ source sourceme .sh**后，你会看到:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_BLAS = true<br>BLAS_DIR = /home/lib/blis<br></code></pre></div></td></tr></table></figure>\n\n<p>现在，您的实现的性能和准确性将与这个优化的库例程进行比较。</p>\n<h3 id=\"2-4-Basic-techniques\"><a href=\"#2-4-Basic-techniques\" class=\"headerlink\" title=\"2.4 Basic techniques\"></a>2.4 Basic techniques</h3><p>在本小节中，我们将介绍一些基本的交易技巧。</p>\n<h4 id=\"2-4-1-Using-pointers\"><a href=\"#2-4-1-Using-pointers\" class=\"headerlink\" title=\"2.4.1 Using pointers\"></a>2.4.1 Using pointers</h4><p>既然优化被关闭了，那么矩阵元素所在地址的计算将显式地公开。(优化编译器可以消除这种开销。)您要做的是更改my_gemm.c中的实现，以便它使用指针。在这样做之前，您可能需要备份原始的my_gemm.c，以防需要从头开始重新启动。实际上，在每个步骤中，您可能都希望在单独的文件中备份前面的实现</p>\n<p>这是基本的想法。假设我们想把C中的所有元素都设为0。一个基本的循环，按照在my_gemm.c中找到的内容来设计</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>        <span class=\"hljs-built_in\">C</span>(i,j) =<span class=\"hljs-number\">0.0</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>Using pointers, we might implement this as</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> *cp;<br><span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j*ldc ];\t\t\t<span class=\"hljs-comment\">//point cp to top of ith column</span><br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>        *cp++ = <span class=\"hljs-number\">0.0</span>;\t\t<span class=\"hljs-comment\">//set element that cp points to to zero and</span><br>    &#125;\t\t<span class=\"hljs-comment\">//advance the pointer</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>注意，我们有意地交换了循环的顺序，以便向前移动指针将我们带到C的列中。</p>\n<h4 id=\"2-4-2-Loop-unrolling\"><a href=\"#2-4-2-Loop-unrolling\" class=\"headerlink\" title=\"2.4.2 Loop unrolling\"></a>2.4.2 Loop unrolling</h4><p>每次通过内部循环更新循环索引i和指针cp都会产生相当大的开销。</p>\n<p>因此，编译器将执行循环展开。使用展开因子4，我们将C设置为0的简单循环变成</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> *cp;<br><br><span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j * ldc ];<br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>        *(cp+<span class=\"hljs-number\">0</span>) = <span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">1</span>) = <span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">2</span>) = <span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">3</span>) = <span class=\"hljs-number\">0.0</span>;<br>        cp+=<span class=\"hljs-number\">4</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>重要的</p>\n<ul>\n<li>i和cp现在每四次迭代才更新一次。</li>\n<li><em>(cp+0)使用称为间接寻址的机器指令，这比使用</em>(cp+k)计算更有效，其中k是变量。</li>\n<li>当它从内存中输入数据到缓存中时，每次输入一条64字节的缓存线。这意味着以64字节的块访问连续数据可以减少内存层之间的内存移动成本。</li>\n</ul>\n<p>请注意，在展开时，如果m不是4的倍数，则可能必须处理“边缘”。</p>\n<p>为了这个练习，你不需要担心这个边缘，只要你明智地选择你的采样块大小，就像第2.5节重申的那样。</p>\n<h4 id=\"2-4-3-Register-variables\"><a href=\"#2-4-3-Register-variables\" class=\"headerlink\" title=\"2.4.3 Register variables\"></a>2.4.3 Register variables</h4><p>注意，只有当数据存储在寄存器中时，计算才会发生。编译器将自动转换代码，以便插入将某些数据放入寄存器的中间步骤。可以给编译器一个提示，将某些数据保存在寄存器中是很好的，如下面的例子所示:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> *cp;<br><br><span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j * ldc ];<br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>        <span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> c0 =<span class=\"hljs-number\">0.0</span>,c1=<span class=\"hljs-number\">0.0</span>,c2=<span class=\"hljs-number\">0.0</span>,c3=<span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">0</span>) = c0;<br>        *(cp+<span class=\"hljs-number\">1</span>) = c1;<br>        *(cp+<span class=\"hljs-number\">2</span>) = c2;<br>        *(cp+<span class=\"hljs-number\">3</span>) = c3;<br>        cp+=<span class=\"hljs-number\">4</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-5-A-modest-first-goal\"><a href=\"#2-5-A-modest-first-goal\" class=\"headerlink\" title=\"2.5 A modest first goal\"></a>2.5 A modest first goal</h4><p>现在我们要求您使用上面讨论的技术来优化my_dgemm.c。现在，只需要考虑如何为较小的矩阵获得更好的性能。具体来说，请看下面这张图:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230215110352304.png\" alt=\"image-20230215110352304\"></p>\n<p>我们想让你做的是编写你的代码，使C的mR × nR块保存在寄存器中。你可以选择mR和nR，但是你需要用这些选项更新文件<strong>include&#x2F;bl_config.h</strong>。这确保了测试驱动程序只尝试这些块大小的倍数的问题大小，所以您不必担心“边缘”。</p>\n<p>您将注意到，即使对于可以放入某个缓存内存中的较小的矩阵，您的实现(比您可能已安装的MKL或其他优化的BLAS库的实现差得多)。原因是编译器没有为浮点运算使用最快的指令。可以通过使用向量intrinsic funtions函数(允许您从C显式地利用它们)或通过在汇编代码中编码来访问这些函数。现在，我们还没到那一步。我们将<br>在步骤3中讨论更多。</p>\n<h2 id=\"3-Step-2-Blocking\"><a href=\"#3-Step-2-Blocking\" class=\"headerlink\" title=\"3 Step 2: Blocking\"></a>3 Step 2: Blocking</h2><h3 id=\"3-1-Poorman’s-BLAS\"><a href=\"#3-1-Poorman’s-BLAS\" class=\"headerlink\" title=\"3.1 Poorman’s BLAS\"></a>3.1 Poorman’s BLAS</h3><p>本练习的第1步使您认识到，随着基于缓存的体系结构的出现，Gemm的高性能实现需要仔细注意数据在内存层之间移动的成本和对该数据的计算的摊薄。为了保持这种可管理性，认识到只有使用相对较小的矩阵执行矩阵-矩阵乘法的“内核”需要高度优化，这是有帮助的，因为使用较大的矩阵的计算可以被分块，然后使用这样的内核而不会对整体性能产生不利影响。这一见解在[9]中得到了明确的提倡。</p>\n<p>这有时被称为“穷人的BLAS”，因为如果一个人只能负担得起优化矩阵-矩阵乘法(使用子矩阵)，那么就可以构建Gemm，以及其他重要的矩阵-矩阵运算，即三级BLAS。我们稍后将看到的是，从模块化和性能的角度来看，这实际上是一个好主意。</p>\n<p>在上一节中，您已经看到了分块的示例。</p>\n<h3 id=\"3-2-Blocked-matrix-matrix-multiplication\"><a href=\"#3-2-Blocked-matrix-matrix-multiplication\" class=\"headerlink\" title=\"3.2 Blocked matrix-matrix multiplication\"></a>3.2 Blocked matrix-matrix multiplication</h3><p>分块Gemm以利用处理器的分层内存的关键是理解当这些矩阵被分块时如何计算C:&#x3D; AB + C。分块</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216130352894.png\" alt=\"image-20230216130352894\"></p>\n<h3 id=\"3-3-Your-mission-if-you-choose-to-accept-it\"><a href=\"#3-3-Your-mission-if-you-choose-to-accept-it\" class=\"headerlink\" title=\"3.3 Your mission, if you choose to accept it\"></a>3.3 Your mission, if you choose to accept it</h3><p>我们现在要求您在my_dgemm中实现分块矩阵-矩阵乘法。具体来说，对于小矩阵，您可以获得比大矩阵更好的性能，因为小矩阵适合缓存。将矩阵划分为能够获得更高性能的子矩阵，您将看到，即使对于更大的矩阵，所得到的实现也能保持更好的性能</p>\n<h2 id=\"4-Step-3-Blocking-for-Multiple-Levels-of-Cache\"><a href=\"#4-Step-3-Blocking-for-Multiple-Levels-of-Cache\" class=\"headerlink\" title=\"4 Step 3: Blocking for Multiple Levels of Cache\"></a>4 Step 3: Blocking for Multiple Levels of Cache</h2><h3 id=\"4-1-The-Goto-Approach-to-Implementing-gemm\"><a href=\"#4-1-The-Goto-Approach-to-Implementing-gemm\" class=\"headerlink\" title=\"4.1 The Goto Approach to Implementing gemm\"></a>4.1 The Goto Approach to Implementing gemm</h3><p>2000年左右，Kazushige Goto用他的技术彻底改变了Gemm在当前cpu上的实现方式，该技术首次发表在论文[6]上。</p>\n<p>最近在[16]中描述了这种方法的进一步“重构”。</p>\n<p>BLIS框架的优点是它将必须高度优化的内核(可能使用向量intrinsic或在汇编代码中)减少为微内核。在本节中，我们将简要描述该方法的重点。然而，我们强烈建议读者熟悉以上两篇论文本身。</p>\n<p>图3(左)说明了Goto方法为三层缓存(L1、L2和L3)构建分块的方式。在BLIS框架中，实现就是这样结构的，因此只有底层的微内核需要针对给定的体系结构进行高度优化和定制。在最初的GotoBLAS实现(现在维护为OpenBLAS[11])中，从围绕微内核的第二个循环开始的操作是定制的。为了获得最佳性能，所有数据都是连续访问的，这就是为什么在到达微内核之前的某个时刻，数据是按照箭头所示的顺序打包的:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216131649371.png\" alt=\"image-20230216131649371\"></p>\n<p>现在，注意上图中A块的每一列都乘以B块对应行中的每个元素(我们称这些A块和B块为微面板)。这意味着L2缓存的延迟(从缓存中引入A微面板元素所需的时间)可以平摊到2nR flop上。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216131916807.png\" alt=\"image-20230216131916807\"></p>\n<p>出于这个原因，我们可以组织计算，使A的微面板通常驻留在L2缓存中。实际上，我们可以做得更好:当A和B的微面板的一列发生排名1的更新时，A的微面板的下一列可以被带入寄存器，这样计算就可以掩盖数据移动的成本。事实上，我们希望将B的微面板保留在L1缓存中(因为它将被A的许多微面板重用)，这限制了分块参数kC。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216132839380.png\" alt=\"image-20230216132839380\"></p>\n<p>有人可能会问，上述方案是否是最优方案。在[7]中给出了一个理论，表明在一个理想化的模型下，上述是局部最优的(在某种意义上，假设数据在层次结构中的某个内存层中，在该级别上提出的阻塞最优地与下一个内存层平摊数据移动的成本)。[13]给出了指导各种分块参数选择的理论。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216133142749.png\" alt=\"image-20230216133142749\"></p>\n<h3 id=\"4-2-Setup\"><a href=\"#4-2-Setup\" class=\"headerlink\" title=\"4.2 Setup\"></a>4.2 Setup</h3><p>图4说明了子目录step3的目录结构。与步骤1相比，我们对以下目录&#x2F;文件进行了修改&#x2F;添加:</p>\n<p><strong>kernels</strong> 这个目录包含各种架构的微内核实现</p>\n<p><strong>bd_gemm_ukr.c</strong>给出了一个原生的C实现</p>\n<p><strong>bl_dgemm_int_kernel.c</strong> gives an <strong>AVX&#x2F;AVX2</strong> intrinsics micro-kernel implementation for Haswell architecture.</p>\n<p><strong>bl_dgemm_asm_kernel.c</strong> gives an <strong>AVX&#x2F;AVX2</strong> assembly micro-kernel implementation for Haswell architecture.</p>\n<h3 id=\"4-3-Advanced-techniques\"><a href=\"#4-3-Advanced-techniques\" class=\"headerlink\" title=\"4.3 Advanced techniques\"></a>4.3 Advanced techniques</h3><p>You can find the vector instructions online:</p>\n<p><strong>Intel Intrinsics Guide</strong></p>\n<p><strong>Intel ISA Extensions</strong></p>\n<h4 id=\"4-3-1-An-introduction-example-for-“axpy”\"><a href=\"#4-3-1-An-introduction-example-for-“axpy”\" class=\"headerlink\" title=\"4.3.1 An introduction example for “axpy”\"></a>4.3.1 An introduction example for “axpy”</h4><p>我们提供了一个实现“axpy”的示例，以演示如何使用Intel AVX intrinsic和Assembly(在misc&#x2F;examples子目录中)。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216134020439.png\" alt=\"image-20230216134020439\"></p>\n<p>这个例子可以作为学习基本broacast&#x2F;fma&#x2F;load&#x2F;store指令的一个很好的起点。此外，这个示例实际上是4×4 rank-1更新的“broadcast”实现的原语。</p>\n<h4 id=\"4-3-2-4×4-rank-1-update\"><a href=\"#4-3-2-4×4-rank-1-update\" class=\"headerlink\" title=\"4.3.2 4×4 rank-1 update\"></a>4.3.2 4×4 rank-1 update</h4><p>微内核实现可以归结为4×4级别1的更新。有两种可能的实现:一种基于广播(图5)，另一种是蝴蝶排列(图6)。您还可以尝试其他可能的实现。</p>\n<h3 id=\"4-4-Your-mission-if-you-choose-to-accept-it\"><a href=\"#4-4-Your-mission-if-you-choose-to-accept-it\" class=\"headerlink\" title=\"4.4 Your mission, if you choose to accept it\"></a>4.4 Your mission, if you choose to accept it</h3><p>我们在my_dgemm中为您提供了简化BLIS框架的参考实现。代码的组织方式与图3所示相同。但是，每个循环中的步长并没有很好地选择，并且微内核实现是一个简单的C版本。因此。您不会期望代码具有高性能。我们要你做的就是:</p>\n<ul>\n<li>在include&#x2F;bl_config.h文件中指定分块参数mC, nC, kC和微内核大小参数mR, nR;</li>\n<li>使用矢量intrinsic或汇编代码实现高效的微内核。将代码放在kernels&#x2F;bl_dgemm_int_kernel.c(用于向量intrinsic)或kernels&#x2F;bl_dgemm_asm_kernel.c(用于as汇编)中。需要在“include&#x2F; BL_config.h”中修改“BL_MICRO_KERNEL”，指定微内核的函数名。</li>\n</ul>\n<p><img src=\"/2023/02/12/blislib002/image-20230216140558800.png\" alt=\"image-20230216140558800\"></p>\n<h2 id=\"5-Step-4-Parallelizing-with-OpenMP\"><a href=\"#5-Step-4-Parallelizing-with-OpenMP\" class=\"headerlink\" title=\"5 Step 4: Parallelizing with OpenMP\"></a>5 Step 4: Parallelizing with OpenMP</h2><p>BLIS构造GotoBLAS方法实现Gemm的好处是，它在tt C中公开了5个循环，这些循环可以很容易地与OpenMP指令并行。</p>\n<h3 id=\"5-1-To-parallelize-or-not-to-parallelize-that’s-the-question\"><a href=\"#5-1-To-parallelize-or-not-to-parallelize-that’s-the-question\" class=\"headerlink\" title=\"5.1 To parallelize or not to parallelize, that’s the question\"></a>5.1 To parallelize or not to parallelize, that’s the question</h3><p>最基本的问题是要并行化哪个循环。在[12]中详细讨论了每个循环的并行化的优点和缺点。对于多核体系结构(具有相对较少核的多线程体系结构)，可以在早期的论文[15]中找到结果。</p>\n<h2 id=\"6-Conclusion\"><a href=\"#6-Conclusion\" class=\"headerlink\" title=\"6 Conclusion\"></a>6 Conclusion</h2><p>我们使用GEMM作为案例研究来展示如何为性能进行编程</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216141029854.png\" alt=\"image-20230216141029854\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216141041389.png\" alt=\"image-20230216141041389\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216141057850.png\" alt=\"image-20230216141057850\"></p>\n",
            "tags": [
                "Linux",
                "dgemm"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/07/niuke003/",
            "url": "https://xingyuanjie.top/2023/02/07/niuke003/",
            "title": "JZ6 从尾到头打印链表",
            "date_published": "2023-02-07T10:21:41.000Z",
            "content_html": "<h2 id=\"JZ6-从尾到头打印链表\"><a href=\"#JZ6-从尾到头打印链表\" class=\"headerlink\" title=\"JZ6 从尾到头打印链表\"></a><strong>JZ6</strong> <strong>从尾到头打印链表</strong></h2><h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=265&tqId=39210&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=265&difficulty=undefined&judgeStatus=undefined&tags=&title=\">从尾到头打印链表_牛客题霸_牛客网 (nowcoder.com)</a></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">*  struct ListNode &#123;</span><br><span class=\"hljs-comment\">*        int val;</span><br><span class=\"hljs-comment\">*        struct ListNode *next;</span><br><span class=\"hljs-comment\">*        ListNode(int x) :</span><br><span class=\"hljs-comment\">*              val(x), next(NULL) &#123;</span><br><span class=\"hljs-comment\">*        &#125;</span><br><span class=\"hljs-comment\">*  &#125;;</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">printListFromTailToHead</span><span class=\"hljs-params\">(ListNode* head)</span> </span>&#123;<br>        vector&lt;<span class=\"hljs-keyword\">int</span>&gt; s;<br>        <span class=\"hljs-keyword\">while</span> (head!=<span class=\"hljs-literal\">NULL</span>) &#123;<br>            s.<span class=\"hljs-built_in\">insert</span>(s.<span class=\"hljs-built_in\">begin</span>(),head-&gt;val);\t\t\t\t<span class=\"hljs-comment\">//利用迭代器头插</span><br>            head=head-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> s;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure>\n\n",
            "tags": [
                "C++",
                "牛客"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/07/niuke002/",
            "url": "https://xingyuanjie.top/2023/02/07/niuke002/",
            "title": "JZ5 替换空格",
            "date_published": "2023-02-07T10:05:25.000Z",
            "content_html": "<h2 id=\"JZ5-替换空格\"><a href=\"#JZ5-替换空格\" class=\"headerlink\" title=\"JZ5 替换空格\"></a><strong>JZ5</strong> <strong>替换空格</strong></h2><h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=265&tqId=39209&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=undefined&judgeStatus=undefined&tags=&title=\">替换空格_牛客题霸_牛客网 (nowcoder.com)</a></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string&gt;</span></span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * </span><br><span class=\"hljs-comment\">     * @param s string字符串 </span><br><span class=\"hljs-comment\">     * @return string字符串</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">replaceSpace</span><span class=\"hljs-params\">(string s)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// write code here</span><br>        string str2 =<span class=\"hljs-string\">&quot;%20&quot;</span>;<br>        string str3;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;s.<span class=\"hljs-built_in\">size</span>(); i++) &#123;<br>            <span class=\"hljs-keyword\">if</span>(s[i]!=<span class=\"hljs-string\">&#x27; &#x27;</span>)\t\t\t\t\t<span class=\"hljs-comment\">//不是空格就插入到str3</span><br>                str3.<span class=\"hljs-built_in\">push_back</span>(s[i]);<br>            <span class=\"hljs-keyword\">else</span><br>                str3.<span class=\"hljs-built_in\">append</span>(str2);\t\t\t<span class=\"hljs-comment\">//如果是空格就把str2插入到str3</span><br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> str3;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n",
            "tags": [
                "C++",
                "牛客"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/07/niuke001/",
            "url": "https://xingyuanjie.top/2023/02/07/niuke001/",
            "title": "JZ3 数组中重复的数字",
            "date_published": "2023-02-07T08:58:01.000Z",
            "content_html": "<h2 id=\"JZ3-数组中重复的数字\"><a href=\"#JZ3-数组中重复的数字\" class=\"headerlink\" title=\"JZ3 数组中重复的数字\"></a>JZ3 数组中重复的数字</h2><h2 id=\"题目链接：\"><a href=\"#题目链接：\" class=\"headerlink\" title=\"题目链接：\"></a>题目链接：</h2><p><a href=\"https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=265&tqId=39207&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=undefined&judgeStatus=undefined&tags=&title=\">数组中重复的数字_牛客题霸_牛客网 (nowcoder.com)</a></p>\n<h2 id=\"完整解答：\"><a href=\"#完整解答：\" class=\"headerlink\" title=\"完整解答：\"></a>完整解答：</h2><p>set::count()是C++ STL中的内置函数，它返回元素在集合中出现的次数。由于set容器仅包含唯一元素，因此只能返回1或0。</p>\n<ul>\n<li>用法：set_name.count(element)</li>\n<li>参数：该函数接受一个强制性参数element，该元素指定要返回其计数的元素。</li>\n<li>返回值：该函数返回1或0，因为该集合仅包含唯一元素。如果设置的容器中存在该值，则返回1。如果容器中不存在它，则返回0。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * </span><br><span class=\"hljs-comment\">     * @param numbers int整型vector </span><br><span class=\"hljs-comment\">     * @return int整型</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">duplicate</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// write code here</span><br>        set&lt;<span class=\"hljs-keyword\">int</span>&gt; s;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;numbers.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(s.<span class=\"hljs-built_in\">count</span>(numbers[i])&gt;<span class=\"hljs-number\">0</span>) \t\t\t\t<span class=\"hljs-comment\">//此元素重复，则返回</span><br>                <span class=\"hljs-keyword\">return</span> numbers[i];<br>            <span class=\"hljs-keyword\">else</span><br>                s.<span class=\"hljs-built_in\">insert</span>(numbers[i]);\t\t\t\t<span class=\"hljs-comment\">//不重复则加入集合</span><br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><p><a href=\"https://blog.csdn.net/cmehppc/article/details/121712019\">(64条消息) 【c++】set.count()用法_杳杳捞到月亮了吗的博客-CSDN博客_c++set count</a></p>\n",
            "tags": [
                "C++",
                "牛客"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/06/matrix001/",
            "url": "https://xingyuanjie.top/2023/02/06/matrix001/",
            "title": "矩阵乘法最基础版本",
            "date_published": "2023-02-06T14:00:14.000Z",
            "content_html": "<h2 id=\"矩阵乘法最基础版本\"><a href=\"#矩阵乘法最基础版本\" class=\"headerlink\" title=\"矩阵乘法最基础版本\"></a>矩阵乘法最基础版本</h2><h3 id=\"数学原理示例\"><a href=\"#数学原理示例\" class=\"headerlink\" title=\"数学原理示例\"></a>数学原理示例</h3><p><img src=\"/2023/02/06/matrix001/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pYW5uaWFueGk=,size_16,color_FFFFFF,t_70.png\" alt=\"img\"></p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><p>用A的第i行分别和B的第j列的各个元素相乘求和，求得C的第i行j列的元素，这种算法中，B的访问是按列进行访问的，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//m是A矩阵的行,k是A矩阵的列,n是B矩阵的列</span><br><span class=\"hljs-keyword\">double</span> temp=<span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i行j列</span><br>        temp = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>            temp += A[i][p] * B[p][j];\t\t<span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>        &#125;<br>        C[i][j] = temp;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">//结果C矩阵m行n列</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/niannianxi/article/details/104028215\">(64条消息) C语言实现矩阵的乘法_꧁年年曦꧂的博客-CSDN博客_c语言矩阵乘法</a></p>\n<p><a href=\"https://www.jb51.net/article/75750.htm\">C语言科学计算入门之矩阵乘法的相关计算_C 语言_脚本之家 (jb51.net)</a></p>\n",
            "tags": [
                "Matrix",
                "GEMM"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/02/register/",
            "url": "https://xingyuanjie.top/2023/02/02/register/",
            "title": "register关键字",
            "date_published": "2023-02-02T11:57:01.000Z",
            "content_html": "<h2 id=\"register关键字\"><a href=\"#register关键字\" class=\"headerlink\" title=\"register关键字\"></a>register关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">int</span> val = <span class=\"hljs-number\">100</span>;<br>\t<span class=\"hljs-comment\">//寄存器变量没有地址，不能取地址</span><br>\tval = <span class=\"hljs-number\">200</span>; <span class=\"hljs-comment\">//可以被写入</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, val);<br>\t<span class=\"hljs-comment\">// 在gcc编译器下 也不允许取地址</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">//由于使用register关键字，直接将val存在寄存器内，因此val没有内存地址，因此不能进行取地址操作。</span><br></code></pre></div></td></tr></table></figure>\n\n<ol>\n<li>我们通常采用局部变量采用 register 的，全局变量会导致 CPU 当中的寄存器被长时间占用。</li>\n<li>一个变量被存放到寄存器当中，那么这个变量的效率就会大大的提高,因为不用访存读取</li>\n<li>register关键字可以与指针变量一起使用。</li>\n<li>寄存器是一个存储类，并且C不允许变量使用多个存储类说明符。因此，register不能与static一起使用。</li>\n<li>寄存器只能在一个块内使用（局部），而不能在全局范围内（在主外部）使用</li>\n<li>寄存器数量有限</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://xie.infoq.cn/article/f6093f4eebd3664c0a1514e26\">【C语言】register 关键字_11月月更_謓泽_InfoQ写作社区</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/263575137\">一步带您了解C语言中的“register”关键字 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.ab62.cn/article/5406.html\">C语言关键字之auto register详解_C 语言_AB教程网 (ab62.cn)</a></p>\n",
            "tags": [
                "C/C++",
                "register"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/02/blislab/",
            "url": "https://xingyuanjie.top/2023/02/02/blislab/",
            "title": "BLISlab dgemm优化",
            "date_published": "2023-02-02T06:38:00.000Z",
            "content_html": "<h1 id=\"BLISlab-dgemm优化\"><a href=\"#BLISlab-dgemm优化\" class=\"headerlink\" title=\"BLISlab dgemm优化\"></a>BLISlab dgemm优化</h1><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><p><strong>Git地址：</strong><a href=\"https://github.com/flame/blislab\">https://github.com/flame/blislab</a></p>\n<p><strong>视频教程：</strong><a href=\"https://www.bilibili.com/video/BV1c94y117Uw?vd_source=3ae32e36058f58c5b85935fca9b77797%E3%80%90%E6%BE%8E%E5%B3%B0%E7%A7%91%E6%8A%80-%E5%BC%A0%E5%85%88%E8%BD%B6%E8%80%81%E5%B8%88%E3%80%91\">https://www.bilibili.com/video/BV1c94y117Uw?vd_source=3ae32e36058f58c5b85935fca9b77797【澎峰科技-张先轶老师】</a></p>\n<p><strong>阅读</strong>：tutorial.pdf【位于代码包中】</p>\n<h2 id=\"Step0\"><a href=\"#Step0\" class=\"headerlink\" title=\"Step0\"></a>Step0</h2><h3 id=\"1-克隆项目到本地\"><a href=\"#1-克隆项目到本地\" class=\"headerlink\" title=\"1.克隆项目到本地\"></a>1.克隆项目到本地</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">git clone https://github.com/flame/blislab.git<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-代码结构\"><a href=\"#2-代码结构\" class=\"headerlink\" title=\"2.代码结构\"></a>2.代码结构</h3><p><img src=\"/2023/02/02/blislab/image-20230202155728203.png\" alt=\"image-20230202155728203\"></p>\n<h3 id=\"3-编译环境\"><a href=\"#3-编译环境\" class=\"headerlink\" title=\"3.编译环境\"></a>3.编译环境</h3><p><img src=\"/2023/02/02/blislab/image-20230202155820411.png\" alt=\"image-20230202155820411\"></p>\n<h3 id=\"4-运行环境配置脚本\"><a href=\"#4-运行环境配置脚本\" class=\"headerlink\" title=\"4.运行环境配置脚本\"></a>4.运行环境配置脚本</h3><p><img src=\"/2023/02/02/blislab/image-20230202160027957.png\" alt=\"image-20230202160027957\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 step0]# source ./sourceme.sh <br>BLISLAB_DIR = .<br>BLISLAB_USE_INTEL = false<br>BLISLAB_USE_BLAS = false<br>COMPILER_OPT_LEVEL = O3<br>BLAS_DIR = /u/jianyu/lib/openblas<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"5-Makefile\"><a href=\"#5-Makefile\" class=\"headerlink\" title=\"5.Makefile\"></a>5.Makefile</h3><p><img src=\"/2023/02/02/blislab/image-20230202160244490.png\" alt=\"image-20230202160244490\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 step0]# make<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/my_dgemm.c -o dgemm/my_dgemm.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/bl_dgemm_ref.c -o dgemm/bl_dgemm_ref.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/bl_dgemm_util.c -o dgemm/bl_dgemm_util.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>ar cr lib/libblislab.a dgemm/my_dgemm.o dgemm/bl_dgemm_ref.o dgemm/bl_dgemm_util.o    <br>ranlib lib/libblislab.a<br>gcc -O3 -march=core-avx2 -fPIC -shared -o lib/libblislab.so dgemm/my_dgemm.o dgemm/bl_dgemm_ref.o dgemm/bl_dgemm_util.o     ./lib/libblislab.a -lpthread -lm -lrt<br>cd ./test &amp;&amp; make &amp;&amp; cd . -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>make[1]: 进入目录“/root/blislab/step0/test”<br>gcc -O3 -march=core-avx2 -fPIC test_bl_dgemm.c -o test_bl_dgemm.x -I../include -I../kernels -I/u/jianyu/lib/openblas/include ../lib/libblislab.a -lpthread -lm -lrt<br>make[1]: 离开目录“/root/blislab/step0/test”<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"6-make-gnu-inc\"><a href=\"#6-make-gnu-inc\" class=\"headerlink\" title=\"6.make.gnu.inc\"></a>6.make.gnu.inc</h3><p><img src=\"/2023/02/02/blislab/image-20230202160608401.png\" alt=\"image-20230202160608401\"></p>\n<h3 id=\"7-ref参考实现是否调用BLAS\"><a href=\"#7-ref参考实现是否调用BLAS\" class=\"headerlink\" title=\"7.ref参考实现是否调用BLAS\"></a>7.ref参考实现是否调用BLAS</h3><p><img src=\"/2023/02/02/blislab/image-20230202160904158.png\" alt=\"image-20230202160904158\"></p>\n<h3 id=\"8-my-dgemm-c\"><a href=\"#8-my-dgemm-c\" class=\"headerlink\" title=\"8.my_dgemm.c\"></a>8.my_dgemm.c</h3><p><img src=\"/2023/02/02/blislab/image-20230202160939940.png\" alt=\"image-20230202160939940\"></p>\n<h3 id=\"9-相关数据变量含义\"><a href=\"#9-相关数据变量含义\" class=\"headerlink\" title=\"9.相关数据变量含义\"></a>9.相关数据变量含义</h3><p><img src=\"/2023/02/02/blislab/image-20230202161055971.png\" alt=\"image-20230202161055971\"></p>\n<h3 id=\"10-代码采用列主元\"><a href=\"#10-代码采用列主元\" class=\"headerlink\" title=\"10.代码采用列主元\"></a>10.代码采用列主元</h3><p><img src=\"/2023/02/02/blislab/image-20230202161219553.png\" alt=\"image-20230202161219553\"></p>\n<h3 id=\"11-dgemm使用脚本测试\"><a href=\"#11-dgemm使用脚本测试\" class=\"headerlink\" title=\"11.dgemm使用脚本测试\"></a>11.dgemm使用脚本测试</h3><p>Test目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 test]# ./run_bl_dgemm.sh <br>result=[<br><span class=\"hljs-meta\">%</span><span class=\"bash\">m\t%n\t%k\t%MY_GFLOPS\t%REF_GFLOPS</span><br>   16\t    16\t    16\t  7.35\t  1.93<br>   32\t    32\t    32\t  7.88\t  1.29<br>   48\t    48\t    48\t  9.81\t  1.17<br>   64\t    64\t    64\t  8.98\t  1.20<br>   80\t    80\t    80\t  9.59\t  1.11<br>   96\t    96\t    96\t  7.74\t  1.08<br>  112\t   112\t   112\t  8.32\t  0.95<br>  128\t   128\t   128\t  7.74\t  1.04<br>  144\t   144\t   144\t  7.39\t  0.99<br>  160\t   160\t   160\t  7.13\t  1.06<br>  176\t   176\t   176\t  7.58\t  1.06<br>  192\t   192\t   192\t  7.73\t  0.98<br>  208\t   208\t   208\t  7.29\t  1.01<br>  224\t   224\t   224\t  7.90\t  0.97<br>  240\t   240\t   240\t  7.61\t  1.00<br>  256\t   256\t   256\t  6.72\t  0.96<br>  272\t   272\t   272\t  7.51\t  0.99<br>  288\t   288\t   288\t  7.39\t  0.99<br>  304\t   304\t   304\t  7.84\t  0.99<br>  320\t   320\t   320\t  7.61\t  0.97<br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//run_bl_dgemm.sh</span><br>#!/bin/bash<br><br>#For Mac OS only<br><span class=\"hljs-keyword\">export</span> DYLD_LIBRARY_PATH=/opt/intel/lib:/opt/intel/mkl/lib<br><br>#Single Thread<br><span class=\"hljs-keyword\">export</span> KMP_AFFINITY=compact  #Rule to bind core to thread <span class=\"hljs-keyword\">for</span> OMP thread with Intel compiler <span class=\"hljs-keyword\">for</span> parallel version<br><span class=\"hljs-keyword\">export</span> OMP_NUM_THREADS=<span class=\"hljs-number\">1</span>     #Set OMP number of threads <span class=\"hljs-keyword\">for</span> parallel version<br><span class=\"hljs-keyword\">export</span> BLISLAB_IC_NT=<span class=\"hljs-number\">1</span>       #Set BLISLAB number of threads <span class=\"hljs-keyword\">for</span> parallel version<br>k_start=<span class=\"hljs-number\">16</span>\t\t\t\t\t\t<span class=\"hljs-comment\">//起始大小\t\t</span><br>k_end=<span class=\"hljs-number\">1024</span>\t\t\t\t\t\t<span class=\"hljs-comment\">//结束大小</span><br>k_blocksize=<span class=\"hljs-number\">16</span>\t\t\t\t\t<span class=\"hljs-comment\">//步长</span><br>echo <span class=\"hljs-string\">&quot;result=[&quot;</span><br>echo -e <span class=\"hljs-string\">&quot;%m\\t%n\\t%k\\t%MY_GFLOPS\\t%REF_GFLOPS&quot;</span><br><span class=\"hljs-keyword\">for</span> (( k=k_start; k&lt;=k_end; k+=k_blocksize ))<br><span class=\"hljs-keyword\">do</span><br>    ./test_bl_dgemm.x     $k $k $k <br>done<br>echo <span class=\"hljs-string\">&quot;];&quot;</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"12-dgemm手动指定参数测试\"><a href=\"#12-dgemm手动指定参数测试\" class=\"headerlink\" title=\"12.dgemm手动指定参数测试\"></a>12.dgemm手动指定参数测试</h3><p>Test目录下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">[root@hadoop1 test]# ./test_bl_dgemm.x <span class=\"hljs-number\">256</span> <span class=\"hljs-number\">256</span> <span class=\"hljs-number\">256</span> <br>  <span class=\"hljs-number\">256</span>\t   <span class=\"hljs-number\">256</span>\t   <span class=\"hljs-number\">256</span>\t  <span class=\"hljs-number\">5.00</span>\t  <span class=\"hljs-number\">0.84</span><br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">[root@hadoop1 test]# ./test_bl_dgemm.x <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">32</span> <span class=\"hljs-number\">128</span><br>   <span class=\"hljs-number\">16</span>\t    <span class=\"hljs-number\">32</span>\t   <span class=\"hljs-number\">128</span>\t  <span class=\"hljs-number\">8.77</span>\t  <span class=\"hljs-number\">1.02</span><br></code></pre></div></td></tr></table></figure>\n\n<p><strong>这里要注意哪个代表m,n,k?</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">( <span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[] )</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span>    m, n, k; <br><br>    <span class=\"hljs-keyword\">if</span> ( argc != <span class=\"hljs-number\">4</span> ) &#123;<br>        <span class=\"hljs-built_in\">printf</span>( <span class=\"hljs-string\">&quot;Error: require 3 arguments, but only %d provided.\\n&quot;</span>, argc - <span class=\"hljs-number\">1</span> );<br>        <span class=\"hljs-built_in\">exit</span>( <span class=\"hljs-number\">0</span> );<br>    &#125;<br><br>    <span class=\"hljs-built_in\">sscanf</span>( argv[ <span class=\"hljs-number\">1</span> ], <span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;m );<br>    <span class=\"hljs-built_in\">sscanf</span>( argv[ <span class=\"hljs-number\">2</span> ], <span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;n );<br>    <span class=\"hljs-built_in\">sscanf</span>( argv[ <span class=\"hljs-number\">3</span> ], <span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;k );<br><br>    <span class=\"hljs-built_in\">test_bl_dgemm</span>( m, n, k );<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"13-计时区域\"><a href=\"#13-计时区域\" class=\"headerlink\" title=\"13.计时区域\"></a><strong>13.计时区域</strong></h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span> ( i = <span class=\"hljs-number\">0</span>; i &lt; nrepeats; i ++ ) &#123;<br>        ref_beg = <span class=\"hljs-built_in\">bl_clock</span>();\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//blislib提供的封装</span><br>        &#123;<br>            <span class=\"hljs-built_in\">bl_dgemm_ref</span>(<br>                    m,<br>                    n,<br>                    k,<br>                    A,<br>                    lda,<br>                    B,<br>                    ldb,<br>                    C_ref,<br>                    ldc_ref<br>                    );<br>        &#125;<br>        ref_time = <span class=\"hljs-built_in\">bl_clock</span>() - ref_beg;<br><br>        <span class=\"hljs-keyword\">if</span> ( i == <span class=\"hljs-number\">0</span> ) &#123;<br>            ref_rectime = ref_time;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            ref_rectime = ref_time &lt; ref_rectime ? ref_time : ref_rectime;\t\t\t\t\t<span class=\"hljs-comment\">//多次计时取最优</span><br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"14-正确性检验\"><a href=\"#14-正确性检验\" class=\"headerlink\" title=\"14.正确性检验\"></a>14.正确性检验</h3><p>Test目录下Test_bl_gemm.c</p>\n<p>结果比较：通过比较你的优化计算结果和参考计算结果对比</p>\n<p>Gflops的计算</p>\n<ul>\n<li>有效浮点次数 &#x3D; 2*m*n*k</li>\n<li>Gflops &#x3D; 有效浮点次数 &#x2F; 时间</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">computeError</span>(<br>        ldc,<br>        ldc_ref,<br>        m,<br>        n,<br>        C,<br>        C_ref<br>        );<br><br><span class=\"hljs-comment\">// Compute overall floating point operations.</span><br>flops = ( m * n / ( <span class=\"hljs-number\">1000.0</span> * <span class=\"hljs-number\">1000.0</span> * <span class=\"hljs-number\">1000.0</span> ) ) * ( <span class=\"hljs-number\">2</span> * k );<br><br><span class=\"hljs-built_in\">printf</span>( <span class=\"hljs-string\">&quot;%5d\\t %5d\\t %5d\\t %5.2lf\\t %5.2lf\\n&quot;</span>, <br>        m, n, k, flops / bl_dgemm_rectime, flops / ref_rectime );<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"15-课后作业\"><a href=\"#15-课后作业\" class=\"headerlink\" title=\"15.课后作业\"></a>15.课后作业</h3><p><strong>perf工具的用法</strong>：</p>\n<p><a href=\"https://xingyuanjie.top/2022/01/19/tool003/\">perf-系统级性能分析工具 - Amicoyuan (xingyuanjie.top)</a></p>\n<p><strong>分析不同的j,p,i循环顺序的性能：</strong></p>\n<p>原因cache miss造成的差异</p>\n<h2 id=\"Step1\"><a href=\"#Step1\" class=\"headerlink\" title=\"Step1\"></a>Step1</h2><h3 id=\"1-与Step0比较\"><a href=\"#1-与Step0比较\" class=\"headerlink\" title=\"1.与Step0比较\"></a>1.与Step0比较</h3><p><strong>左边是Step1右边是Step0</strong></p>\n<p><img src=\"/2023/02/02/blislab/image-20230202165659964.png\" alt=\"image-20230202165659964\"></p>\n<h3 id=\"2-基本分块\"><a href=\"#2-基本分块\" class=\"headerlink\" title=\"2.基本分块\"></a>2.基本分块</h3><p><img src=\"/2023/02/02/blislab/image-20230202170723811.png\" alt=\"image-20230202170723811\"></p>\n<h3 id=\"3-反汇编\"><a href=\"#3-反汇编\" class=\"headerlink\" title=\"3.反汇编\"></a>3.反汇编</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 dgemm]# objdump -d ./my_dgemm.o &gt; my_dgemm.S<br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs assembly\">./my_dgemm.o：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;AddDot&gt;:<br>   0:\t85 ff                \ttest   %edi,%edi<br>   2:\t7e 2e                \tjle    32 &lt;AddDot+0x32&gt;<br>   4:\t48 63 d2             \tmovslq %edx,%rdx<br>   7:\tc4 c1 7b 10 01       \tvmovsd (%r9),%xmm0<br>   c:\t31 c0                \txor    %eax,%eax<br>   e:\t48 c1 e2 03          \tshl    $0x3,%rdx<br>  12:\t66 0f 1f 44 00 00    \tnopw   0x0(%rax,%rax,1)<br>  18:\tc5 fb 10 0e          \tvmovsd (%rsi),%xmm1<br>  1c:\t48 01 d6             \tadd    %rdx,%rsi<br>  1f:\tc4 e2 f1 b9 04 c1    \tvfmadd231sd (%rcx,%rax,8),%xmm1,%xmm0<br>  25:\t48 83 c0 01          \tadd    $0x1,%rax<br>  29:\tc4 c1 7b 11 01       \tvmovsd %xmm0,(%r9)<br>  2e:\t39 c7                \tcmp    %eax,%edi<br>  30:\t7f e6                \tjg     18 &lt;AddDot+0x18&gt;<br>  32:\tf3 c3                \trepz retq <br>  34:\t66 90                \txchg   %ax,%ax<br>  36:\t66 2e 0f 1f 84 00 00 \tnopw   %cs:0x0(%rax,%rax,1)<br>  3d:\t00 00 00 <br><br>0000000000000040 &lt;AddDot_MRxNR&gt;:<br>  40:\te9 00 00 00 00       \tjmpq   45 &lt;AddDot_MRxNR+0x5&gt;<br>  45:\t90                   \tnop<br>  46:\t66 2e 0f 1f 84 00 00 \tnopw   %cs:0x0(%rax,%rax,1)<br>  4d:\t00 00 00 <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"4-反汇编（-fPIC引入的差异）\"><a href=\"#4-反汇编（-fPIC引入的差异）\" class=\"headerlink\" title=\"4.反汇编（-fPIC引入的差异）\"></a>4.反汇编（-fPIC引入的差异）</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 test]# objdump -d ./test_bl_dgemm.x  &gt; test.S<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202171234007.png\" alt=\"image-20230202171234007\"></p>\n<h3 id=\"5-Gcc生成汇编\"><a href=\"#5-Gcc生成汇编\" class=\"headerlink\" title=\"5.Gcc生成汇编\"></a>5.Gcc生成汇编</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 step1]# gcc -O3 -march=core-avx2 -fPIC -S dgemm/my_dgemm.c -o dgemm/my_dgemm1.S -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202171758087.png\" alt=\"image-20230202171758087\"></p>\n<h3 id=\"6-Step0与Step1比较\"><a href=\"#6-Step0与Step1比较\" class=\"headerlink\" title=\"6.Step0与Step1比较\"></a>6.Step0与Step1比较</h3><p><img src=\"/2023/02/02/blislab/image-20230202172816584.png\" alt=\"image-20230202172816584\"></p>\n<h3 id=\"7-分块，修改MR，-NR为4×4\"><a href=\"#7-分块，修改MR，-NR为4×4\" class=\"headerlink\" title=\"7.分块，修改MR， NR为4×4\"></a>7.分块，修改MR， NR为4×4</h3><p><img src=\"/2023/02/02/blislab/image-20230202173132817.png\" alt=\"image-20230202173132817\"></p>\n<h3 id=\"8-分块（2×2）\"><a href=\"#8-分块（2×2）\" class=\"headerlink\" title=\"8.分块（2×2）\"></a>8.分块（2×2）</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">void</span> AddDot_2×<span class=\"hljs-number\">2</span>( <span class=\"hljs-keyword\">int</span> k, <span class=\"hljs-keyword\">double</span> *A, <span class=\"hljs-keyword\">int</span> lda, <span class=\"hljs-keyword\">double</span> *B, <span class=\"hljs-keyword\">int</span> ldb, <span class=\"hljs-keyword\">double</span> *C,<span class=\"hljs-keyword\">int</span> ldc ) &#123;<br>\t<span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> C00, C01, C10, C11;<br>    <span class=\"hljs-keyword\">int</span> p;<br>    C00=<span class=\"hljs-number\">0.0</span>;<br>    C01=<span class=\"hljs-number\">0.0</span>;<br>    C10=<span class=\"hljs-number\">0.0</span>;<br>    C11=<span class=\"hljs-number\">0.0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span>( p=<span class=\"hljs-number\">0</span> ;p &lt; k; p++)<br>    &#123;<br>        C00 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>);<br>        C01 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>);<br>        C10 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>);<br>        C11 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>) +=C00;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>) +=C01;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) +=C10;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>) +=C11;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202173645399.png\" alt=\"image-20230202173645399\"></p>\n<h3 id=\"9-AddDot-2x2汇编代码\"><a href=\"#9-AddDot-2x2汇编代码\" class=\"headerlink\" title=\"9.AddDot_2x2汇编代码\"></a>9.AddDot_2x2汇编代码</h3><p><img src=\"/2023/02/02/blislab/image-20230202191728644.png\" alt=\"image-20230202191728644\"></p>\n<h3 id=\"10-AddDot-2x2最内层循环展开\"><a href=\"#10-AddDot-2x2最内层循环展开\" class=\"headerlink\" title=\"10.AddDot_2x2最内层循环展开\"></a>10.AddDot_2x2最内层循环展开</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">void</span> AddDot_2×<span class=\"hljs-number\">2</span>( <span class=\"hljs-keyword\">int</span> k, <span class=\"hljs-keyword\">double</span> *A, <span class=\"hljs-keyword\">int</span> lda, <span class=\"hljs-keyword\">double</span> *B, <span class=\"hljs-keyword\">int</span> ldb, <span class=\"hljs-keyword\">double</span> *C,<span class=\"hljs-keyword\">int</span> ldc ) &#123;<br>\t<span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> C00, C01, C10, C11;<br>    <span class=\"hljs-keyword\">int</span> p;<br>    C00=<span class=\"hljs-number\">0.0</span>;<br>    C01=<span class=\"hljs-number\">0.0</span>;<br>    C10=<span class=\"hljs-number\">0.0</span>;<br>    C11=<span class=\"hljs-number\">0.0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span>( p=<span class=\"hljs-number\">0</span> ;p &lt; k; p+=<span class=\"hljs-number\">2</span>)<br>    &#123;<br>        C00 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>        C01 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);<br>        C10 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>        C11 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>) +=C00;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>) +=C01;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) +=C10;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>) +=C11;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202192033816.png\" alt=\"image-20230202192033816\"></p>\n<h3 id=\"11-AddDot-2x2汇编代码【最内层循环展开】\"><a href=\"#11-AddDot-2x2汇编代码【最内层循环展开】\" class=\"headerlink\" title=\"11.AddDot_2x2汇编代码【最内层循环展开】\"></a>11.AddDot_2x2汇编代码【最内层循环展开】</h3><p><img src=\"/2023/02/02/blislab/image-20230202192319993.png\" alt=\"image-20230202192319993\"></p>\n<h2 id=\"Step2\"><a href=\"#Step2\" class=\"headerlink\" title=\"Step2\"></a>Step2</h2><h3 id=\"1-与Step1的性能比较\"><a href=\"#1-与Step1的性能比较\" class=\"headerlink\" title=\"1.与Step1的性能比较\"></a>1.与Step1的性能比较</h3><p><img src=\"/2023/02/02/blislab/image-20230206163219051.png\" alt=\"image-20230206163219051\"></p>\n<h3 id=\"2-优化kernel-x2F-bl-dgemm-ukr-c\"><a href=\"#2-优化kernel-x2F-bl-dgemm-ukr-c\" class=\"headerlink\" title=\"2.优化kernel&#x2F;bl_dgemm_ukr.c\"></a>2.优化kernel&#x2F;bl_dgemm_ukr.c</h3><p><img src=\"/2023/02/02/blislab/image-20230206163713966.png\" alt=\"image-20230206163713966\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206163803615.png\" alt=\"image-20230206163803615\"></p>\n<h3 id=\"3-优化后性能对比\"><a href=\"#3-优化后性能对比\" class=\"headerlink\" title=\"3.优化后性能对比\"></a>3.优化后性能对比</h3><p><img src=\"/2023/02/02/blislab/image-20230206163833950.png\" alt=\"image-20230206163833950\"></p>\n<h3 id=\"4-下降原因分析\"><a href=\"#4-下降原因分析\" class=\"headerlink\" title=\"4.下降原因分析\"></a>4.下降原因分析</h3><p><img src=\"/2023/02/02/blislab/image-20230206164335213.png\" alt=\"image-20230206164335213\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206164734050.png\" alt=\"image-20230206164734050\"></p>\n<h3 id=\"5-如何进行分块\"><a href=\"#5-如何进行分块\" class=\"headerlink\" title=\"5.如何进行分块\"></a>5.如何进行分块</h3><p><img src=\"/2023/02/02/blislab/image-20230206165017812.png\" alt=\"image-20230206165017812\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206165103417.png\" alt=\"image-20230206165103417\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170050450.png\" alt=\"image-20230206170050450\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170105998.png\" alt=\"image-20230206170105998\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170126588.png\" alt=\"image-20230206170126588\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170153251.png\" alt=\"image-20230206170153251\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170226248.png\" alt=\"image-20230206170226248\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170242872.png\" alt=\"image-20230206170242872\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170320842.png\" alt=\"image-20230206170320842\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170334857.png\" alt=\"image-20230206170334857\"></p>\n<h3 id=\"6-Dgemm代码\"><a href=\"#6-Dgemm代码\" class=\"headerlink\" title=\"6.Dgemm代码\"></a>6.Dgemm代码</h3><p><img src=\"/2023/02/02/blislab/image-20230206171538013.png\" alt=\"image-20230206171538013\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206171556767.png\" alt=\"image-20230206171556767\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206171622104.png\" alt=\"image-20230206171622104\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206171639209.png\" alt=\"image-20230206171639209\"></p>\n<h3 id=\"7-Dgemm-macro-kenrel代码\"><a href=\"#7-Dgemm-macro-kenrel代码\" class=\"headerlink\" title=\"7.Dgemm macro kenrel代码\"></a>7.Dgemm macro kenrel代码</h3><p><img src=\"/2023/02/02/blislab/image-20230206171903844.png\" alt=\"image-20230206171903844\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206171940282.png\" alt=\"image-20230206171940282\"></p>\n<h3 id=\"8-Gemm汇总\"><a href=\"#8-Gemm汇总\" class=\"headerlink\" title=\"8.Gemm汇总\"></a>8.Gemm汇总</h3><p><img src=\"/2023/02/02/blislab/image-20230206172351890.png\" alt=\"image-20230206172351890\"></p>\n<h3 id=\"9-拓展\"><a href=\"#9-拓展\" class=\"headerlink\" title=\"9.拓展\"></a>9.拓展</h3><p><img src=\"/2023/02/02/blislab/image-20230206172425329.png\" alt=\"image-20230206172425329\"></p>\n<h3 id=\"10-双缓冲优化\"><a href=\"#10-双缓冲优化\" class=\"headerlink\" title=\"10.双缓冲优化\"></a>10.双缓冲优化</h3><p><img src=\"/2023/02/02/blislab/image-20230206172846408.png\" alt=\"image-20230206172846408\"></p>\n",
            "tags": [
                "Linux",
                "dgemm"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/01/28/cuda006/",
            "url": "https://xingyuanjie.top/2023/01/28/cuda006/",
            "title": "CUDA线程管理",
            "date_published": "2023-01-28T07:41:55.000Z",
            "content_html": "<h3 id=\"1-线程管理\"><a href=\"#1-线程管理\" class=\"headerlink\" title=\"1.线程管理\"></a>1.线程管理</h3><p>当核函数在主机端启动时，它的执行会移动到设备上，此时设备中会产生大量的线程并且每个线程都执行由核函数指定的语句。了解如何组织线程是CUDA编程的一个关键部分。CUDA明确了线程层次抽象的概念以便于你组织线程。这是一个两层的线程层次结构，由线程块和线程块网格构成，如图2-5所示。</p>\n<p><img src=\"/2023/01/28/cuda006/image-20230128160011560.png\" alt=\"image-20230128160011560\"></p>\n<p>由一个内核启动所产生的所有线程统称为一个网格。同一网格中的所有线程共享相同的全局内存空间。一个网格由多个线程块构成，一个线程块包含一组线程，同一线程块内的线程协作可以通过以下方式来实现。</p>\n<p>​\t-同步</p>\n<p>​\t-共享内存</p>\n<p>不同块内的线程不能协作。</p>\n<p>线程依靠以下两个坐标变量来区分彼此。</p>\n<p>​\t-blockIdx(线程块在线程格内的索引)</p>\n<p>​\t-threadIdx(块内的线程索引)</p>\n<p>这些变量是核函数中需要预初始化的内置变量。当执行一个核函数时，CUDA运行时为每个线程分配坐标变量blockIdx和threadIdx。基于这些坐标，你可以将部分数据分配给不同的线程。</p>\n<p>该坐标变量是基于uint3定义的CUDA内置的向量类型，是一个包含3个无符号整数的结构，可以通过x,y,z三个字段来指定。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">blockIdx.x<br>blockIdx.y<br>blockIdx.z<br>threadIdx.x<br>threadIdx.y<br>threadIdx.z<br></code></pre></div></td></tr></table></figure>\n\n<p>CUDA可以组织三维的网格和块。图2-5展示了一个线程层次结构的示例，其结构是一个包含二维块的二维网格。网格和块的维度由下列两个内置变量指定。</p>\n<p>​\t-blockDim(线程块的维度，用每个线程块中的线程数来表示)</p>\n<p>​\t-gridDim(线程格的维度，用每个线程格中的线程数来表示)</p>\n<p>它们是dim3类型的变量，是基于uint3定义的整数型向量，用来表示维度。当定义一个dim3类型的变量时，所有未指定的元素都被初始化为1。dim3类型变量中的每个组件可以通过它的x,y,z字段获得。如下所示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">blockDim.x<br>blockDim.y<br>blockDim.z<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-网格和线程块的维度\"><a href=\"#2-网格和线程块的维度\" class=\"headerlink\" title=\"2.网格和线程块的维度\"></a>2.网格和线程块的维度</h3><p>通常，一个线程格会被组织成线程块的二维数组形式，一个线程块会被组织成线程的三维数组形式。</p>\n<p>线程格和线程块均使用3个dim3类型的无符号整型字段，而未使用的字段将被初始化为1且忽略不计。</p>\n<p>在CUDA程序中有两组不同的网格和块变量：手动定义的dim3数据类型和预定义的uint3数据类型。在主机端，作为内核调用的一部分，你可以使用dim3数据类型定义一个网格和块的维度。当执行核函数时，CUDA运行时会生成相应的内置预初始化的网格，块和线程变量，它们在核函数内均可被访问到且为unit3类型。手动定义的dim3类型的网络和块变量仅在主机端可见，而unit3类型的内置预初始化的网格和块变量仅在设备端可见。</p>\n<p>你可以通过代码清单2-2来验证这些变量如何使用。首先，定义程序所用的数据大小，为了对此进行说明，我们定义一个较小的数据。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> nElem = <span class=\"hljs-number\">6</span>;<br></code></pre></div></td></tr></table></figure>\n\n<p>接下来，定义块的尺寸并基于块和数据的大小计算网格尺寸。在下面例子中，定义了一个包含3个线程的一维线程块，以及一个基于块和数据大小定义的一定数量线程块的一维线程网格。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">dim3 <span class=\"hljs-title\">block</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>)</span></span>;<br><span class=\"hljs-function\">dim3 <span class=\"hljs-title\">grid</span><span class=\"hljs-params\">((nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x)</span></span>;<br></code></pre></div></td></tr></table></figure>\n\n<p>你会发现网格大小是块大小的倍数。以下主机端上的程序段用来检查网格和块维度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d grid.y %d grid.z %d\\n&quot;</span>,grid.x,grid.y,grid.z);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;block.x %d block.y %d block.z %d\\n&quot;</span>,block.x,block.y,block.z);<br></code></pre></div></td></tr></table></figure>\n\n<p>在核函数中，每个线程都输出自己的线程索引，块索引，块维度和网格维度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;threadIdx:(%d, %d, %d) blockIdx:(%d, %d, %d) blockDim:(%d, %d, %d) &quot;</span> <span class=\"hljs-string\">&quot;gridDim:(%d, %d, %d)\\n&quot;</span>, threadIdx.x, threadIdx,y, threadIdz.z,blockIdx.x, blockIdx.y, blockIdx.z, blockDim.x, blockDim.y, blockDim.z, gridDim.x,gridDim.y,gridDim.z);<br></code></pre></div></td></tr></table></figure>\n\n<p>把代码合并保存成名为checkDimension.cu的文件，如代码清单2-2所示。</p>\n<p><strong>代码清单2-2     检查网络和块的索引和维度（checkDimension.cu）</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cuda_runtime.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\">__global__ <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">checkIndex</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>)</span></span>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;threadIdx:(%d, %d, %d) blockIdx:(%d, %d, %d) blockDim:(%d, %d, %d) &quot;</span> <span class=\"hljs-string\">&quot;gridDim:(%d, %d, %d)\\n&quot;</span>, \t\tthreadIdx.x, threadIdx,y, threadIdz.z, blockIdx.x, blockIdx.y, blockIdx.z, blockDim.x, blockDim.y, \t\t\tblockDim.z, gridDim.x,gridDim.y,gridDim.z);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> **argv)</span></span>&#123;<br>    <span class=\"hljs-comment\">//define total data element</span><br>    <span class=\"hljs-keyword\">int</span> nElem = <span class=\"hljs-number\">6</span>;<br>    <span class=\"hljs-comment\">//define grid and block structure</span><br>    <span class=\"hljs-function\">dim3 <span class=\"hljs-title\">block</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>)</span></span>;<br>\t<span class=\"hljs-function\">dim3 <span class=\"hljs-title\">grid</span><span class=\"hljs-params\">((nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x)</span></span>;<br>    <br>    <span class=\"hljs-comment\">//check grid and block dimension from host side</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d grid.y %d grid.z %d\\n&quot;</span>,grid.x,grid.y,grid.z);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;block.x %d block.y %d block.z %d\\n&quot;</span>,block.x,block.y,block.z);<br>\t<br>    <span class=\"hljs-comment\">//check grid and block dimension from device side</span><br>    checkIndex&lt;&lt;&lt;grid, block&gt;&gt;&gt;();<br>    <br>    <span class=\"hljs-comment\">//reset device before you leave</span><br>    <span class=\"hljs-built_in\">cudaDeviceReset</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>现在开始编译和运行这段程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">nvcc -arch=sm_20 checkDimension.cu -o check<br>./check<br></code></pre></div></td></tr></table></figure>\n\n<p>因为printf函数只支持Fermi及以上版本的GPU架构，所以必须添加-arch&#x3D;sm_20编译器选项。默认情况下，nvcc会产生支持最低版本GPU架构的代码。这个应用程序的运行结果如下。可以看到，每个线程都有自己的坐标，所有的线程都有相同的块维度和网格维度。</p>\n<p><img src=\"/2023/01/28/cuda006/image-20230129172501750.png\" alt=\"image-20230129172501750\"></p>\n<h3 id=\"3-从主机端和设备端访问网格-x2F-块变量\"><a href=\"#3-从主机端和设备端访问网格-x2F-块变量\" class=\"headerlink\" title=\"3.从主机端和设备端访问网格&#x2F;块变量\"></a>3.从主机端和设备端访问网格&#x2F;块变量</h3><p>区别主机端和设备端的网格和块变量的访问是很重要的。例如，声明一个主机端的块变量，你按如下定义它的坐标并对其进行访问：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">block.x,block.y,block.z<br></code></pre></div></td></tr></table></figure>\n\n<p>在设备端，你已经预定义了内置块变量的大小：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">blockDim.x,blockDim.y,blockDim.z<br></code></pre></div></td></tr></table></figure>\n\n<p>总之，在启动内核之前就定义了主机端的网格和块变量，并从主机端通过由x,y,z三个字段决定的矢量结构来访问它们。当内核启动时，可以使用内核中预初始化的内置变量。</p>\n<p>对于一个给定的数据大小，确定网格和块尺寸的一般步骤为：</p>\n<p>​\t-确定块的大小</p>\n<p>​\t-在已知数据大小和块大小的基础上计算网格维度</p>\n<p>要确定块尺寸，通常需要考虑：</p>\n<p>​\t-内核的性能特性</p>\n<p>​\t-GPU资源的限制</p>\n<p>代码清单2-3使用了一个一维网格和一个一维块来说明当块的大小改变时，网格的尺寸也会随之改变。</p>\n<p><strong>代码清单2-3 在主机上定义网格和块的大小（defineGridBlock.cu）</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cuda_runtime.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> **argv)</span></span>&#123;<br>    <span class=\"hljs-comment\">//define total data element</span><br>    <span class=\"hljs-keyword\">int</span> nElem = <span class=\"hljs-number\">1024</span>;<br>    <br>    <span class=\"hljs-comment\">//define grid and block structure</span><br>    <span class=\"hljs-function\">dim3 <span class=\"hljs-title\">block</span>\t<span class=\"hljs-params\">(<span class=\"hljs-number\">1024</span>)</span></span>;<br>    <span class=\"hljs-function\">dim3 <span class=\"hljs-title\">grid</span> <span class=\"hljs-params\">((nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x)</span></span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d block.x %d \\n&quot;</span>,grid.x, block.x);<br>    <br>    <span class=\"hljs-comment\">//reset block</span><br>    block.x = <span class=\"hljs-number\">512</span>;<br>    grid.x = (nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d block.x %d \\n&quot;</span>,grid.x, block.x);<br>    <br>    <span class=\"hljs-comment\">//reset block</span><br>    block.x = <span class=\"hljs-number\">256</span>;<br>    grid.x = (nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d block.x %d \\n&quot;</span>,grid.x, block.x);<br>    <br>    <span class=\"hljs-comment\">//reset block</span><br>    block.x = <span class=\"hljs-number\">128</span>;<br>    grid.x = (nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d block.x %d \\n&quot;</span>,grid.x, block.x);<br>    <br>    <span class=\"hljs-comment\">//reset device before you leave</span><br>    <span class=\"hljs-built_in\">cudaDeviceReset</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>用下列命令编译和运行这段程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">nvcc defineGridBlock.cu\t-o block<br>./block<br></code></pre></div></td></tr></table></figure>\n\n<p>下面是一个输出示例。由于应用程序中的数据大小是固定的，因此当块的大小发生改变时，相应的网格尺寸也会发生改变。</p>\n<p><img src=\"/2023/01/28/cuda006/image-20230129174300533.png\" alt=\"image-20230129174300533\"></p>\n<h3 id=\"4-线程层次结构\"><a href=\"#4-线程层次结构\" class=\"headerlink\" title=\"4.线程层次结构\"></a>4.线程层次结构</h3><p>CUDA的特点之一就是通过编程模型揭示了一个两层的线程层次结构。由于一个内核启动的网格和块的维数会影响性能，这一结构为程序员优化程序提供了一个额外的途径。</p>\n<p>网格和块的维度存在几个限制因素，对于块大小的一个主要限制因素就是可利用的计算资源，如寄存器，共享内存等。某些限制可以通过查询GPU设备撤回。</p>\n<p>网格和块从逻辑上代表了一个核函数的线程层次结构。</p>\n<h3 id=\"5-参考资料\"><a href=\"#5-参考资料\" class=\"headerlink\" title=\"5.参考资料\"></a>5.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        }
    ]
}