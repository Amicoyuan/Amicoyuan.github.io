{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/02/02/register/",
            "url": "http://example.com/2023/02/02/register/",
            "title": "register关键字",
            "date_published": "2023-02-02T11:57:01.000Z",
            "content_html": "<h2 id=\"register关键字\"><a href=\"#register关键字\" class=\"headerlink\" title=\"register关键字\"></a>register关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">int</span> val = <span class=\"hljs-number\">100</span>;<br>\t<span class=\"hljs-comment\">//寄存器变量没有地址，不能取地址</span><br>\tval = <span class=\"hljs-number\">200</span>; <span class=\"hljs-comment\">//可以被写入</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, val);<br>\t<span class=\"hljs-comment\">// 在gcc编译器下 也不允许取地址</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">//由于使用register关键字，直接将val存在寄存器内，因此val没有内存地址，因此不能进行取地址操作。</span><br></code></pre></div></td></tr></table></figure>\n\n<ol>\n<li>我们通常采用局部变量采用 register 的，全局变量会导致 CPU 当中的寄存器被长时间占用。</li>\n<li>一个变量被存放到寄存器当中，那么这个变量的效率就会大大的提高,因为不用访存读取</li>\n<li>register关键字可以与指针变量一起使用。</li>\n<li>寄存器是一个存储类，并且C不允许变量使用多个存储类说明符。因此，register不能与static一起使用。</li>\n<li>寄存器只能在一个块内使用（局部），而不能在全局范围内（在主外部）使用</li>\n<li>寄存器数量有限</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://xie.infoq.cn/article/f6093f4eebd3664c0a1514e26\">【C语言】register 关键字_11月月更_謓泽_InfoQ写作社区</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/263575137\">一步带您了解C语言中的“register”关键字 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.ab62.cn/article/5406.html\">C语言关键字之auto register详解_C 语言_AB教程网 (ab62.cn)</a></p>\n",
            "tags": [
                "C/C++",
                "register"
            ]
        },
        {
            "id": "http://example.com/2023/02/02/blislab/",
            "url": "http://example.com/2023/02/02/blislab/",
            "title": "BLISlab dgemm优化",
            "date_published": "2023-02-02T06:38:00.000Z",
            "content_html": "<h1 id=\"BLISlab-dgemm优化\"><a href=\"#BLISlab-dgemm优化\" class=\"headerlink\" title=\"BLISlab dgemm优化\"></a>BLISlab dgemm优化</h1><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><p><strong>Git地址：</strong><a href=\"https://github.com/flame/blislab\">https://github.com/flame/blislab</a></p>\n<p><strong>视频教程：</strong><a href=\"https://www.bilibili.com/video/BV1c94y117Uw?vd_source=3ae32e36058f58c5b85935fca9b77797%E3%80%90%E6%BE%8E%E5%B3%B0%E7%A7%91%E6%8A%80-%E5%BC%A0%E5%85%88%E8%BD%B6%E8%80%81%E5%B8%88%E3%80%91\">https://www.bilibili.com/video/BV1c94y117Uw?vd_source=3ae32e36058f58c5b85935fca9b77797【澎峰科技-张先轶老师】</a></p>\n<p><strong>阅读</strong>：tutorial.pdf【位于代码包中】</p>\n<h2 id=\"Step0\"><a href=\"#Step0\" class=\"headerlink\" title=\"Step0\"></a>Step0</h2><h3 id=\"1-克隆项目到本地\"><a href=\"#1-克隆项目到本地\" class=\"headerlink\" title=\"1.克隆项目到本地\"></a>1.克隆项目到本地</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">git clone https://github.com/flame/blislab.git<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-代码结构\"><a href=\"#2-代码结构\" class=\"headerlink\" title=\"2.代码结构\"></a>2.代码结构</h3><p><img src=\"/2023/02/02/blislab/image-20230202155728203.png\" alt=\"image-20230202155728203\"></p>\n<h3 id=\"3-编译环境\"><a href=\"#3-编译环境\" class=\"headerlink\" title=\"3.编译环境\"></a>3.编译环境</h3><p><img src=\"/2023/02/02/blislab/image-20230202155820411.png\" alt=\"image-20230202155820411\"></p>\n<h3 id=\"4-运行环境配置脚本\"><a href=\"#4-运行环境配置脚本\" class=\"headerlink\" title=\"4.运行环境配置脚本\"></a>4.运行环境配置脚本</h3><p><img src=\"/2023/02/02/blislab/image-20230202160027957.png\" alt=\"image-20230202160027957\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 step0]# source ./sourceme.sh <br>BLISLAB_DIR = .<br>BLISLAB_USE_INTEL = false<br>BLISLAB_USE_BLAS = false<br>COMPILER_OPT_LEVEL = O3<br>BLAS_DIR = /u/jianyu/lib/openblas<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"5-Makefile\"><a href=\"#5-Makefile\" class=\"headerlink\" title=\"5.Makefile\"></a>5.Makefile</h3><p><img src=\"/2023/02/02/blislab/image-20230202160244490.png\" alt=\"image-20230202160244490\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 step0]# make<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/my_dgemm.c -o dgemm/my_dgemm.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/bl_dgemm_ref.c -o dgemm/bl_dgemm_ref.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/bl_dgemm_util.c -o dgemm/bl_dgemm_util.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>ar cr lib/libblislab.a dgemm/my_dgemm.o dgemm/bl_dgemm_ref.o dgemm/bl_dgemm_util.o    <br>ranlib lib/libblislab.a<br>gcc -O3 -march=core-avx2 -fPIC -shared -o lib/libblislab.so dgemm/my_dgemm.o dgemm/bl_dgemm_ref.o dgemm/bl_dgemm_util.o     ./lib/libblislab.a -lpthread -lm -lrt<br>cd ./test &amp;&amp; make &amp;&amp; cd . -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>make[1]: 进入目录“/root/blislab/step0/test”<br>gcc -O3 -march=core-avx2 -fPIC test_bl_dgemm.c -o test_bl_dgemm.x -I../include -I../kernels -I/u/jianyu/lib/openblas/include ../lib/libblislab.a -lpthread -lm -lrt<br>make[1]: 离开目录“/root/blislab/step0/test”<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"6-make-gnu-inc\"><a href=\"#6-make-gnu-inc\" class=\"headerlink\" title=\"6.make.gnu.inc\"></a>6.make.gnu.inc</h3><p><img src=\"/2023/02/02/blislab/image-20230202160608401.png\" alt=\"image-20230202160608401\"></p>\n<h3 id=\"7-ref参考实现是否调用BLAS\"><a href=\"#7-ref参考实现是否调用BLAS\" class=\"headerlink\" title=\"7.ref参考实现是否调用BLAS\"></a>7.ref参考实现是否调用BLAS</h3><p><img src=\"/2023/02/02/blislab/image-20230202160904158.png\" alt=\"image-20230202160904158\"></p>\n<h3 id=\"8-my-dgemm-c\"><a href=\"#8-my-dgemm-c\" class=\"headerlink\" title=\"8.my_dgemm.c\"></a>8.my_dgemm.c</h3><p><img src=\"/2023/02/02/blislab/image-20230202160939940.png\" alt=\"image-20230202160939940\"></p>\n<h3 id=\"9-相关数据变量含义\"><a href=\"#9-相关数据变量含义\" class=\"headerlink\" title=\"9.相关数据变量含义\"></a>9.相关数据变量含义</h3><p><img src=\"/2023/02/02/blislab/image-20230202161055971.png\" alt=\"image-20230202161055971\"></p>\n<h3 id=\"10-代码采用列主元\"><a href=\"#10-代码采用列主元\" class=\"headerlink\" title=\"10.代码采用列主元\"></a>10.代码采用列主元</h3><p><img src=\"/2023/02/02/blislab/image-20230202161219553.png\" alt=\"image-20230202161219553\"></p>\n<h3 id=\"11-dgemm使用脚本测试\"><a href=\"#11-dgemm使用脚本测试\" class=\"headerlink\" title=\"11.dgemm使用脚本测试\"></a>11.dgemm使用脚本测试</h3><p>Test目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 test]# ./run_bl_dgemm.sh <br>result=[<br><span class=\"hljs-meta\">%</span><span class=\"bash\">m\t%n\t%k\t%MY_GFLOPS\t%REF_GFLOPS</span><br>   16\t    16\t    16\t  7.35\t  1.93<br>   32\t    32\t    32\t  7.88\t  1.29<br>   48\t    48\t    48\t  9.81\t  1.17<br>   64\t    64\t    64\t  8.98\t  1.20<br>   80\t    80\t    80\t  9.59\t  1.11<br>   96\t    96\t    96\t  7.74\t  1.08<br>  112\t   112\t   112\t  8.32\t  0.95<br>  128\t   128\t   128\t  7.74\t  1.04<br>  144\t   144\t   144\t  7.39\t  0.99<br>  160\t   160\t   160\t  7.13\t  1.06<br>  176\t   176\t   176\t  7.58\t  1.06<br>  192\t   192\t   192\t  7.73\t  0.98<br>  208\t   208\t   208\t  7.29\t  1.01<br>  224\t   224\t   224\t  7.90\t  0.97<br>  240\t   240\t   240\t  7.61\t  1.00<br>  256\t   256\t   256\t  6.72\t  0.96<br>  272\t   272\t   272\t  7.51\t  0.99<br>  288\t   288\t   288\t  7.39\t  0.99<br>  304\t   304\t   304\t  7.84\t  0.99<br>  320\t   320\t   320\t  7.61\t  0.97<br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//run_bl_dgemm.sh</span><br>#!/bin/bash<br><br>#For Mac OS only<br><span class=\"hljs-keyword\">export</span> DYLD_LIBRARY_PATH=/opt/intel/lib:/opt/intel/mkl/lib<br><br>#Single Thread<br><span class=\"hljs-keyword\">export</span> KMP_AFFINITY=compact  #Rule to bind core to thread <span class=\"hljs-keyword\">for</span> OMP thread with Intel compiler <span class=\"hljs-keyword\">for</span> parallel version<br><span class=\"hljs-keyword\">export</span> OMP_NUM_THREADS=<span class=\"hljs-number\">1</span>     #Set OMP number of threads <span class=\"hljs-keyword\">for</span> parallel version<br><span class=\"hljs-keyword\">export</span> BLISLAB_IC_NT=<span class=\"hljs-number\">1</span>       #Set BLISLAB number of threads <span class=\"hljs-keyword\">for</span> parallel version<br>k_start=<span class=\"hljs-number\">16</span>\t\t\t\t\t\t<span class=\"hljs-comment\">//起始大小\t\t</span><br>k_end=<span class=\"hljs-number\">1024</span>\t\t\t\t\t\t<span class=\"hljs-comment\">//结束大小</span><br>k_blocksize=<span class=\"hljs-number\">16</span>\t\t\t\t\t<span class=\"hljs-comment\">//步长</span><br>echo <span class=\"hljs-string\">&quot;result=[&quot;</span><br>echo -e <span class=\"hljs-string\">&quot;%m\\t%n\\t%k\\t%MY_GFLOPS\\t%REF_GFLOPS&quot;</span><br><span class=\"hljs-keyword\">for</span> (( k=k_start; k&lt;=k_end; k+=k_blocksize ))<br><span class=\"hljs-keyword\">do</span><br>    ./test_bl_dgemm.x     $k $k $k <br>done<br>echo <span class=\"hljs-string\">&quot;];&quot;</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"12-dgemm手动指定参数测试\"><a href=\"#12-dgemm手动指定参数测试\" class=\"headerlink\" title=\"12.dgemm手动指定参数测试\"></a>12.dgemm手动指定参数测试</h3><p>Test目录下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">[root@hadoop1 test]# ./test_bl_dgemm.x <span class=\"hljs-number\">256</span> <span class=\"hljs-number\">256</span> <span class=\"hljs-number\">256</span> <br>  <span class=\"hljs-number\">256</span>\t   <span class=\"hljs-number\">256</span>\t   <span class=\"hljs-number\">256</span>\t  <span class=\"hljs-number\">5.00</span>\t  <span class=\"hljs-number\">0.84</span><br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">[root@hadoop1 test]# ./test_bl_dgemm.x <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">32</span> <span class=\"hljs-number\">128</span><br>   <span class=\"hljs-number\">16</span>\t    <span class=\"hljs-number\">32</span>\t   <span class=\"hljs-number\">128</span>\t  <span class=\"hljs-number\">8.77</span>\t  <span class=\"hljs-number\">1.02</span><br></code></pre></div></td></tr></table></figure>\n\n<p><strong>这里要注意哪个代表m,n,k?</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">( <span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[] )</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span>    m, n, k; <br><br>    <span class=\"hljs-keyword\">if</span> ( argc != <span class=\"hljs-number\">4</span> ) &#123;<br>        <span class=\"hljs-built_in\">printf</span>( <span class=\"hljs-string\">&quot;Error: require 3 arguments, but only %d provided.\\n&quot;</span>, argc - <span class=\"hljs-number\">1</span> );<br>        <span class=\"hljs-built_in\">exit</span>( <span class=\"hljs-number\">0</span> );<br>    &#125;<br><br>    <span class=\"hljs-built_in\">sscanf</span>( argv[ <span class=\"hljs-number\">1</span> ], <span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;m );<br>    <span class=\"hljs-built_in\">sscanf</span>( argv[ <span class=\"hljs-number\">2</span> ], <span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;n );<br>    <span class=\"hljs-built_in\">sscanf</span>( argv[ <span class=\"hljs-number\">3</span> ], <span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;k );<br><br>    <span class=\"hljs-built_in\">test_bl_dgemm</span>( m, n, k );<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"13-计时区域\"><a href=\"#13-计时区域\" class=\"headerlink\" title=\"13.计时区域\"></a><strong>13.计时区域</strong></h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span> ( i = <span class=\"hljs-number\">0</span>; i &lt; nrepeats; i ++ ) &#123;<br>        ref_beg = <span class=\"hljs-built_in\">bl_clock</span>();\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//blislib提供的封装</span><br>        &#123;<br>            <span class=\"hljs-built_in\">bl_dgemm_ref</span>(<br>                    m,<br>                    n,<br>                    k,<br>                    A,<br>                    lda,<br>                    B,<br>                    ldb,<br>                    C_ref,<br>                    ldc_ref<br>                    );<br>        &#125;<br>        ref_time = <span class=\"hljs-built_in\">bl_clock</span>() - ref_beg;<br><br>        <span class=\"hljs-keyword\">if</span> ( i == <span class=\"hljs-number\">0</span> ) &#123;<br>            ref_rectime = ref_time;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            ref_rectime = ref_time &lt; ref_rectime ? ref_time : ref_rectime;\t\t\t\t\t<span class=\"hljs-comment\">//多次计时取最优</span><br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"14-正确性检验\"><a href=\"#14-正确性检验\" class=\"headerlink\" title=\"14.正确性检验\"></a>14.正确性检验</h3><p>Test目录下Test_bl_gemm.c</p>\n<p>结果比较：通过比较你的优化计算结果和参考计算结果对比</p>\n<p>Gflops的计算</p>\n<ul>\n<li>有效浮点次数 &#x3D; 2*m*n*k</li>\n<li>Gflops &#x3D; 有效浮点次数 &#x2F; 时间</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">computeError</span>(<br>        ldc,<br>        ldc_ref,<br>        m,<br>        n,<br>        C,<br>        C_ref<br>        );<br><br><span class=\"hljs-comment\">// Compute overall floating point operations.</span><br>flops = ( m * n / ( <span class=\"hljs-number\">1000.0</span> * <span class=\"hljs-number\">1000.0</span> * <span class=\"hljs-number\">1000.0</span> ) ) * ( <span class=\"hljs-number\">2</span> * k );<br><br><span class=\"hljs-built_in\">printf</span>( <span class=\"hljs-string\">&quot;%5d\\t %5d\\t %5d\\t %5.2lf\\t %5.2lf\\n&quot;</span>, <br>        m, n, k, flops / bl_dgemm_rectime, flops / ref_rectime );<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"15-课后作业\"><a href=\"#15-课后作业\" class=\"headerlink\" title=\"15.课后作业\"></a>15.课后作业</h3><p><strong>perf工具的用法</strong>：</p>\n<p><a href=\"https://xingyuanjie.top/2022/01/19/tool003/\">perf-系统级性能分析工具 - Amicoyuan (xingyuanjie.top)</a></p>\n<p><strong>分析不同的j,p,i循环顺序的性能：</strong></p>\n<p>原因cache miss造成的差异</p>\n<h2 id=\"Step1\"><a href=\"#Step1\" class=\"headerlink\" title=\"Step1\"></a>Step1</h2><h3 id=\"1-与Step0比较\"><a href=\"#1-与Step0比较\" class=\"headerlink\" title=\"1.与Step0比较\"></a>1.与Step0比较</h3><p><strong>左边是Step1右边是Step0</strong></p>\n<p><img src=\"/2023/02/02/blislab/image-20230202165659964.png\" alt=\"image-20230202165659964\"></p>\n<h3 id=\"2-基本分块\"><a href=\"#2-基本分块\" class=\"headerlink\" title=\"2.基本分块\"></a>2.基本分块</h3><p><img src=\"/2023/02/02/blislab/image-20230202170723811.png\" alt=\"image-20230202170723811\"></p>\n<h3 id=\"3-反汇编\"><a href=\"#3-反汇编\" class=\"headerlink\" title=\"3.反汇编\"></a>3.反汇编</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 dgemm]# objdump -d ./my_dgemm.o &gt; my_dgemm.S<br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs assembly\">./my_dgemm.o：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;AddDot&gt;:<br>   0:\t85 ff                \ttest   %edi,%edi<br>   2:\t7e 2e                \tjle    32 &lt;AddDot+0x32&gt;<br>   4:\t48 63 d2             \tmovslq %edx,%rdx<br>   7:\tc4 c1 7b 10 01       \tvmovsd (%r9),%xmm0<br>   c:\t31 c0                \txor    %eax,%eax<br>   e:\t48 c1 e2 03          \tshl    $0x3,%rdx<br>  12:\t66 0f 1f 44 00 00    \tnopw   0x0(%rax,%rax,1)<br>  18:\tc5 fb 10 0e          \tvmovsd (%rsi),%xmm1<br>  1c:\t48 01 d6             \tadd    %rdx,%rsi<br>  1f:\tc4 e2 f1 b9 04 c1    \tvfmadd231sd (%rcx,%rax,8),%xmm1,%xmm0<br>  25:\t48 83 c0 01          \tadd    $0x1,%rax<br>  29:\tc4 c1 7b 11 01       \tvmovsd %xmm0,(%r9)<br>  2e:\t39 c7                \tcmp    %eax,%edi<br>  30:\t7f e6                \tjg     18 &lt;AddDot+0x18&gt;<br>  32:\tf3 c3                \trepz retq <br>  34:\t66 90                \txchg   %ax,%ax<br>  36:\t66 2e 0f 1f 84 00 00 \tnopw   %cs:0x0(%rax,%rax,1)<br>  3d:\t00 00 00 <br><br>0000000000000040 &lt;AddDot_MRxNR&gt;:<br>  40:\te9 00 00 00 00       \tjmpq   45 &lt;AddDot_MRxNR+0x5&gt;<br>  45:\t90                   \tnop<br>  46:\t66 2e 0f 1f 84 00 00 \tnopw   %cs:0x0(%rax,%rax,1)<br>  4d:\t00 00 00 <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"4-反汇编（-fPIC引入的差异）\"><a href=\"#4-反汇编（-fPIC引入的差异）\" class=\"headerlink\" title=\"4.反汇编（-fPIC引入的差异）\"></a>4.反汇编（-fPIC引入的差异）</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 test]# objdump -d ./test_bl_dgemm.x  &gt; test.S<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202171234007.png\" alt=\"image-20230202171234007\"></p>\n<h3 id=\"5-Gcc生成汇编\"><a href=\"#5-Gcc生成汇编\" class=\"headerlink\" title=\"5.Gcc生成汇编\"></a>5.Gcc生成汇编</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 step1]# gcc -O3 -march=core-avx2 -fPIC -S dgemm/my_dgemm.c -o dgemm/my_dgemm1.S -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202171758087.png\" alt=\"image-20230202171758087\"></p>\n<h3 id=\"6-Step0与Step1比较\"><a href=\"#6-Step0与Step1比较\" class=\"headerlink\" title=\"6.Step0与Step1比较\"></a>6.Step0与Step1比较</h3><p><img src=\"/2023/02/02/blislab/image-20230202172816584.png\" alt=\"image-20230202172816584\"></p>\n<h3 id=\"7-分块，修改MR，-NR为4×4\"><a href=\"#7-分块，修改MR，-NR为4×4\" class=\"headerlink\" title=\"7.分块，修改MR， NR为4×4\"></a>7.分块，修改MR， NR为4×4</h3><p><img src=\"/2023/02/02/blislab/image-20230202173132817.png\" alt=\"image-20230202173132817\"></p>\n<h3 id=\"8-分块（2×2）\"><a href=\"#8-分块（2×2）\" class=\"headerlink\" title=\"8.分块（2×2）\"></a>8.分块（2×2）</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">void</span> AddDot_2×<span class=\"hljs-number\">2</span>( <span class=\"hljs-keyword\">int</span> k, <span class=\"hljs-keyword\">double</span> *A, <span class=\"hljs-keyword\">int</span> lda, <span class=\"hljs-keyword\">double</span> *B, <span class=\"hljs-keyword\">int</span> ldb, <span class=\"hljs-keyword\">double</span> *C,<span class=\"hljs-keyword\">int</span> ldc ) &#123;<br>\t<span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> C00, C01, C10, C11;<br>    <span class=\"hljs-keyword\">int</span> p;<br>    C00=<span class=\"hljs-number\">0.0</span>;<br>    C01=<span class=\"hljs-number\">0.0</span>;<br>    C10=<span class=\"hljs-number\">0.0</span>;<br>    C11=<span class=\"hljs-number\">0.0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span>( p=<span class=\"hljs-number\">0</span> ;p &lt; k; p++)<br>    &#123;<br>        C00 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>);<br>        C01 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>);<br>        C10 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>);<br>        C11 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>) +=C00;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>) +=C01;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) +=C10;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>) +=C11;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202173645399.png\" alt=\"image-20230202173645399\"></p>\n<h3 id=\"9-AddDot-2x2汇编代码\"><a href=\"#9-AddDot-2x2汇编代码\" class=\"headerlink\" title=\"9.AddDot_2x2汇编代码\"></a>9.AddDot_2x2汇编代码</h3><p><img src=\"/2023/02/02/blislab/image-20230202191728644.png\" alt=\"image-20230202191728644\"></p>\n<h3 id=\"10-AddDot-2x2最内层循环展开\"><a href=\"#10-AddDot-2x2最内层循环展开\" class=\"headerlink\" title=\"10.AddDot_2x2最内层循环展开\"></a>10.AddDot_2x2最内层循环展开</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">void</span> AddDot_2×<span class=\"hljs-number\">2</span>( <span class=\"hljs-keyword\">int</span> k, <span class=\"hljs-keyword\">double</span> *A, <span class=\"hljs-keyword\">int</span> lda, <span class=\"hljs-keyword\">double</span> *B, <span class=\"hljs-keyword\">int</span> ldb, <span class=\"hljs-keyword\">double</span> *C,<span class=\"hljs-keyword\">int</span> ldc ) &#123;<br>\t<span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> C00, C01, C10, C11;<br>    <span class=\"hljs-keyword\">int</span> p;<br>    C00=<span class=\"hljs-number\">0.0</span>;<br>    C01=<span class=\"hljs-number\">0.0</span>;<br>    C10=<span class=\"hljs-number\">0.0</span>;<br>    C11=<span class=\"hljs-number\">0.0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span>( p=<span class=\"hljs-number\">0</span> ;p &lt; k; p+=<span class=\"hljs-number\">2</span>)<br>    &#123;<br>        C00 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>        C01 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);<br>        C10 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>        C11 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>) +=C00;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>) +=C01;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) +=C10;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>) +=C11;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202192033816.png\" alt=\"image-20230202192033816\"></p>\n<h3 id=\"11-AddDot-2x2汇编代码【最内层循环展开】\"><a href=\"#11-AddDot-2x2汇编代码【最内层循环展开】\" class=\"headerlink\" title=\"11.AddDot_2x2汇编代码【最内层循环展开】\"></a>11.AddDot_2x2汇编代码【最内层循环展开】</h3><p><img src=\"/2023/02/02/blislab/image-20230202192319993.png\" alt=\"image-20230202192319993\"></p>\n",
            "tags": [
                "Linux",
                "dgemm"
            ]
        },
        {
            "id": "http://example.com/2023/01/28/cuda006/",
            "url": "http://example.com/2023/01/28/cuda006/",
            "title": "CUDA线程管理",
            "date_published": "2023-01-28T07:41:55.000Z",
            "content_html": "<h3 id=\"1-线程管理\"><a href=\"#1-线程管理\" class=\"headerlink\" title=\"1.线程管理\"></a>1.线程管理</h3><p>当核函数在主机端启动时，它的执行会移动到设备上，此时设备中会产生大量的线程并且每个线程都执行由核函数指定的语句。了解如何组织线程是CUDA编程的一个关键部分。CUDA明确了线程层次抽象的概念以便于你组织线程。这是一个两层的线程层次结构，由线程块和线程块网格构成，如图2-5所示。</p>\n<p><img src=\"/2023/01/28/cuda006/image-20230128160011560.png\" alt=\"image-20230128160011560\"></p>\n<p>由一个内核启动所产生的所有线程统称为一个网格。同一网格中的所有线程共享相同的全局内存空间。一个网格由多个线程块构成，一个线程块包含一组线程，同一线程块内的线程协作可以通过以下方式来实现。</p>\n<p>​\t-同步</p>\n<p>​\t-共享内存</p>\n<p>不同块内的线程不能协作。</p>\n<p>线程依靠以下两个坐标变量来区分彼此。</p>\n<p>​\t-blockIdx(线程块在线程格内的索引)</p>\n<p>​\t-threadIdx(块内的线程索引)</p>\n<p>这些变量是核函数中需要预初始化的内置变量。当执行一个核函数时，CUDA运行时为每个线程分配坐标变量blockIdx和threadIdx。基于这些坐标，你可以将部分数据分配给不同的线程。</p>\n<p>该坐标变量是基于uint3定义的CUDA内置的向量类型，是一个包含3个无符号整数的结构，可以通过x,y,z三个字段来指定。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">blockIdx.x<br>blockIdx.y<br>blockIdx.z<br>threadIdx.x<br>threadIdx.y<br>threadIdx.z<br></code></pre></div></td></tr></table></figure>\n\n<p>CUDA可以组织三维的网格和块。图2-5展示了一个线程层次结构的示例，其结构是一个包含二维块的二维网格。网格和块的维度由下列两个内置变量指定。</p>\n<p>​\t-blockDim(线程块的维度，用每个线程块中的线程数来表示)</p>\n<p>​\t-gridDim(线程格的维度，用每个线程格中的线程数来表示)</p>\n<p>它们是dim3类型的变量，是基于uint3定义的整数型向量，用来表示维度。当定义一个dim3类型的变量时，所有未指定的元素都被初始化为1。dim3类型变量中的每个组件可以通过它的x,y,z字段获得。如下所示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">blockDim.x<br>blockDim.y<br>blockDim.z<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-网格和线程块的维度\"><a href=\"#2-网格和线程块的维度\" class=\"headerlink\" title=\"2.网格和线程块的维度\"></a>2.网格和线程块的维度</h3><p>通常，一个线程格会被组织成线程块的二维数组形式，一个线程块会被组织成线程的三维数组形式。</p>\n<p>线程格和线程块均使用3个dim3类型的无符号整型字段，而未使用的字段将被初始化为1且忽略不计。</p>\n<p>在CUDA程序中有两组不同的网格和块变量：手动定义的dim3数据类型和预定义的uint3数据类型。在主机端，作为内核调用的一部分，你可以使用dim3数据类型定义一个网格和块的维度。当执行核函数时，CUDA运行时会生成相应的内置预初始化的网格，块和线程变量，它们在核函数内均可被访问到且为unit3类型。手动定义的dim3类型的网络和块变量仅在主机端可见，而unit3类型的内置预初始化的网格和块变量仅在设备端可见。</p>\n<p>你可以通过代码清单2-2来验证这些变量如何使用。首先，定义程序所用的数据大小，为了对此进行说明，我们定义一个较小的数据。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> nElem = <span class=\"hljs-number\">6</span>;<br></code></pre></div></td></tr></table></figure>\n\n<p>接下来，定义块的尺寸并基于块和数据的大小计算网格尺寸。在下面例子中，定义了一个包含3个线程的一维线程块，以及一个基于块和数据大小定义的一定数量线程块的一维线程网格。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">dim3 <span class=\"hljs-title\">block</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>)</span></span>;<br><span class=\"hljs-function\">dim3 <span class=\"hljs-title\">grid</span><span class=\"hljs-params\">((nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x)</span></span>;<br></code></pre></div></td></tr></table></figure>\n\n<p>你会发现网格大小是块大小的倍数。以下主机端上的程序段用来检查网格和块维度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d grid.y %d grid.z %d\\n&quot;</span>,grid.x,grid.y,grid.z);<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;block.x %d block.y %d block.z %d\\n&quot;</span>,block.x,block.y,block.z);<br></code></pre></div></td></tr></table></figure>\n\n<p>在核函数中，每个线程都输出自己的线程索引，块索引，块维度和网格维度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;threadIdx:(%d, %d, %d) blockIdx:(%d, %d, %d) blockDim:(%d, %d, %d) &quot;</span> <span class=\"hljs-string\">&quot;gridDim:(%d, %d, %d)\\n&quot;</span>, threadIdx.x, threadIdx,y, threadIdz.z,blockIdx.x, blockIdx.y, blockIdx.z, blockDim.x, blockDim.y, blockDim.z, gridDim.x,gridDim.y,gridDim.z);<br></code></pre></div></td></tr></table></figure>\n\n<p>把代码合并保存成名为checkDimension.cu的文件，如代码清单2-2所示。</p>\n<p><strong>代码清单2-2     检查网络和块的索引和维度（checkDimension.cu）</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cuda_runtime.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\">__global__ <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">checkIndex</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>)</span></span>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;threadIdx:(%d, %d, %d) blockIdx:(%d, %d, %d) blockDim:(%d, %d, %d) &quot;</span> <span class=\"hljs-string\">&quot;gridDim:(%d, %d, %d)\\n&quot;</span>, \t\tthreadIdx.x, threadIdx,y, threadIdz.z, blockIdx.x, blockIdx.y, blockIdx.z, blockDim.x, blockDim.y, \t\t\tblockDim.z, gridDim.x,gridDim.y,gridDim.z);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> **argv)</span></span>&#123;<br>    <span class=\"hljs-comment\">//define total data element</span><br>    <span class=\"hljs-keyword\">int</span> nElem = <span class=\"hljs-number\">6</span>;<br>    <span class=\"hljs-comment\">//define grid and block structure</span><br>    <span class=\"hljs-function\">dim3 <span class=\"hljs-title\">block</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>)</span></span>;<br>\t<span class=\"hljs-function\">dim3 <span class=\"hljs-title\">grid</span><span class=\"hljs-params\">((nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x)</span></span>;<br>    <br>    <span class=\"hljs-comment\">//check grid and block dimension from host side</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d grid.y %d grid.z %d\\n&quot;</span>,grid.x,grid.y,grid.z);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;block.x %d block.y %d block.z %d\\n&quot;</span>,block.x,block.y,block.z);<br>\t<br>    <span class=\"hljs-comment\">//check grid and block dimension from device side</span><br>    checkIndex&lt;&lt;&lt;grid, block&gt;&gt;&gt;();<br>    <br>    <span class=\"hljs-comment\">//reset device before you leave</span><br>    <span class=\"hljs-built_in\">cudaDeviceReset</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>现在开始编译和运行这段程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">nvcc -arch=sm_20 checkDimension.cu -o check<br>./check<br></code></pre></div></td></tr></table></figure>\n\n<p>因为printf函数只支持Fermi及以上版本的GPU架构，所以必须添加-arch&#x3D;sm_20编译器选项。默认情况下，nvcc会产生支持最低版本GPU架构的代码。这个应用程序的运行结果如下。可以看到，每个线程都有自己的坐标，所有的线程都有相同的块维度和网格维度。</p>\n<p><img src=\"/2023/01/28/cuda006/image-20230129172501750.png\" alt=\"image-20230129172501750\"></p>\n<h3 id=\"3-从主机端和设备端访问网格-x2F-块变量\"><a href=\"#3-从主机端和设备端访问网格-x2F-块变量\" class=\"headerlink\" title=\"3.从主机端和设备端访问网格&#x2F;块变量\"></a>3.从主机端和设备端访问网格&#x2F;块变量</h3><p>区别主机端和设备端的网格和块变量的访问是很重要的。例如，声明一个主机端的块变量，你按如下定义它的坐标并对其进行访问：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">block.x,block.y,block.z<br></code></pre></div></td></tr></table></figure>\n\n<p>在设备端，你已经预定义了内置块变量的大小：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">blockDim.x,blockDim.y,blockDim.z<br></code></pre></div></td></tr></table></figure>\n\n<p>总之，在启动内核之前就定义了主机端的网格和块变量，并从主机端通过由x,y,z三个字段决定的矢量结构来访问它们。当内核启动时，可以使用内核中预初始化的内置变量。</p>\n<p>对于一个给定的数据大小，确定网格和块尺寸的一般步骤为：</p>\n<p>​\t-确定块的大小</p>\n<p>​\t-在已知数据大小和块大小的基础上计算网格维度</p>\n<p>要确定块尺寸，通常需要考虑：</p>\n<p>​\t-内核的性能特性</p>\n<p>​\t-GPU资源的限制</p>\n<p>代码清单2-3使用了一个一维网格和一个一维块来说明当块的大小改变时，网格的尺寸也会随之改变。</p>\n<p><strong>代码清单2-3 在主机上定义网格和块的大小（defineGridBlock.cu）</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cuda_runtime.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> **argv)</span></span>&#123;<br>    <span class=\"hljs-comment\">//define total data element</span><br>    <span class=\"hljs-keyword\">int</span> nElem = <span class=\"hljs-number\">1024</span>;<br>    <br>    <span class=\"hljs-comment\">//define grid and block structure</span><br>    <span class=\"hljs-function\">dim3 <span class=\"hljs-title\">block</span>\t<span class=\"hljs-params\">(<span class=\"hljs-number\">1024</span>)</span></span>;<br>    <span class=\"hljs-function\">dim3 <span class=\"hljs-title\">grid</span> <span class=\"hljs-params\">((nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x)</span></span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d block.x %d \\n&quot;</span>,grid.x, block.x);<br>    <br>    <span class=\"hljs-comment\">//reset block</span><br>    block.x = <span class=\"hljs-number\">512</span>;<br>    grid.x = (nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d block.x %d \\n&quot;</span>,grid.x, block.x);<br>    <br>    <span class=\"hljs-comment\">//reset block</span><br>    block.x = <span class=\"hljs-number\">256</span>;<br>    grid.x = (nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d block.x %d \\n&quot;</span>,grid.x, block.x);<br>    <br>    <span class=\"hljs-comment\">//reset block</span><br>    block.x = <span class=\"hljs-number\">128</span>;<br>    grid.x = (nElem+block.x<span class=\"hljs-number\">-1</span>)/block.x;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;grid.x %d block.x %d \\n&quot;</span>,grid.x, block.x);<br>    <br>    <span class=\"hljs-comment\">//reset device before you leave</span><br>    <span class=\"hljs-built_in\">cudaDeviceReset</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>用下列命令编译和运行这段程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">nvcc defineGridBlock.cu\t-o block<br>./block<br></code></pre></div></td></tr></table></figure>\n\n<p>下面是一个输出示例。由于应用程序中的数据大小是固定的，因此当块的大小发生改变时，相应的网格尺寸也会发生改变。</p>\n<p><img src=\"/2023/01/28/cuda006/image-20230129174300533.png\" alt=\"image-20230129174300533\"></p>\n<h3 id=\"4-线程层次结构\"><a href=\"#4-线程层次结构\" class=\"headerlink\" title=\"4.线程层次结构\"></a>4.线程层次结构</h3><p>CUDA的特点之一就是通过编程模型揭示了一个两层的线程层次结构。由于一个内核启动的网格和块的维数会影响性能，这一结构为程序员优化程序提供了一个额外的途径。</p>\n<p>网格和块的维度存在几个限制因素，对于块大小的一个主要限制因素就是可利用的计算资源，如寄存器，共享内存等。某些限制可以通过查询GPU设备撤回。</p>\n<p>网格和块从逻辑上代表了一个核函数的线程层次结构。</p>\n<h3 id=\"5-参考资料\"><a href=\"#5-参考资料\" class=\"headerlink\" title=\"5.参考资料\"></a>5.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "http://example.com/2023/01/28/avx006/",
            "url": "http://example.com/2023/01/28/avx006/",
            "title": "如何使用AVX和AVX2处理数据(个人翻译)[未完成]",
            "date_published": "2023-01-28T06:51:44.000Z",
            "content_html": "<h2 id=\"1-文章来源\"><a href=\"#1-文章来源\" class=\"headerlink\" title=\"1.文章来源\"></a>1.文章来源</h2><p><strong>Matt Scarpino</strong></p>\n<p><a href=\"https://www.codeproject.com/Articles/874396/Crunching-Numbers-with-AVX-and-AVX\">Crunching Numbers with AVX and AVX2 - CodeProject</a></p>\n<h2 id=\"2-介绍\"><a href=\"#2-介绍\" class=\"headerlink\" title=\"2.介绍\"></a>2.介绍</h2><p>在2003年，<a href=\"https://www.codeproject.com/script/Membership/View.aspx?mid=22834\">Alex Fr</a>写了一篇优秀的<a href=\"https://www.codeproject.com/Articles/4522/Introduction-to-SSE-Programming\">文章</a>[该文章现在已经被原作者删除]，解释了如何使用Intel的流式SIMD扩展(SSE)执行SIMD(单指令，多数据)处理。SSE是英特尔处理器支持的一组指令，可对大量数据执行高速运算。</p>\n<p>2008年，英特尔推出了一套新的高性能指令，称为高级向量扩展(AVX)。AVX执行许多与SSE指令相同的操作，但以更快的速度对更大的数据块进行操作。最近，英特尔在AVX2和AVX512系列中发布了额外的指令。本文的重点是通过称为intrinsic funtions的特殊C函数访问AVX和AVX2指令。</p>\n<p>本文不介绍整个AVX&#x2F;AVX2 intrinsics，而是侧重于数学计算。特别地，目标是复数相乘。要使用AVX&#x2F;AVX2执行此操作，需要三种类型的intrinsic:</p>\n<ol>\n<li>Initialization intrinscis</li>\n<li>Arithmetic intrinsics</li>\n<li>Permute&#x2F;shuffle intrinsics</li>\n</ol>\n<p>\t\t</p>\n<p>本文讨论每个类别中的intrinsics，并解释如何在代码中使用它们。本文的最后将展示如何用这些intrinsic进行乘法复数运算。</p>\n<p>理解处理器指令和intrinsic function之间的区别是很重要的。AVX指令是执行不可分割操作的汇编命令。例如，AVX指令vaddps添加了两个操作数，并将结果放在第三个操作数中。</p>\n<p>要在C&#x2F;C++中执行操作，the intrinsic funtion _mm256_add_ps()直接映射到vaddps，将汇编的性能与高级函数的便利性结合起来。An intrinsic funtion不一定映射到单个指令，但与其他C&#x2F; C++函数相比，AVX&#x2F;AVX2 intrinsics提供了可靠的高性能。</p>\n<h2 id=\"3-基本要求\"><a href=\"#3-基本要求\" class=\"headerlink\" title=\"3.基本要求\"></a>3.基本要求</h2><p>要理解本文的内容，您需要基本熟悉C语言和SIMD处理。要执行代码，您需要一个支持AVX或AVX&#x2F;AVX2的CPU。以下是支持AVX的cpu:</p>\n<ul>\n<li>Intel’s Sandy Bridge&#x2F;Sandy Bridge E&#x2F;Ivy Bridge&#x2F;Ivy Bridge E</li>\n<li>Intel’s Haswell&#x2F;Haswell E&#x2F;Broadwell&#x2F;Broadwell E</li>\n<li>AMD’s Bulldozer&#x2F;Piledriver&#x2F;Steamroller&#x2F;Excavator</li>\n</ul>\n<p>支持AVX2的CPU也支持AVX。以下是这些设备:</p>\n<ul>\n<li>Intel’s Haswell&#x2F;Haswell E&#x2F;Broadwell&#x2F;Broadwell E</li>\n<li>AMD’s Excavator</li>\n</ul>\n<p>本文中讨论的大多数函数都是由AVX提供的。但也有一些是AVX2特有的。为了区分它们，在本文的表中，我在AVX2 intrinsic的名称前面加上(2)。</p>\n<p>[个人补充]</p>\n<p>判断自己电脑CPU是否支持AVX和AVX2，最简单的就是在命令行执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">lscpu<br></code></pre></div></td></tr></table></figure>\n\n<p>你会得到以下结果：</p>\n<p><img src=\"/2023/01/28/avx006/image-20230129153048825.png\" alt=\"image-20230129153048825\"></p>\n<p>在Flags里面你可以清楚的看到你的电脑是否支持AVX以及AVX2。</p>\n<h2 id=\"4-向量化概述\"><a href=\"#4-向量化概述\" class=\"headerlink\" title=\"4.向量化概述\"></a>4.向量化概述</h2><p>AVX指令通过同时处理大块值而不是单独处理值来提高应用程序的性能。这些值块称为向量，AVX向量最多可以包含256位数据。</p>\n<p>常见的AVX向量包含4个double (4 x 64位&#x3D; 256)，8个float (8 x 32位&#x3D; 256)或8个int (8 x 32位&#x3D; 256)。[double 8B, flout 4B, int 4B]</p>\n<p>一个示例将演示AVX&#x2F;AVX2处理的强大功能。假设一个函数需要将一个数组的8个浮点数乘以第二个数组的8个浮点数，并将结果添加到第三个数组。如果没有向量化，函数可能是这样的:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">multiply_and_add</span>(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">float</span>* a, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">float</span>* b, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">float</span>* c, <span class=\"hljs-keyword\">float</span>* d) &#123;  <br><br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">8</span>; i++) &#123;<br>    d[i] = a[i] * b[i];<br>    d[i] = d[i] + c[i];<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>下面是使用AVX2函数的例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">__m256 <span class=\"hljs-title\">multiply_and_add</span><span class=\"hljs-params\">(__m256 a, __m256 b, __m256 c)</span> </span>&#123;<br><br>  <span class=\"hljs-keyword\">return</span> _mm256_fmadd_ps(a, b, c);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>This AVX2 intrinsic funtion _mm256_fmadd_ps处理24个floats，但它不映射到单个指令。相反，它执行三个指令:vfmadd132ps、vfmadd213ps和vfmadd231ps。尽管如此，它执行得很快，比遍历单个元素快得多。尽管英特尔的intrinsics功能强大，但它们还是让许多程序员感到紧张。这通常有两个原因。首先，数据类型有奇怪的名字，比如__m256。其次，函数有奇怪的名称，如_mm256_fmadd_ps。因此，在详细讨论intrinsic funtions之前，我想先讨论一下Intel的数据类型和命名约定。</p>\n<h2 id=\"5-AVX编程基础\"><a href=\"#5-AVX编程基础\" class=\"headerlink\" title=\"5.AVX编程基础\"></a>5.AVX编程基础</h2><p>本文主要关注AVX和AVX2提供的与数学相关的intrinsic functions。但在看函数之前，有三点很重要:</p>\n<ul>\n<li>Data types</li>\n<li>Function naming conventions</li>\n<li>Compiling AVX applications</li>\n</ul>\n<p>本节涉及这些要点，并提供一个简单的应用程序，用于从一个向量减去另一个向量。</p>\n<h3 id=\"5-1数据类型\"><a href=\"#5-1数据类型\" class=\"headerlink\" title=\"5.1数据类型\"></a>5.1数据类型</h3><p>少数intrinsic接受传统的数据类型，如ints或floats，但大多数intrinsic操作有特定的AVX和AVX2的数据类型。有六种主要的向量类型，表1列出了它们。</p>\n<p><strong>Table 1:AVX&#x2F;AVX2 Data Types</strong></p>\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>__m128</code></td>\n<td>128-bit vector containing 4 <code>float</code>s</td>\n</tr>\n<tr>\n<td><code>__m128d</code></td>\n<td>128-bit vector containing 2 <code>double</code>s</td>\n</tr>\n<tr>\n<td><code>__m128i</code></td>\n<td>128-bit vector containing integers</td>\n</tr>\n<tr>\n<td><code>__m256</code></td>\n<td>256-bit vector containing 8 <code>float</code>s</td>\n</tr>\n<tr>\n<td><code>__m256d</code></td>\n<td>256-bit vector containing 4 <code>double</code>s</td>\n</tr>\n<tr>\n<td><code>__m256i</code></td>\n<td>256-bit vector containing integers</td>\n</tr>\n</tbody></table>\n<p>每种类型都以两个下划线、一个m和向量的宽度(以位为单位)开始。AVX512支持以_m512开头的512位向量类型，但AVX&#x2F;AVX2向量不超过256位。如果向量类型以d结尾，则代表double，如果没有后缀，则代表float。看起来_m128i和_m256i向量必须包含int型，但事实并非如此。整数向量类型可以包含任何类型的整数，from chars to shorts to unsigned long longs.That is, an _m256i may contain 32 chars, 16 shorts, 8 ints, or 4 longs.  These integers can be signed or unsigned.</p>\n<h3 id=\"5-3函数命名约定\"><a href=\"#5-3函数命名约定\" class=\"headerlink\" title=\"5.3函数命名约定\"></a>5.3函数命名约定</h3><p>AVX&#x2F;AVX2 intrinsics的名称一开始可能令人困惑，但命名约定确是非常直白的。一旦你理解了它，你就可以通过看它的名字来大致判断一个函数是做什么的。AVX&#x2F;AVX2 intrinsics的一般形式如下:</p>\n<p>_mm<bit_width>_<name>_<data_type></data_type></name></bit_width></p>\n<p>该格式的各部分如下所示:</p>\n<ol>\n<li><code>&lt;bit_width&gt;</code> identifies the size of the vector returned by the function. For 128-bit vectors, this is empty. For 256-bit vectors, this is set to <code>256</code>.</li>\n<li><code>&lt;name&gt;</code> describes the operation performed by the intrinsic</li>\n<li><code>&lt;data_type&gt;</code> identifies the data type of the function’s primary arguments</li>\n</ol>\n<p>最后一部分<data_type>有点复杂。它标识输入值的内容，可以设置为以下任何值:</data_type></p>\n<ul>\n<li><code>ps</code> - vectors contain <code>float</code>s (<code>ps</code> stands for packed single-precision)</li>\n<li><code>pd</code> - vectors contain <code>double</code>s (<code>pd</code> stands for packed double-precision)</li>\n<li><code>epi8/epi16/epi32/epi64</code> - vectors contain 8-bit&#x2F;16-bit&#x2F;32-bit&#x2F;64-bit signed integers</li>\n<li><code>epu8/epu16/epu32/epu64</code> - vectors contain 8-bit&#x2F;16-bit&#x2F;32-bit&#x2F;64-bit unsigned integers</li>\n<li><code>si128</code>&#x2F;<code>si256</code> - unspecified 128-bit vector or 256-bit vector</li>\n<li><code>m128/m128i/m128d/m256/m256i/m256d</code> - identifies input vector types when they’re different than the type of the returned vector</li>\n</ul>\n<p>例如，考虑_mm256_srlv_epi64。即使您不知道srlv是什么意思，_mm256前缀告诉您该函数返回一个256位向量，_epi64告诉您参数包含64位有符号整数。</p>\n<p>作为第二个示例，考虑_mm_testnzc_ps。_mm表示函数返回一个128位的向量。末尾的_ps表示参数向量包含浮点数。</p>\n<p>AVX数据类型以两个下划线和一个m开头。函数以一个下划线和两个ms开头。我很容易搞混这一点，所以我想出了一种方法来记住它们的区别:数据类型代表内存，函数代表多媒体操作。这是我能做的最好的了。</p>\n<h3 id=\"5-4构建AVX应用程序\"><a href=\"#5-4构建AVX应用程序\" class=\"headerlink\" title=\"5.4构建AVX应用程序\"></a>5.4构建AVX应用程序</h3><p>要构建使用AVX intrinsic的应用程序，不需要链接任何库。但是您需要包含imminrin .h头文件。此头文件包括将AVX&#x2F;AVX2函数映射到指令的其他头文件。</p>\n<p>hello_avx.c中的代码显示了一个基本的AVX应用程序的样子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;immintrin.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><br>  <span class=\"hljs-comment\">/* Initialize the two argument vectors */</span>\t\t\t<span class=\"hljs-comment\">//初始化</span><br>  __m256 evens = _mm256_set_ps(<span class=\"hljs-number\">2.0</span>, <span class=\"hljs-number\">4.0</span>, <span class=\"hljs-number\">6.0</span>, <span class=\"hljs-number\">8.0</span>, <span class=\"hljs-number\">10.0</span>, <span class=\"hljs-number\">12.0</span>, <span class=\"hljs-number\">14.0</span>, <span class=\"hljs-number\">16.0</span>);<br>  __m256 odds = _mm256_set_ps(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">3.0</span>, <span class=\"hljs-number\">5.0</span>, <span class=\"hljs-number\">7.0</span>, <span class=\"hljs-number\">9.0</span>, <span class=\"hljs-number\">11.0</span>, <span class=\"hljs-number\">13.0</span>, <span class=\"hljs-number\">15.0</span>);<br><br>  <span class=\"hljs-comment\">/* Compute the difference between the two vectors */</span><br>  __m256 result = _mm256_sub_ps(evens, odds);\t\t\t<span class=\"hljs-comment\">//减法</span><br><br>  <span class=\"hljs-comment\">/* Display the elements of the result vector */</span><br>  <span class=\"hljs-keyword\">float</span>* f = (<span class=\"hljs-keyword\">float</span>*)&amp;result;\t\t\t\t\t<span class=\"hljs-comment\">//类型转换</span><br>  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%f %f %f %f %f %f %f %f\\n&quot;</span>,<br>    f[<span class=\"hljs-number\">0</span>], f[<span class=\"hljs-number\">1</span>], f[<span class=\"hljs-number\">2</span>], f[<span class=\"hljs-number\">3</span>], f[<span class=\"hljs-number\">4</span>], f[<span class=\"hljs-number\">5</span>], f[<span class=\"hljs-number\">6</span>], f[<span class=\"hljs-number\">7</span>]);<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>要构建应用程序，需要告诉编译器该体系结构支持AVX。这个标志取决于编译器，gcc需要-mavx标志。因此，可以使用以下命令编译hello_avx.c源文件:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">gcc -mavx -o hello_avx hello_avx.c<br></code></pre></div></td></tr></table></figure>\n\n<p>在本例中，所有函数都以_mm256开始，以_ps结束，因此我希望所有操作都清楚地涉及包含floats的256位向量。我还希望结果向量中的每个元素都等于1.0。如果运行应用程序，您将看到情况就是这样。</p>\n<h3 id=\"5-5初始化intrinsics\"><a href=\"#5-5初始化intrinsics\" class=\"headerlink\" title=\"5.5初始化intrinsics\"></a>5.5初始化intrinsics</h3><p>在对AVX向量进行操作之前，需要用数据填充向量。因此，本文讨论的第一组intrinsics用数据初始化向量。有两种方法:用标量值初始化向量和用从内存加载的数据初始化向量。</p>\n<h4 id=\"5-5-1使用标量值初始化\"><a href=\"#5-5-1使用标量值初始化\" class=\"headerlink\" title=\"5.5.1使用标量值初始化\"></a>5.5.1使用标量值初始化</h4><p>AVX提供了将一个或多个值组合成256位向量的intrinsics funtions。表2列出了它们的名称，并提供了每个名称的描述。也有类似的intrinsics初始化128位向量，但它们是由SSE提供的，而不是AVX。函数名的唯一区别是_mm256_被替换为_mm_。</p>\n<p><strong>Table 2: Initialization Intrinsics</strong></p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>_mm256_setzero_ps/pd</code></td>\n<td>Returns a floating-point vector filled with zeros</td>\n</tr>\n<tr>\n<td><code>_mm256_setzero_si256</code></td>\n<td>Returns an integer vector whose bytes are set to zero</td>\n</tr>\n<tr>\n<td><code>_mm256_set1_ps/pd</code></td>\n<td>Fill a vector with a floating-point value</td>\n</tr>\n<tr>\n<td><code>_mm256_set1_epi8/epi16</code> <code>_mm256_set1_epi32/epi64</code></td>\n<td>Fill a vector with an integer</td>\n</tr>\n<tr>\n<td><code>_mm256_set_ps/pd</code></td>\n<td>Initialize a vector with eight floats (ps) or four doubles (pd)</td>\n</tr>\n<tr>\n<td><code>_mm256_set_epi8/epi16</code> <code>_mm256_set_epi32/epi64</code></td>\n<td>Initialize a vector with integers</td>\n</tr>\n<tr>\n<td><code>_mm256_set_m128/m128d/</code> <code>_mm256_set_m128i</code></td>\n<td>Initialize a 256-bit vector with two 128-bit vectors</td>\n</tr>\n<tr>\n<td><code>_mm256_setr_ps/pd</code></td>\n<td>Initialize a vector with eight floats (ps) or four doubles (pd) in reverse order</td>\n</tr>\n<tr>\n<td><code>_mm256_setr_epi8/epi16</code> <code>_mm256_setr_epi32/epi64</code></td>\n<td>Initialize a vector with integers in reverse order</td>\n</tr>\n</tbody></table>\n<p>表中的第一个函数是最容易理解的。_m256_setzero_ps返回一个__m256向量，包含8个设置为0的浮点数。类似地，_m256_setzero_si256返回一个__m256i向量，其字节被设置为0。例如，下面这行代码创建了一个256位的向量，其中包含4个设为0的double:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">_m256d dbl_vector = _m256_setzero_pd();<br></code></pre></div></td></tr></table></figure>\n\n<p>名称中包含set1的函数接受一个值，并在整个向量中重复该值。例如，下面这行代码创建了一个__m256i，它的16个short value被设置为47:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">_m256i short_vector = _m256_set1_pd();<br></code></pre></div></td></tr></table></figure>\n\n<p>表2中的其他函数包含_set_或_setr_。这些函数接受一系列值，每个向量的元素对应一个值。这些值被放置在返回的向量中，理解顺序很重要。下面的函数调用返回一个包含8个整数的向量，其值范围为1到8:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">_m256i int_vector = _m256_set_epi32(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>);<br></code></pre></div></td></tr></table></figure>\n\n<p>您可能希望值按照给定的顺序存储。但英特尔的架构是小端存储类型的，所以最低有效值(8)先存储，最高有效值(1)最后存储。您可以通过将int_vector转换为int指针并打印存储的值来验证这一点。如下代码所示:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256i int_vector = _mm256_set_epi32(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>);<br><span class=\"hljs-keyword\">int</span> *ptr = (<span class=\"hljs-keyword\">int</span>*)&amp;int_vector;<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d %d %d %d %d %d %d\\n&quot;</span>, ptr[<span class=\"hljs-number\">0</span>], ptr[<span class=\"hljs-number\">1</span>], ptr[<span class=\"hljs-number\">2</span>], ptr[<span class=\"hljs-number\">3</span>], ptr[<span class=\"hljs-number\">4</span>], ptr[<span class=\"hljs-number\">5</span>], ptr[<span class=\"hljs-number\">6</span>], ptr[<span class=\"hljs-number\">7</span>]);<br>--&gt; <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span><br></code></pre></div></td></tr></table></figure>\n\n<p>如果希望值按给定顺序存储，可以使用_setr_函数之一创建向量，其中r可能代表reverse。下面的代码展示了它是如何工作的:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256i int_vector = _mm256_setr_epi32(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>);<br><span class=\"hljs-keyword\">int</span> *ptr = (<span class=\"hljs-keyword\">int</span>*)&amp;int_vector;<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d %d %d %d %d %d %d\\n&quot;</span>, ptr[<span class=\"hljs-number\">0</span>], ptr[<span class=\"hljs-number\">1</span>], ptr[<span class=\"hljs-number\">2</span>], ptr[<span class=\"hljs-number\">3</span>], ptr[<span class=\"hljs-number\">4</span>], ptr[<span class=\"hljs-number\">5</span>], ptr[<span class=\"hljs-number\">6</span>], ptr[<span class=\"hljs-number\">7</span>]);<br>--&gt; <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span><br></code></pre></div></td></tr></table></figure>\n\n<p>有趣的是，AVX和AVX2都没有提供用无符号整数初始化向量的intrinsic。但是，它们提供了对带无符号整数的向量进行操作的函数。</p>\n<h4 id=\"5-5-2从内存加载数据\"><a href=\"#5-5-2从内存加载数据\" class=\"headerlink\" title=\"5.5.2从内存加载数据\"></a>5.5.2从内存加载数据</h4><p>AVX&#x2F;AVX2的一个常见用法是将数据从内存加载到向量中，对向量进行处理，并将结果存储回内存。第一步是使用表3中列出的intrinsic funtions完成的。最后两个函数前面有(2)，因为它们是由AVX2而不是AVX提供的。</p>\n<p><strong>Table 3: Vector Load Intrinsics</strong></p>\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>_mm256_load_ps/pd</code></td>\n<td>Loads a floating-point vector from an  aligned memory address</td>\n</tr>\n<tr>\n<td><code>_mm256_load_si256</code></td>\n<td>Loads an integer vector from an aligned memory address</td>\n</tr>\n<tr>\n<td><code>_mm256_loadu_ps/pd</code></td>\n<td>Loads a floating-point vector from an  unaligned memory address</td>\n</tr>\n<tr>\n<td><code>_mm256_loadu_si256</code></td>\n<td>Loads an integer vector from an unaligned memory address</td>\n</tr>\n<tr>\n<td><code>_mm_maskload_ps/pd</code> <code>_mm256_maskload_ps/pd</code></td>\n<td>Load portions of a 128-bit&#x2F;256-bit floating-point vector according to a mask</td>\n</tr>\n<tr>\n<td><code>(2)_mm_maskload_epi32/64</code> <code>(2)_mm256_maskload_epi32/64</code></td>\n<td>Load portions of a 128-bit&#x2F;256-bit integer vector according to a mask</td>\n</tr>\n</tbody></table>\n<p>当将数据加载到向量中时，内存对齐变得特别重要。每个_mm256_load_* intrinsic接受一个必须在32字节边界上对齐的内存地址。即地址必须能被32整除。下面的代码展示了如何在实践中使用它:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">float</span>* aligned_floats = (<span class=\"hljs-keyword\">float</span>*)<span class=\"hljs-built_in\">aligned_alloc</span>(<span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">64</span> * <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">float</span>));\t\t<span class=\"hljs-comment\">//这里使用了内存对齐</span><br>... Initialize data ...<br>__m256 vec = _mm256_load_ps(aligned_floats);<br></code></pre></div></td></tr></table></figure>\n\n<p>【个人补充】关于内存对齐以及相关函数</p>\n<p><a href=\"https://xingyuanjie.top/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/\">内存对齐 - Amicoyuan (xingyuanjie.top)</a></p>\n<p><a href=\"https://xingyuanjie.top/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/\">AVX向量化学习(二)-内存对齐的应用 - Amicoyuan (xingyuanjie.top)</a></p>\n<p>任何使用_m256_load_*加载未对齐数据的尝试都会造成segmentation fault。如果数据不是在32位边界对齐，则应该使用_m256_loadu_*函数。如下代码所示:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">float</span>* unaligned_floats = (<span class=\"hljs-keyword\">float</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">64</span> * <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">float</span>));\t\t\t\t<span class=\"hljs-comment\">//未使用内存对齐</span><br>... Initialize data ...<br>__m256 vec = _mm256_loadu_ps(unaligned_floats);<br></code></pre></div></td></tr></table></figure>\n\n<p>假设你想用AVX向量处理一个浮点数组(float)，但是数组的长度是11，不能被8整除。在这种情况下，第二个__m256向量的最后五个浮点数需要设置为0，这样它们就不会影响计算。这种选择性加载可以用表3底部的_maskload_函数来完成。</p>\n<p>每个_maskload_函数接受两个参数:一个内存地址和一个与返回向量元素数量相同的整数向量。对于整数向量中最高位为1的每个元素，将从内存中读取返回向量中相应的元素。如果整数向量中的最高位为零，则返回向量中的相应元素被设置为零。</p>\n<p>一个示例将说明如何使用这些函数。mask_load.c中的代码将8个整型读入一个向量，最后3个应该设置为0。要使用的函数是_mm256_maskload_epi32，它的第二个参数应该是__m256i掩码向量。这个掩码向量包含5个最高位为1的整数和3个最高位为0的整数。下面是代码的样子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;immintrin.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><br>  <span class=\"hljs-keyword\">int</span> i;<br>  <br>  <span class=\"hljs-keyword\">int</span> int_array[<span class=\"hljs-number\">8</span>] = &#123;<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">700</span>, <span class=\"hljs-number\">800</span>&#125;;<br>  <br>  <span class=\"hljs-comment\">/* Initialize the mask vector */</span><br>  __m256i mask = _mm256_setr_epi32(<span class=\"hljs-number\">-20</span>, <span class=\"hljs-number\">-72</span>, <span class=\"hljs-number\">-48</span>, <span class=\"hljs-number\">-9</span>, <span class=\"hljs-number\">-100</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>);\t<span class=\"hljs-comment\">//这里需要充分理解计算机组成原理中的补码</span><br><br>  <span class=\"hljs-comment\">/* Selectively load data into the vector */</span><br>  __m256i result = _mm256_maskload_epi32(int_array, mask);<br>  <br>  <span class=\"hljs-comment\">/* Display the elements of the result vector */</span><br>  <span class=\"hljs-keyword\">int</span>* res = (<span class=\"hljs-keyword\">int</span>*)&amp;result;<br>  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d %d %d %d %d %d %d\\n&quot;</span>, <br>    res[<span class=\"hljs-number\">0</span>], res[<span class=\"hljs-number\">1</span>], res[<span class=\"hljs-number\">2</span>], res[<span class=\"hljs-number\">3</span>], res[<span class=\"hljs-number\">4</span>], res[<span class=\"hljs-number\">5</span>], res[<span class=\"hljs-number\">6</span>], res[<span class=\"hljs-number\">7</span>]);<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>如果您在支持AVX2的系统上运行此应用程序，它将打印以下结果:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-number\">100</span> <span class=\"hljs-number\">200</span> <span class=\"hljs-number\">300</span> <span class=\"hljs-number\">400</span> <span class=\"hljs-number\">500</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<p>有三点是需要注意的：</p>\n<ol>\n<li>代码使用_setr_函数而不是_set_来设置掩码向量的内容，因为它在将向量元素传递给函数时对它们进行排序。</li>\n<li>负整数的最高位总是1。这就是掩码向量包含五个负数和三个正数的原因。</li>\n<li>_mm256_maskload_epi32函数由AVX2提供，而不是AVX。因此，要用gcc编译这段代码，必须使用-mavx2标志而不是-mavx。</li>\n</ol>\n<p>除了表3中列出的函数之外，AVX2还提供了从内存加载索引数据的集合函数。</p>\n<h2 id=\"6-Arithmetic-Intrinsics\"><a href=\"#6-Arithmetic-Intrinsics\" class=\"headerlink\" title=\"6.Arithmetic Intrinsics\"></a>6.Arithmetic Intrinsics</h2><p>数学是AVX存在的主要原因，基本操作是加、减、乘和除。本节将介绍执行这些操作的intrinsic funtions，还将介绍AVX2提供的新的融合乘法和加法函数。</p>\n<h3 id=\"6-1加法和减法\"><a href=\"#6-1加法和减法\" class=\"headerlink\" title=\"6.1加法和减法\"></a>6.1加法和减法</h3><p>表4列出了执行加法和减法的AVX&#x2F;AVX2 intrinsic。由于考虑到饱和度，它们大多数都作用于包含整数的向量。</p>\n<p><strong>Table 4: Addition and Subtraction Intrinsics</strong></p>\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>_mm256_add_ps/pd</code></td>\n<td>Add two floating-point vectors</td>\n</tr>\n<tr>\n<td><code>_mm256_sub_ps/pd</code></td>\n<td>Subtract two floating-point vectors</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_add_epi8/16/32/64 </code></td>\n<td>Add two integer vectors</td>\n</tr>\n<tr>\n<td><code>(2)_mm236_sub_epi8/16/32/64</code></td>\n<td>Subtract two integer vectors</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_adds_epi8/16</code> <code>(2)_mm256_adds_epu8/16 </code></td>\n<td>Add two integer vectors with saturation</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_subs_epi8/16</code> <code>(2)_mm256_subs_epu8/16</code></td>\n<td>Subtract two integer vectors with saturation</td>\n</tr>\n<tr>\n<td><code>_mm256_hadd_ps/pd</code></td>\n<td>Add two floating-point vectors horizontally</td>\n</tr>\n<tr>\n<td><code>_mm256_hsub_ps/pd</code></td>\n<td>Subtract two floating-point vectors horizontally</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_hadd_epi16/32</code></td>\n<td>Add two integer vectors horizontally</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_hsub_epi16/32</code></td>\n<td>Subtract two integer vectors horizontally</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_hadds_epi16</code></td>\n<td>Add two vectors containing shorts horizontally with saturation</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_hsubs_epi16</code></td>\n<td>Subtract two vectors containing shorts horizontally with saturation</td>\n</tr>\n<tr>\n<td><code>_mm256_addsub_ps/pd</code></td>\n<td>Add and subtract two floating-point vectors</td>\n</tr>\n</tbody></table>\n<p>在加法和减法整数向量时，重要的是要查看_add_&#x2F;_sub_函数和_adds_&#x2F;_subs_函数之间的区别。额外的s代表饱和，当结果需要的内存超过向量可以存储的内存时，就会产生饱和。Functions that take saturation into account clamp the result to the minimum&#x2F;maximum value that can be stored.没有饱和的函数在发生饱和时忽略内存问题。</p>\n<p>例如，假设一个向量包含有符号字节，那么每个元素的最大值是127 (0x7F)。如果一个运算将98加到85，数学和是183 (0xB7)。</p>\n<ul>\n<li>如果使用_mm256_add_epi8添加这些值，饱和度将被忽略，存储的结果将是-73 (0xB7)。</li>\n<li>如果使用_mm256_adds_epi8添加这些值，结果将被固定为最大值127 (0x7F)。</li>\n</ul>\n<p>作为另一个例子，考虑两个包含有符号短整数的向量。最小值为-32,768。如果计算-18,000 - 19,000，数学结果是-37,000 (0xFFFF6F78作为32位整数)。</p>\n<ul>\n<li>如果用_mm256_sub_epi16减去这些值，饱和度将被忽略，存储的结果将是28,536 (0x6F78)。</li>\n<li>如果用_mm256_subs_epi16减去这些值，结果将被压缩到最小值-32,768 (0x8000)。</li>\n</ul>\n<p>_hadd_&#x2F;_hsub_函数水平执行加法和减法。也就是说，它们不是添加或减去不同向量的元素，而是在每个向量中添加或减去相邻的元素。结果以交错的方式存储。图1显示了_mm256_hadd_pd的工作原理，它水平地添加了两个向量A和B:</p>\n<p><img src=\"/2023/01/28/avx006/Fig1.jpg\" alt=\"Image 1\"></p>\n<p><strong>Figure 1: Horizontal Addition of Two Vectors</strong></p>\n<p>水平加减元素看起来可能很奇怪，但这些操作在复数相乘时很有用。本文稍后将对此进行解释。表4中的最后一个函数_mm256_addsub_ps&#x2F;pd交替减法和加法两个浮点向量的元素。也就是说，偶数元素被减去，奇数元素被加上。例如，如果vec_a包含(0.1,0.2,0.3,0.4)，vec_b包含(0.5,0.6,0.7,0.8)，则_mm256_addsub_pd(vec_a, vec_b)等于(-0.4,0.8，-0.4,1.2)。</p>\n<h3 id=\"6-2乘法和除法\"><a href=\"#6-2乘法和除法\" class=\"headerlink\" title=\"6.2乘法和除法\"></a>6.2乘法和除法</h3><p>表5列出了执行乘法和除法的AVX&#x2F;AVX2 intrinsic。与加法和减法一样，对整数进行运算也有一些特殊的特性。</p>\n<p><strong>Table 5: Multiplication and Division Intrinsics</strong></p>\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>_mm256_mul_ps/pd</code></td>\n<td>Multiply two floating-point vectors</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_mul_epi32/</code> <code>(2)_mm256_mul_epu32 </code></td>\n<td>Multiply the lowest four elements of vectors containing 32-bit integers</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_mullo_epi16/32</code></td>\n<td>Multiply integers and store low halves</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_mulhi_epi16/</code> <code>(2)_mm256_mulhi_epu16</code></td>\n<td>Multiply integers and store high halves</td>\n</tr>\n<tr>\n<td><code>(2)_mm256_mulhrs_epi16</code></td>\n<td>Multiply 16-bit elements to form 32-bit elements</td>\n</tr>\n<tr>\n<td><code>_mm256_div_ps/pd</code></td>\n<td>Divide two floating-point vectors</td>\n</tr>\n</tbody></table>\n<p>如果两个N位的数字在计算机上相乘，结果可以占用2N位。因此，只有_mm256_mul_epi32和_mm256_mul_epu32的四个低元素被乘在一起，结果是一个包含四个长整数的向量。图2显示了它的工作原理:【动态图丢失】</p>\n<p><strong>图2:整数向量的低元素相乘</strong></p>\n<p>_mullo_函数类似于整数_mul_函数，但它们不是乘低元素，而是乘两个向量的每个元素，只存储每个乘积的低一半。图3显示了它的外观:【图片丢失】</p>\n<p><strong>图3:整数相乘和存储低二分之一</strong></p>\n<p>_mm256_mulhi_epi16和_mm256_mulhi_epu16 intrinsics类似，但是它们存储整数积的高一半。</p>\n<h3 id=\"6-3Fused-Multiply-and-Add-FMA\"><a href=\"#6-3Fused-Multiply-and-Add-FMA\" class=\"headerlink\" title=\"6.3Fused Multiply and Add (FMA)\"></a>6.3Fused Multiply and Add (FMA)</h3><p>如前所述，两个N位数字相乘的结果可以占用2N位。</p>\n",
            "tags": [
                "AVX",
                "AVX2"
            ]
        },
        {
            "id": "http://example.com/2023/01/17/cuda005/",
            "url": "http://example.com/2023/01/17/cuda005/",
            "title": "CUDA内存管理",
            "date_published": "2023-01-17T14:03:10.000Z",
            "content_html": "<h3 id=\"1-内存管理\"><a href=\"#1-内存管理\" class=\"headerlink\" title=\"1.内存管理\"></a>1.内存管理</h3><p>CUDA编程模型假设系统是由一个主机和一个设备组成的，而且各自拥有独立的内存。核函数是在设备上运行的。为使你拥有充分的控制权并使系统达到最佳性能，CUDA运行时负责分配与释放设备内存，并且在主机内存和设备内存之间传输数据。表2-1列出了标准的C函数以及相应地针对内存操作的CUDA C函数。</p>\n<p>用于执行GPU内存分配的是cudaMalloc函数，其函数原型为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">cudaError_t <span class=\"hljs-title\">cudaMalloc</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>** devPtr, <span class=\"hljs-keyword\">size_t</span> size)</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/01/17/cuda005/image-20230117223254853.png\" alt=\"image-20230117223254853\"></p>\n<p>该函数负责向设备分配一定字节的线性内存，并以devPtr的形式返回指向所分配内存的指针。cudaMalloc与标准C语言中的malloc函数几乎一样，只是此函数在GPU的内存里分配内存。通过充分保持与标准C语言运行库中的接口一致性，可以实现CUDA应用程序的轻松接入。</p>\n<p>cudaMemcpy函数负责主机和设备之间的数据传输，其函数原型为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">cudaError_t <span class=\"hljs-title\">cudaMencpy</span><span class=\"hljs-params\">( <span class=\"hljs-keyword\">void</span>* dst, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">void</span>* src, <span class=\"hljs-keyword\">size_t</span> count, cudaMemcpyKind kind)</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p>此函数从src指向的源存储区复制一定数量的字节到dst指向的目标存储区。复制方向由kind指定，其中的kind有以下几种。</p>\n<ol>\n<li>cudaMemcpyHostToHost</li>\n<li>cudaMemcpyHostToDevice</li>\n<li>cudaMemcpyDeviceToHost</li>\n<li>cudaMemcpyDeviceToDevice</li>\n</ol>\n<p>这个函数以同步方式执行，因为在cudaMemcpy函数返回以及传输操作完成之前主机应用程序是阻塞的。除了内核启动之外的CUDA调用都会返回一个错误的枚举类型cudaError_t。如果GPU内存分配成功，函数返回：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">cudaSuccess<br></code></pre></div></td></tr></table></figure>\n\n<p>否则返回：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">cudaErrorMemoryAllocation<br></code></pre></div></td></tr></table></figure>\n\n<p>可以使用以下CUDA运行时函数将错误代码转化为可读的错误消息：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">char</span>* <span class=\"hljs-title\">cudaGetErroeString</span><span class=\"hljs-params\">(cudaError_t error)</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p>cudaGetErrorString函数和C语言中的strerror函数类似。</p>\n<p>CUDA编程模型从GPU架构中抽象出一个内存层次结构，图2-3所示的是一个简化的GPU内存结构，它主要包含两部分：全局内存和共享内存。</p>\n<h3 id=\"2-内存层次结构\"><a href=\"#2-内存层次结构\" class=\"headerlink\" title=\"2.内存层次结构\"></a>2.内存层次结构</h3><p>CUDA编程模型最显著的一个特点就是揭示了内存层次结构。每一个GPU设备都有用于不同用途的存储类型。</p>\n<p>在GPU内存层次结构中，最主要的两种内存是全局内存和共享内存。全局类似于CPU的系统内存，而共享内存类似于CPU的缓存。然而GPU的共享内存可以由CUDA C的内核直接控制。</p>\n<p><img src=\"/2023/01/17/cuda005/image-20230128140743600.png\" alt=\"image-20230128140743600\"></p>\n<p>下面，我们将通过一个简单的两个数组相加的例子来学习如何在主机和设备之间进行数据传输，以及如何使用CUDA C编程。如图2-4所示，数组a的第一个元素与数组b的第一个元素相加，得到的结果作为数组c的第一个元素，重复这个过程直到数组中的所有元素都进行了一次运算。‘</p>\n<p><img src=\"/2023/01/17/cuda005/image-20230128141008674.png\" alt=\"image-20230128141008674\"></p>\n<p>首先，执行主机端代码使两个数组相加（如代码清单2-1所示）。</p>\n<h4 id=\"代码清单2-1-sumArraysOnHost-c\"><a href=\"#代码清单2-1-sumArraysOnHost-c\" class=\"headerlink\" title=\"代码清单2-1 sumArraysOnHost.c\"></a>代码清单2-1 sumArraysOnHost.c</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;time.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sumArraysOnHost</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> *A, <span class=\"hljs-keyword\">float</span> *B, <span class=\"hljs-keyword\">float</span> *C, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> N)</span></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> idx=<span class=\"hljs-number\">0</span>;idx&lt;n;idx++)<br>        C[idx]=A[idx]+B[idx];<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initialData</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> *ip,<span class=\"hljs-keyword\">int</span> size)</span></span>&#123;<br>    <span class=\"hljs-comment\">//generate different seed for random number time_t t;</span><br>    <span class=\"hljs-built_in\">srand</span>((<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>) <span class=\"hljs-built_in\">time</span> (&amp;t));<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>        ip[i]=(<span class=\"hljs-keyword\">float</span>)(<span class=\"hljs-built_in\">rand</span>() &amp; OxFF)/<span class=\"hljs-number\">10.0f</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> **argv)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> nElem =<span class=\"hljs-number\">1024</span>;<br>    <span class=\"hljs-keyword\">size_t</span> nBytes = nElem *<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">float</span>);<br>    <br>    <span class=\"hljs-keyword\">float</span> *h_A, *h_B, *h_C;<br>    h_A = (<span class=\"hljs-keyword\">float</span> *)<span class=\"hljs-built_in\">malloc</span>(nBytes);<br>    h_B = (<span class=\"hljs-keyword\">float</span> *)<span class=\"hljs-built_in\">malloc</span>(nBytes);<br>    h_C = (<span class=\"hljs-keyword\">float</span> *)<span class=\"hljs-built_in\">malloc</span>(nBytes);<br>    <br>    <span class=\"hljs-built_in\">initialData</span>(h_A, nElem);<br>    <span class=\"hljs-built_in\">initialData</span>(h_B, nElem);<br>    <br>    <span class=\"hljs-built_in\">sumArraysOnHost</span>(h_A, h_B, h_C, nElem);<br>    <br>    <span class=\"hljs-built_in\">free</span>(h_A);<br>    <span class=\"hljs-built_in\">free</span>(h_B);<br>    <span class=\"hljs-built_in\">free</span>(h_C);<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>\n\n<p>这是一个纯C语言编写的程序，你可以用C语言编译器进行编译，也可以像下面这样用nvcc进行编译。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">nvcc -Xcompiler -std=c99 sumArraysOnHost.c -o sum<br>./sum<br></code></pre></div></td></tr></table></figure>\n\n<p>nvcc封装了几种内部编译工具，CUDA编译器允许通过命令行选项在不同阶段启动不同的工具完成编译工作。-Xcompiler用于指定命令行选项是指向C编译器还是预处理器。在前面的例子中，将-std&#x3D;c99传递给编译器，因为这里的C程序是按照C99标准编写的。</p>\n<p>现在，你可以在GPU上修改代码来进行数组加法运算，用cudaMalloc在GPU上申请内存。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">float</span> *h_A, *h_B, *h_C;<br><span class=\"hljs-built_in\">cudaMalloc</span>((<span class=\"hljs-keyword\">float</span>**)&amp;d_A, nBytes);<br><span class=\"hljs-built_in\">cudaMalloc</span>((<span class=\"hljs-keyword\">float</span>**)&amp;d_B, nBytes);<br><span class=\"hljs-built_in\">cudaMalloc</span>((<span class=\"hljs-keyword\">float</span>**)&amp;d_C, nBytes);<br></code></pre></div></td></tr></table></figure>\n\n<p>使用cudaMemcpy函数把数据从主机内存拷贝到GPU的全局内存中，参考cudaMemcpyHostToDevice指定数据拷贝方向。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">cudaMemcpy</span>(d_A, h_A, nBytes, cudaMemcpyHostToDevice);<br><span class=\"hljs-built_in\">cudaMemcpy</span>(d_B, h_B, nBytes, cudaMemcpyHostToDevice);<br></code></pre></div></td></tr></table></figure>\n\n<p>当数据被转移到GPU的全局内存后，主机端调用核函数在GPU上进行数组求和。一旦内核被调用，控制权立刻被传回主机，这样的话，当核函数在GPU上运行时，主机可以执行其他函数。因此，内核与主机是异步的。</p>\n<p>当内核在GPU上完成了对所有数组元素的处理后，其结果将以数组d_C的形式存储在GPU的全局内存中，然后用cudaMemcpy函数把结果从GPU复制回到主机的数组gpuRef中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">cudaMemcpy</span>(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost);<br></code></pre></div></td></tr></table></figure>\n\n<p>cudaMemcpy的调用会导致主机运行阻塞。cudaMemcpyDeviceToHost的作用就是将存储在GPU上的数组d_C中的结果复制到gpuRef中。最后，调用cudaFree释放GPU的内存。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">cudaFree</span>(d_A);<br><span class=\"hljs-built_in\">cudaFree</span>(d_B);<br><span class=\"hljs-built_in\">cudaFree</span>(d_C);<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3-不同的存储空间\"><a href=\"#3-不同的存储空间\" class=\"headerlink\" title=\"3.不同的存储空间\"></a>3.不同的存储空间</h3><p>使用CUDA C进行编程的人最常犯的错误就是对不同内存空间的不恰当引用。对于在GPU上被分配的内存来说，设备指针在主机代码中可能并没有被引用。如果你执行了错误的内存分配，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">gpuRef = d_C<br></code></pre></div></td></tr></table></figure>\n\n<p>而不是用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">cudaMemcpy</span>(gpuRef, d_C, nBytes, cudaMemcpyDeviceToHost);<br></code></pre></div></td></tr></table></figure>\n\n<p>应用程序在运行时将会崩溃。</p>\n<p>为了避免这类错误，CUDA6.0提出了统一寻址，使用一个指针来访问CPU和GPU的内存</p>\n<h3 id=\"4-参考资料\"><a href=\"#4-参考资料\" class=\"headerlink\" title=\"4.参考资料\"></a>4.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "http://example.com/2023/01/17/cuda004/",
            "url": "http://example.com/2023/01/17/cuda004/",
            "title": "CUDA编程结构",
            "date_published": "2023-01-17T13:36:04.000Z",
            "content_html": "<h2 id=\"CUDA编程结构\"><a href=\"#CUDA编程结构\" class=\"headerlink\" title=\"CUDA编程结构\"></a>CUDA编程结构</h2><p>CUDA编程模型使用由C语言扩展生成的注释代码在异构计算系统中执行应用程序。</p>\n<p>在一个异构环境中包含多个CPU和GPU，每个GPU和CPU的内存都由一条PCI-Express总线分隔开。因此，需要注意区别以下内容。</p>\n<ol>\n<li>主机：CPU及其内存（主机内存）</li>\n<li>设备：GPU及其内存（设备内存）</li>\n</ol>\n<p>为了清楚地指明不同的内存空间，在本书的示例代码中，主机内存中的变量名以h__为前缀，设备内存中的变量名以d__为前缀。</p>\n<p>从CUDA6.0开始，NVDIA提出了名为“统一寻址”（Unified Memory）的编程模型的改进，它连接了主机内存和设备内存空间，可使用单个指针访问CPU和GPU内存，无须彼此之间手动拷贝数据。现在，重要的是应学会如何为主机和设备分配内存空间以及如何在CPU和GPU之间拷贝共享数据。这种程序员管理模式控制下的内存和数据可以优化应用程序并实现硬件系统利用率的最大化。</p>\n<p>内核（kernel）是CUDA编程模型的一个重要组成部分，其代码在GPU上运行。作为一个开发人员，你可以串行的执行核函数。在此背景下，CUDA的调度管理程序员在GPU线程上编写核函数。在主机上，基于应用程序数据以及GPU的性能定义如何让设备实现算法功能。这样做的目的是使你专注于算法的逻辑（通过编写串行代码），且在创建和管理大量的GPU线程时不必拘泥于细节。</p>\n<p>多数情况下，主机可以独立地对设备进行操作。内核一旦被启动，端粒权立刻返回给主机，释放CPU来执行由设备上运行的并行代码实现的额外的任务。CUDA编程模型主要是异步的，因此在GPU上进行的运算可以与主机-设备通信重叠。一个典型的CUDA程序包括由并行代码互补的串行代码。如图2-2所示，串行代码（及任务并行代码）在主机CPU上执行，而并行代码在GPU上执行。主机代码按照ANSI C标准进行编写，而设备代码使用CUDA C进行编写。你可以将所有的代码统一放在一个源文件中，也可以使用多个源文件来构建应用程序和库。NVIDIA的C编译器(nvcc)为主机和设备生成可执行代码。</p>\n<p>一个典型的CUDA程序实现流程遵循以下模式</p>\n<ol>\n<li>把数据从CPU内存拷贝到GPU内存</li>\n<li>调用核函数对存储在GPU内存中的数据进行操作</li>\n<li>将数据从GPU内存传送回到CPU内存</li>\n</ol>\n<p>首先，你要学习的是内存管理及主机和设备之间的数据传输。</p>\n<p><img src=\"/2023/01/17/cuda004/image-20230117220146068.png\" alt=\"image-20230117220146068\"></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "http://example.com/2023/01/17/cuda003/",
            "url": "http://example.com/2023/01/17/cuda003/",
            "title": "CUDA编程模型概述",
            "date_published": "2023-01-17T12:29:01.000Z",
            "content_html": "<h2 id=\"CUDA编程模型概述\"><a href=\"#CUDA编程模型概述\" class=\"headerlink\" title=\"CUDA编程模型概述\"></a>CUDA编程模型概述</h2><p>CUDA编程模型提供了一个计算机架构抽象作为应用程序和其可用硬件之间的桥梁。图2-1说明了程序和编程模型实现之间的抽象结构的重要。通信抽象是程序与编程模型实现之间的分界线，它通过专业的硬件原语和操作系统的编译器或库来实现。利用编程模型所编写的程序指定了程序的各组成部分是如何共享信息及相互协作的。编程模型从逻辑上提供了一个特定的计算机架构，通常它体现在编程语言或编程环境中。</p>\n<p><img src=\"/2023/01/17/cuda003/image-20230117203406633.png\" alt=\"image-20230117203406633\"></p>\n<p>除了与其他并行编程模型共有的抽象外，CUDA编程模型还利用GPU架构的计算能力提供了以下几个特有功能。</p>\n<ol>\n<li>一种通过层次结构在GPU中组织线程的方法</li>\n<li>一种通过层次结构在GPU中访问内存的方法</li>\n</ol>\n<p>以程序员的角度可以从以下几个不同的层面来看待并行计算。</p>\n<ol>\n<li>领域层</li>\n<li>逻辑层</li>\n<li>硬件层</li>\n</ol>\n<p>在编程与算法设计的过程中，你最关心的应是在领域层如何解析数据和函数，以便在并行环境中能正确，高效地解决问题。当进入编程阶段，你的关注点应转向如何组织并发线程。在这个阶段，你需要从逻辑层面来思考，以确保你的线程和计算能正确地解决问题。在C语言并行编程中，需要使用pthreads或OpenMP技术来显式地管理线程。CUDA提出了一个线程层次结构抽象的概念，以允许控制线程行为。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "http://example.com/2023/01/16/cuda002/",
            "url": "http://example.com/2023/01/16/cuda002/",
            "title": "CUDA:一种异构计算平台",
            "date_published": "2023-01-16T09:46:48.000Z",
            "content_html": "<h2 id=\"CUDA-一种异构计算平台\"><a href=\"#CUDA-一种异构计算平台\" class=\"headerlink\" title=\"CUDA:一种异构计算平台\"></a>CUDA:一种异构计算平台</h2><h3 id=\"1-CUDA的简单介绍\"><a href=\"#1-CUDA的简单介绍\" class=\"headerlink\" title=\"1.CUDA的简单介绍\"></a>1.CUDA的简单介绍</h3><p>CUDA是一种通用的并行计算平台和编程模型，它利用NVIDIA GPU中的并行计算引擎能够有效地解决复杂的计算问题。通过使用CUDA，你可以像在CPU上，通过GPU来进行计算。</p>\n<p>CUDA平台可以通过CUDA加速库，编译器指令，应用编程接口以及行业标准程序语言的扩展（包括C,C++,Fortran，Python，如图1-12所示）来使用。</p>\n<p>CUDA C是标准ANSI C语言的一个扩展，它带有的少数语言扩展功能使异构编程成为可能，同时也能通过API来管理设备，内存和其他任务。CUDA还是一个可扩展的编程模型，它使程序能对有不同数量核的GPU明显地扩展其并行性，同时对熟悉C编程语言的程序员来说也比较容易上手。</p>\n<p><img src=\"/2023/01/16/cuda002/image-20230116175503342.png\" alt=\"image-20230116175503342\"></p>\n<p>CUDA提供了两层API来管理GPU设备和组织线程，如图1-13所示。</p>\n<p><img src=\"/2023/01/16/cuda002/image-20230116175610403.png\" alt=\"image-20230116175610403\"></p>\n<p>-CUDA驱动API</p>\n<p>-CUDA运行时API</p>\n<p>驱动API是一种低级API，它相对来说较难编程，但是它对于在GPU设备使用上提供了更多的控制。运行时API是一个高级API，他在驱动API的上层实现。每个运行时API函数都被分解为更多传给驱动API的基本运算。</p>\n<h3 id=\"2-运行时API与驱动API\"><a href=\"#2-运行时API与驱动API\" class=\"headerlink\" title=\"2.运行时API与驱动API\"></a>2.运行时API与驱动API</h3><p>运行时API和驱动API之间没有明显的性能差异。在设备端，内核是如何使用内存以及你是如何组织线程的，对性能有更显著的影响。</p>\n<p>这两种API是相互排斥的，你必须使用两者之一，从两者中混合函数调用是不可能的。本书中所有例子都使用运行时API。</p>\n<p>一个CUDA程序包含了以下两个部分的混合。</p>\n<p>-在CPU上运行的主机代码</p>\n<p>-在GPU上运行的设备代码</p>\n<p>NVIDIA的CUDA nvcc编译器在编译过程中将设备代码从主机代码中分离出来。如图1-14所示，主机代码是标准的C代码，使用C编译器进行编译。设备代码，也就是核函数，是用扩展的带有标记数据并行函数关键字的CUDA C语言编写的。设备代码通过nvcc进行编译。在链接阶段，在内核程序调用和显示GPU设备操作中添加CUDA运行时库。</p>\n<p><img src=\"/2023/01/16/cuda002/image-20230116180725596.png\" alt=\"image-20230116180725596\"></p>\n<p>CUDA nvcc编译器是以广泛使用LLVM开源编译系统为基础的。在GPU加速器的支持下，通过使用CUDA编译器SDK，你可以创建或扩展编程语言，如图1-15所示。</p>\n<p>CUDA平台也是支持多样化并行计算生态系统的基础，如图1-26所示。现在，随着越来越多的公司可以提供全球性的工具，服务和解决方案，CUDA生态系统迅速成长。如果你想在GPU上建立你的应用程序，强化GPU性能最简单方式是使用CUDA工具包（cuda-toolkit），它为C和C++开发人员提供了一个综合的开发环境。CUDA工具包包括编译器，数学库，以及调式和优化应用程序性能的工具。同时提供了代码样例，编程指南，用户手册，API参考文档和其他帮助你入门的文档。</p>\n<p><img src=\"/2023/01/16/cuda002/image-20230116181439404.png\" alt=\"image-20230116181439404\"></p>\n<p><img src=\"/2023/01/16/cuda002/image-20230116181447616.png\" alt=\"image-20230116181447616\"></p>\n<h3 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3.参考资料\"></a>3.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "http://example.com/2023/01/16/cuda001/",
            "url": "http://example.com/2023/01/16/cuda001/",
            "title": "CUDA用GPU输出Hello World",
            "date_published": "2023-01-16T08:58:39.000Z",
            "content_html": "<h2 id=\"用GPU输出Hello-World\"><a href=\"#用GPU输出Hello-World\" class=\"headerlink\" title=\"用GPU输出Hello World\"></a>用GPU输出Hello World</h2><h3 id=\"1-检查环境\"><a href=\"#1-检查环境\" class=\"headerlink\" title=\"1.检查环境\"></a>1.检查环境</h3><p>学习一个新编程语言的最好方式就是使用这种语言来编写程序。在本节，你将开始编写在GPU上运行的第一个内核代码。像其他任何编程语言一样编写GPU上的第一个程序是输出字符串“Hello World”。</p>\n<p>如果这是你第一次使用CUDA,在Linux系统中，你可以想使用以下命令来检查CUDA编译器是否正确安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">which nvcc<br></code></pre></div></td></tr></table></figure>\n\n<p>通常的结果可能是</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">/usr/local/cuda/bin/nvcc<br></code></pre></div></td></tr></table></figure>\n\n<p>你还需要检查你的机器上是否安装了GPU加速卡。对吃你可以在Linux系统上使用以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">ls -l /dev/nv*<br></code></pre></div></td></tr></table></figure>\n\n<p>通常的结果是：</p>\n<p><img src=\"/2023/01/16/cuda001/image-20230116170920773.png\" alt=\"image-20230116170920773\"></p>\n<p>在这个例子中，你发现了两个GPU卡（不同的用户配置可能有所不同，因此显示结果会有所差异）。</p>\n<h3 id=\"2-第一个CUDA-C程序\"><a href=\"#2-第一个CUDA-C程序\" class=\"headerlink\" title=\"2.第一个CUDA C程序\"></a>2.第一个CUDA C程序</h3><p>现在你要准备好写你的第一个CUDA C程序。写一个CUDA C程序，你需要以下几个步骤：</p>\n<ol>\n<li>用专用扩展名.cu来创建一个源文件。</li>\n<li>使用CUDA nvcc编译器来编译程序。</li>\n<li>从命令行运行可执行文件，这个文件有可在GPU上运行的内核代码。</li>\n</ol>\n<p>首先，我们编写一个C语言程序来输出“Hello World”,如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello World from CPU!\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>把代码保存到hello.cu中，然后使用nvcc编译器来编译。CUDA nvcc编译器和gcc编译器及其他编译器有相似的语义</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">nvcc hello.cu -o hello<br></code></pre></div></td></tr></table></figure>\n\n<p>如果你运行可执行文件hello，将会输出：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs angelscript\">Hello World <span class=\"hljs-keyword\">from</span> CPU!<br></code></pre></div></td></tr></table></figure>\n\n<p>接下来，编写一个内核函数，命名为helloFromGPU，用它来输出字符串“Hello World from GPU!”。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">__global__ <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">helloFromGPU</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>)</span></span>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello World from GPU!\\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>修饰符__global__告诉编译器这个函数将会从CPU中调用，然后在GPU上执行。用下面代码启用内核函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">helloFromGPU&lt;&lt;&lt;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">10</span>&gt;&gt;&gt;();<br></code></pre></div></td></tr></table></figure>\n\n<p>三重尖括号意味着从主线程到设备端代码的调用。一个内核函数通过一组线程来执行，所有线程执行相同的代码。三重尖括号里面的参数是执行配置，用来说明使用多少线程来执行内核函数。在这个例子中，有10个GPU线程被调用。综上所述，得到代码清单1-1所示的程序。</p>\n<h3 id=\"3-代码清单1-1Hello-World-from-GPU-hello-cu\"><a href=\"#3-代码清单1-1Hello-World-from-GPU-hello-cu\" class=\"headerlink\" title=\"3.代码清单1-1Hello World from GPU! (hello.cu)\"></a>3.代码清单1-1Hello World from GPU! (hello.cu)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\">__global__ <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">helloFromGPU</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>)</span></span>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello World from GPU!\\n&quot;</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-comment\">//hello from cpu</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello World from CPU!\\n&quot;</span>);<br>    <br>    <br>    helloFromGPU&lt;&lt;&lt;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">10</span>&gt;&gt;&gt;();<br>    <span class=\"hljs-built_in\">cudaDeviceReset</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>函数cudaDeviceRest（）用来显式地释放和清空当前进程中与当前设别有关的所有资源。如下所示，在nvcc命令行中使用-arch sm_20进行编译：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">nvcc -arch sm_20 hello.cu -o hello<br></code></pre></div></td></tr></table></figure>\n\n<p>开关语句-arch sm_20使编译器为Fermi架构生成设备代码。运行这个可执行文件，它将输出10条字符串“Hello World from CPU!”，每个线程输出一条。</p>\n<p><img src=\"/2023/01/16/cuda001/image-20230116173446169.png\" alt=\"image-20230116173446169\"></p>\n<h3 id=\"4-一个典型的CUDA编程结构包括5个主要步骤\"><a href=\"#4-一个典型的CUDA编程结构包括5个主要步骤\" class=\"headerlink\" title=\"4.一个典型的CUDA编程结构包括5个主要步骤\"></a>4.一个典型的CUDA编程结构包括5个主要步骤</h3><ol>\n<li>分配GPU内存</li>\n<li>从CPU内存中拷贝数据到GPU内存</li>\n<li>调用CUDA内核函数来完成程序指定的运算</li>\n<li>将数据从GPU拷回CPU内存</li>\n<li>释放GPU内存空间</li>\n</ol>\n<p>在hello.cu中，你只看到了第三步：调用内核。</p>\n<h3 id=\"5-参考资料\"><a href=\"#5-参考资料\" class=\"headerlink\" title=\"5.参考资料\"></a>5.参考资料</h3><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "http://example.com/2023/01/14/openmp006/",
            "url": "http://example.com/2023/01/14/openmp006/",
            "title": "OpenMP生产者消费者问题(未完结)",
            "date_published": "2023-01-14T14:30:05.000Z",
            "content_html": "<h2 id=\"OpenMP生产者消费者问题\"><a href=\"#OpenMP生产者消费者问题\" class=\"headerlink\" title=\"OpenMP生产者消费者问题\"></a>OpenMP生产者消费者问题</h2><p><strong>本节将讨论一个不适合用parallel for指令或者for指令来并行化的问题。</strong></p>\n<h3 id=\"1-队列\"><a href=\"#1-队列\" class=\"headerlink\" title=\"1.队列\"></a>1.队列</h3><p>队列是一种抽象的数据结构，插入元素时将元素插入到队列“尾部”，而读取元素时，队列“头部”的元素被返回并从队列中被移除。队列可以看做是在超市中等待付款的消费者的抽象，队列中的元素是消费者。新的消费者到达时排在等待队列的尾部，下一个付款离开等待队列的是排在队列头部的消费者。</p>\n<p>当一个新的元素插入到队列的尾部时，通常称这个新的元素“入队”了；当一个元素从队列的头部被移除时，通常称这个元素“出队”了。</p>\n<p>队列在计算机科学中随处可见。例如，如果有多个进程，每个进程都试图向硬盘写入数据，为了确保每次只有一个进程在写硬盘，一种自然而然的方法是将进程组织为队列。换句话说，排在队列第一个的进程在当前进程结束对硬盘的使用后，第一个获得硬盘的访问权限；排在队列第二个的进程在排在队列第一个的进程使用完硬盘后获得硬盘的访问权限，依此类推。</p>\n<p>队列也是在多线程应用程序中经常使用到的数据结构。例如，我们有几个“生产者”线程和几个“消费者”线程。生产者线程“产生”对服务器数据的请求———例如当前股票的价格，而消费者线程通过发现和生成数据（例如，当前股票的价格）来“消费”请求。生产者线程将请求入队，而消费者线程将请求从队列中移除。在这个例子中，只有当消费者线程将请求的数据发送给生产者线程时，进程才会结束。</p>\n<h3 id=\"2-消息传递\"><a href=\"#2-消息传递\" class=\"headerlink\" title=\"2.消息传递\"></a>2.消息传递</h3><p>生产者和消费者问题模型的另外一个应用是在共享内存系统上实现消息传递。每一个线程有一个消息共享队列，当一个线程要向另一个线程“发送消息“时，他将消息放入目标线程的消息队列中。一个线程接受消息时只需从它的消息队列的头部取出消息。</p>\n<p>这里我们将实现一个简单的消息传递程序，在这个程序中，每个线程随机产生整数”消息“和消息的日志目标线程。当创建一条消息后，线程将消息加入到合适的消息队列中。当发送消息之后，该线程查看它自己的消息队列以获知它是否收到了消息，如果它收到了消息，它将从队首的消息出队并打印该消息。每个线程交替发送和接受消息，用户需要指定每个线程发送消息的数目。当一个线程发送完所有消息后，该线程不断接受消息直到所有的线程都已完成，此时所有的线程都结束了。每个线程的伪代码如下。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(send_msgs = <span class=\"hljs-number\">0</span>; sent_msgs &lt; send_max ;sent_msgs++)&#123;<br>    <span class=\"hljs-built_in\">Send_msg</span>();<br>    <span class=\"hljs-built_in\">Try_receive</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">while</span>(!<span class=\"hljs-built_in\">Done</span>())<br>    <span class=\"hljs-built_in\">Try_receive</span>();<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3-发送消息\"><a href=\"#3-发送消息\" class=\"headerlink\" title=\"3.发送消息\"></a>3.发送消息</h3><p>需要注意的是，访问消息队列并将消息入队，可能是一个临界区。尽管我们还没有深入地研究如何实现消息队列，但我们很有可能需要用一个变量来跟踪队列的尾部。例如，使用一个单链表来实现消息队列，链表的尾部对应着队列的尾部。然后，为了有效地进行入队操作，需要存储指向链表尾部的指针，当一条新消息入队时，需要检查和更新这个队尾指针。如果两个线程试图同时进行这些操作，那么可能会丢失一条已经由其中一个线程入队的消息.（画张图能够有助于理解这种情况！）两个操作的结果会发生冲突，因此入队操作形成了临界区。</p>\n<p>Send_msg()函数的伪代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">mesg = <span class=\"hljs-built_in\">random</span>();<br>dest = <span class=\"hljs-built_in\">random</span>() % thread_count;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp critical</span><br><span class=\"hljs-built_in\">Enqueue</span>(queue,dest,my_rank.mesg);<br></code></pre></div></td></tr></table></figure>\n\n<p>注意在上面的实现中，允许线程向它自己发送消息。</p>\n<h3 id=\"4-接受消息\"><a href=\"#4-接受消息\" class=\"headerlink\" title=\"4.接受消息\"></a>4.接受消息</h3><p>接受消息的同步问题与发送消息有些不同。只有消息队列的拥有者（即目标线程）可以从给定的消息队列中获取消息。如果消息队列中至少有两条消息，那么只要每次只出队一条消息，那么出队操作和入队操作就不可能冲突。因此如果队列中至少有两条消息，通过跟踪队列的大小就可以避免任何同步（例如critical指令）</p>\n<p>现在的问题是如何存储队列大小。如果只使用一个变量来存储队列的大小，那么对该变量的操作会形成临界区。然而可以使用两个变量：enqueued和dequeued，那么队列中消息的个数（队列的大小）就为</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">queue_size = enqueued - dequeued<br></code></pre></div></td></tr></table></figure>\n\n<p>并且，唯一能够更新dequeued的线程是消息队列的拥有者。可以看到在一个线程使用enqueued计算队列大小queue_size的同时，另外一个线程可以更新enqueued。为了解释这种情况，假如进程q正在计算queue_size，那么它将可能得到enqueued新的或者旧的值。当queue_size实际值是1或者2时，线程q可能会得到queue_size是0或者1。但这只会引起程序一定的延迟，而不会引起程序错误。如果queue_size本应该是1，却误计算为0，那么线程q延迟一段时间后会试图重新计算队列的大小；如果queue_size本应该是2，却误计算为1，那么线程q将执行临界区指令，虽然这本来是不必要的。</p>\n<p>因此，可以按照如下的方式实现Try_receive:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">queue_size = enqueued - dequeued;<br><span class=\"hljs-keyword\">if</span>(queue_size == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(queue_size == <span class=\"hljs-number\">1</span>)<br>    \t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp critical</span><br>    \t<span class=\"hljs-built_in\">Dequeue</span>(queue,&amp;src,&amp;mesg);<br>\t<span class=\"hljs-keyword\">else</span><br>    \t<span class=\"hljs-built_in\">Dequeue</span>(queue,&amp;src,&amp;mesg);<br>\t<span class=\"hljs-built_in\">Print_message</span>(src,mesg);<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"5-终止检测\"><a href=\"#5-终止检测\" class=\"headerlink\" title=\"5.终止检测\"></a>5.终止检测</h3><p>接下来，我们探讨如何实现Done函数。首先，我们给出一个”直接“的实现，但这个实现隐藏着问题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">queue_size = enqueued - dequeued;<br><span class=\"hljs-keyword\">if</span>(queue_size == <span class=\"hljs-number\">0</span>)<br>    <span class=\"hljs-keyword\">return</span> True;<br><span class=\"hljs-keyword\">else</span><br>    <span class=\"hljs-keyword\">return</span> False;<br></code></pre></div></td></tr></table></figure>\n\n<p>如果线程u执行这段代码，那么很有可能有些线程，如线程v，在线程u计算出queue_size &#x3D; 0后向线程u发送一条消息。当然，线程u在得出queue_size &#x3D; 0后将终止，那么线程v发送给它的消息就永远不会被接受到。</p>\n<p>然而，在我们程序中，每个线程在执行完for循环后将不再发送任何消息。因此可以增加一个计数器done_sending，每个线程在for循环结束后将该计数器加1，Done的实现如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">queue_size = enqueued - dequeued;<br><span class=\"hljs-keyword\">if</span>(queue_size == <span class=\"hljs-number\">0</span> &amp;&amp; done_sending == thread_count)<br>    <span class=\"hljs-keyword\">return</span> TRUE;<br><span class=\"hljs-keyword\">else</span><br>    rerun FALSE;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"6-启动\"><a href=\"#6-启动\" class=\"headerlink\" title=\"6.启动\"></a>6.启动</h3><p>当程序开始执行时，主线程将得到命令行参数并且分配一个数组空间给消息队列，每个线程对应着一个消息队列。由于每个线程可以向其他任意的下次线程发送消息，所以这个数组应该被所有线程共享，而且每个线程可以向任何一个消息队列插入一条消息。消息队列（至少）可以存储：</p>\n<ol>\n<li>消息列表</li>\n<li>队尾指针或索引</li>\n<li>队首指针或索引</li>\n<li>入队消息的数目</li>\n<li>出队消息的数目</li>\n</ol>\n<p>最好将队列存在消息队列的结构体中，为了减少参数传递时复制的开销，最好用指向结构体的指针数组来实现消息队列。因此，一旦主线程分配了队列数组，就可以使用parallel指令开始执行线程，每个线程可以为自己的队列分配存储空间。</p>\n<p>这里一个重要的问题是：一个或者多个线程可能在其他线程之前完成它的队列分配。如果这种情况出现了，那么完成分配的线程可能会试图开始向那些还没有完成队列分配的线程发送消息，这将导致程序崩溃。因此，我们必须确保任何一个线程都必须在所有的线程都完成了队列分配后才开始发送消息。回想一下，之前我们见过一些OpenMP指令在结束时提供隐式路障，即任何一个线程都必须等到组中所有的线程完成了某个程序块后才可以接着执行后续代码。然而，在这个例子中，我们处于parallel块的中间，所以我们不能依赖于OpenMP提供的隐式路障——我们应当使用显式路障。幸运的是，OpenMP提供了相应的指令：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp barrier</span><br></code></pre></div></td></tr></table></figure>\n\n<p>当线程遇到路障时，它将被阻塞，直到组中所有的线程都到达了这个路障。当组中所有的线程都到达了这个路障时，这些线程就可以接着往下执行。</p>\n<h3 id=\"7-atomic指令\"><a href=\"#7-atomic指令\" class=\"headerlink\" title=\"7.atomic指令\"></a>7.atomic指令</h3><p>发送完所有的消息后，每个线程在执行最后的循环以便接受消息之前，需要对done_sending加1.显然，对done_sending的增量操作是临界区，可以通过critical指令来保护它。然后，OpenMP提供了另外一种可能更加高效的指令：atomic指令：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp atomic</span><br></code></pre></div></td></tr></table></figure>\n\n<p>与critical指令不同，它只能保护由一条C语言赋值语句所形成的临界区。此外，语句必须是一下几种形式之一：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">x &lt;op&gt; = &lt;expression&gt;<br>x++;<br>++x;<br>x--;<br>--x;<br></code></pre></div></td></tr></table></figure>\n\n<p><op>可以是以下任意的二元操作符：</op></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">+,*,-,/,&amp;,|,^,&lt;&lt;,<span class=\"hljs-keyword\">or</span> &gt;&gt;<br></code></pre></div></td></tr></table></figure>\n\n<p>这里要记住，<expression>不能引用x。</expression></p>\n<p>需要注意的是，只有x的装载和存储可以确保是受保护的，例如在下面的代码中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp atomic</span><br>x += y++;<br></code></pre></div></td></tr></table></figure>\n\n<p>其他线程对x的更新必须等到该线程对x的更新结束之后。但是对y的更新不受保护，因此程序的结果是不可预测的。</p>\n<p>atomic指令的思想是许多处理器提供专门的装载-修改-存储(load-modify-store)指令。使用这种专门的指令而不使用保护临界区的通用结构，可以更高效地保护临界区。</p>\n<h3 id=\"8-临界区和锁\"><a href=\"#8-临界区和锁\" class=\"headerlink\" title=\"8.临界区和锁\"></a>8.临界区和锁</h3><p>为了完成对消息传递程序的讨论，我们需要进一步仔细研究OpenMP critical指令的规范。在更早的例子中，程序最多只有一个临界区，critical指令强制所有的线程对该区域进行互斥访问。在这个程序中，临界区的使用将更加复杂。我们将在源代码中看到3个在critical或atomic指令后面的代码块：</p>\n<ol>\n<li>done_sending++</li>\n<li>Enqueue(q_p,my_rank,mesg);</li>\n<li>Dequeue(q_p,&amp;src,&amp;mesg);</li>\n</ol>\n<p>然而，我们不需要强制对3个代码块都进行互斥访问，甚至不需要强制对第二个和第三个代码块进行完全的互斥访问。例如，线程0在向线程1的消息队列写消息的同时，线程1可以向线程2的消息队列写消息。但是OpenMP的规定第二个和第三个代码块是被critical指令保护的代码块。在OpenMP看来，我们的程序有两个不同的临界区；被atomic指令保护的done_sending++和“复合”临界区。在“复合”临界区中，程序读取和发送消息。</p>\n<p>强制线程间的互斥会使程序的执行串行化。OpenMP默认的做法是将所有的临界区代码块作为复合临界区的一部分，这可能非常不利于程序的性能。OpenMP提供了向critical指令添加名字的选项：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp critical(name)</span><br></code></pre></div></td></tr></table></figure>\n\n<p>采取这种方式，两个用不同名字的critical指令保护的代码块就可以同时执行。我们想为每一个线程的消息队列的临界区提供不同的名字，但是临界区的名字是在程序编译过程中设置的。因此，我们需要在程序执行的过程中设置临界区的名字。但是按照为我们的设置，当我们想让访问不同队列的线程可以同时访问相同的代码块时，被命名的critical指令就不能满足我们的要求了。</p>\n<p>解决方案是使用锁（lock）。锁由一个数据结构和定义在这个数据结构上的函数组成，这些函数使得程序员可以显式地强制对临界区进行互斥访问。锁的使用可以大概用下面的伪代码描述：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/*Executed by one thread*/</span><br>initialize the lock data structure;<br>...<br><span class=\"hljs-comment\">/*Executed by multiple threads*/</span><br>Attempt to lock <span class=\"hljs-keyword\">or</span> set the lock data structure;<br>Critical section;<br>Unlock <span class=\"hljs-keyword\">or</span> unset the lock data structure;<br>...<br><span class=\"hljs-comment\">/*Executed by one thread*/</span><br>Destory the lock data structure;<br></code></pre></div></td></tr></table></figure>\n\n<p>锁的数据结构被执行临界区的线程所共享，这些线程中的某个线程（如主线程）会初始化锁。而当所有的线程都使用完锁后，某个线程应当负责销毁锁。</p>\n<p>在一个线程进入临界区前，它尝试通过调用锁函数来上锁（set）。如果没有其他的线程正在执行临界区代码，那么它将获得锁并进入临界区。当该线程执行完临界区代码后，它调用解锁函数释放（relinquish或者unset）锁，以便其他线程可以获得锁。</p>\n<p>当一个线程拥有锁时，其他线程都不能进入该临界区。其他线程尝试通过调用锁函数进入该临界区时会阻塞。如果有多个线程被锁函数阻塞，则当临界区的线程释放锁时，这些线程中的某个线程会获得锁，而其他线程仍被阻塞。</p>\n<p>OpenMP有两种锁：简单（simple）锁和嵌套（nested）锁。简单锁在被释放前只能获得一次，而一个嵌套锁在被释放前可以被同一个线程获得多次。OpenMP简单锁的类型是omp_lock_t，定义简单锁的函数包括：</p>\n<p><img src=\"/2023/01/14/openmp006/image-20230116165204803.png\" alt=\"image-20230116165204803\"></p>\n<p>相关的类型和函数在头文件omp.h中声明。第一个函数的作为是初始化锁，所以此时锁处于解锁状态，换句话说，此时没有线程拥有这个锁。第二个函数尝试获得锁，如果成功，调用该函数的线程可以继续执行；如果失败，调用该函数的线程将被阻塞，直到锁被其他线程释放。第三个函数释放锁，以便其他线程可以获得该锁。第四个函数销毁锁。</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2023/01/14/openmp005/",
            "url": "http://example.com/2023/01/14/openmp005/",
            "title": "OpenMP循环调度",
            "date_published": "2023-01-14T05:04:25.000Z",
            "content_html": "<h2 id=\"OpenMP循环调度\"><a href=\"#OpenMP循环调度\" class=\"headerlink\" title=\"OpenMP循环调度\"></a>OpenMP循环调度</h2><h3 id=\"1-循环调度\"><a href=\"#1-循环调度\" class=\"headerlink\" title=\"1.循环调度\"></a>1.循环调度</h3><p>当第一次遇到parallel for指令时，我们看到将各次循环分配给线程的操作是由系统完成的。然而，大部分OpenMP实现只是粗略地使用块分割：如果在串行循环中有n次迭代，那么在并行循环中，前n&#x2F;thread_count个迭代分配给线程0，接下来的n&#x2F;thread_count个迭代分配给线程1，依此类推。不难想到，这种分配方式肯定不是最优的。例如，假如我们想要并行化循环：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">sum = <span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;=n;i++)<br>    sum+=<span class=\"hljs-built_in\">f</span>(i);<br></code></pre></div></td></tr></table></figure>\n\n<p>同时，假设对f函数调用所需要的时间与参数i的大小成正比，那么与分配给线程0的工作相比，分配给线程thread_count-1的工作量相对较大。一个更好的分配方案是轮流分配线程的工作（循环划分）。在循环划分中，各次迭代被“轮流”地一次一个地分配给线程。假如 t&#x3D;thread_count。那么一个循环划分将如下分配各次迭代：</p>\n<p><img src=\"/2023/01/14/openmp005/image-20230114132246596.png\" alt=\"image-20230114132246596\"></p>\n<p>为了了解这样分配是如何影响性能的，我们编写了如下程序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> j,start=i*(i+<span class=\"hljs-number\">1</span>)/<span class=\"hljs-number\">2</span>,finish=start+i;<br>    <span class=\"hljs-keyword\">double</span> return_val = <span class=\"hljs-number\">0.0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span>(j = start; j&lt;=finish; j++)&#123;<br>        return_val += <span class=\"hljs-built_in\">sin</span>(j);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> return_val;<br>    <span class=\"hljs-comment\">/* f */</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>每当函数f（i）调用i次sin函数。例如，执行f（2i）的时间几乎是执行f（i）的时间的两倍。</p>\n<p>当n&#x3D;10000并且只用一个线程运行程序时，运行时间是3.67秒。当用两个线程和缺省分配方式（第0-5000次迭代分配给线程0，第5001-10000次迭代分配给线程1），运行程序时，运行时间为2.76秒。加速比仅为1.33.然而，当运行两个线程并采用循环划分时，运行时间减少到1.84秒。与单线程运行相比，加速比为1.99；与双线程，块分割相比，加速比为1.5！</p>\n<p>我们看到一个好的迭代分配能够对性能有很大的影响。再OpenMP中，将循环分配给线程称为调度，schedule子句用于在parallel for或者for指令中进行迭代分配。</p>\n<h3 id=\"2-schedule子句\"><a href=\"#2-schedule子句\" class=\"headerlink\" title=\"2.schedule子句\"></a>2.schedule子句</h3><p>在例子中，我们已经知道如何乎获取缺省调度：只需要添加parallel for指令和reduction子句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">sum=<span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)</span><br><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;=n;i++)&#123;<br>    sum+=<span class=\"hljs-built_in\">f</span>(i);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>为了对线程进行调度，可以添加一个schedule子句到parallel for指令中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">sum=<span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)\tschedule(static,1)</span><br><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;=n;i++)&#123;<br>    sum+=<span class=\"hljs-built_in\">f</span>(i);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>一般而言，schedule子句有如下形式：</p>\n<p>schedule（<type>[.<chunksize>]）</chunksize></type></p>\n<p>type可以是下列任意一个：</p>\n<ol>\n<li>static：迭代能够在循环执行前分配给线程</li>\n<li>dynamic或guided：迭代在循环执行时被分配给线程，因此在一个线程完成了它的当前迭代集合后，它能从运行时系统中请求更多</li>\n<li>auto：编译器和运行时系统决定调度方式</li>\n<li>runtime：调度在运行时决定</li>\n</ol>\n<p>chunksize是一个正整数。在OpenMP中，迭代块是在顺序循环中连续执行的一块迭代语句，块中的迭代次数是chunksize。只有static，dynamic和guided调度有chunksize。这虽然决定了调度的细节，但准确的解释还是依赖于type。</p>\n<h3 id=\"3-stastic调度类型\"><a href=\"#3-stastic调度类型\" class=\"headerlink\" title=\"3.stastic调度类型\"></a>3.stastic调度类型</h3><p>对于static调度，系统以轮转的方式分配chunksize块个迭代给每个线程。例如，假如有12个迭代，0，1，—，11和3个线程，如果在parallel for或for指令中使用schedule（static，1）迭代将如下分配：</p>\n<p><img src=\"/2023/01/14/openmp005/image-20230114141741424.png\" alt=\"image-20230114141741424\"></p>\n<p>如果使用schedule（static，2），迭代将如下进行分配：</p>\n<p><img src=\"/2023/01/14/openmp005/image-20230114141830866.png\" alt=\"image-20230114141830866\"></p>\n<p>如果使用schedule（static，4），迭代将如下分配：</p>\n<p><img src=\"/2023/01/14/openmp005/image-20230114141909092.png\" alt=\"image-20230114141909092\"></p>\n<p>因此，子句schedule（static,total_iterations&#x2F;thread_count）就相当于被大部分OpenMP实现所使用的缺省调度。</p>\n<p>这里，chunksize可以被忽略。如果他被忽略了，chunksize就近似等于total_iterations&#x2F;thread_count。</p>\n<h3 id=\"4-dynamic和guided调度类型\"><a href=\"#4-dynamic和guided调度类型\" class=\"headerlink\" title=\"4.dynamic和guided调度类型\"></a>4.dynamic和guided调度类型</h3><p>在dynamic调度中，迭代也被分成chunksize个连续迭代的块。每个线程执行一块，并且当一个线程完成一块时，它将从运行时系统请求另一块，直到所有的迭代完成。chunksize可以被忽略。当它被忽略时，chunksize为1。</p>\n<p>在guided调度中，每个线程也执行一块，并且当一个线程完成一块时，将请求另一块。然而，在guided调度中，当块完成后，新块的大小会变小。例如，在我们的系统中，如果用parallel for指令和schedule（guided）子句来运行梯形积分法程序，那么当n&#x3D;10000并且thread_count&#x3D;2时。迭代将如表5-3那样分配。块的大小近似等于剩下的迭代数除以线程数。第一个块的大小9999&#x2F;2≈5000，因为有9999个迭代未被分配的迭代。第二个块的大小为4999&#x2F;2≈2500，一次类推。</p>\n<p><img src=\"/2023/01/14/openmp005/image-20230114143233692.png\" alt=\"image-20230114143233692\"></p>\n<p>在guided调度中，如果没有指定chunksize，那么块的大小为1；如果指定了chunksize，那么块的大小就是chunksize，除了最后一块的大小可以比chunksize小。</p>\n<h3 id=\"5-runtime调度类型\"><a href=\"#5-runtime调度类型\" class=\"headerlink\" title=\"5.runtime调度类型\"></a>5.runtime调度类型</h3><p>为了理解schedule（runtime），我们需要离题一会儿，讨论一下环境变量。正如名字所暗示的，环境变量是能够被运行时系统所访问的命名值，即它们在程序的环境中是可得的。一些经常被使用的环境变量是PATH,HOME和SHELL。PATH变量明确了当寻找一个可执行文件时shell应该搜索哪些目录。它通常在UNIX和Windows系统中定义。HOME变量指定用户主目录的位置，而SHELL变量指定用户shell的可执行位置。这样通常在UNIX系统中。在类UNIX系统（例如Linux和Mac OS X）和Windows，环境变量能够在命令行中检查和指定。在类UNIX系统中，能使用shell命令行；在windows中，能使用集成开发环境的命令行。</p>\n<p>例如，如果我们正使用bash shell，要检查一个环境变量的值只需要输入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$PATH</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p>我们能够使用export命令来设置一个环境变量的值</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"><span class=\"hljs-built_in\">export</span> TEST_VAR = <span class=\"hljs-string\">&quot;hello&quot;</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p>如何检查和设置特定系统的环境变量，请咨询本地系统的专家。</p>\n<p>当schedule（runtime）指定时，系统使用环境变量OMP_SCHEDULE在运行时来决定如何调度循环。OMP_SCHEDULE环境变量会呈现任何能够被static，dynamic或guided调度所使用的值。例如，假设在程序中有一条parallel for指令，并且它已经被schedule（runtime）修改了。那么如果使用bash shell，就能通过执行以下命令将一个循环分配所得到的迭代分配给线程：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"><span class=\"hljs-built_in\">export</span> OMP_SCHEDULE=<span class=\"hljs-string\">&quot;static,1&quot;</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p>现在，当开始执行程序时，系统将调度for循环的迭代，就如同使用子句schedule（static，1）修改了parallel for指令那样。</p>\n<h3 id=\"6-调度选择\"><a href=\"#6-调度选择\" class=\"headerlink\" title=\"6.调度选择\"></a>6.调度选择</h3><p>如果需要并行化一个for循环，那么我们如何决定使用哪一种电镀和chuncksize的大小？实际上，每一中schedule子句有不同的系统开销。dynamic调度的系统开销要大于static调度，而guided调度的系统开销是三种方式中最大的。因此，如果不使用schedule子句就已经达到了令人满意的性能，就不需要进行多余的工作。但是，如果我们怀疑调度的性能可以提升，那么我们可以对各种调度进行试验。</p>\n<p>在本节开始提供的例子中，在程序使用两个线程的情况下，使用schedule（static，1）代替默认调度时，加速比从1.33提升到1.99。因为在两个线程的条件下，加速比几乎不可能比1.99更好，所以我们可以不用再尝试其他的调度方式，至少在只用两个线程并且迭代数为10000的情况下是这样。如果做更多的试验，改变线程的个数和迭代的次数，我们可能会发现：最优的调度方式是由线程的个数和迭代的次数共同决定的。</p>\n<p>如果我们断定默认的调度方式性能低下，那么我们会做大量的实验来寻找最优的调度方式和迭代次数。在进行了大量的工作以后，我们可能发现，这些循环没有得到很好的并行化，没有哪一种调度可以带来比较显著的性能提升。编程作业5.4就是这样一个例子。</p>\n<p>但在某些情况下，应该优先考虑有些调度：</p>\n<ol>\n<li>如果循环的每次迭代需要几乎相同的计算量，那么可能默认的调度方式能提供最好的性能</li>\n<li>如果随着循环的进行，迭代的计算量线性猛增（或递减），那么采用比较小的chuncksize的static调度可能会提供最好的性能</li>\n<li>如果每次迭代的开销事先不能确定，那么就可能需要尝试使用多种不同的调度策略。在这种情况下，应当使用schedule（runtime）子句，通过富裕环境变量OMP_SCHEDULE不同的值来比较不同调度策略下程序的性能</li>\n</ol>\n<h3 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7.总结\"></a>7.总结</h3><ol>\n<li>调度方式对加速效果的重要性</li>\n<li>合理分析任务特性，选择最适合的调度方式</li>\n</ol>\n<h3 id=\"8-参考资料\"><a href=\"#8-参考资料\" class=\"headerlink\" title=\"8.参考资料\"></a>8.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2023/01/13/openmp004/",
            "url": "http://example.com/2023/01/13/openmp004/",
            "title": "OpenMP排序",
            "date_published": "2023-01-13T08:26:51.000Z",
            "content_html": "<h2 id=\"OpenMP排序\"><a href=\"#OpenMP排序\" class=\"headerlink\" title=\"OpenMP排序\"></a>OpenMP排序</h2><h3 id=\"1-冒泡排序\"><a href=\"#1-冒泡排序\" class=\"headerlink\" title=\"1.冒泡排序\"></a>1.冒泡排序</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(list_length = n; list.length &gt;= <span class=\"hljs-number\">2</span>; list_length--)\t\t\t\t<span class=\"hljs-comment\">//升序排列</span><br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">0</span>;i &lt; list_length<span class=\"hljs-number\">-1</span>; i++)<br>        <span class=\"hljs-keyword\">if</span>(a[i] &gt; a[i+<span class=\"hljs-number\">1</span>])&#123;<br>            tmp = a[i];<br>            a[i] = a[i+<span class=\"hljs-number\">1</span>];<br>            a[i+<span class=\"hljs-number\">1</span>] = tmp;<br>        &#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>​\t\t显然，在外部循环中有一个循环依赖，在外部循环的任何一次迭代中，当前列表的内容依赖于外部循环的前一次迭代。例如，如果在算法开始时，a&#x3D;3,4,1,2，那么外部循环的第二次迭代将对列表3，1，2进行操作，因为4在第一次迭代中应该已经被移动到列表的最后了。但如果前两次迭代同时执行，则可能第二次迭代的有效列表包含4。\t</p>\n<p>​\t\t内部循环的循环依赖也很容易发现。在第i次迭代中，被比较的元素依赖于第i-1次迭代。如果在第i-1次迭代中a[i-1]和a[i]没有交换，那么第i次迭代将比较a[i]和a[i+1]。另一方面，如果第i-1次迭代交换了a[i-1]和a[i]，那么第i次迭代将比较原始的a[i-1] (现在是a[i]和a[i+1])。例如，假如当前列表是{3，1，2}。那么当i&#x3D;1时，我们将比较3和2，但如果i&#x3D;0和i&#x3D;1次迭代同时发生，则完全有可能i&#x3D;1次迭代回比较1和2。</p>\n<p>​\t\t我们完全不清楚怎样在不完全重写算法的情况下一处任何一个循环依赖。记住。即使我们总能找到循环依赖，但可能很难甚至不可能移除它。对于并行化for循环而言，parallel for指令不是一个通用的解决方法。</p>\n<h3 id=\"2-奇偶交换排序\"><a href=\"#2-奇偶交换排序\" class=\"headerlink\" title=\"2.奇偶交换排序\"></a>2.奇偶交换排序</h3><p>​\t\t奇偶交换排序是一个与冒泡排序相似的算法，但它相对来说更容易并行化。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(phase = <span class=\"hljs-number\">0</span>;phase &lt; n ; phase++)<br>    <span class=\"hljs-keyword\">if</span>(phase % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span>; i &lt; n ;i += <span class=\"hljs-number\">2</span>)<br>            <span class=\"hljs-keyword\">if</span>(a[i<span class=\"hljs-number\">-1</span>] &gt; a[i]) <span class=\"hljs-built_in\">swap</span>(a[i<span class=\"hljs-number\">-1</span>],a[i]);<br>\t<span class=\"hljs-keyword\">else</span><br>        <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span>;i &lt; n<span class=\"hljs-number\">-1</span> ;i += <span class=\"hljs-number\">2</span>)<br>            <span class=\"hljs-keyword\">if</span>(a[i] &gt; a[i+<span class=\"hljs-number\">1</span>]) <span class=\"hljs-built_in\">swap</span>(a[i],a[i+<span class=\"hljs-number\">1</span>]);<br></code></pre></div></td></tr></table></figure>\n\n<p>列表a存储n个整数，算法对他们进行升序排列。在一个“偶阶段”（phase %2 &#x3D;&#x3D;0 ）里，每个偶下标元素a[i]与它左边的元素a[i-1]相比较。如果他们是没有排好序的，就交换它们。在一个“奇阶段”里，每个奇下标元素与它右边的元素相比较。如果他们是没有排好序的，则交换他们。有定理证明：在n个阶段后，列表可以完成排序。</p>\n<p>​\t\t作为一个简单的例子，假设a&#x3D;{9,7,8,6}。表5-1显示了各个阶段的情况。在这个例子中，最后的阶段不是必要的，但算法并不在执行每个阶段前检查列表是否已经有序。</p>\n<p><img src=\"/2023/01/13/openmp004/image-20230113174202896.png\" alt=\"image-20230113174202896\"></p>\n<p>​\t\t不难看到外部循环有一个循环依赖。例如在a &#x3D; {9，7，8，6}之前。在阶段0中，内部循环将比较（9，7）和（8，6）这两对中的元素，这两对都会被交换。因此对于阶段1，列表将是{7，9，6，8}，并在阶段1中（9，6）中的元素被比较并交换。然而，如果阶段0和阶段1同时执行，则在阶段1中被检查可能是（7，8），是有序的。此外，我们尚不清楚如何消除这个循环依赖，因此并行化外部for循环不是一个好的选择。</p>\n<p>​\t\t但是，内部for循环并没有任何循环依赖。例如，在偶阶段循环中，变量i是奇数，所以对于两个不同的i值，例如，i&#x3D;j和i&#x3D;k，{j-1,j}和{k-1,k}将是不同的。（a[j-1],a[j]）和（a[k-1],a[k]）所产生的比较和可能的交换能够同时进行。</p>\n<p>​\t\t所以，我们试图使用程序5-4的代码并行化奇偶变化排序，但还是会有一些潜在的问题，首先，尽管任何一个偶阶段迭代并不依赖任何这个阶段的其他迭代，但是还需要注意，对p阶段和p+1阶段却并不是这样的。我们需要确定在任何一个线程开始p+1阶段之前，所有的线程必须先完成p阶段。然而，像parallel指令那样，parallel for指令在循环结束处有一个隐式的路障，因此，在所有的线程完成当前阶段（即阶段P之前），没有线程能够进入下一阶段，即p+1阶段。【这里需要注意在MPI中并没有隐式的路障来实现这个功能，需要程序员手动设置路障点】</p>\n<p>​\t\t其次，是创建和合并线程的开销。OpenMP实现可能会在每一遍外部循环都创建和合并thread__count个线程。表5-2的第一行显示了当输入列表包含20000个元素时，在我们系统上运行1，2，3，4个线程的运行时间。</p>\n<h3 id=\"3-程序5-4奇偶排序的第一个OpenMP实现\"><a href=\"#3-程序5-4奇偶排序的第一个OpenMP实现\" class=\"headerlink\" title=\"3.程序5-4\t奇偶排序的第一个OpenMP实现\"></a>3.程序5-4\t奇偶排序的第一个OpenMP实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(phase = <span class=\"hljs-number\">0</span>;phase &lt; n; phase++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(phase %<span class=\"hljs-number\">2</span> ==<span class=\"hljs-number\">0</span>)<br>    \t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp)</span><br>        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">1</span>;i&lt;n;i+=<span class=\"hljs-number\">2</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[i<span class=\"hljs-number\">-1</span>]&gt;a[i])&#123;<br>                tmp = a[i<span class=\"hljs-number\">-1</span>];<br>                a[i<span class=\"hljs-number\">-1</span>] = a[i];<br>                a[i] =tmp;<br>            &#125;<br>        &#125;<br>    <span class=\"hljs-keyword\">else</span><br>        <span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp)</span><br>        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">1</span>;i&lt;n<span class=\"hljs-number\">-1</span>;i+=<span class=\"hljs-number\">2</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[i] &gt; a[i+<span class=\"hljs-number\">1</span>])&#123;<br>                tmp = a[i+<span class=\"hljs-number\">1</span>];<br>                a[i+<span class=\"hljs-number\">1</span>] = a[i];<br>                a[i] = tmp;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/01/13/openmp004/image-20230113225724364.png\" alt=\"image-20230113225724364\"></p>\n<p>​\t\t这些时间耗费并不非常糟糕，但是我们想看看是否能做得更好。每次执行内部循环时，使用同样数量的线程。因此只创建一次线程，并在每次内部循环的执行中重用它们，这样做可能更好。幸运的是，OpenMP提供了允许这样做的指令。用parallel指令在外部循环前创建thread__count个线程的集合。然后，我们不在每次内部循环执行时创建一组新的线程，而是使用一个for指令，告诉OpenMP用已有的线程组来并行化for循环，对原有OpenMP实现的改动显示在程序5-5中。</p>\n<h3 id=\"4-程序5-5奇偶排序的第二个OpenMP实现\"><a href=\"#4-程序5-5奇偶排序的第二个OpenMP实现\" class=\"headerlink\" title=\"4.程序5-5\t奇偶排序的第二个OpenMP实现\"></a>4.程序5-5\t奇偶排序的第二个OpenMP实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp,phase)</span><br><span class=\"hljs-keyword\">for</span>(phase = <span class=\"hljs-number\">0</span>;phase &lt; n; phase++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(phase %<span class=\"hljs-number\">2</span> ==<span class=\"hljs-number\">0</span>)<br>\t\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp for</span><br>        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">1</span>;i&lt;n;i+=<span class=\"hljs-number\">2</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[i<span class=\"hljs-number\">-1</span>]&gt;a[i])&#123;<br>                tmp = a[i<span class=\"hljs-number\">-1</span>];<br>                a[i<span class=\"hljs-number\">-1</span>] = a[i];<br>                a[i] =tmp;<br>            &#125;<br>        &#125;<br>    <span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp for</span><br>        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">1</span>;i&lt;n<span class=\"hljs-number\">-1</span>;i+=<span class=\"hljs-number\">2</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[i] &gt; a[i+<span class=\"hljs-number\">1</span>])&#123;<br>                tmp = a[i+<span class=\"hljs-number\">1</span>];<br>                a[i+<span class=\"hljs-number\">1</span>] = a[i];<br>                a[i] = tmp;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>与parallel for指令不同的是，for指令并不创建任何线程。它使用已经在parallel块中创建的线程。在循环的末尾有一个隐式的路障。代码的结果（最终列表）将因此与原有的并行化代码所取得到的结果一样。</p>\n<p>​\t\t奇偶排序的第二个版本的运行时间显示在表5-2的第二行。当使用两个或更多线程时，使用两条for指令的版本要比使用两条parallel for指令的版本快17%。因此对于这个系统而言，为这点改变所做的小小努力是值得的。</p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><ol>\n<li>循环依赖总会出现，我们可能会很难去解决它甚至根本无法解决。</li>\n<li>在构造并行区时要尽量减少创建和合并线程的开销</li>\n</ol>\n<h3 id=\"6-参考文献\"><a href=\"#6-参考文献\" class=\"headerlink\" title=\"6.参考文献\"></a>6.参考文献</h3><p>并行程序导论 （美）Peter S.Pacheco</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2023/01/09/openmp003/",
            "url": "http://example.com/2023/01/09/openmp003/",
            "title": "OpenMP π值估计",
            "date_published": "2023-01-09T07:06:18.000Z",
            "content_html": "<h2 id=\"π值估计\"><a href=\"#π值估计\" class=\"headerlink\" title=\"π值估计\"></a>π值估计</h2><h3 id=\"1-数学背景\"><a href=\"#1-数学背景\" class=\"headerlink\" title=\"1.数学背景\"></a>1.数学背景</h3><p><img src=\"/2023/01/09/openmp003/image-20230109150836877.png\" alt=\"image-20230109150836877\"></p>\n<p>我们能够在串行代码下实行这个公式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> factor = <span class=\"hljs-number\">1.0</span>;<br><span class=\"hljs-keyword\">double</span> sum = <span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">0</span> ; k &lt; n; k++)&#123;<br>    sum += factor /(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br>    factor = - factor;<br>&#125;<br>pi_approx = <span class=\"hljs-number\">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-OpenMP并行化\"><a href=\"#2-OpenMP并行化\" class=\"headerlink\" title=\"2.OpenMP并行化\"></a>2.OpenMP并行化</h3><p>为了使用OpenMP来并行化，可以首先倾向于这样做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">double</span> factor = <span class=\"hljs-number\">1.0</span>;<br><span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">double</span> sum = <span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-number\">3</span> <span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)  <span class=\"hljs-comment\">//对sum进行求和归约</span></span><br><span class=\"hljs-number\">4</span> <span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">0</span> ; k &lt; n; k++)&#123;<br><span class=\"hljs-number\">5</span>     sum += factor /(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br><span class=\"hljs-number\">6</span>     factor = - factor;<br><span class=\"hljs-number\">7</span> &#125;<br><span class=\"hljs-number\">8</span> pi_approx = <span class=\"hljs-number\">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure>\n\n<p>然而，第k次迭代中对第6行的factor的更新和接下来的第k + 1次迭代中对第5行的sum的累加是一个循环依赖（数据依赖）。如果第k次迭代被分配·到一个线程，而第k + 1次迭代被分配给另一个线程，则我们不能保证第6行中factor的值是正确的。</p>\n<p>在这种情况下我们能通过检查系数来解决这个问题：</p>\n<p><img src=\"/2023/01/09/openmp003/image-20230109161031989.png\" alt=\"image-20230109161031989\"></p>\n<p>可以看到：在第k次迭代，factor的值应该是<img src=\"/2023/01/09/openmp003/image-20230109161206995.png\" alt=\"image-20230109161206995\">。如果k是偶数，那么值是+1；如果k是奇数，值是-1。</p>\n<h3 id=\"3-消除循环依赖（数据依赖）\"><a href=\"#3-消除循环依赖（数据依赖）\" class=\"headerlink\" title=\"3.消除循环依赖（数据依赖）\"></a>3.消除循环依赖（数据依赖）</h3><p>因此，如果将下述代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">sum += factor /(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br>factor = - factor;<br></code></pre></div></td></tr></table></figure>\n\n<p>替换为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">if</span>(k % <span class=\"hljs-number\">2</span> ==<span class=\"hljs-number\">0</span>)\t\t\t<span class=\"hljs-comment\">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    factor = <span class=\"hljs-number\">1.0</span>;<br><span class=\"hljs-keyword\">else</span><br>    factor = <span class=\"hljs-number\">-1.0</span>;<br>sum += factor/(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br></code></pre></div></td></tr></table></figure>\n\n<p>这样就消除了循环依赖（数据依赖）。</p>\n<h3 id=\"4-作用域\"><a href=\"#4-作用域\" class=\"headerlink\" title=\"4.作用域\"></a>4.作用域</h3><p>​\t然而，事情仍然不是完全正确的。如果在我们的系统上使用两个线程运行程序，并设n&#x3D;1000，那么结果仍然是错误的。例如，</p>\n<p><img src=\"/2023/01/09/openmp003/image-20230109164120205.png\" alt=\"image-20230109164120205\"></p>\n<p>另一方面，如果只有一个线程运行程序，我们总是得到：</p>\n<p><img src=\"/2023/01/09/openmp003/image-20230109164204808.png\" alt=\"image-20230109164204808\"></p>\n<p>为什么会有这种错误。在一个已经被parallel for指令并行化的块中，缺省情况下任何在循环前声明的变量（唯一的例外是循环变量）在线程间都是共享的。因此factor被共享（被所有线程所共享）。例如，线程0可能会给他赋值1，但在它能用这个值更新sum前，线程1可能又给他赋值为-1了。因此，除了消除计算factor时的循环依赖（数据依赖）外，我们还需要保证每个线程有它自己的factor副本，就是说，为了使代码正确，我们需要保证factor有私有作用域（简单来说就是保证当前线程的factor的值不能被其他线程修改，也只有当前线程能更新和使用factor）。通过添加一个private子句到parallel指令中来实现这一目标。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"> <span class=\"hljs-keyword\">double</span> factor = <span class=\"hljs-number\">1.0</span>;<br> <span class=\"hljs-keyword\">double</span> sum = <span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum) private(factor)  <span class=\"hljs-comment\">//对sum进行求和归约</span></span><br> <span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">0</span> ; k &lt; n; k++)&#123;<br>     <span class=\"hljs-keyword\">if</span>(k % <span class=\"hljs-number\">2</span> ==<span class=\"hljs-number\">0</span>)\t\t\t<span class=\"hljs-comment\">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    \tfactor = <span class=\"hljs-number\">1.0</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>    \tfactor = <span class=\"hljs-number\">-1.0</span>;<br>     sum += factor /(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br> &#125;<br> pi_approx = <span class=\"hljs-number\">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure>\n\n<p>在private子句内列举的变量，在每个线程上都有一个私有副本被创建。因此，在我们的例子中，thread_count个线程中的每一个都有它自己的factor变量的副本，因此一个线程对factor的更新不会影响另一个线程的factor值。</p>\n<p>​\t\t要记住的重要的一点是，一个有私有作用域的变量的值在parallel块或者parallel for块的开始处是未指定的。它的值在parallel或parallel for块完成之后也是未指定的。例如，下列代码中的第一个printf语句的输出是非确定的，因为在它被现实初始化之前就打印了私有变量x。类似地，最终的printf输出也是非确定的，因为他在parallel块完成之后打印x。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> x = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel num_threads(thread_count) private(x)</span><br>&#123;<br>    <span class=\"hljs-keyword\">int</span> my_rank = <span class=\"hljs-built_in\">omp_get_thread_num</span>();<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Thread %d &gt; before initialization,x = %d\\n&quot;</span>,myrank,x);<br>    x = <span class=\"hljs-number\">2</span>*my_rank + <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Thread %d &gt; after initialization,x = %d\\n&quot;</span>,my_rank,x);<br>&#125;<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;After parallel block, x = %d\\n&quot;</span>,x);<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"5-关于作用域的更多问题\"><a href=\"#5-关于作用域的更多问题\" class=\"headerlink\" title=\"5.关于作用域的更多问题\"></a>5.关于作用域的更多问题</h3><p>​\t\t关于变量factor的问题是常见问题中的一个。我们通常需要考虑在parallel块或parallel for块中的每个变量的作用域。因此，与其让OpenMP决定每个变量的作用域，还不如让程序员明确块中每个变量的作用域。事实上，OpenMP提供了一个子句default，该子句显示地要求我们这样做。如果我们添加子句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\"><span class=\"hljs-keyword\">default</span></span>(none)<br></code></pre></div></td></tr></table></figure>\n\n<p>到parallel或parallel for指令中，那么编译器将要求我们明确在这个块中使用的每个变量和已经在块之外声明的变量的作用域。（在一个块中声明的变量都是私有的，因为它们会被分配给线程的栈。）</p>\n<p>​\t例如，使用一个default（none）子句，对π的计算将如下所示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) default(none) reduction(+:sum) private(k,factor)  <span class=\"hljs-comment\">//对sum进行求和归约</span></span><br> <span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">0</span> ; k &lt; n; k++)&#123;<br>     <span class=\"hljs-keyword\">if</span>(k % <span class=\"hljs-number\">2</span> ==<span class=\"hljs-number\">0</span>)\t\t\t<span class=\"hljs-comment\">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    \tfactor = <span class=\"hljs-number\">1.0</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>    \tfactor = <span class=\"hljs-number\">-1.0</span>;<br>     sum += factor /(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br> &#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在这个例子中，我们在for循环中使用4个变量。由于default子句，我们需要明确每个变量的作用域。正如我们已经注意到的，sum是一个归约变量（同时拥有私有和共享作用域的属性）。我们也已经注意到factor和循环变量中k应该有私有作用域。从未在parallel或parallel for块中更新的变量，如这个例子中的n，能够被安全的共享。与私有变量不同，共享变量在块内具有在parallel或parallel for块之前的值，在块之后的值与块内的最后一个值相同。因此，如果n在块之前被初始化为1000，则在parallel for语句中他将保持这个值。因为在for循环中值没有改变，所有在循环结束后它将保持这个值。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><ol>\n<li>分析数学背景，解决循环依赖（数据依赖）</li>\n<li>判断变量的作用域</li>\n</ol>\n<h3 id=\"7-参考资料\"><a href=\"#7-参考资料\" class=\"headerlink\" title=\"7.参考资料\"></a>7.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2023/01/06/openmp002/",
            "url": "http://example.com/2023/01/06/openmp002/",
            "title": "OpenMP寻找循环依赖",
            "date_published": "2023-01-06T09:15:48.000Z",
            "content_html": "<h3 id=\"1-OpenMP寻找循环依赖\"><a href=\"#1-OpenMP寻找循环依赖\" class=\"headerlink\" title=\"1.OpenMP寻找循环依赖\"></a>1.OpenMP寻找循环依赖</h3><p>​\t\t当我们试图使用一个parallel for指令时，首先应该注意的是：要小心发现循环依赖。我们不需要担心一般的数据依赖。例如，在下面循环中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>    x[i] = a + i*h;\t\t\t<span class=\"hljs-comment\">//2</span><br>    y[i] = <span class=\"hljs-built_in\">exp</span>(x[i]);\t\t<span class=\"hljs-comment\">//3</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在第二行和第三行之间有一个数据依赖。然而，如下的并行化没有问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel num_threads(thread_count)</span><br><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>    x[i] = a + i*h;\t\t\t<span class=\"hljs-comment\">//3</span><br>    y[i] = <span class=\"hljs-built_in\">exp</span>(x[i]);\t\t<span class=\"hljs-comment\">//4</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>因为x[ i ]的计算与它接下来的使用总是被分配给同一个进程。</p>\n<p>​\t\t我们也应该观察到，有依赖关系的语句，其中至少一条语句会有序地写或更新变量。因此为了检测循环依赖，我们只需要重点观察被循环体更新的变量，即我们应该寻找在一个迭代中被读或被写，而在另一个迭代中被写的变量。</p>\n<h3 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2.总结\"></a>2.总结</h3><ol>\n<li>数据依赖在优化过程中非常常见</li>\n<li>如何解决数据依赖对提升并行化的效果影响很大</li>\n</ol>\n<h3 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3.参考资料\"></a>3.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2023/01/03/openmp001/",
            "url": "http://example.com/2023/01/03/openmp001/",
            "title": "OpenMP梯度积分法",
            "date_published": "2023-01-03T09:19:45.000Z",
            "content_html": "<h2 id=\"OpenMP梯度积分法\"><a href=\"#OpenMP梯度积分法\" class=\"headerlink\" title=\"OpenMP梯度积分法\"></a>OpenMP梯度积分法</h2><h3 id=\"1-梯度积分法\"><a href=\"#1-梯度积分法\" class=\"headerlink\" title=\"1.梯度积分法\"></a>1.梯度积分法</h3><p><img src=\"/2023/01/03/openmp001/image-20230106165434252.png\" alt=\"001\"></p>\n<p><img src=\"/2023/01/03/openmp001/image-20230106165507737.png\" alt=\"image-20230106165507737\"></p>\n<h3 id=\"2-识别两类任务\"><a href=\"#2-识别两类任务\" class=\"headerlink\" title=\"2.识别两类任务\"></a>2.识别两类任务</h3><p><img src=\"/2023/01/03/openmp001/image-20230106164847677.png\" alt=\"image-20230106164847677\"></p>\n<ol>\n<li>单个梯形的面积计算</li>\n<li>梯形面积求和</li>\n</ol>\n<p>在2.1的任务中，没有任务间的通信，但这一组任务中的每一组任务都与2.2的任务通信</p>\n<h3 id=\"3-累加线程结果\"><a href=\"#3-累加线程结果\" class=\"headerlink\" title=\"3.累加线程结果\"></a>3.累加线程结果</h3><p>​\t使用一个共享变量作为所有线程的和 ，每个线程可以将它计算的部分结果累加到共享变量中，让每个线程执行类似下面的语句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp critical</span><br>global_result += myresult;                <span class=\"hljs-comment\">//需要互斥访问</span><br></code></pre></div></td></tr></table></figure>\n\n<p>竞争条件，使用临界区解决。保证每次只有一个线程执行这段结构性代码。</p>\n<h3 id=\"4-程序完整代码\"><a href=\"#4-程序完整代码\" class=\"headerlink\" title=\"4.程序完整代码\"></a>4.程序完整代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;omp.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Trap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> a,<span class=\"hljs-keyword\">double</span> b,<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">double</span> *global_result_p)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span> global_result = <span class=\"hljs-number\">0.0</span>;<br>\t<span class=\"hljs-keyword\">double</span> a,b;\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//为了区分local_a,local_b</span><br>\t<span class=\"hljs-keyword\">int</span> n;<br>\t<span class=\"hljs-keyword\">int</span> thread_count;<br>\t<br>\tthread_count = <span class=\"hljs-number\">8</span>;                                      \t<span class=\"hljs-comment\">//指定你的线程数</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter a,b, and n\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%lf %lf %d&quot;</span>,&amp;a,&amp;b,&amp;n);<br>    <br>    <span class=\"hljs-comment\">//并行区开始</span><br>\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel num_threads(thread_count)\t\t\t<span class=\"hljs-comment\">//指定Trap函数由thread_count个线程执行</span></span><br>\t<span class=\"hljs-built_in\">Trap</span>(a,b,n,&amp;global_result);<br>\t<span class=\"hljs-comment\">//并行区结束</span><br>    <br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;With n = %d trapezoids, our estimate\\n&quot;</span>,n);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;of the integral from %f to %f = %.4lf\\n&quot;</span>,a,b,global_result);<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Trap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> a,<span class=\"hljs-keyword\">double</span> b,<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">double</span> *global_result_p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span> h,x,my_result;<br>\t<span class=\"hljs-keyword\">double</span> local_a,local_b;<br>\t<span class=\"hljs-keyword\">int</span> i,local_n;\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//local_n代表本进程被分配了多少个任务</span><br>\t<span class=\"hljs-keyword\">int</span> my_rank = <span class=\"hljs-built_in\">omp_get_thread_num</span>();<br>\t<span class=\"hljs-keyword\">int</span> thread_count = <span class=\"hljs-built_in\">omp_get_num_threads</span>();<br>\t<br>\th = (b-a)/n;\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//梯形底的长度</span><br>\tlocal_n = n/thread_count;\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//每个线程分配的梯形数，保证能整除</span><br>\tlocal_a = a + my_rank*local_n*h;\t\t\t\t\t\t<span class=\"hljs-comment\">//区间的左端点</span><br>\tlocal_b = local_a + local_n*h;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//区间的右端点</span><br>\t<span class=\"hljs-comment\">//对global_result共享部分和</span><br>    my_result = (<span class=\"hljs-built_in\">f</span>(local_a) + <span class=\"hljs-built_in\">f</span>(local_b))/<span class=\"hljs-number\">2.0</span>;\t\t\t\t<span class=\"hljs-comment\">//f(x)是目标函数</span><br>\t<span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span> ; i&lt;=local_n<span class=\"hljs-number\">-1</span>; i++)&#123;<br>\t\tx = local_a + i*h;<br>\t\tmy_result += <span class=\"hljs-built_in\">f</span>(x);<br>\t&#125;<br>\tmy_result = my_result*h;<br>    <span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp critical\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//临界区，这里可以直接使用OpenMP提供的reduction</span></span><br>\t*global_result_p += my_result;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//线程将部分和结果累加到共享变量</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><ol>\n<li>核心是拆分任务区域，把子任务分配到个个线程</li>\n<li>共享变量的选取决定了可并行度</li>\n<li>通过共享变量实现了归约的操作(这里使用到了临界区)</li>\n</ol>\n<h3 id=\"6-参考资料\"><a href=\"#6-参考资料\" class=\"headerlink\" title=\"6.参考资料\"></a>6.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2022/06/22/mirror001/",
            "url": "http://example.com/2022/06/22/mirror001/",
            "title": "国内常用镜像源",
            "date_published": "2022-06-22T12:13:38.000Z",
            "content_html": "<h2 id=\"国内常用镜像源\"><a href=\"#国内常用镜像源\" class=\"headerlink\" title=\"国内常用镜像源\"></a>国内常用镜像源</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">清华大学： https:<span class=\"hljs-comment\">//pypi.tuna.tsinghua.edu.cn/simple/</span><br>阿里云： https:<span class=\"hljs-comment\">//mirrors.aliyun.com/pypi/simple/</span><br>豆瓣： http:<span class=\"hljs-comment\">//pypi.douban.com/simple/</span><br>中国科学技术大学： http:<span class=\"hljs-comment\">//pypi.mirrors.ustc.edu.cn/simple/</span><br>华中科技大学：http:<span class=\"hljs-comment\">//pypi.hustunique.com/simple/</span><br>山东理工大学：http:<span class=\"hljs-comment\">//pypi.sdutlinux.org/simple/</span><br></code></pre></div></td></tr></table></figure>\n\n",
            "tags": [
                "Mirror"
            ]
        },
        {
            "id": "http://example.com/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/",
            "url": "http://example.com/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/",
            "title": "内存对齐",
            "date_published": "2022-06-12T07:11:29.730Z",
            "content_html": "<h1 id=\"内存对齐\"><a href=\"#内存对齐\" class=\"headerlink\" title=\"内存对齐\"></a>内存对齐</h1><h2 id=\"CPU读取内存的方式\"><a href=\"#CPU读取内存的方式\" class=\"headerlink\" title=\"CPU读取内存的方式\"></a>CPU读取内存的方式</h2><p>CPU读取内存的方式其实非常复杂，为了更进一步的了解相关的原理，需要对计算机组成原理进行深度学习。</p>\n<h3 id=\"Memory-access-granularity-内存读取粒度\"><a href=\"#Memory-access-granularity-内存读取粒度\" class=\"headerlink\" title=\"Memory access granularity(内存读取粒度)\"></a>Memory access granularity(内存读取粒度)</h3><p>However, your computer’s processor does not read from and write to memory in byte-sized chunks. Instead, it accesses memory in two-, four-, eight- 16- or even 32-byte chunks. We’ll call the size in which a processor accesses memory its memory access granularity.</p>\n<p>CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为<em>memory access granularity（粒度）</em> 本人把它翻译为“内存读取粒度” 。</p>\n<p><a href=\"https://www.cnblogs.com/feng9exe/p/10059543.html\">https://www.cnblogs.com/feng9exe/p/10059543.html</a> ”内存对齐“</p>\n<h2 id=\"内存对齐举例\"><a href=\"#内存对齐举例\" class=\"headerlink\" title=\"内存对齐举例\"></a>内存对齐举例</h2><p>假设此计算机的内存读取粒度是4。</p>\n<h3 id=\"如果内存对齐时\"><a href=\"#如果内存对齐时\" class=\"headerlink\" title=\"如果内存对齐时\"></a>如果内存对齐时</h3><p>前提知识：</p>\n<p>1 Byte &#x3D; 8bit </p>\n<p>1 int8 占用 1 Byte</p>\n<p>1 int16 占用 2 Byte</p>\n<p>1 int32 占用 4 Byte</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//一个结构体的定义如下</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">S</span></span><br><span class=\"hljs-class\">&#123;</span><br>    int8 a;<br>    int32 b;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n\n\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th align=\"center\">4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n<th>12</th>\n<th>13</th>\n<th>14</th>\n<th>15</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int8 a</td>\n<td></td>\n<td></td>\n<td></td>\n<td align=\"center\">int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>我们可以发现int8 a储存在0号内存上，占用1个Byte，1-3号内存空下了3个Byte。int32 b储存在了4-7号内存，一共4个Byte。</p>\n<p>由于此计算机的内存读取粒度时是4</p>\n<p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p>\n<p>当需要读取b(4-7号内存时)，计算机会读取4-7号内存，访问次数1次。</p>\n<h3 id=\"如果内存没有对齐时\"><a href=\"#如果内存没有对齐时\" class=\"headerlink\" title=\"如果内存没有对齐时\"></a>如果内存没有对齐时</h3><table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n<th>12</th>\n<th>13</th>\n<th>14</th>\n<th>15</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int8 a</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>我们可以发现int8 a储存在0号内存上，占用了1个Byte。int32 b储存在1-4号内存上，一共4个Byte。</p>\n<p>由于此计算机的内存读取粒度时是4</p>\n<p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p>\n<p>当需要读取b(1-4号内存)时，计算机会先读取0-3号一组内存，去掉0号内存，再读取4-7号一组内存，去掉5-7号内存，随后再拼接1-3号内存和4号内存组成完整的b。访问次数2次。</p>\n<h2 id=\"内存对齐的目的\"><a href=\"#内存对齐的目的\" class=\"headerlink\" title=\"内存对齐的目的\"></a>内存对齐的目的</h2><p>合理的内存对齐可以高效的利用硬件性能，减少处理器内存访问次数。</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0\">https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0</a> “内存对齐”</p>\n<p><a href=\"https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0\">https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0</a> “内存对齐对程序性能的影响”</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/",
            "url": "http://example.com/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/",
            "title": "MPI学习(一)-简单的发送接收",
            "date_published": "2022-06-12T07:11:29.651Z",
            "content_html": "<h1 id=\"MPI-简单的发送接收\"><a href=\"#MPI-简单的发送接收\" class=\"headerlink\" title=\"MPI-简单的发送接收\"></a>MPI-简单的发送接收</h1><p>打印来自进程问候语句的MPI程序</p>\n<h2 id=\"所使用的MPI原语\"><a href=\"#所使用的MPI原语\" class=\"headerlink\" title=\"所使用的MPI原语\"></a>所使用的MPI原语</h2><p><img src=\"/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi001.png\"></p>\n<p><img src=\"/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi002.png\"></p>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>mpicc  3.1.cpp -o 3.1</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>mpirun -np 4 .&#x2F;3.1(本地提交,采取4个进程)</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;mpi.h&gt;</span>   <span class=\"hljs-comment\">//头文件</span></span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> MAX_STRING = <span class=\"hljs-number\">100</span> ;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc,<span class=\"hljs-keyword\">char</span> **argv)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> greeting[MAX_STRING];<br>\t<span class=\"hljs-keyword\">int</span> comm_sz;<br>\t<span class=\"hljs-keyword\">int</span> my_rank;<br>\tMPI_Status status;<br><br>\t<span class=\"hljs-built_in\">MPI_Init</span>(&amp;argc,&amp;argv);<br><br>\t<span class=\"hljs-built_in\">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;comm_sz);<br>\t<span class=\"hljs-built_in\">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;my_rank);<br>\t<br>\t<span class=\"hljs-keyword\">if</span>(my_rank != <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">//其他进程向0号进程发消息</span><br>\t\t<span class=\"hljs-built_in\">sprintf</span>(greeting,<span class=\"hljs-string\">&quot;Greetings from process %d of %d!&quot;</span>,my_rank,comm_sz);<br>\t\t<span class=\"hljs-built_in\">MPI_Send</span>(greeting,<span class=\"hljs-built_in\">strlen</span>(greeting)+<span class=\"hljs-number\">1</span>,MPI_CHAR,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,MPI_COMM_WORLD); <br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Greetings from process %d of %d!\\n&quot;</span>,my_rank,comm_sz);<br>\t\t<span class=\"hljs-comment\">//0号进程接受来自其他进程的消息并输出</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> q=<span class=\"hljs-number\">1</span>;q&lt;comm_sz;q++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">MPI_Recv</span>(greeting,MAX_STRING,MPI_CHAR,q,<span class=\"hljs-number\">0</span>,MPI_COMM_WORLD,&amp;status);<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>,greeting);<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">MPI_Finalize</span>();<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"程序运行结果\"><a href=\"#程序运行结果\" class=\"headerlink\" title=\"程序运行结果\"></a>程序运行结果</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">Greetings from process <span class=\"hljs-number\">0</span> of <span class=\"hljs-number\">4</span>!<br>Greetings from process <span class=\"hljs-number\">1</span> of <span class=\"hljs-number\">4</span>!<br>Greetings from process <span class=\"hljs-number\">2</span> of <span class=\"hljs-number\">4</span>!<br>Greetings from process <span class=\"hljs-number\">3</span> of <span class=\"hljs-number\">4</span>!<br></code></pre></div></td></tr></table></figure>\n\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/",
            "url": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/",
            "title": "AVX向量化学习(二)-内存对齐的应用",
            "date_published": "2022-06-12T07:11:29.549Z",
            "content_html": "<h1 id=\"AVX指令集的简单操作-内存对齐版\"><a href=\"#AVX指令集的简单操作-内存对齐版\" class=\"headerlink\" title=\"AVX指令集的简单操作(内存对齐版)\"></a>AVX指令集的简单操作(内存对齐版)</h1><p>使用AVX指令集进行2个double型的数组相加操作</p>\n<h2 id=\"常用的内存对齐函数\"><a href=\"#常用的内存对齐函数\" class=\"headerlink\" title=\"常用的内存对齐函数\"></a>常用的内存对齐函数</h2><p>因为AVX中要求mem__addr必须在32字节边界上对齐，否则可能会产生通用保护异常。  </p>\n<h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span>*\ta =(<span class=\"hljs-keyword\">double</span>*)<span class=\"hljs-built_in\">memalign</span>(<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">9</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>));<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span>*\ta =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(<span class=\"hljs-number\">9</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span>*\ta =(<span class=\"hljs-keyword\">double</span>*)<span class=\"hljs-built_in\">aligned_alloc</span>(<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">9</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>));<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__attribute__ ((<span class=\"hljs-built_in\">aligned</span>(<span class=\"hljs-number\">32</span>)))<span class=\"hljs-keyword\">double</span> a[<span class=\"hljs-number\">9</span>]  =&#123;<span class=\"hljs-number\">1.1</span>,<span class=\"hljs-number\">2.2</span>,<span class=\"hljs-number\">3.3</span>,<span class=\"hljs-number\">4.4</span>,<span class=\"hljs-number\">5.5</span>,<span class=\"hljs-number\">6.6</span>,<span class=\"hljs-number\">7.7</span>,<span class=\"hljs-number\">8.8</span>,<span class=\"hljs-number\">2.1</span>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256d _mm256_load_pd (<span class=\"hljs-keyword\">double</span> <span class=\"hljs-keyword\">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Description</strong></p>\n<p>Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>\n<p><strong>Operation</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">dst[<span class=\"hljs-number\">255</span>:<span class=\"hljs-number\">0</span>] := MEM[mem_addr+<span class=\"hljs-number\">255</span>:mem_addr]<br>dst[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-1\"><a href=\"#2-1\" class=\"headerlink\" title=\"2.\"></a>2.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256 _mm256_add_ps (__m256 a, __m256 b)<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Description</strong></p>\n<p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p>\n<p><strong>Operation</strong></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">FOR</span> j := <span class=\"hljs-number\">0</span> to <span class=\"hljs-number\">7</span><br>\t<span class=\"hljs-attribute\">i</span> := j*<span class=\"hljs-number\">32</span><br>\t<span class=\"hljs-attribute\">dst</span>[i+<span class=\"hljs-number\">31</span>:i] := a[i+<span class=\"hljs-number\">31</span>:i] + b[i+<span class=\"hljs-number\">31</span>:i]<br><span class=\"hljs-attribute\">ENDFOR</span><br><span class=\"hljs-attribute\">dst</span>[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3-stream的作用：绕过缓存直接写入内存\"><a href=\"#3-stream的作用：绕过缓存直接写入内存\" class=\"headerlink\" title=\"3.stream的作用：绕过缓存直接写入内存\"></a>3.stream的作用：绕过缓存直接写入内存</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">void</span> _mm256_stream_pd (<span class=\"hljs-keyword\">double</span> * mem_addr, __m256d a)<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Description</strong></p>\n<p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>\n<p><strong>Operation</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">MEM[mem_addr+<span class=\"hljs-number\">255</span>:mem_addr] := a[<span class=\"hljs-number\">255</span>:<span class=\"hljs-number\">0</span>]<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"样例程序举例：\"><a href=\"#样例程序举例：\" class=\"headerlink\" title=\"样例程序举例：\"></a>样例程序举例：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;malloc.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;immintrin.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span>*\ta =(<span class=\"hljs-keyword\">double</span>*)<span class=\"hljs-built_in\">memalign</span>(<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">9</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>));<br>\t<span class=\"hljs-keyword\">double</span>*\tb =(<span class=\"hljs-keyword\">double</span>*)<span class=\"hljs-built_in\">memalign</span>(<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">4</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>));<br>\t<span class=\"hljs-keyword\">double</span> af[<span class=\"hljs-number\">9</span>]=&#123;<span class=\"hljs-number\">1.1</span>,<span class=\"hljs-number\">2.2</span>,<span class=\"hljs-number\">3.3</span>,<span class=\"hljs-number\">4.4</span>,<span class=\"hljs-number\">5.5</span>,<span class=\"hljs-number\">6.6</span>,<span class=\"hljs-number\">7.7</span>,<span class=\"hljs-number\">8.8</span>,<span class=\"hljs-number\">2.1</span>&#125; ;<br>\t<span class=\"hljs-keyword\">double</span> bf[<span class=\"hljs-number\">9</span>]=&#123;<span class=\"hljs-number\">2.1</span>,<span class=\"hljs-number\">3.2</span>,<span class=\"hljs-number\">6.4</span>,<span class=\"hljs-number\">8.6</span>,<span class=\"hljs-number\">3.7</span>,<span class=\"hljs-number\">9.9</span>,<span class=\"hljs-number\">5.1</span>,<span class=\"hljs-number\">4.2</span>,<span class=\"hljs-number\">6.6</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span>*\tc =(<span class=\"hljs-keyword\">double</span>*)<span class=\"hljs-built_in\">memalign</span>(<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">4</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>));<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i =<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\ta[i]=af[i];<br>\t\tb[i]=bf[i];<br>\t&#125;<br>\t<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br>\t__m256d v0;<br>\t__m256d v1;<br>\t__m256d v2;<br>\t<span class=\"hljs-keyword\">for</span>(;i&lt;<span class=\"hljs-number\">9</span><span class=\"hljs-number\">-4</span>;i+=<span class=\"hljs-number\">4</span>)<br>\t&#123;\t<br>\t\t\tv0 = _mm256_load_pd(a+i);<br>\t\t\tv1 = _mm256_load_pd(b+i);<br>\t\t\tv2=_mm256_add_pd(v0,v1);<br>\t\t \t_mm256_stream_pd(c+i,v2);<br>\t\t\t<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\tc[i]=a[i]+b[i];<br>\t<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;this is c.\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%lf\\n&quot;</span>,c[i]);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"样例程序输出：\"><a href=\"#样例程序输出：\" class=\"headerlink\" title=\"样例程序输出：\"></a>样例程序输出：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">this</span> is c.<br><span class=\"hljs-number\">3.200000</span><br><span class=\"hljs-number\">5.400000</span><br><span class=\"hljs-number\">9.700000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">9.200000</span><br><span class=\"hljs-number\">16.500000</span><br><span class=\"hljs-number\">12.800000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">8.700000</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/",
            "url": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/",
            "title": "AVX向量化学习(一)",
            "date_published": "2022-06-12T07:11:29.538Z",
            "content_html": "<h1 id=\"AVX指令集的简单操作\"><a href=\"#AVX指令集的简单操作\" class=\"headerlink\" title=\"AVX指令集的简单操作\"></a>AVX指令集的简单操作</h1><p>使用AVX指令集进行2个double型的数组相加操作</p>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256 _mm256_loadu_ps (<span class=\"hljs-keyword\">float</span> <span class=\"hljs-keyword\">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>\n<h3 id=\"Operation\"><a href=\"#Operation\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">dst[<span class=\"hljs-number\">255</span>:<span class=\"hljs-number\">0</span>] := MEM[mem_addr+<span class=\"hljs-number\">255</span>:mem_addr]<br>dst[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256d _mm256_add_pd (__m256d a, __m256d b)<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"Description-1\"><a href=\"#Description-1\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p>\n<h3 id=\"Operation-1\"><a href=\"#Operation-1\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">FOR j := <span class=\"hljs-number\">0</span> to <span class=\"hljs-number\">3</span><br>\ti := j*<span class=\"hljs-number\">64</span><br>\tdst[i+<span class=\"hljs-number\">63</span>:i] := a[i+<span class=\"hljs-number\">63</span>:i] + b[i+<span class=\"hljs-number\">63</span>:i]<br>ENDFOR<br>dst[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">void</span> _mm256_storeu_pd (<span class=\"hljs-keyword\">double</span> * mem_addr, __m256d a)<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"Description-2\"><a href=\"#Description-2\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>\n<h3 id=\"Operation-2\"><a href=\"#Operation-2\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">MEM[mem_addr+<span class=\"hljs-number\">255</span>:mem_addr] := a[<span class=\"hljs-number\">255</span>:<span class=\"hljs-number\">0</span>]<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"未进行AVX向量化的情况\"><a href=\"#未进行AVX向量化的情况\" class=\"headerlink\" title=\"未进行AVX向量化的情况\"></a>未进行AVX向量化的情况</h2><h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span> a[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">1.1</span>,<span class=\"hljs-number\">2.2</span>,<span class=\"hljs-number\">3.3</span>,<span class=\"hljs-number\">4.4</span>,<span class=\"hljs-number\">5.5</span>,<span class=\"hljs-number\">6.6</span>,<span class=\"hljs-number\">7.7</span>,<span class=\"hljs-number\">8.8</span>,<span class=\"hljs-number\">2.1</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span> b[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">2.1</span>,<span class=\"hljs-number\">3.2</span>,<span class=\"hljs-number\">6.4</span>,<span class=\"hljs-number\">8.6</span>,<span class=\"hljs-number\">3.7</span>,<span class=\"hljs-number\">9.9</span>,<span class=\"hljs-number\">5.1</span>,<span class=\"hljs-number\">4.2</span>,<span class=\"hljs-number\">6.6</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span> c[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>\t<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span> ;i&lt;<span class=\"hljs-number\">9</span>;i++)\t<br>\t&#123;<br>\t\tc[i]=a[i]+b[i];<br>\t\t<br>\t&#125;<br>\t<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;this is c.\\n&quot;</span>);<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%lf\\n&quot;</span>,c[i]);<br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">this</span> is c.<br><span class=\"hljs-number\">3.200000</span><br><span class=\"hljs-number\">5.400000</span><br><span class=\"hljs-number\">9.700000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">9.200000</span><br><span class=\"hljs-number\">16.500000</span><br><span class=\"hljs-number\">12.800000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">8.700000</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"进行AVX向量化的情况\"><a href=\"#进行AVX向量化的情况\" class=\"headerlink\" title=\"进行AVX向量化的情况\"></a>进行AVX向量化的情况</h2><h3 id=\"程序源代码-1\"><a href=\"#程序源代码-1\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;immintrin.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span> a[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">1.1</span>,<span class=\"hljs-number\">2.2</span>,<span class=\"hljs-number\">3.3</span>,<span class=\"hljs-number\">4.4</span>,<span class=\"hljs-number\">5.5</span>,<span class=\"hljs-number\">6.6</span>,<span class=\"hljs-number\">7.7</span>,<span class=\"hljs-number\">8.8</span>,<span class=\"hljs-number\">2.1</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span> b[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">2.1</span>,<span class=\"hljs-number\">3.2</span>,<span class=\"hljs-number\">6.4</span>,<span class=\"hljs-number\">8.6</span>,<span class=\"hljs-number\">3.7</span>,<span class=\"hljs-number\">9.9</span>,<span class=\"hljs-number\">5.1</span>,<span class=\"hljs-number\">4.2</span>,<span class=\"hljs-number\">6.6</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span> c[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>\t__m256d v0;<br>\t__m256d v1;<br>\t__m256d v2;<br>\t<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span>(;i&lt;<span class=\"hljs-number\">9</span><span class=\"hljs-number\">-4</span>;i+=<span class=\"hljs-number\">4</span>)<br>\t&#123;\t<br>\t\t\tv0 = _mm256_loadu_pd(a+i);<br>\t\t\tv1 = _mm256_loadu_pd(b+i);<br>\t\t\tv2=_mm256_add_pd(v0,v1);<br>\t\t \t_mm256_storeu_pd(c+i,v2);<br>\t\t\t<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\tc[i]=a[i]+b[i];<br>\t<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;this is c with AVX.\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%lf\\n&quot;</span>,c[i]);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"程序输出-1\"><a href=\"#程序输出-1\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">this</span> is c with AVX.<br><span class=\"hljs-number\">3.200000</span><br><span class=\"hljs-number\">5.400000</span><br><span class=\"hljs-number\">9.700000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">9.200000</span><br><span class=\"hljs-number\">16.500000</span><br><span class=\"hljs-number\">12.800000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">8.700000</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“ Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        }
    ]
}