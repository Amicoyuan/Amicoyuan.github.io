{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/",
            "url": "http://example.com/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/",
            "title": "内存对齐",
            "date_published": "2022-06-12T07:11:29.730Z",
            "content_html": "<h1 id=\"内存对齐\"><a href=\"#内存对齐\" class=\"headerlink\" title=\"内存对齐\"></a>内存对齐</h1><h2 id=\"CPU读取内存的方式\"><a href=\"#CPU读取内存的方式\" class=\"headerlink\" title=\"CPU读取内存的方式\"></a>CPU读取内存的方式</h2><p>CPU读取内存的方式其实非常复杂，为了更进一步的了解相关的原理，需要对计算机组成原理进行深度学习。</p>\n<h3 id=\"Memory-access-granularity-内存读取粒度\"><a href=\"#Memory-access-granularity-内存读取粒度\" class=\"headerlink\" title=\"Memory access granularity(内存读取粒度)\"></a>Memory access granularity(内存读取粒度)</h3><p>However, your computer’s processor does not read from and write to memory in byte-sized chunks. Instead, it accesses memory in two-, four-, eight- 16- or even 32-byte chunks. We’ll call the size in which a processor accesses memory its memory access granularity.</p>\n<p>CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为<em>memory access granularity（粒度）</em> 本人把它翻译为“内存读取粒度” 。</p>\n<p><a href=\"https://www.cnblogs.com/feng9exe/p/10059543.html\">https://www.cnblogs.com/feng9exe/p/10059543.html</a> ”内存对齐“</p>\n<h2 id=\"内存对齐举例\"><a href=\"#内存对齐举例\" class=\"headerlink\" title=\"内存对齐举例\"></a>内存对齐举例</h2><p>假设此计算机的内存读取粒度是4。</p>\n<h3 id=\"如果内存对齐时\"><a href=\"#如果内存对齐时\" class=\"headerlink\" title=\"如果内存对齐时\"></a>如果内存对齐时</h3><p>前提知识：</p>\n<p>1 Byte &#x3D; 8bit </p>\n<p>1 int8 占用 1 Byte</p>\n<p>1 int16 占用 2 Byte</p>\n<p>1 int32 占用 4 Byte</p>\n<pre><code class=\"c++\">//一个结构体的定义如下\nstruct S\n&#123;\n    int8 a;\n    int32 b;\n&#125;\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th align=\"center\">4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n<th>12</th>\n<th>13</th>\n<th>14</th>\n<th>15</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int8 a</td>\n<td></td>\n<td></td>\n<td></td>\n<td align=\"center\">int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>我们可以发现int8 a储存在0号内存上，占用1个Byte，1-3号内存空下了3个Byte。int32 b储存在了4-7号内存，一共4个Byte。</p>\n<p>由于此计算机的内存读取粒度时是4</p>\n<p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p>\n<p>当需要读取b(4-7号内存时)，计算机会读取4-7号内存，访问次数1次。</p>\n<h3 id=\"如果内存没有对齐时\"><a href=\"#如果内存没有对齐时\" class=\"headerlink\" title=\"如果内存没有对齐时\"></a>如果内存没有对齐时</h3><table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n<th>12</th>\n<th>13</th>\n<th>14</th>\n<th>15</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int8 a</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>我们可以发现int8 a储存在0号内存上，占用了1个Byte。int32 b储存在1-4号内存上，一共4个Byte。</p>\n<p>由于此计算机的内存读取粒度时是4</p>\n<p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p>\n<p>当需要读取b(1-4号内存)时，计算机会先读取0-3号一组内存，去掉0号内存，再读取4-7号一组内存，去掉5-7号内存，随后再拼接1-3号内存和4号内存组成完整的b。访问次数2次。</p>\n<h2 id=\"内存对齐的目的\"><a href=\"#内存对齐的目的\" class=\"headerlink\" title=\"内存对齐的目的\"></a>内存对齐的目的</h2><p>合理的内存对齐可以高效的利用硬件性能，减少处理器内存访问次数。</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0\">https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0</a> “内存对齐”</p>\n<p><a href=\"https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0\">https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0</a> “内存对齐对程序性能的影响”</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/",
            "url": "http://example.com/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/",
            "title": "MPI学习(一)-简单的发送接收",
            "date_published": "2022-06-12T07:11:29.651Z",
            "content_html": "<h1 id=\"MPI-简单的发送接收\"><a href=\"#MPI-简单的发送接收\" class=\"headerlink\" title=\"MPI-简单的发送接收\"></a>MPI-简单的发送接收</h1><p>打印来自进程问候语句的MPI程序</p>\n<h2 id=\"所使用的MPI原语\"><a href=\"#所使用的MPI原语\" class=\"headerlink\" title=\"所使用的MPI原语\"></a>所使用的MPI原语</h2><p><img src=\"/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi001.png\"></p>\n<p><img src=\"/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi002.png\"></p>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>mpicc  3.1.cpp -o 3.1</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>mpirun -np 4 .&#x2F;3.1(本地提交,采取4个进程)</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><pre><code class=\"c++\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;mpi.h&gt;   //头文件\n\nconst int MAX_STRING = 100 ;\n\nint main(int argc,char **argv)\n&#123;\n    char greeting[MAX_STRING];\n    int comm_sz;\n    int my_rank;\n    MPI_Status status;\n\n    MPI_Init(&amp;argc,&amp;argv);\n\n    MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);\n    MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);\n    \n    if(my_rank != 0)\n    &#123;\n        //其他进程向0号进程发消息\n        sprintf(greeting,&quot;Greetings from process %d of %d!&quot;,my_rank,comm_sz);\n        MPI_Send(greeting,strlen(greeting)+1,MPI_CHAR,0,0,MPI_COMM_WORLD); \n    &#125;\n    else\n    &#123;\n        printf(&quot;Greetings from process %d of %d!\\n&quot;,my_rank,comm_sz);\n        //0号进程接受来自其他进程的消息并输出\n        for(int q=1;q&lt;comm_sz;q++)\n        &#123;\n            MPI_Recv(greeting,MAX_STRING,MPI_CHAR,q,0,MPI_COMM_WORLD,&amp;status);\n            printf(&quot;%s\\n&quot;,greeting);\n        &#125;\n    &#125;\n    MPI_Finalize();\n    \n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"程序运行结果\"><a href=\"#程序运行结果\" class=\"headerlink\" title=\"程序运行结果\"></a>程序运行结果</h2><pre><code class=\"c++\">Greetings from process 0 of 4!\nGreetings from process 1 of 4!\nGreetings from process 2 of 4!\nGreetings from process 3 of 4!\n</code></pre>\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/",
            "url": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/",
            "title": "AVX向量化学习(二)-内存对齐的应用",
            "date_published": "2022-06-12T07:11:29.549Z",
            "content_html": "<h1 id=\"AVX指令集的简单操作-内存对齐版\"><a href=\"#AVX指令集的简单操作-内存对齐版\" class=\"headerlink\" title=\"AVX指令集的简单操作(内存对齐版)\"></a>AVX指令集的简单操作(内存对齐版)</h1><p>使用AVX指令集进行2个double型的数组相加操作</p>\n<h2 id=\"常用的内存对齐函数\"><a href=\"#常用的内存对齐函数\" class=\"headerlink\" title=\"常用的内存对齐函数\"></a>常用的内存对齐函数</h2><p>因为AVX中要求mem__addr必须在32字节边界上对齐，否则可能会产生通用保护异常。  </p>\n<h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><pre><code class=\"c++\">double*\ta =(double*)memalign(32,9*sizeof(double));\n</code></pre>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><pre><code class=\"c++\">double*\ta =(double*)_mm_malloc(9*sizeof(double),32);\n</code></pre>\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h3><pre><code class=\"c++\">double*\ta =(double*)aligned_alloc(32,9*sizeof(double));\n</code></pre>\n<h3 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h3><pre><code class=\"c++\">__attribute__ ((aligned(32)))double a[9]  =&#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;\n</code></pre>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><pre><code class=\"c++\">__m256d _mm256_load_pd (double const * mem_addr)\n</code></pre>\n<p><strong>Description</strong></p>\n<p>Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>\n<p><strong>Operation</strong></p>\n<pre><code class=\"c++\">dst[255:0] := MEM[mem_addr+255:mem_addr]\ndst[MAX:256] := 0\n</code></pre>\n<h3 id=\"2-1\"><a href=\"#2-1\" class=\"headerlink\" title=\"2.\"></a>2.</h3><pre><code class=\"c++\">__m256 _mm256_add_ps (__m256 a, __m256 b)\n</code></pre>\n<p><strong>Description</strong></p>\n<p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p>\n<p><strong>Operation</strong></p>\n<pre><code>FOR j := 0 to 7\n    i := j*32\n    dst[i+31:i] := a[i+31:i] + b[i+31:i]\nENDFOR\ndst[MAX:256] := 0\n</code></pre>\n<h3 id=\"3-stream的作用：绕过缓存直接写入内存\"><a href=\"#3-stream的作用：绕过缓存直接写入内存\" class=\"headerlink\" title=\"3.stream的作用：绕过缓存直接写入内存\"></a>3.stream的作用：绕过缓存直接写入内存</h3><pre><code class=\"c++\">void _mm256_stream_pd (double * mem_addr, __m256d a)\n</code></pre>\n<p><strong>Description</strong></p>\n<p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>\n<p><strong>Operation</strong></p>\n<pre><code class=\"c++\">MEM[mem_addr+255:mem_addr] := a[255:0]\n</code></pre>\n<h2 id=\"样例程序举例：\"><a href=\"#样例程序举例：\" class=\"headerlink\" title=\"样例程序举例：\"></a>样例程序举例：</h2><pre><code class=\"c++\">#include&lt;stdio.h&gt;\n#include&lt;malloc.h&gt;\n#include &lt;immintrin.h&gt;\nint main()\n&#123;\n    double*\ta =(double*)memalign(32,9*sizeof(double));\n    double*\tb =(double*)memalign(32,4*sizeof(double));\n    double af[9]=&#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125; ;\n    double bf[9]=&#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;\n    double*\tc =(double*)memalign(32,4*sizeof(double));\n    for(int i =0;i&lt;9;i++)\n    &#123;\n        a[i]=af[i];\n        b[i]=bf[i];\n    &#125;\n    int i=0;\n    __m256d v0;\n    __m256d v1;\n    __m256d v2;\n    for(;i&lt;9-4;i+=4)\n    &#123;\t\n            v0 = _mm256_load_pd(a+i);\n            v1 = _mm256_load_pd(b+i);\n            v2=_mm256_add_pd(v0,v1);\n         \t_mm256_stream_pd(c+i,v2);\n            \n    &#125;\n    for(;i&lt;9;i++)\n    &#123;\n        c[i]=a[i]+b[i];\n    \n    &#125;\n    printf(&quot;this is c.\\n&quot;);\n        for(int i=0;i&lt;9;i++)\n    &#123;\n        printf(&quot;%lf\\n&quot;,c[i]);\n    &#125;\n    return 0;\n &#125; \n</code></pre>\n<h2 id=\"样例程序输出：\"><a href=\"#样例程序输出：\" class=\"headerlink\" title=\"样例程序输出：\"></a>样例程序输出：</h2><pre><code class=\"c++\">this is c.\n3.200000\n5.400000\n9.700000\n13.000000\n9.200000\n16.500000\n12.800000\n13.000000\n8.700000\n</code></pre>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/",
            "url": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/",
            "title": "AVX向量化学习(一)",
            "date_published": "2022-06-12T07:11:29.538Z",
            "content_html": "<h1 id=\"AVX指令集的简单操作\"><a href=\"#AVX指令集的简单操作\" class=\"headerlink\" title=\"AVX指令集的简单操作\"></a>AVX指令集的简单操作</h1><p>使用AVX指令集进行2个double型的数组相加操作</p>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><pre><code class=\"c++\">__m256 _mm256_loadu_ps (float const * mem_addr)\n</code></pre>\n<h3 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>\n<h3 id=\"Operation\"><a href=\"#Operation\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><pre><code class=\"c++\">dst[255:0] := MEM[mem_addr+255:mem_addr]\ndst[MAX:256] := 0\n</code></pre>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><pre><code class=\"c++\">__m256d _mm256_add_pd (__m256d a, __m256d b)\n</code></pre>\n<h3 id=\"Description-1\"><a href=\"#Description-1\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p>\n<h3 id=\"Operation-1\"><a href=\"#Operation-1\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><pre><code class=\"c++\">FOR j := 0 to 3\n    i := j*64\n    dst[i+63:i] := a[i+63:i] + b[i+63:i]\nENDFOR\ndst[MAX:256] := 0\n</code></pre>\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h3><pre><code class=\"c++\">void _mm256_storeu_pd (double * mem_addr, __m256d a)\n</code></pre>\n<h3 id=\"Description-2\"><a href=\"#Description-2\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>\n<h3 id=\"Operation-2\"><a href=\"#Operation-2\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><pre><code class=\"c++\">MEM[mem_addr+255:mem_addr] := a[255:0]\n</code></pre>\n<h2 id=\"未进行AVX向量化的情况\"><a href=\"#未进行AVX向量化的情况\" class=\"headerlink\" title=\"未进行AVX向量化的情况\"></a>未进行AVX向量化的情况</h2><h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><pre><code class=\"c++\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    double a[9] = &#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;\n    double b[9] = &#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;\n    double c[9] = &#123;0&#125;;\n    \n    for(int i=0 ;i&lt;9;i++)\t\n    &#123;\n        c[i]=a[i]+b[i];\n        \n    &#125;\n    \n    printf(&quot;this is c.\\n&quot;);\n    for(int i=0;i&lt;9;i++)\n    &#123;\n        printf(&quot;%lf\\n&quot;,c[i]);\n    &#125;\n    \n    return 0;\n &#125; \n</code></pre>\n<h3 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><pre><code class=\"c++\">this is c.\n3.200000\n5.400000\n9.700000\n13.000000\n9.200000\n16.500000\n12.800000\n13.000000\n8.700000\n</code></pre>\n<h2 id=\"进行AVX向量化的情况\"><a href=\"#进行AVX向量化的情况\" class=\"headerlink\" title=\"进行AVX向量化的情况\"></a>进行AVX向量化的情况</h2><h3 id=\"程序源代码-1\"><a href=\"#程序源代码-1\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><pre><code class=\"c++\">#include&lt;stdio.h&gt;\n#include &lt;immintrin.h&gt;\nint main()\n&#123;\n    double a[9] = &#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;\n    double b[9] = &#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;\n    double c[9] = &#123;0&#125;;\n    __m256d v0;\n    __m256d v1;\n    __m256d v2;\n    int i=0;\n    for(;i&lt;9-4;i+=4)\n    &#123;\t\n            v0 = _mm256_loadu_pd(a+i);\n            v1 = _mm256_loadu_pd(b+i);\n            v2=_mm256_add_pd(v0,v1);\n         \t_mm256_storeu_pd(c+i,v2);\n            \n    &#125;\n    for(;i&lt;9;i++)\n    &#123;\n        c[i]=a[i]+b[i];\n    \n    &#125;\n    printf(&quot;this is c with AVX.\\n&quot;);\n        for(int i=0;i&lt;9;i++)\n    &#123;\n        printf(&quot;%lf\\n&quot;,c[i]);\n    &#125;\n\n    return 0;\n &#125; \n</code></pre>\n<h3 id=\"程序输出-1\"><a href=\"#程序输出-1\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><pre><code class=\"c++\">this is c with AVX.\n3.200000\n5.400000\n9.700000\n13.000000\n9.200000\n16.500000\n12.800000\n13.000000\n8.700000\n</code></pre>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“ Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/05/20/slurm001/",
            "url": "http://example.com/2022/05/20/slurm001/",
            "title": "Slurm",
            "date_published": "2022-05-20T09:43:02.000Z",
            "content_html": "<h2 id=\"Slurm\"><a href=\"#Slurm\" class=\"headerlink\" title=\"Slurm\"></a>Slurm</h2><h4 id=\"1-sstat-查看RUNNING作业\"><a href=\"#1-sstat-查看RUNNING作业\" class=\"headerlink\" title=\"1.sstat 查看RUNNING作业\"></a>1.sstat 查看RUNNING作业</h4><pre><code class=\"shell\">sstat -e\n</code></pre>\n<p><img src=\"/2022/05/20/slurm001/image-20220520174453969.png\" alt=\"image-20220520174453969\"></p>\n<p><strong>使用举例：</strong></p>\n<pre><code class=\"shell\">sstat -a --format=&quot;JobId,Pids,AveCPU,AveRSS,MaxRSS&quot;  1755818\n</code></pre>\n<p><img src=\"/2022/05/20/slurm001/image-20220520175001331.png\" alt=\"image-20220520175001331\"></p>\n<h4 id=\"2-sacct-查看FINISHED作业\"><a href=\"#2-sacct-查看FINISHED作业\" class=\"headerlink\" title=\"2.sacct 查看FINISHED作业\"></a>2.sacct 查看FINISHED作业</h4><pre><code class=\"shell\">sacct -e\n</code></pre>\n<p><img src=\"/2022/05/20/slurm001/image-20220520174622868.png\" alt=\"image-20220520174622868\"></p>\n<p><strong>使用举例：</strong></p>\n<pre><code class=\"shell\">sacct --format=&quot;JobId,Elapsed,CPUTime,CPUTimeRAW,AveCPU,TotalCPU,UserCPU,SystemCPU,AveRSS,MaxRSS&quot; -j 1754217\n</code></pre>\n<p><img src=\"/2022/05/20/slurm001/image-20220520174807162.png\" alt=\"image-20220520174807162\"></p>\n<h4 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h4><p><a href=\"https://blog.csdn.net/kongxx/article/details/52556943\">(28条消息) Slurm查看作业CPU和MEM_kongxx的博客-CSDN博客_slurm 查看节点</a></p>\n",
            "tags": [
                "Linux",
                "Slurm"
            ]
        },
        {
            "id": "http://example.com/2022/05/20/numactl001/",
            "url": "http://example.com/2022/05/20/numactl001/",
            "title": "numactl",
            "date_published": "2022-05-20T09:35:59.000Z",
            "content_html": "<ol>\n<li></li>\n</ol>\n<pre><code class=\"shell\">numactl --hardware\n</code></pre>\n<p><img src=\"/2022/05/20/numactl001/image-20220520173911653.png\" alt=\"image-20220520173911653\"></p>\n<ol start=\"2\">\n<li></li>\n</ol>\n<pre><code class=\"shelll\">numastat\n</code></pre>\n<p><img src=\"/2022/05/20/numactl001/image-20220520174030171.png\" alt=\"image-20220520174030171\"></p>\n<ol start=\"3\">\n<li></li>\n</ol>\n<pre><code class=\"c++\">numactl --show\n</code></pre>\n<p><img src=\"/2022/05/20/numactl001/image-20220520174148487.png\" alt=\"image-20220520174148487\"></p>\n<h5 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h5><p><a href=\"https://blog.csdn.net/qccz123456/article/details/81979819\">(28条消息) Linux工具之numactl_qccz123456的博客-CSDN博客_numactl</a></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1699088343604813491&wfr=spider&for=pc&searchword=numactl\">宋宝华：为什么numactl内存绑定对代码段不起作用 (baidu.com)</a></p>\n",
            "tags": [
                "Linux",
                "Numactl"
            ]
        },
        {
            "id": "http://example.com/2022/05/20/Linux002/",
            "url": "http://example.com/2022/05/20/Linux002/",
            "title": "linux的jobs,fg,bg命令",
            "date_published": "2022-05-20T09:13:08.000Z",
            "content_html": "<h3 id=\"linux让前台程序脱离终端运行\"><a href=\"#linux让前台程序脱离终端运行\" class=\"headerlink\" title=\"linux让前台程序脱离终端运行\"></a>linux让前台程序脱离终端运行</h3><p>1.首先运行你的程序</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520171436032.png\" alt=\"image-20220520171436032\"></p>\n<p>2.随后使用Ctrl + z，挂起你的进程</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520171510946.png\" alt=\"image-20220520171510946\"></p>\n<p>3.然后使用jobs查看所有的进程</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520171913979.png\" alt=\"image-20220520171913979\"></p>\n<p>4.随后使用bg+id，表示该任务为后台1号任务</p>\n<p>bg命令用于将作业放到后台运行，使前台可以执行其他任务</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520172110992.png\" alt=\"image-20220520172110992\"></p>\n<h3 id=\"linux让后台程序移动到前台终端\"><a href=\"#linux让后台程序移动到前台终端\" class=\"headerlink\" title=\"linux让后台程序移动到前台终端\"></a>linux让后台程序移动到前台终端</h3><p>Linux常用命令fg主要用于将后台作业移动到前台终端运行</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520172358345.png\" alt=\"image-20220520172358345\"></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "http://example.com/2022/05/20/Linux001/",
            "url": "http://example.com/2022/05/20/Linux001/",
            "title": "Linux常用指令",
            "date_published": "2022-05-20T09:08:45.000Z",
            "content_html": "<h2 id=\"Linux常用指令\"><a href=\"#Linux常用指令\" class=\"headerlink\" title=\"Linux常用指令\"></a>Linux常用指令</h2><h4 id=\"杀死进程\"><a href=\"#杀死进程\" class=\"headerlink\" title=\"杀死进程\"></a>杀死进程</h4><pre><code class=\"c++\">kill -9 id\n</code></pre>\n<p><img src=\"/2022/05/20/Linux001/image-20220520171246860.png\" alt=\"image-20220520171246860\"></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "http://example.com/2022/05/08/tool004/",
            "url": "http://example.com/2022/05/08/tool004/",
            "title": "gcov代码覆盖率测试-完整样例-SLIC",
            "date_published": "2022-05-08T02:34:59.000Z",
            "content_html": "<h2 id=\"gcov代码覆盖率测试-完整样例-SLIC\"><a href=\"#gcov代码覆盖率测试-完整样例-SLIC\" class=\"headerlink\" title=\"gcov代码覆盖率测试-完整样例-SLIC\"></a>gcov代码覆盖率测试-完整样例-SLIC</h2><h3 id=\"gcov代码覆盖率测试介绍：\"><a href=\"#gcov代码覆盖率测试介绍：\" class=\"headerlink\" title=\"gcov代码覆盖率测试介绍：\"></a>gcov代码覆盖率测试介绍：</h3><p><a href=\"https://xingyuanjie.top/2022/01/18/tool002/\">gcov代码覆盖率测试 - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n<h3 id=\"完整样例-SLIC：\"><a href=\"#完整样例-SLIC：\" class=\"headerlink\" title=\"完整样例-SLIC：\"></a>完整样例-SLIC：</h3><p><a href=\"https://xingyuanjie.top/2022/05/08/tool004/result.zip\">https://xingyuanjie.top/2022/05/08/tool004/result.zip</a></p>\n",
            "tags": [
                "性能分析工具",
                "gcov"
            ]
        },
        {
            "id": "http://example.com/2022/05/06/Algorithm037/",
            "url": "http://example.com/2022/05/06/Algorithm037/",
            "title": "图的存储",
            "date_published": "2022-05-06T08:38:38.000Z",
            "content_html": "<h2 id=\"图的存储\"><a href=\"#图的存储\" class=\"headerlink\" title=\"图的存储\"></a>图的存储</h2><h3 id=\"邻接矩阵法\"><a href=\"#邻接矩阵法\" class=\"headerlink\" title=\"邻接矩阵法\"></a>邻接矩阵法</h3><pre><code class=\"c++\">#define MaxVertexNum 100\t\t\t\t\t\t\t\t\t//顶点数目的最大值\ntypedef char VertexType;\t\t\t\t\t\t\t\t\t//顶点的数据类型\ntypedef int EdgeType;\t\t\t\t\t\t\t\t\t\t//带权图中边上权值的数据类型\ntypedef struct&#123;\n    VertexType Vex[MaxVertexNum];\t\t\t\t\t\t\t//顶点表\n    EdgeType Edge[MaxVertexNum][MaxVertexNum];\t\t\t\t//邻接矩阵，边表\n    int vexnum,arcnum;\t\t\t\t\t\t\t\t\t\t//图中当前顶点数和弧数\n&#125;MGraph;\n</code></pre>\n<h3 id=\"邻接表法\"><a href=\"#邻接表法\" class=\"headerlink\" title=\"邻接表法\"></a>邻接表法</h3><pre><code class=\"c++\">#define MaxVertexNum 100\t\t\t\t\t\t\t\t\t//图中顶点数目的最大值\ntypedef struct ArcNode&#123;\t\t\t\t\t\t\t\t\t\t//边表结点\n    int adjvex;\t\t\t\t\t\t\t\t\t\t\t\t//该弧所指向的顶点的位置\n    struct ArcNode *next;\t\t\t\t\t\t\t\t\t//指向下一条弧的指针\n    //InfoType infp;\t\t\t\t\t\t\t\t\t\t//网的边权值\n&#125;ArcNode;\ntypedef struct VNode&#123;\t\t\t\t\t\t\t\t\t\t//顶点表结点\n    VertexType data;\t\t\t\t\t\t\t\t\t\t//顶点信息\n    ArcNode *first;\t\t\t\t\t\t\t\t\t\t\t//指向第一条依附该顶点的弧的指针\n&#125;VNode,AdjList[MaxVertexNum];\ntypedef struct&#123;\n    AdjList vertices;\t\t\t\t\t\t\t\t\t\t//邻接表\n    int vexnum,arcnum;\t\t\t\t\t\t\t\t\t\t//图的顶点数和弧数\n&#125;ALGraph;\t\t\t\t\t\t\t\t\t\t\t\t\t//ALGraph是以邻接表存储的图的类型\n</code></pre>\n",
            "tags": [
                "Data Structure",
                "Graph"
            ]
        },
        {
            "id": "http://example.com/2022/05/05/Algorithm036/",
            "url": "http://example.com/2022/05/05/Algorithm036/",
            "title": "树、森林",
            "date_published": "2022-05-05T08:58:34.000Z",
            "content_html": "<h2 id=\"树、森林\"><a href=\"#树、森林\" class=\"headerlink\" title=\"树、森林\"></a>树、森林</h2><h3 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h3><h4 id=\"双亲表示法\"><a href=\"#双亲表示法\" class=\"headerlink\" title=\"双亲表示法\"></a>双亲表示法</h4><pre><code class=\"c++\">#define MAX_TREE_SIZE 100\t\t\t\t\t//树中最多节点数\t\ntypedef struct&#123;\t\t\t\t\t\t\t\t//树的结点定义\n    ElemType data;\t\t\t\t\t\t\t//数据元素\t\n    int parent;\t\t\t\t\t\t\t\t//双亲位置域\n&#125;PTNode;\ntypedef struct&#123;\t\t\t\t\t\t\t\t//树的类型定义\n    PTNode nodes[MAX_TREE_SIZE];\t\t\t//双亲表示\n    int n;\t\t\t\t\t\t\t\t\t//节点数\n&#125;PTree;\n</code></pre>\n<h4 id=\"孩子兄弟法\"><a href=\"#孩子兄弟法\" class=\"headerlink\" title=\"孩子兄弟法\"></a>孩子兄弟法</h4><pre><code class=\"c++\">typedef struct CSNode&#123;\n    ElemType data;\t\t\t\t\t\t\t\t\t\t\t//数据域\n    struct CSNode *firstchild,*nextsibling;\t\t\t\t\t//第一个孩子和右兄弟指针\n&#125;CSNode,*CSTree;\n</code></pre>\n",
            "tags": [
                "Data Structure",
                "Tree",
                "森林"
            ]
        },
        {
            "id": "http://example.com/2022/05/04/Algorithm035/",
            "url": "http://example.com/2022/05/04/Algorithm035/",
            "title": "线索二叉树",
            "date_published": "2022-05-04T12:05:19.000Z",
            "content_html": "<h2 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h2><h3 id=\"线索二叉树的存储结构\"><a href=\"#线索二叉树的存储结构\" class=\"headerlink\" title=\"线索二叉树的存储结构\"></a>线索二叉树的存储结构</h3><p>线索二叉树的存储结构描述如下</p>\n<pre><code class=\"c++\">ltag = 0 lchild域指示结点的左孩子\nltag = 1 lchild域指示结点的前驱\n//\nrtag = 0 rchild域指示结点的右孩子\nrtag = 1 rchild域指示结点的后继\n</code></pre>\n<pre><code class=\"c++\">typedef struct ThreadNode&#123;\n    ElemType data;\t\t\t\t\t\t//数据元素\n    struct ThreadNode *lchild,*rchild;\t\t\t\t//左右孩子指针\n    int ltag,rtag;\t\t\t\t\t\t\t\t\t//左右线索标志\n&#125;ThreadNode，*ThreadTree;\n</code></pre>\n<h3 id=\"中序线索二叉树的构造\"><a href=\"#中序线索二叉树的构造\" class=\"headerlink\" title=\"中序线索二叉树的构造\"></a>中序线索二叉树的构造</h3><pre><code class=\"c++\">void InThread(ThreadTree &amp;p,ThreadNode &amp;pre)&#123;\n    if(p!=NULL)&#123;\n        InThread(p-&gt;lchild,pre);\t\t\t//递归，线索化左子树\n        &#123;\n            if(p-&gt;lchild==NULL)&#123;\t\t\t//左子树为空，建立前驱线索\n                p-&gt;lchild=pre;\n                p-&gt;ltag=1;\n            &#125;\n            if(pre!=NULL&amp;&amp;pre-&gt;rchild==NULL)&#123;\n                pre-&gt;rchild=p;\t\t\t\t//建立前驱结点的后继线索\n                pre-&gt;rtag=1;\n            &#125;\n            pre=p;\t\t\t\t\t\t\t//标记当前结点成为刚刚访问过的结点\n            InThread(p-&gt;rchild,pre);\t\t//递归，线索化右子树\n        &#125;//if(p!=NULL)\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"c++\">void CreateInThread(ThreadTree T)&#123;\n    ThreadTree pre = NULL;\n    if(T!=NULL)&#123;\t\t\t\t\t\t//非空二叉树。线索化\n        InThread(T,pre);\t\t\t\t//线索化二叉树\n        pre-&gt;rchild=NULL;\t\t\t\t//处理遍历的最后一个结点\n        pre-&gt;rtag=1;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"中序线索二叉树的遍历\"><a href=\"#中序线索二叉树的遍历\" class=\"headerlink\" title=\"中序线索二叉树的遍历\"></a>中序线索二叉树的遍历</h3><p>1)求中序线索二叉树中中序序列下的第一个结点</p>\n<pre><code class=\"c++\">Thread *Firstnode(ThreadNode *p)&#123;\n    while(p-&gt;ltag==0) p=p-&gt;lchild;\t\t//最左下结点（不一定是叶结点）\n    return p;\n&#125;\n</code></pre>\n<p>2)求中序线索二叉树中结点p在中序序列下的后继</p>\n<pre><code class=\"c++\">ThreadNode *Nextnode(ThreadNode *p)&#123;\n    if(p-&gt;rtag==0) return Firstnode(p-&gt;rchild);\n    else return p-&gt;rchild;\t\t\t//rtag==1直接返回后继线索\n&#125;\n</code></pre>\n<p>3)利用上面两个算法，可以写出不含头节点的中序线索二叉树的中序遍历算法</p>\n<pre><code class=\"c++\">void Inorder(ThreadNode *T)&#123;\n    for(ThreadNode *p=Firstnode;p!=NULL;p=Nextnode(p))\n        visit(p);\n&#125;\n</code></pre>\n",
            "tags": [
                "Data Structure",
                "Binary tree",
                "线索二叉树"
            ]
        },
        {
            "id": "http://example.com/2022/04/27/Algorithm034/",
            "url": "http://example.com/2022/04/27/Algorithm034/",
            "title": "串的模式匹配算法-KMP算法",
            "date_published": "2022-04-27T11:39:05.000Z",
            "content_html": "<h2 id=\"串的模式匹配算法-KMP算法\"><a href=\"#串的模式匹配算法-KMP算法\" class=\"headerlink\" title=\"串的模式匹配算法-KMP算法\"></a>串的模式匹配算法-KMP算法</h2><h3 id=\"求next数组\"><a href=\"#求next数组\" class=\"headerlink\" title=\"求next数组\"></a>求next数组</h3><pre><code class=\"c++\">void get_next(SSting t,int next[])\n&#123;\n    int i=1,j=0;\n    next[1]=0;\n    while(i&lt;t.length)\n    &#123;\n        if(j==0||t.ch[i]==t.ch[j])\n        &#123;\n            i++;\n            j++;\n            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1\n        &#125;else&#123;\n            j=next[j];      //否则令j=next[j]，循环继续\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"KMP匹配算法\"><a href=\"#KMP匹配算法\" class=\"headerlink\" title=\"KMP匹配算法\"></a>KMP匹配算法</h3><pre><code class=\"c++\">int Index_KMP(SSting s,SSting t,int next[])&#123;\n    int i=1,j=1;\n    while (i&lt;=s.length&amp;&amp;j&lt;=t.length)&#123;\n        if(j==0||s.ch[i]==t.ch[j])\n        &#123;\n            j++;                    //继续比较后续字符\n            i++;\n        &#125;else&#123;\n            j=next[j];              //模式串向右移动\n        &#125;\n    &#125;\n    if(j&gt;t.length)\n    &#123;\n        return i-t.length;          //匹配成功\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"完整代码：\"><a href=\"#完整代码：\" class=\"headerlink\" title=\"完整代码：\"></a>完整代码：</h3><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define MAXLEN 255\t\t\t\t\t//预定义最大串长\ntypedef struct&#123;\n    char ch[MAXLEN];\t\t\t\t//每个分量存储一个字符\n    int length;\t\t\t\t\t\t//串的实际长度\n&#125;SSting;\nvoid get_next(SSting t,int next[])\n&#123;\n    int i=1,j=0;\n    next[1]=0;\n    while(i&lt;t.length)\n    &#123;\n        if(j==0||t.ch[i]==t.ch[j])\n        &#123;\n            i++;\n            j++;\n            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1\n        &#125;else&#123;\n            j=next[j];      //否则令j=next[j]，循环继续\n        &#125;\n    &#125;\n&#125;\nint Index_KMP(SSting s,SSting t,int next[])&#123;\n    int i=1,j=1;\n    while (i&lt;=s.length&amp;&amp;j&lt;=t.length)&#123;\n        if(j==0||s.ch[i]==t.ch[j])\n        &#123;\n            j++;                    //继续比较后续字符\n            i++;\n        &#125;else&#123;\n            j=next[j];              //模式串向右移动\n        &#125;\n    &#125;\n    if(j&gt;t.length)\n    &#123;\n        return i-t.length;          //匹配成功\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\nint main()\n&#123;\n    SSting a,b;\n    string s1=&quot;ababcabcacbab&quot;;\n    string s2=&quot;abcac&quot;;\n    a.length=s1.size();\n    b.length=s2.size();\n    int next[s2.size()+1];\n    get_next(b,next);\n    for (int i = 0; i &lt;s1.size(); ++i) &#123;\t//初始化\n        a.ch[i+1]=s1[i];\n    &#125;\n    for (int j = 0; j &lt;s2.size() ; ++j) &#123;\t//初始化\n        b.ch[j+1]=s2[j];\n    &#125;\n    int x=Index_KMP(a,b,next);\n    if(x!=0)\n    &#123;\n        cout&lt;&lt;&quot;找到了位置是：&quot;&lt;&lt;x&lt;&lt;endl;\n    &#125;else&#123;\n        cout&lt;&lt;&quot;没有找到&quot;&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"程序输出：\"><a href=\"#程序输出：\" class=\"headerlink\" title=\"程序输出：\"></a>程序输出：</h3><pre><code class=\"c++\">找到了位置是：6\n</code></pre>\n",
            "tags": [
                "Data Structure",
                "String",
                "KMP"
            ]
        },
        {
            "id": "http://example.com/2022/04/27/Algorithm033/",
            "url": "http://example.com/2022/04/27/Algorithm033/",
            "title": "串-简单的模式匹配算法",
            "date_published": "2022-04-27T09:11:18.000Z",
            "content_html": "<h2 id=\"串-简单的模式匹配算法\"><a href=\"#串-简单的模式匹配算法\" class=\"headerlink\" title=\"串-简单的模式匹配算法\"></a>串-简单的模式匹配算法</h2><h3 id=\"简单的模式匹配算法\"><a href=\"#简单的模式匹配算法\" class=\"headerlink\" title=\"简单的模式匹配算法\"></a>简单的模式匹配算法</h3><pre><code class=\"c++\">int Index(SSting s,SSting t)        //简单的模式匹配算法\n&#123;\n    int i=1,j=1;\n    while(i&lt;=s.length &amp;&amp; j&lt;= t.length)\n    &#123;\n        if(s.ch[i]==t.ch[j])\n        &#123;\n            i++;                      //继续比较后继字符\n            j++;\n        &#125;else&#123;                        //指针后退重新开始匹配\n            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位\n            j=1;\n        &#125;\n    &#125;\n    if(j&gt;t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号\n    else return 0;\n&#125;\n</code></pre>\n<h3 id=\"完整程序源代码\"><a href=\"#完整程序源代码\" class=\"headerlink\" title=\"完整程序源代码\"></a>完整程序源代码</h3><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define MAXLEN 255\t\t\t\t\t//预定义最大串长\ntypedef struct&#123;\n    char ch[MAXLEN];\t\t\t\t//每个分量存储一个字符\n    int length;\t\t\t\t\t\t//串的实际长度\n&#125;SSting;\nint Index(SSting s,SSting t)        //简单的模式匹配算法\n&#123;\n    int i=1,j=1;\n    while(i&lt;=s.length &amp;&amp; j&lt;= t.length)\n    &#123;\n        if(s.ch[i]==t.ch[j])\n        &#123;\n            i++;                      //继续比较后继字符\n            j++;\n        &#125;else&#123;                        //指针后退重新开始匹配\n            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位\n            j=1;\n        &#125;\n    &#125;\n    if(j&gt;t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号\n    else return 0;\n&#125;\nint main()\n&#123;\n    SSting a,b;\n    string s1=&quot;ababcabcacbab&quot;;\n    string s2=&quot;abcac&quot;;\n    a.length=s1.size();\n    b.length=s2.size();\n    for (int i = 0; i &lt;s1.size(); ++i) &#123;\t//初始化\n        a.ch[i+1]=s1[i];\n    &#125;\n    for (int j = 0; j &lt;s2.size() ; ++j) &#123;\t//初始化\n        b.ch[j+1]=s2[j];\n    &#125;\n    int x=Index(a,b);\n    if(x!=0)\n    &#123;\n        cout&lt;&lt;&quot;找到了位置是：&quot;&lt;&lt;x&lt;&lt;endl;\n    &#125;else&#123;\n        cout&lt;&lt;&quot;没有找到&quot;&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><pre><code class=\"c++\">找到了位置是：6\n</code></pre>\n",
            "tags": [
                "Data Structure",
                "String"
            ]
        },
        {
            "id": "http://example.com/2022/04/23/Algorithm032/",
            "url": "http://example.com/2022/04/23/Algorithm032/",
            "title": "L2-036 网红点打卡攻略 (25 分)",
            "date_published": "2022-04-23T13:50:27.000Z",
            "content_html": "<h2 id=\"L2-036-网红点打卡攻略-25-分\"><a href=\"#L2-036-网红点打卡攻略-25-分\" class=\"headerlink\" title=\"L2-036 网红点打卡攻略 (25 分)\"></a>L2-036 网红点打卡攻略 (25 分)</h2><p>一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>首先第一行给出两个正整数：网红点的个数 <em>N</em>（1&lt;<em>N</em>≤200）和网红点之间通路的条数 <em>M</em>。随后 <em>M</em> 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 <em>N</em> 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 <code>0</code>。</p>\n<p>再下一行给出一个正整数 <em>K</em>，是待检验的攻略的数量。随后 <em>K</em> 行，每行给出一条待检攻略，格式为：</p>\n<p><em>n</em> <em>V</em>1 <em>V</em>2 ⋯ Vn</p>\n<p>其中 <em>n</em>(≤200) 是攻略中的网红点数，<em>Vi</em> 是路径上的网红点编号。这里假设你从家里出发，从 <em>V</em>1 开始打卡，最后从 <em>Vn</em> 回家。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在第一行输出满足要求的攻略的个数。</p>\n<p>在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。</p>\n<p>题目保证至少存在一个有效攻略，并且总路费不超过 109。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre><code class=\"in\">6 13\n0 5 2\n6 2 2\n6 0 1\n3 4 2\n1 5 2\n2 5 1\n3 1 1\n4 1 2\n1 6 1\n6 3 2\n1 2 1\n4 5 3\n2 0 2\n7\n6 5 1 4 3 6 2\n6 5 2 1 6 3 4\n8 6 2 1 6 3 4 5 2\n3 2 1 5\n6 6 1 3 4 5 2\n7 6 2 1 3 4 5 2\n6 5 2 1 4 3 6\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre><code class=\"out\">3\n5 11\n</code></pre>\n<h3 id=\"样例说明：\"><a href=\"#样例说明：\" class=\"headerlink\" title=\"样例说明：\"></a>样例说明：</h3><p>第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。</p>\n<p>第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 &#x3D; 14；</p>\n<p>第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &#x3D; 11，是一条更省钱的攻略；</p>\n<p>第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。</p>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint n,m;\nint g[205][205];\nint minsize=INT_MAX;\t\t\t//初始化为INT_MAX\nint minid=0;\nint main()\n&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    int cnt=0;\n    memset(g,0,sizeof(g));\n    for (int i = 0; i &lt;m ; ++i) &#123;\n        int a,b,c;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n        g[a][b]=c;\n        g[b][a]=c;\n    &#125;\n    int time;\n    cin&gt;&gt;time;\n    for (int j = 0; j &lt;time ; ++j) &#123;\n        int k;\n        cin&gt;&gt;k;\n        int roll[k+5];\n        int has[k+5];\n        memset(has,0,sizeof(has));\n        roll[0]=roll[k+1]=0;\t\t\t\t\t//起点和终点必定是家\n        for (int i = 1; i &lt;=k ; ++i) &#123;\n            cin&gt;&gt;roll[i];\n            if(has[roll[i]]) has[0]=1;\t\t\t//每个打卡点仅能打卡一次\n            else has[roll[i]]=1;\n        &#125;\n        int flag=1;\n        int tmpsize=0;\n        if(k!=n||has[0]) continue;\n        for (int l = 1; l &lt;=k+1 ; ++l) &#123;\n            if(g[roll[l-1]][roll[l]]==0)\n            &#123;\n                flag=0;\n                break;\n            &#125;\n            tmpsize+=g[roll[l-1]][roll[l]];\n        &#125;\n        if(flag==1)\n        &#123;\n            if(tmpsize&lt;minsize)&#123;\n                minsize=tmpsize;\n                minid=j+1;\n\n            &#125;\n            cnt++;\n        &#125;\n    &#125;\n    cout&lt;&lt;cnt&lt;&lt;endl;\n    cout&lt;&lt;minid&lt;&lt;&quot; &quot;&lt;&lt;minsize&lt;&lt;endl;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059\">题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Graph",
                "邻接矩阵"
            ]
        },
        {
            "id": "http://example.com/2022/04/23/Algorithm031/",
            "url": "http://example.com/2022/04/23/Algorithm031/",
            "title": "L2-039 清点代码库 (25 分)",
            "date_published": "2022-04-23T13:44:47.000Z",
            "content_html": "<h2 id=\"L2-039-清点代码库-25-分\"><a href=\"#L2-039-清点代码库-25-分\" class=\"headerlink\" title=\"L2-039 清点代码库 (25 分)\"></a>L2-039 清点代码库 (25 分)</h2><p><img src=\"/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg\" alt=\"code.jpg\"></p>\n<p>上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”</p>\n<p>这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 <strong>int</strong> 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行中给出 2 个正整数，依次为 <em>N</em>（≤104）和 <em>M</em>（≤102），对应功能模块的个数和系列测试输入的个数。</p>\n<p>随后 <em>N</em> 行，每行给出一个功能模块的 <em>M</em> 个对应输出，数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>首先在第一行输出不同功能的个数 <em>K</em>。随后 <em>K</em> 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。</p>\n<p>注：所谓数列 { <em>A</em>1, …, <em>A</em>M } 比 { <em>B</em>1, …, <em>B</em>M } 大，是指存在 1≤i&lt;*M*，使得 *A*1&#x3D;*B*1，…，*Ai*&#x3D;*Bi* 成立，且 *Ai*+1&gt;<em>B</em>+1。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre><code class=\"in\">7 3\n35 28 74\n-1 -1 22\n28 74 35\n-1 -1 22\n11 66 0\n35 28 74\n35 28 74\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre><code class=\"out\">4\n3 35 28 74\n2 -1 -1 22\n1 11 66 0\n1 28 74 35\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>利用map的映射关系</strong></p>\n<pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nmap&lt;vector&lt;int&gt;,int&gt; mp;   //key，value\nvector&lt;int&gt; tmp;\nint n,m;\nbool cmp(pair&lt;vector&lt;int&gt;,int&gt; a,pair&lt;vector&lt;int&gt;,int&gt; b)\n&#123;\n    if(a.second==b.second)\n    &#123;\n        return a.first&lt;b.first;\n    &#125;\n    return a.second&gt;b.second;\n\n&#125;\nint main()\n&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for (int i = 0; i &lt;n ; ++i) &#123;\n        for (int j = 0; j &lt; m; ++j) &#123;\n            int num;\n            cin&gt;&gt;num;\n            tmp.push_back(num);\n        &#125;\n        mp[tmp]++;\n        tmp.clear();\n    &#125;\n    vector&lt;pair&lt;vector&lt;int&gt;,int&gt;&gt; v(mp.begin(),mp.end());\t\t//把map类型转化成vector\n    cout&lt;&lt;v.size()&lt;&lt;endl;\n    sort(v.begin(),v.end(),cmp);\t\t\t\t\t\t\t\t//sort排序，注意终点和起点\n    for (int k = 0; k &lt;v.size() ; ++k) &#123;\n        cout&lt;&lt;v[k].second&lt;&lt;&quot; &quot;;\n        for (int i = 0; i &lt;m ; ++i) &#123;\n            if(i!=m-1)&#123;\n                cout&lt;&lt;v[k].first[i]&lt;&lt;&quot; &quot;;\n            &#125; else&#123;\n                cout&lt;&lt;v[k].first[i]&lt;&lt;endl;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362\">题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Sort",
                "Vector",
                "Map",
                "Pair"
            ]
        },
        {
            "id": "http://example.com/2022/04/23/Algorithm030/",
            "url": "http://example.com/2022/04/23/Algorithm030/",
            "title": "L2-005 集合相似度 (25 分)",
            "date_published": "2022-04-23T13:39:53.000Z",
            "content_html": "<h2 id=\"L2-005-集合相似度-25-分\"><a href=\"#L2-005-集合相似度-25-分\" class=\"headerlink\" title=\"L2-005 集合相似度 (25 分)\"></a>L2-005 集合相似度 (25 分)</h2><p>给定两个整数集合，它们的相似度定义为：Nc&#x2F;Nt×100%。其中Nc是两个集合都有的不相等整数的个数，Nt是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤50），是集合的个数。随后<em>N</em>行，每行对应一个集合。每个集合首先给出一个正整数<em>M</em>（≤104），是集合中元素的个数；然后跟<em>M</em>个[0,109]区间内的整数。</p>\n<p>之后一行给出一个正整数<em>K</em>（≤2000），随后<em>K</em>行，每行对应一对需要计算相似度的集合的编号（集合从1到<em>N</em>编号）。数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre><code class=\"in\">3\n3 99 87 101\n4 87 101 5 87\n7 99 101 18 5 135 18 99\n2\n1 2\n1 3\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre><code class=\"out\">50.00%\n33.33%\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>双set模拟</strong></p>\n<pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n    int n;\n    set&lt;int&gt; s[55];\n    cin&gt;&gt;n;\n    for (int i = 0; i &lt;n ; ++i) &#123;\n        int time;\n        cin&gt;&gt;time;\n        for (int j = 0; j &lt;time ; ++j) &#123;\n            int num;\n            cin&gt;&gt;num;\n            s[i].insert(num);\n        &#125;\n    &#125;\n    int find;\n    cin&gt;&gt;find;\n    for (int l = 0; l &lt;find ; ++l) &#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        int sum=0;\n        set&lt;int&gt;::iterator it;\t\t\t\t\t\t\t\t//迭代器\n        int cnt=0;\n        for (it=s[a-1].begin(); it!=s[a-1].end() ; it++) &#123;\n            if(s[b-1].find(*it)!=s[b-1].end())&#123;\t\t\t\t//找到了\n                cnt++;\t\t\t\t\t\t\t\t\t\t//Nc\n            &#125;\n        &#125;\n        sum=s[a-1].size()+s[b-1].size()-cnt;\t\t\t\t//Nt=两个集合的总个数-相同个数\n        double ans=double(double(cnt)/double(sum))*100.0;\n        printf(&quot;%.2lf%\\n&quot;,ans);\n\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805070149828608\">题目详情 - L2-005 集合相似度 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "C++",
                "Set",
                "团体程序设计天梯赛",
                "模拟"
            ]
        },
        {
            "id": "http://example.com/2022/04/16/Algorithm029/",
            "url": "http://example.com/2022/04/16/Algorithm029/",
            "title": "STL中map的使用",
            "date_published": "2022-04-16T08:26:03.000Z",
            "content_html": "<h2 id=\"STL中map的使用\"><a href=\"#STL中map的使用\" class=\"headerlink\" title=\"STL中map的使用\"></a>STL中map的使用</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>map 是 STL 的一个关联容器，它提供一对一的数据处理能力。</p>\n<p>map 对象是<strong>模板类</strong>，需要<strong>关键字</strong>和<strong>存储对象</strong>两个模板参数：其中第一个参数称为关键字，每个关键字只能在 map 中出现一次；第二个参数称为该关键字的值。可以将关键字和存储对象理解为“{键，值}对”。</p>\n<pre><code class=\"c++\">map&lt;int,string&gt; mp;\n</code></pre>\n<h3 id=\"map的数据插入操作\"><a href=\"#map的数据插入操作\" class=\"headerlink\" title=\"map的数据插入操作\"></a>map的数据插入操作</h3><pre><code class=\"c++\">//使用insert函数插入pair数据\nmp.insert(pair&lt;int,string&gt;(3,&quot;xingyuanjie&quot;));\n//使用数组方式插入数据\nmp[2]=&quot;wangzhouyang&quot;;\n</code></pre>\n<p><strong>说明：上面的两种方法是有区别的，用 insert 函数插入数据，涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能实现数据插入的；但是数组方式能够插入数据，插入的数据会覆盖该关键字之前对应的值。</strong></p>\n<h3 id=\"map中数据的遍历\"><a href=\"#map中数据的遍历\" class=\"headerlink\" title=\"map中数据的遍历\"></a>map中数据的遍历</h3><pre><code class=\"c++\">map&lt;int,string&gt;::iterator it;\t\t\t\t\t//迭代器\nfor (it=mp.begin();it!=mp.end();it++) &#123;\n    cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;\n&#125;\n</code></pre>\n<h3 id=\"map中数据的查找\"><a href=\"#map中数据的查找\" class=\"headerlink\" title=\"map中数据的查找\"></a>map中数据的查找</h3><pre><code class=\"c++\">map&lt;int,string&gt;::iterator it;\t\t\t\t\t//迭代器\nit=mp.find(1);\nif(it!=mp.end())&#123;\n        cout &lt;&lt; &quot;Find it, the relative value is: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n&#125;\nelse&#123;\n           cout &lt;&lt; &quot;Can not find the relative value.&quot; &lt;&lt; endl;\n&#125;\n</code></pre>\n<h3 id=\"map中数据的删除\"><a href=\"#map中数据的删除\" class=\"headerlink\" title=\"map中数据的删除\"></a>map中数据的删除</h3><pre><code class=\"c++\">map&lt;int,string&gt;::iterator it;\t\t\t\t\t//迭代器\nit = mp.find(2);\nmp.erase(it);\n</code></pre>\n<h3 id=\"map中数据的排序\"><a href=\"#map中数据的排序\" class=\"headerlink\" title=\"map中数据的排序\"></a>map中数据的排序</h3><p><strong>map 中的所有元素都会根据元素的键值，自动进行升序排序。</strong></p>\n<h3 id=\"完整操作\"><a href=\"#完整操作\" class=\"headerlink\" title=\"完整操作\"></a>完整操作</h3><h4 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h4><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nmap&lt;int,string&gt; mp;\nint main()\n&#123;\n    //使用insert函数插入pair数据\n    mp.insert(pair&lt;int,string&gt;(3,&quot;xingyuanjie&quot;));\n    mp.insert(pair&lt;int,string&gt;(1,&quot;shicheng&quot;));\n    mp.insert(pair&lt;int,string&gt;(4,&quot;tanghaipeng&quot;));\n    mp.insert(pair&lt;int,string&gt;(6,&quot;zhouyuhao&quot;));\n    mp.insert(pair&lt;int,string&gt;(5,&quot;heqichuan&quot;));\n    //使用数组方式插入数据\n    mp[2]=&quot;wangzhouyang&quot;;\n    //map的遍历\n    map&lt;int,string&gt;::iterator it;\n    for (it=mp.begin();it!=mp.end();it++) &#123;\n        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;\n    &#125;\n    //查找操作\n    it=mp.find(1);\n    if(it!=mp.end())&#123;\n        cout &lt;&lt; &quot;Find it, the relative value is: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n    else &#123;\n        cout &lt;&lt; &quot;Can not find the relative value.&quot; &lt;&lt; endl;\n    &#125;\n    //删除操作\n    it = mp.find(2);\n    mp.erase(it);\n    for (it=mp.begin();it!=mp.end();it++) &#123;\n        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"程序输出：\"><a href=\"#程序输出：\" class=\"headerlink\" title=\"程序输出：\"></a>程序输出：</h4><pre><code class=\"c++\">1 shicheng\n2 wangzhouyang\n3 xingyuanjie\n4 tanghaipeng\n5 heqichuan\n6 zhouyuhao\nFind it, the relative value is: shicheng\n1 shicheng\n3 xingyuanjie\n4 tanghaipeng\n5 heqichuan\n6 zhouyuhao\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://blog.csdn.net/liitdar/article/details/80009712\">(20条消息) STL中map介绍_liitdar的博客-CSDN博客_stlmap</a></p>\n",
            "tags": [
                "STL",
                "Map"
            ]
        },
        {
            "id": "http://example.com/2022/04/16/Algorithm028/",
            "url": "http://example.com/2022/04/16/Algorithm028/",
            "title": "L2-010 排座位 (25 分)",
            "date_published": "2022-04-16T06:57:46.000Z",
            "content_html": "<h2 id=\"L2-010-排座位-25-分\"><a href=\"#L2-010-排座位-25-分\" class=\"headerlink\" title=\"L2-010 排座位 (25 分)\"></a><strong>L2-010 排座位 (25 分)</strong></h2><p>布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入第一行给出3个正整数：<code>N</code>（≤100），即前来参宴的宾客总人数，则这些人从1到<code>N</code>编号；<code>M</code>为已知两两宾客之间的关系数；<code>K</code>为查询的条数。随后<code>M</code>行，每行给出一对宾客之间的关系，格式为：<code>宾客1 宾客2 关系</code>，其中<code>关系</code>为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后<code>K</code>行，每行给出一对需要查询的宾客编号。</p>\n<p>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出<code>No problem</code>；如果他们之间并不是朋友，但也不敌对，则输出<code>OK</code>；如果他们之间有敌对，然而也有共同的朋友，则输出<code>OK but...</code>；如果他们之间只有敌对关系，则输出<code>No way</code>。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre><code class=\"in\">7 8 4\n5 6 1\n2 7 -1\n1 3 1\n3 4 1\n6 7 -1\n1 2 1\n1 4 1\n2 3 -1\n3 4\n5 7\n2 3\n7 2\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre><code class=\"out\">No problem\nOK\nOK but...\nNo way\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接矩阵 + 并查集</strong></p>\n<p><strong>并查集具体链接：</strong></p>\n<p><a href=\"https://xingyuanjie.top/2022/01/04/Algorithm004/\">并查集 - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n<pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint pre[100];\t\t\t\t//父节点\nint deep[100];\t\t\t\t//深度\nint g[101][101];\t\t\t//邻接矩阵建图\nvoid init(int n)&#123;\n    for (int i = 0; i &lt;n ; ++i) &#123;\n        pre[i]=i;\n        deep[i]=0;\n    &#125;\n&#125;\nint find(int x)&#123;\n    if(pre[x]==x)&#123;\n        return x;\n    &#125; else&#123;\n        return pre[x]=find(pre[x]);\n    &#125;\n&#125;\nvoid unit(int x,int y)&#123;\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n    if(deep[x]&lt;deep[y])&#123;\n        pre[x]=y;\n    &#125;else&#123;\n        pre[y]=x;\n        if(deep[x]==deep[y])&#123;\n            deep[x]++;\n        &#125;\n    &#125;\n&#125;\nint main()\n&#123;\n    int n,m,k;\n    init(105);\n    memset(g,0,sizeof(g));\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n    for (int i = 0; i &lt;m ; ++i) &#123;\n        int a,b,c;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n        g[a][b]=g[b][a]=c;\n        if(c==1) unit(a,b);\t\t\t\t\t//如果是朋友则合并\n    &#125;\n    for (int j = 0; j &lt;k ; ++j) &#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        if(g[a][b]==1&amp;&amp;g[b][a]==1) cout&lt;&lt;&quot;No problem&quot;&lt;&lt;endl;\n        else if(g[a][b]==0&amp;&amp;g[b][a]==0) cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl;\t\t\t//两人毫无关系\n        else if(g[a][b]==-1&amp;&amp;g[b][a]==-1&amp;&amp;find(a)==find(b)) cout&lt;&lt;&quot;OK but...&quot;&lt;&lt;endl;\t//敌对且有共同朋友\n        else if(g[a][b]==-1&amp;&amp;g[b][a]==-1) cout&lt;&lt;&quot;No way&quot;&lt;&lt;endl;\t\t//仅敌对\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://blog.csdn.net/weixin_45260385/article/details/109752008\">(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客</a></p>\n<p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680\">题目详情 - L2-010 排座位 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Graph",
                "邻接矩阵",
                "并查集"
            ]
        },
        {
            "id": "http://example.com/2022/04/16/Algorithm027/",
            "url": "http://example.com/2022/04/16/Algorithm027/",
            "title": "L2-009 抢红包 (25 分)",
            "date_published": "2022-04-16T06:57:38.000Z",
            "content_html": "<h2 id=\"L2-009-抢红包-25-分\"><a href=\"#L2-009-抢红包-25-分\" class=\"headerlink\" title=\"L2-009 抢红包 (25 分)\"></a><strong>L2-009 抢红包 (25 分)</strong></h2><p>没有人没抢过红包吧…… 这里给出<em>N</em>个人之间互相发红包、抢红包的记录，请你统计一下他们抢红包的收获。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤104），即参与发红包和抢红包的总人数，则这些人从1到<em>N</em>编号。随后<em>N</em>行，第<em>i</em>行给出编号为<em>i</em>的人发红包的记录，格式如下：</p>\n<p><em>K     N</em>1 <em>P</em>1⋯ NK PK</p>\n<p>其中<em>K</em>（0≤<em>K</em>≤20）是发出去的红包个数，<em>N</em>i<em>是抢到红包的人的编号，</em>Pi（&gt;0）是其抢到的红包金额（以分为单位）。注意：对于同一个人发出的红包，每人最多只能抢1次，不能重复抢。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>按照收入金额从高到低的递减顺序输出每个人的编号和收入金额（以元为单位，输出小数点后2位）。每个人的信息占一行，两数字间有1个空格。如果收入金额有并列，则按抢到红包的个数递减输出；如果还有并列，则按个人编号递增输出。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre><code class=\"in\">10\n3 2 22 10 58 8 125\n5 1 345 3 211 5 233 7 13 8 101\n1 7 8800\n2 1 1000 2 1000\n2 4 250 10 320\n6 5 11 9 22 8 33 7 44 10 55 4 2\n1 3 8800\n2 1 23 2 123\n1 8 250\n4 2 121 4 516 7 112 9 10\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre><code class=\"out\">1 11.63\n2 3.63\n8 3.63\n3 2.11\n7 1.69\n6 -1.67\n9 -2.18\n10 -3.26\n5 -3.26\n4 -12.32\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>结构体 + Sort</strong></p>\n<p><strong>需要注意的就是double类型相等的比较</strong></p>\n<p><strong>首先，浮点数在计算机中并不能精确的表示，所以在判断两个double类型的数时需要其他的手段，而不是直接 a&#x3D;&#x3D; b</strong></p>\n<pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct student&#123;\n    int id=0;\n    double money=0;\n    int cnt=0;\n&#125;;\ndouble dis=1e-6;\t\t\t\t//定义一个误差\nbool cmp(student a,student b)&#123;\n    if(abs(a.money-b.money)&lt;dis)&#123;\t\t\t\t//如果两个double型相减在误差的范围内，我们认定这两个double类型相等\n        if(a.cnt==b.cnt)&#123;\n            return a.id&lt;b.id;\n        &#125;else&#123;\n            return a.cnt&gt;b.cnt;\n        &#125;\n    &#125;\n    return a.money&gt;b.money;\n&#125;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    student st[n+5];\n    for (int i = 0; i &lt;n ; ++i) &#123;\n        int time;\n        cin&gt;&gt;time;\n        st[i].id=i+1;\n        for (int j = 0; j &lt;time ; ++j) &#123;\n            int p;\n            double x;\n            cin&gt;&gt;p&gt;&gt;x;\n            st[p-1].money+=x/100;\n            st[i].money-=x/100;\n            st[p-1].cnt++;\t\t\t\t\t//记录抢到的红包数\n        &#125;\n    &#125;\n    sort(st,st+n,cmp);\t\t\t\t\t\t//sort从数组下标0开始排序，左闭右开\n    for (int k = 0; k &lt;n ; ++k) &#123;\n        printf(&quot;%d %.2lf\\n&quot;,st[k].id,st[k].money);\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://blog.csdn.net/dingpiao190/article/details/73512811?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1\">(20条消息) double类型是否相等的判断方法_dingpiao190的博客-CSDN博客_double判断相等</a></p>\n<p><a href=\"https://blog.csdn.net/patrick_star_cowboy/article/details/82083392\">(20条消息) 如何判断两个double类型的数是否相等？_Patrick-Star的博客-CSDN博客_两个double怎么判断相等</a></p>\n<p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805066890854400\">题目详情 - L2-009 抢红包 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "C++",
                "团体程序设计天梯赛",
                "Sort",
                "结构体",
                "Double类型相等比较"
            ]
        }
    ]
}