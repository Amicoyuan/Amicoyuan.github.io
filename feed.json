{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan",
    "description": "",
    "home_page_url": "https://xingyuanjie.top",
    "items": [
        {
            "id": "https://xingyuanjie.top/2023/03/06/cuda011/",
            "url": "https://xingyuanjie.top/2023/03/06/cuda011/",
            "title": "cuda011",
            "date_published": "2023-03-06T08:18:09.000Z",
            "content_html": "<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/03/06/cuda010/",
            "url": "https://xingyuanjie.top/2023/03/06/cuda010/",
            "title": "CUDA处理错误",
            "date_published": "2023-03-06T08:17:59.000Z",
            "content_html": "<h2 id=\"CUDA处理错误\"><a href=\"#CUDA处理错误\" class=\"headerlink\" title=\"CUDA处理错误\"></a>CUDA处理错误</h2><p>由于许多CUDA调用是异步的，所以有时可能很难确定某个错误是由哪一步程序引起的。定义一个错误处理宏封装所有的CUDA API调用，这简化了错误检查过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> CHECK(call)</span><br>&#123;<br>    <span class=\"hljs-keyword\">const</span> cudaError_t error = call;<br>    <span class=\"hljs-keyword\">if</span>(error != cudaSuccess)<br>    &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Error:%s:%d, &quot;</span>, __FILE__, __LINE__);<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;code:%d, reason: %s\\n&quot;</span>, error, <span class=\"hljs-built_in\">cudaGetErrorString</span>(error));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>例如，你可以在以下代码中使用宏：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-constructor\">CHECK(<span class=\"hljs-params\">cudaMemcpy</span>(<span class=\"hljs-params\">d_C</span>, <span class=\"hljs-params\">gpuRef</span>, <span class=\"hljs-params\">nBytes</span>, <span class=\"hljs-params\">cudaMemcpyHostToDevice</span>)</span>);<br></code></pre></div></td></tr></table></figure>\n\n<p>如果内存拷贝或之前的异步操作产生了错误，这个宏会报告错误代码，并输出一个可读信息，然后停止程序。也可以用下述方法，在核函数调用后检查核函数错误：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">kernel_function&lt;&lt;&lt;grid,block&gt;&gt;&gt;(argument list);<br><span class=\"hljs-built_in\">CHECK</span>(<span class=\"hljs-built_in\">cudaDeviceSynchronize</span>());<br></code></pre></div></td></tr></table></figure>\n\n<p>CHECK(cudaDeviceSynchronize())会阻塞主机端线程的运行直到设备端所有的请求任务都结束，并确保最后的核函数启动部分不会出错。以上仅是以调试为目的的，因为在核函数启动后添加这个检查点会阻塞主机端线程，使该检查点成为全局屏障。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/03/06/cuda009/",
            "url": "https://xingyuanjie.top/2023/03/06/cuda009/",
            "title": "CUDA验证核函数",
            "date_published": "2023-03-06T08:06:35.000Z",
            "content_html": "<h2 id=\"CUDA验证核函数\"><a href=\"#CUDA验证核函数\" class=\"headerlink\" title=\"CUDA验证核函数\"></a>CUDA验证核函数</h2><p>既然你已经编写了核函数，你如何能知道它是否正确运行？你需要一个主机函数来验证核函数的结果。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">checkResult</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> *hostRef, <span class=\"hljs-keyword\">float</span> *gpuRef, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> N)</span></span>&#123;<br>    <span class=\"hljs-keyword\">double</span> epsilon = <span class=\"hljs-number\">1.0E-8</span>;<br>    <span class=\"hljs-keyword\">int</span> match = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span> ;i &lt; N; i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">abs</span>(hostRef[i] - gpuRef[i]) &gt; epsilon)&#123;<br>            match = <span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Arrays do not match!\\n&quot;</span>);<br>            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;host %5.2f gpu %5.2f at current %d\\n&quot;</span>,hostRef[i],gpuRef[i],i);<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(match) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Arrays match.\\n\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"验证核函数代码\"><a href=\"#验证核函数代码\" class=\"headerlink\" title=\"验证核函数代码\"></a>验证核函数代码</h3><p>除了许多可用的调试工具外，还有两个非常简单实用的方法可以验证核函数。</p>\n<p>首先，你可以在Fermi及更高版本的设备端的核函数中使用printf函数。</p>\n<p>其次，可以将执行参数设置为&lt;&lt;&lt;1,1&gt;&gt;&gt;，因此强制用一个块和一个线程执行核函数，这模拟了串行执行程序。这对于调试和验证结果是否正确是非常有用的，而且，如果你遇到了运算次序的问题，这有助于你对比验证数值结果是否是按位精确的。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/03/06/cuda008/",
            "url": "https://xingyuanjie.top/2023/03/06/cuda008/",
            "title": "CUDA编写核函数",
            "date_published": "2023-03-06T07:46:00.000Z",
            "content_html": "<h2 id=\"编写核函数\"><a href=\"#编写核函数\" class=\"headerlink\" title=\"编写核函数\"></a>编写核函数</h2><p>核函数是在设备端执行的代码。在核函数中，需要为一个线程规定要进行的计算以及要进行的数据访问。当核函数被调用时，许多不同的CUDA线程并行执行同一个计算任务。以下是用_<em>global</em>_</p>\n<p>声明定义核函数：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs reasonml\">__global__  void kernel<span class=\"hljs-constructor\">_name(<span class=\"hljs-params\">argument</span> <span class=\"hljs-params\">list</span>)</span>;<br></code></pre></div></td></tr></table></figure>\n\n<p>核函数必须有一个void返回类型。</p>\n<p>表2-2总结了CUDA C程序中的函数类型限定符。函数类型限定符指定一个函数在主机上执行还是在设备上执行，以及可被主机调用还是被设备调用。</p>\n<p><img src=\"/2023/03/06/cuda008/image-20230306155126122.png\" alt=\"image-20230306155126122\"></p>\n<p>_<em>device</em>_   和 __host__限定符可以一齐使用，这样函数可以同时在主机和设备端进行编译。</p>\n<h3 id=\"CUDA核函数的限制\"><a href=\"#CUDA核函数的限制\" class=\"headerlink\" title=\"CUDA核函数的限制\"></a>CUDA核函数的限制</h3><p>以下限制适用于所有核函数：</p>\n<ul>\n<li>只能访问设备内存</li>\n<li>必须具有void返回类型</li>\n<li>不支持可变数量的参数</li>\n<li>不支持静态变量</li>\n<li>显示异步行为</li>\n</ul>\n<p>考虑一个简单的例子：将两个大小为N的向量A和B相加，主机端的向量加法C代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sumArrayOnHost</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> *A, <span class=\"hljs-keyword\">float</span> *B, <span class=\"hljs-keyword\">float</span> *C, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> N)</span></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N; i++)<br>        C[i] = A[i] + B[i];<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>这是一个迭代N次的串行程序，循环结束后将产生以下核函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">__global__ <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sumArrayOnHost</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> *A, <span class=\"hljs-keyword\">float</span> *B, <span class=\"hljs-keyword\">float</span> *C)</span></span>&#123;<br>    \t<span class=\"hljs-keyword\">int</span> i = threadIdx.x;<br>        C[i] = A[i] + B[i];<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>C函数和核函数之间有什么不同？你可能已经注意到循环体消失了，内置的线程坐标变量替换了数组索引，由于N是被隐式定义用来启动N个线程的，所以N没有什么参考价值。</p>\n<p>假设有一个长度为32个元素的向量，你可以按以下方法用32个线程来调用核函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">sumArraysOnGPU&lt;&lt;&lt;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">32</span>&gt;&gt;&gt;(<span class=\"hljs-keyword\">float</span> *A, <span class=\"hljs-keyword\">float</span> *B, <span class=\"hljs-keyword\">float</span> *C);<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/03/06/cuda007/",
            "url": "https://xingyuanjie.top/2023/03/06/cuda007/",
            "title": "启动一个CUDA核函数",
            "date_published": "2023-03-06T05:59:18.000Z",
            "content_html": "<h2 id=\"启动一个CUDA核函数\"><a href=\"#启动一个CUDA核函数\" class=\"headerlink\" title=\"启动一个CUDA核函数\"></a>启动一个CUDA核函数</h2><p>你应该对下列C语言函数调用语句很熟悉：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">function_name</span> (argument list);<br></code></pre></div></td></tr></table></figure>\n\n<p>CUDA内核调用是对C语言函数调用语句的延申，&lt;&lt;&lt;&gt;&gt;&gt;运算符内是核函数的执行配置。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">kerbel_name&lt;&lt;&lt;grid,block&gt;&gt;&gt;(srgument list);<br></code></pre></div></td></tr></table></figure>\n\n<p>正如上一节所述，CUDA编程模型揭示了线程层次结构。利用执行配置可以指定线程在GPU上调度运行的方式。执行配置的第一个值是网格维度，也就是启动块的数目。第二个值是块维度，也就是每个块中线程的数目。通过指定网格和块的维度，你可以进行一下配置：</p>\n<ul>\n<li>内核中线程的数目</li>\n<li>内核中使用的线程布局</li>\n</ul>\n<p>同一个块中的线程之间可以相互协作，不同块内的线程不能协作。对于一个给定的问题，可以使用不同的网格和块布局来组织你的线程。例如，假设你有32个数据元素用于计算，每8个元素一个块，需要启动4个块：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">kernel_name&lt;&lt;&lt;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">8</span>&gt;&gt;&gt;(argument list);<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/03/06/cuda007/image-20230306140924311.png\" alt=\"image-20230306140924311\"></p>\n<p>由于数据在全局内存中是线性存储的，因此可以用变量blockIdx.x和threadIdx.x来进行以下操作。</p>\n<ul>\n<li>在网格中标识一个唯一的线程</li>\n<li>建立线程和数据元素之间的映射关系</li>\n</ul>\n<p>如果把32个元素放到一个块里，那么只会得到一个块：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">kernel_name&lt;&lt;&lt;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">32</span>&gt;&gt;&gt;(argument list);<br></code></pre></div></td></tr></table></figure>\n\n<p>如果每个块只含一个元素，那么会有32个块：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">kernel_name&lt;&lt;&lt;<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">1</span>&gt;&gt;&gt;(argument list);<br></code></pre></div></td></tr></table></figure>\n\n<p>核函数的调用与主机线程是异步的。核函数调用结束后，控制权立刻返回给主机端。你可以调用以下函数来强制主机端程序等待所有的核函数执行结束：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">cudaError_t <span class=\"hljs-title\">cudaDeviceSynchronize</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>)</span></span>;<br></code></pre></div></td></tr></table></figure>\n\n<p>一些CUDA运行时API在主机和设备之间是隐式同步的。当使用cudaMemcpy函数在主机和设备之间拷贝数据时，主机端隐式同步，即主机端程序必须等待数据拷贝完成后才能继续执行程序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">cudaError_t <span class=\"hljs-title\">cudaMemcpy</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>* dst, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">void</span>* src, <span class=\"hljs-keyword\">size_t</span> count, cudaMemcpyKind kind)</span></span>;<br></code></pre></div></td></tr></table></figure>\n\n<p>之前所有的核函数调用完成后开始拷贝数据。当拷贝完成后，控制权立刻返回给主机端。</p>\n<h3 id=\"异步行为\"><a href=\"#异步行为\" class=\"headerlink\" title=\"异步行为\"></a>异步行为</h3><p>不同于C语言的函数调用，所有的CUDA核函数的启动都是异步的。CUDA内核调用完成后，控制权立刻返回给CPU。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>CUDA C编程权威指南 程润伟，Max Grossman(美)，Ty Mckercher </p>\n",
            "tags": [
                "CUDA"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/03/02/leetcode205/",
            "url": "https://xingyuanjie.top/2023/03/02/leetcode205/",
            "title": "205.同构字符串",
            "date_published": "2023-03-02T12:44:27.000Z",
            "content_html": "<h2 id=\"205-同构字符串\"><a href=\"#205-同构字符串\" class=\"headerlink\" title=\"205.同构字符串\"></a>205.同构字符串</h2><h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"https://leetcode.cn/problems/isomorphic-strings/\">205. 同构字符串 - 力扣（LeetCode）</a></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isIsomorphic</span><span class=\"hljs-params\">(string s, string t)</span> </span>&#123;<br>        string ss;<br>        string st;<br>        <span class=\"hljs-keyword\">int</span> hash[<span class=\"hljs-number\">255</span>];<br>        <span class=\"hljs-keyword\">int</span> index=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-built_in\">memset</span>(hash, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(hash));<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(hash[<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">int</span></span>(s[i])]==<span class=\"hljs-number\">0</span>)<br>            &#123;<br>                index++;<br>                hash[<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">int</span></span>(s[i])]=index;<br>                ss.<span class=\"hljs-built_in\">push_back</span>(index+<span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                ss.<span class=\"hljs-built_in\">push_back</span>(hash[<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">int</span></span>(s[i])]+<span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>            &#125;<br>        &#125;<br>        index=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-built_in\">memset</span>(hash, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(hash));<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;t.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(hash[<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">int</span></span>(t[i])]==<span class=\"hljs-number\">0</span>)<br>            &#123;<br>                index++;<br>                hash[<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">int</span></span>(t[i])]=index;<br>                st.<span class=\"hljs-built_in\">push_back</span>(index+<span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                st.<span class=\"hljs-built_in\">push_back</span>(hash[<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">int</span></span>(t[i])]+<span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">int</span> ans = ss.<span class=\"hljs-built_in\">compare</span>(st);<br>        <span class=\"hljs-keyword\">if</span>(ans==<span class=\"hljs-number\">0</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考代码\"><a href=\"#参考代码\" class=\"headerlink\" title=\"参考代码\"></a>参考代码</h2><p><img src=\"/2023/03/02/leetcode205/image-20230302204605581.png\" alt=\"image-20230302204605581\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isIsomorphic</span><span class=\"hljs-params\">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class=\"hljs-keyword\">char</span>, <span class=\"hljs-keyword\">char</span>&gt; s2t;<br>        unordered_map&lt;<span class=\"hljs-keyword\">char</span>, <span class=\"hljs-keyword\">char</span>&gt; t2s;<br>        <span class=\"hljs-keyword\">int</span> len = s.<span class=\"hljs-built_in\">length</span>();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; ++i) &#123;<br>            <span class=\"hljs-keyword\">char</span> x = s[i], y = t[i];<br>            <span class=\"hljs-keyword\">if</span> ((s2t.<span class=\"hljs-built_in\">count</span>(x) &amp;&amp; s2t[x] != y) || (t2s.<span class=\"hljs-built_in\">count</span>(y) &amp;&amp; t2s[y] != x)) &#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>            &#125;<br>            s2t[x] = y;<br>            t2s[y] = x;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://leetcode.cn/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/\">同构字符串 - 同构字符串 - 力扣（LeetCode）</a></p>\n",
            "tags": [
                "C++",
                "LeetCode",
                "哈希表"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/03/02/leetcode189/",
            "url": "https://xingyuanjie.top/2023/03/02/leetcode189/",
            "title": "189.轮转数组",
            "date_published": "2023-03-02T12:03:32.000Z",
            "content_html": "<h2 id=\"189-轮转数组\"><a href=\"#189-轮转数组\" class=\"headerlink\" title=\"189.轮转数组\"></a>189.轮转数组</h2><h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"https://leetcode.cn/problems/rotate-array/\">189. 轮转数组 - 力扣（LeetCode）</a></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><img src=\"/2023/03/02/leetcode189/image-20230302200538871.png\" alt=\"image-20230302200538871\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">reverse</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums,<span class=\"hljs-keyword\">int</span> begin,<span class=\"hljs-keyword\">int</span> end)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">while</span>(begin&lt;end)&#123;<br>            <span class=\"hljs-built_in\">swap</span>(nums[begin], nums[end]);<br>            begin++;<br>            end--;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">rotate</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>        <span class=\"hljs-comment\">//数组翻转</span><br>        <span class=\"hljs-keyword\">int</span> p = k%nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-built_in\">reverse</span>(nums,<span class=\"hljs-number\">0</span>,nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>);<br>        <span class=\"hljs-built_in\">reverse</span>(nums,<span class=\"hljs-number\">0</span>,p<span class=\"hljs-number\">-1</span>);<br>        <span class=\"hljs-built_in\">reverse</span>(nums,p,nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://leetcode.cn/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/\">旋转数组 - 轮转数组 - 力扣（LeetCode）</a></p>\n",
            "tags": [
                "C++",
                "LeetCode",
                "数组翻转"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/03/01/leetcode724/",
            "url": "https://xingyuanjie.top/2023/03/01/leetcode724/",
            "title": "724.寻找数组的中心下标",
            "date_published": "2023-03-01T09:35:03.000Z",
            "content_html": "<h1 id=\"724-寻找数组的中心下标\"><a href=\"#724-寻找数组的中心下标\" class=\"headerlink\" title=\"724.寻找数组的中心下标\"></a>724.寻找数组的中心下标</h1><h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"https://leetcode.cn/problems/find-pivot-index/\">724. 寻找数组的中心下标 - 力扣（LeetCode）</a></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><img src=\"/2023/03/01/leetcode724/image-20230301173931031.png\" alt=\"image-20230301173931031\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">pivotIndex</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> total=<span class=\"hljs-built_in\">accumulate</span>(nums.<span class=\"hljs-built_in\">begin</span>(), nums.<span class=\"hljs-built_in\">end</span>(),<span class=\"hljs-number\">0</span>);\t<span class=\"hljs-comment\">//第三个形参是累加的初始值</span><br>        <span class=\"hljs-keyword\">int</span> sum=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>();i++)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">2</span>*sum+nums[i] == total)&#123;<br>                <span class=\"hljs-keyword\">return</span> i;<br>            &#125;<br>            sum+=nums[i];<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://leetcode.cn/problems/find-pivot-index/solution/xun-zhao-shu-zu-de-zhong-xin-suo-yin-by-gzjle/\">寻找数组的中心索引 - 寻找数组的中心下标 - 力扣（LeetCode）</a></p>\n",
            "tags": [
                "C++",
                "LeetCode",
                "前缀和"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/28/vectorbool/",
            "url": "https://xingyuanjie.top/2023/02/28/vectorbool/",
            "title": "vector<bool>与vector<T>",
            "date_published": "2023-02-28T12:59:01.000Z",
            "content_html": "<h1 id=\"vector-lt-bool-gt-与vector-lt-T-gt\"><a href=\"#vector-lt-bool-gt-与vector-lt-T-gt\" class=\"headerlink\" title=\"vector&lt;bool&gt;与vector&lt;T&gt;\"></a>vector&lt;bool&gt;与vector&lt;T&gt;</h1><p>vector&lt;bool&gt; 不像其他容器一样按Byte存储的，它是按bit存储的，也就是说一个正常的bool类型的空间可以存放vector&lt;bool&gt;中的8个，空间上确实优化了很多，然而，c++是不能直接取对bit操作的（因为C++的最小可寻址值通常以byte为单位），对其使用operator[]其实返回的不是bool的引用而是一个”proxy reference”是”std::vector&lt; bool&gt;:reference”类型的对象。</p>\n<p>正因为如此，vector&lt;bool&gt;通过代理对象进行存取访问时需要执行逐位处理，访问通常比int之类的普通类型操作要慢很多。</p>\n<p>因此，对vecotr&lt;bool&gt;的使用需慎重考虑以下几点：<br>(1)是否需要牺牲速度来获取空间上的优化<br>(2)算法中会否有对vecotr地址进行解引用操作的可能。</p>\n<p>如果不满足以上条件，建议使用deque&lt;bool&gt;来取代vector&lt;bool&gt;，功能基本相同，但deque&lt;bool&gt;未对其进行特殊处理。</p>\n<p>下面是vector&lt;bool&gt;与vector&lt;T&gt;简单的对比例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\tvector&lt;<span class=\"hljs-keyword\">char</span>&gt; ch;<br>\tvector&lt;<span class=\"hljs-keyword\">int</span>&gt; in;<br>\tvector&lt;<span class=\"hljs-keyword\">bool</span>&gt; bo;<br> <br>\t<span class=\"hljs-keyword\">int</span> m = <span class=\"hljs-number\">1e6</span>;<br>\t<span class=\"hljs-keyword\">clock_t</span> t1, t2, t3;<br> <br>\tt1 = <span class=\"hljs-built_in\">clock</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>\t\tch.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>\t&#125;<br>\tt1 = <span class=\"hljs-built_in\">clock</span>() - t1;<br> <br>\tt2 = <span class=\"hljs-built_in\">clock</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>\t\tin.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">0</span>);<br>\t&#125;<br>\tt2 = <span class=\"hljs-built_in\">clock</span>() - t2;<br> <br>\tt3 = <span class=\"hljs-built_in\">clock</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>\t\tbo.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br>\tt3 = <span class=\"hljs-built_in\">clock</span>() - t3;<br> <br>\tcout &lt;&lt;<span class=\"hljs-string\">&quot;vector&lt;char&gt; &quot;</span>&lt;&lt; t1 &lt;&lt; <span class=\"hljs-string\">&quot;\\n vector&lt;int&gt; &quot;</span> &lt;&lt; t2 &lt;&lt; <span class=\"hljs-string\">&quot;\\nvector&lt;bool&gt; &quot;</span> &lt;&lt; t3 &lt;&lt; endl;<br>\tcout &lt;&lt; endl;<br> <br>\t<span class=\"hljs-built_in\">system</span>(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs cpp\">vector&lt;<span class=\"hljs-keyword\">char</span>&gt; <span class=\"hljs-number\">216</span><br>vextor&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-number\">229</span><br>vector&lt;<span class=\"hljs-keyword\">bool</span>&gt; <span class=\"hljs-number\">16535</span><br></code></pre></div></td></tr></table></figure>\n\n<p>这里发现vector&lt;bool&gt;相较于其他vector&lt;T&gt;速度要慢的多！</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/qq_52134928/article/details/121066304?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121066304-blog-86603050.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121066304-blog-86603050.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1\">(65条消息) 【C++】vector＜bool＞的特别之处_小陶同学_的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/u013249689/article/details/25297657\">(65条消息) 不使用vector的原因和替代方法_jackycmu的博客-CSDN博客</a></p>\n",
            "tags": [
                "STL",
                "Vector",
                "C/C++",
                "bool"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/28/Linux004/",
            "url": "https://xingyuanjie.top/2023/02/28/Linux004/",
            "title": "C/C++关键字之restrict",
            "date_published": "2023-02-28T11:45:09.000Z",
            "content_html": "<h1 id=\"C-x2F-C-关键字之restrict\"><a href=\"#C-x2F-C-关键字之restrict\" class=\"headerlink\" title=\"C&#x2F;C++关键字之restrict\"></a>C&#x2F;C++关键字之restrict</h1><p>在C语言中，restrict关键字用于修饰指针（C99标准）。通过加上restrict关键字，程序员可提示编译器：在该指针的生命周期内，其指向的对象不会被别的指针所引用。</p>\n<p>需要注意的是，在C++中，并无明确统一的标准支持restrict关键字。但是很多编译器实现了功能相同的关键字，例如gcc和clang中的__restrict关键字。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>*a, <span class=\"hljs-keyword\">int</span>* b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    *a = <span class=\"hljs-number\">10</span>;<br>    *b = <span class=\"hljs-number\">12</span>;<br>    <span class=\"hljs-keyword\">return</span> *a + *b;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>add1函数的返回值会永远是10 + 12 &#x3D; 22吗？</p>\n<p>答案是不一定。在指针a和b的地址不同时，返回22没有问题。但是当指针a与b指向的是同一个int对象时，该对象先被赋值为10，后被赋值为12，因此a和b都返回12，因此add1函数最终返回24。</p>\n<p>下面是一个简单的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>* a, <span class=\"hljs-keyword\">int</span>* b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    *a = <span class=\"hljs-number\">10</span>;<br>    *b = <span class=\"hljs-number\">12</span>;<br>    <span class=\"hljs-keyword\">return</span> *a + *b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span>* c;<br>    <span class=\"hljs-keyword\">int</span>* d;<br>    d=(<span class=\"hljs-keyword\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">int</span>)*<span class=\"hljs-number\">1</span>);<br>    c=(<span class=\"hljs-keyword\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">int</span>)*<span class=\"hljs-number\">1</span>);<br>    *c=<span class=\"hljs-number\">10</span>;<br>    *d=<span class=\"hljs-number\">12</span>;<br>    *d=<span class=\"hljs-number\">12</span>;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;c:&quot;</span>&lt;&lt;*c&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;d:&quot;</span>&lt;&lt;*d&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;When Pointers a and b have different addresses&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-built_in\">add1</span>(c,d)&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;When Pointers a and b have the same address&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-built_in\">add1</span>(c,c)&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>程序输出：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">c:<span class=\"hljs-number\">10</span><br>d:<span class=\"hljs-number\">12</span><br>When Pointers a <span class=\"hljs-keyword\">and</span> b have different addresses<br><span class=\"hljs-number\">22</span><br>When Pointers a <span class=\"hljs-keyword\">and</span> b have the same address<br><span class=\"hljs-number\">24</span><br></code></pre></div></td></tr></table></figure>\n\n<p>开启-O3优化，add1对应的汇编代码如下:</p>\n<p>为了得到<code>*a</code>的值访问了1次内存，而不管在何种条件下(<code>a == b</code> or <code>a != b</code>)，<code>*b</code>的值都是12。因此编译器将<code>*a</code>的值载入<code>eax</code>寄存器后，直接加上立即数12，而无需再访问内存获取<code>*b</code>的值。在无法确定指针a和b是否相同的情况下，编译器只能帮你优化到这里了。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\"><span class=\"hljs-number\">0000000000400</span>a10 &lt;_Z4add1PiS_&gt;:<br>  <span class=\"hljs-number\">400</span>a10:   c7 <span class=\"hljs-number\">07</span> <span class=\"hljs-number\">0</span>a <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0</span>xa,(%rdi) ; *a = <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-number\">400</span>a16:   c7 <span class=\"hljs-number\">06</span> <span class=\"hljs-number\">0</span>c <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0</span>xc,(%rsi) ; *b = <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-number\">400</span>a1c:   <span class=\"hljs-number\">8</span>b <span class=\"hljs-number\">07</span>                   mov    (%rdi),%eax ; 结果 = *a<br>  <span class=\"hljs-number\">400</span>a1e:   <span class=\"hljs-number\">83</span> c0 <span class=\"hljs-number\">0</span>c                add    $<span class=\"hljs-number\">0</span>xc,%eax   ; 结果 += <span class=\"hljs-number\">12</span> <br>  <span class=\"hljs-number\">400</span>a21:   c3                      retq<br></code></pre></div></td></tr></table></figure>\n\n<p>加上了restrict关键字过后，同样开启-O3优化，add1对应的汇编代码如下：</p>\n<p>加上关键字restrict后，编译器能够确认指针a和b不可能指向同一个内存地址，因此在求*a + *b时，无虚访问内存，因为*a必然等于立即数10，*b必然等于立即数12。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>* __restrict  a, <span class=\"hljs-keyword\">int</span>* __restrict b)</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>    *a = <span class=\"hljs-number\">10</span>;<br>    *b = <span class=\"hljs-number\">12</span>;<br>    <span class=\"hljs-keyword\">return</span> *a + *b ;<br>&#125;<br><span class=\"hljs-number\">0000000000400</span>a30 &lt;_Z4add2PiS_&gt;:<br>  <span class=\"hljs-number\">400</span>a30:   c7 <span class=\"hljs-number\">07</span> <span class=\"hljs-number\">0</span>a <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0xa</span>,(%rdi) ; *a = <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-number\">400</span>a36:   b8 <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>          mov    $<span class=\"hljs-number\">0x16</span>,%eax  ; 结果 = <span class=\"hljs-number\">22</span><br>  <span class=\"hljs-number\">400</span>a3b:   c7 <span class=\"hljs-number\">06</span> <span class=\"hljs-number\">0</span>c <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0xc</span>,(%rsi) ; *b = <span class=\"hljs-number\">12</span><br>  <span class=\"hljs-number\">400</span>a41:   c3  <br></code></pre></div></td></tr></table></figure>\n\n<p>有无restrict关键字的两种情况下的汇编指令可看到，后者比前者少访问一次内存，且少执行一条指令。就是因为没加restruct关键字时，编译器不能确定别的地方是不是会修改此值，所以会去相应的地址查看。</p>\n<p><strong>这样当我们明确知道两个指针不可能指向同一个地址时，我们就可以通过使用restrict关键字来进行性能优化。</strong></p>\n<p>注意使用restrict的时候，程序员必须确保不会出现<strong>pointer aliasing</strong>，即同一块内存无法通过两个或以上的指针变量名访问。不满足这个条件强行指定restrict，将会出现<strong>underfined behavior</strong>。</p>\n<p>通常编写代码时会忽略pointer aliasing的问题。更常见是在性能分析时，通过反汇编看到很多冗余的读取指令，才会想到加入restrict关键字来提升性能。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zhuanlan.zhihu.com/p/349726808\">C&#x2F;C++关键字之restrict - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://github.com/ClickHouse/ClickHouse/pull/19946\">Improve performance of aggregate functions by alexey-milovidov · Pull Request #19946 · ClickHouse&#x2F;ClickHouse (github.com)</a></p>\n<p><a href=\"https://en.cppreference.com/w/c/language/restrict\">restrict type qualifier - cppreference.com</a></p>\n<p><a href=\"https://www.zhihu.com/question/41653775/answer/2535730128\">如何理解C语言关键字restrict？ - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://blog.csdn.net/qq_41822235/article/details/83479562\">(65条消息) 关键字_restrict___restrict_楚楚可薇的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qq_41950508/article/details/126619881?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-126619881-blog-102577325.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-126619881-blog-102577325.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1\">(65条消息) 【C++】关键字restrict的作用_restrict关键字的作用_不知所措的渣渣辉的博客-CSDN博客</a></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/26/intel001/",
            "url": "https://xingyuanjie.top/2023/02/26/intel001/",
            "title": "unroll_and_jam/nounroll_and_jam",
            "date_published": "2023-02-26T11:12:51.000Z",
            "content_html": "<h1 id=\"unroll-and-jam-x2F-nounroll-and-jam\"><a href=\"#unroll-and-jam-x2F-nounroll-and-jam\" class=\"headerlink\" title=\"unroll_and_jam&#x2F;nounroll_and_jam\"></a>unroll_and_jam&#x2F;nounroll_and_jam</h1><p>启用或禁用循环展开和阻塞。这些指令只能应用于迭代for循环。</p>\n<h2 id=\"Syntax\"><a href=\"#Syntax\" class=\"headerlink\" title=\"Syntax\"></a>Syntax</h2><p>#pragma unroll_and_jam\t#pragma unroll_and_jam (n)\t#pragma nounroll_and_jam</p>\n<h2 id=\"Arguments\"><a href=\"#Arguments\" class=\"headerlink\" title=\"Arguments\"></a>Arguments</h2><p>展开因子，表示展开循环的次数;必须是0到255之间的整数常数</p>\n<h2 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h2><p>unroll_and_jam指令部分展开套中比最内层循环更高的一个或多个循环，并将结果循环融合&#x2F;阻塞回一起。这种转换允许在循环中进行更多的重用。</p>\n<p>此pragma对最内层循环无效。确保紧随其后的循环不是编译器发起的交换完成后的最内层循环。</p>\n<p>指定此pragma是向编译器提示展开和阻塞序列是合法且有利可图的。编译器会在任何可能的情况下启用这种转换。</p>\n<p>对于它影响的每个for循环，unroll_and_jam指令必须在for语句之前。如果指定了n，优化器将展开循环n次。如果n被省略或超出允许的范围，优化器将分配展开循环的次数。编译器通过比较n和循环计数生成正确的代码。</p>\n<p>只有在设置了编译器选项O3时，才支持此pragma。unroll_and_jam指令将覆盖从命令行展开循环的任何设置。</p>\n<p>当展开循环会增加寄存器压力和代码大小时，可能需要防止展开嵌套循环或不完美的嵌套循环。在这种情况下，使用nounroll_and_jam编译指令。nounroll_and_jam pragma提示编译器不要展开指定的循环。</p>\n<p><strong>Examples</strong></p>\n<p><strong>Use the unroll_and_jam pragma:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> a[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10</span>]; <br><span class=\"hljs-keyword\">int</span> b[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10</span>]; <br><span class=\"hljs-keyword\">int</span> c[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10</span>]; <br><span class=\"hljs-keyword\">int</span> d[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10</span>]; <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">unroll</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> i,j,k;<br>    <span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> unroll_and_jam (6)</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">1</span>; i &lt; n; i++) &#123;<br>       <span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> unroll_and_jam (6)</span><br>       <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">1</span>; j &lt; n; j++) &#123;<br>          <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">1</span>; k &lt; n; k++)&#123;<br>            a[i][j] += b[i][k]*c[k][j];<br>            &#125;<br>       &#125;<br>    &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/pragmas/intel-specific-pragma-reference/unroll-and-jam-nounroll-and-jam.html\">unroll_and_jam nounroll_and_jam (intel.com)</a></p>\n",
            "tags": [
                "C++",
                "Intel"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/26/cache001/",
            "url": "https://xingyuanjie.top/2023/02/26/cache001/",
            "title": "Cache Blocking Techniques【个人翻译】",
            "date_published": "2023-02-26T10:02:29.000Z",
            "content_html": "<h2 id=\"Cache-Blocking-Techniques\"><a href=\"#Cache-Blocking-Techniques\" class=\"headerlink\" title=\"Cache Blocking Techniques\"></a>Cache Blocking Techniques</h2><p><strong>文章来源：</strong><a href=\"https://www.intel.cn/content/www/cn/zh/developer/articles/technical/cache-blocking-techniques.html\">Cache Blocking Techniques (intel.cn)</a></p>\n<p><strong>文章作者：</strong><a href=\"https://community.intel.com/cipcp26785/plugins/custom/intel/intel/custom.userprofile?id=3UpJu61CDTyShonSVJNwDw==&iv=8843887237217530\">Amanda K Sharp</a></p>\n<h3 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h3><p>一类重要的算法更改涉及分块数据结构以适应缓存。通过组织数据内存访问，可以用一个大得多的数据集的一个小子集加载缓存。接下来的想法是在缓存中处理这个数据块。通过在缓存中使用&#x2F;重用这些数据，我们减少了访问内存的需要(减少内存带宽压力)。</p>\n<h3 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h3><p>分块是一种著名的优化技术，可以帮助避免许多应用程序中的内存带宽瓶颈。分块背后的关键思想是利用应用程序中固有的数据重用，确保数据在多个用途之间保持在缓存中。分块可以在1-D、2-D或3-D空间数据结构上执行。一些迭代应用程序可以进一步受益于多次迭代的分块(通常称为时间分块)，以进一步缓解带宽瓶颈。就代码更改而言，分块通常涉及循环分割和交换的组合。在大多数应用程序代码中，通过对分块因子进行一些参数化，对源进行正确的更改，用户可以最好地执行分块。</p>\n<h3 id=\"Original-Source\"><a href=\"#Original-Source\" class=\"headerlink\" title=\"Original Source\"></a>Original Source</h3><figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\">for (body1 = <span class=\"hljs-number\">0</span>; body1 &lt; NBODIES; body1 ++) &#123;<br>   for (body2=<span class=\"hljs-number\">0</span>; body2 &lt; NBODIES; body2++) &#123;<br>     <span class=\"hljs-keyword\">OUT</span>[body1] += compute(body1, body2);<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在本例中，数据(body2)来自内存。假设NBODIES很大，我们将无法在缓存中重用。此应用程序受内存带宽限制。应用程序将以内存到CPU的速度运行，而不是最佳速度。</p>\n<p><strong>Modified Source (with 1-D blocking):</strong></p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\">for (body2 = <span class=\"hljs-number\">0</span>; body2 &lt; NBODIES; body2 += <span class=\"hljs-keyword\">BLOCK</span>) &#123;<br>   for (body1=<span class=\"hljs-number\">0</span>; body1 &lt; NBODIES; body1 ++) &#123;<br>      for (body22=<span class=\"hljs-number\">0</span>; body22 &lt; <span class=\"hljs-keyword\">BLOCK</span>; body22 ++) &#123;<br>         <span class=\"hljs-keyword\">OUT</span>[body1] += compute(body1, body2 + body22);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在修改后的代码中，数据(body22)在缓存中被保留和重用，从而获得更好的性能。</p>\n<p>例如，上面的代码片段显示了一个分块NBody代码的示例。有两个循环(body1和body2)遍历所有主体。顶部的原始代码流经内部循环中的整个主体集，并且必须在每次迭代中从内存中加载body2值。底部的分块代码是通过将body2循环分解为一个迭代多个BLOCK中的body的外部循环和一个迭代BLOCK中的元素的内部body22循环，并交织body1和body2循环来获得的。这段代码在body1循环的多次迭代中重用了一组BLOCK body2值。如果BLOCK被选中，使得这组值适合缓存，内存流量就会降低一个BLOCK的因子。</p>\n<p>以下是来自OpenMP*版本的NBody基准测试的相关代码片段(使用CHUNK_SIZE因子进行分块应用)。</p>\n<p>在这种情况下，循环展开-阻塞转换被表示为一个pragma，并由编译器完成。在这种情况下，研究-opt-report的输出可以确认编译器确实为你的循环执行了展开阻塞优化。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\">#define CHUNK_SIZE <span class=\"hljs-number\">8192</span><br><br>#pragma omp parallel <span class=\"hljs-keyword\">private</span>(body_start_index)<br>  for(body_start_index = <span class=\"hljs-number\">0</span>; body_start_index &lt; global_number_of_bodies; body_start_index += CHUNK_SIZE) &#123;<br>    <span class=\"hljs-built_in\">int</span> i;<br>    <span class=\"hljs-built_in\">int</span> body_end_index = body_start_index + CHUNK_SIZE;<br><br>    #pragma omp for <span class=\"hljs-keyword\">private</span>(i) schedule(guided)<br>    #pragma unroll_and_jam (<span class=\"hljs-number\">4</span>)<br>    for(i=starting_index; i&lt;ending_index; i++) &#123;<br>      <span class=\"hljs-built_in\">int</span> j;<br>      <span class=\"hljs-keyword\">TYPE</span> acc_x_0 = <span class=\"hljs-number\">0</span>, acc_y_0 = <span class=\"hljs-number\">0</span>, acc_z_0 = <span class=\"hljs-number\">0</span>;<br>      for(j=body_start_index; j&lt;body_end_index; j+=<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">TYPE</span> delta_x_0 = Input_Position_X[(j+<span class=\"hljs-number\">0</span>)] - Input_Position_X[i];<br>        <span class=\"hljs-keyword\">TYPE</span> delta_y_0 = Input_Position_Y[(j+<span class=\"hljs-number\">0</span>)] - Input_Position_Y[i];<br>        <span class=\"hljs-keyword\">TYPE</span> delta_z_0 = Input_Position_Z[(j+<span class=\"hljs-number\">0</span>)] - Input_Position_Z[i];<br><br>        <span class=\"hljs-keyword\">TYPE</span> gamma_0 = delta_x_0*delta_x_0 + delta_y_0*delta_y_0 + delta_z_0*delta_z_0 + epsilon_sqr;<br>        <span class=\"hljs-keyword\">TYPE</span> s_0 = Mass[j+<span class=\"hljs-number\">0</span>]/(gamma_0 * <span class=\"hljs-built_in\">SQRT</span>(gamma_0));<br>        acc_x_0 += s_0*delta_x_0;<br>        acc_y_0 += s_0*delta_y_0;<br>        acc_z_0 += s_0*delta_z_0;<br>      &#125;<br>      Output_Acceleration[<span class=\"hljs-number\">3</span>*(i+<span class=\"hljs-number\">0</span>)+<span class=\"hljs-number\">0</span>] += acc_x_0;<br>      Output_Acceleration[<span class=\"hljs-number\">3</span>*(i+<span class=\"hljs-number\">0</span>)+<span class=\"hljs-number\">1</span>] += acc_y_0;<br>      Output_Acceleration[<span class=\"hljs-number\">3</span>*(i+<span class=\"hljs-number\">0</span>)+<span class=\"hljs-number\">2</span>] += acc_z_0;<br>    &#125;<br>  &#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>下面是Fortran中的一个矩阵乘法代码示例，其中用户执行高级块展开-分块转换(在修改版本中)，涉及本地复制数组以获得最佳性能。</p>\n<p><strong>Fortran Source Example:</strong></p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\"><span class=\"hljs-keyword\">do</span> j=<span class=\"hljs-number\">1</span>,N<br>  <span class=\"hljs-keyword\">do</span> k = <span class=\"hljs-number\">1</span>,N<br>    <span class=\"hljs-keyword\">do</span> i = <span class=\"hljs-number\">1</span>,N<br>      c(i,j) = c(i,j) + a(i,k) * b(k,j)<br>    <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>  <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br><span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Modified Fortran Source:</strong></p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\"><span class=\"hljs-keyword\">do</span> JJ = <span class=\"hljs-number\">1</span>, N, TJ<br><br>       <span class=\"hljs-keyword\">do</span> KK = <span class=\"hljs-number\">1</span>, N, TK<br>         <span class=\"hljs-keyword\">do</span> jjj = <span class=\"hljs-number\">1</span>,<span class=\"hljs-built_in\">min</span>(tj,N-jj+<span class=\"hljs-number\">1</span>)                     <span class=\"hljs-comment\">! BCOPY - no transpose</span><br>           <span class=\"hljs-keyword\">do</span> kkk = <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">min</span>(tk,N-kk+<span class=\"hljs-number\">1</span>)<br>             p(kkk,jjj-<span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">1</span>) = B(kk+kkk-<span class=\"hljs-number\">1</span>, jj+jjj-<span class=\"hljs-number\">1</span>)<br>           <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>         <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>         <span class=\"hljs-keyword\">do</span> II = <span class=\"hljs-number\">1</span>, N, TI<br>           <span class=\"hljs-keyword\">do</span> iii = <span class=\"hljs-number\">1</span>,<br>             <span class=\"hljs-built_in\">min</span>(ti,N-ii+<span class=\"hljs-number\">1</span>)                   <span class=\"hljs-comment\">!ACOPY - transpose</span><br>             <span class=\"hljs-keyword\">do</span> kkk = <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">min</span>(tk,N-kk+<span class=\"hljs-number\">1</span>)<br>                Q(kkk,iii) = A(ii+iii-<span class=\"hljs-number\">1</span>, kk+kkk-<span class=\"hljs-number\">1</span>)<br>             <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>           <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>           <span class=\"hljs-keyword\">do</span> J = <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">min</span>(tj,N-jj+<span class=\"hljs-number\">1</span>), <span class=\"hljs-number\">4</span><br>             <span class=\"hljs-keyword\">do</span> I = <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">min</span>(ti,N-ii+<span class=\"hljs-number\">1</span>), <span class=\"hljs-number\">2</span><br>                t1 = <span class=\"hljs-number\">0</span> ; t2 = <span class=\"hljs-number\">0</span> ; t5 = <span class=\"hljs-number\">0</span> ; t6 = <span class=\"hljs-number\">0</span> ; t9 = <span class=\"hljs-number\">0</span> ; t10 = <span class=\"hljs-number\">0</span> ; t13 =<span class=\"hljs-number\">0</span> ; t14 = <span class=\"hljs-number\">0</span><br>                <span class=\"hljs-comment\">!DIR$ vector aligned                      !DIR$ unroll(2)</span><br>                <span class=\"hljs-keyword\">do</span> K = <span class=\"hljs-number\">1</span>,<span class=\"hljs-built_in\">min</span>(TK,N-kk+<span class=\"hljs-number\">1</span>)      <span class=\"hljs-comment\">! Innermost loop, vectorized and unrolled by 2 after that</span><br>                   qi = Q(K,I)           ;    qi1 = Q(K,I+<span class=\"hljs-number\">1</span>)  <br>                   t1 = t1+qi*P(K,J)     ;    t2 = t2+ qi1*P(K,J)<br>                   t5 = t5+ qi*P(K,J+<span class=\"hljs-number\">1</span>)  ;    t6 = t6+ qi1*P(K,J+<span class=\"hljs-number\">1</span>)<br>                   t9 = t9+ qi*P(K,J+<span class=\"hljs-number\">2</span>)  ;    t10 = t10+ qi1*P(K,J+<span class=\"hljs-number\">2</span>)<br>                   t13 = t13+ qi*P(K,J+<span class=\"hljs-number\">3</span>);    t14 = t14+qi1*P(K,J+<span class=\"hljs-number\">3</span>)<br>                <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>               c(i+ii-<span class=\"hljs-number\">1</span>,j+jj-<span class=\"hljs-number\">1</span>) = c(i+ii-<span class=\"hljs-number\">1</span>,j+jj-<span class=\"hljs-number\">1</span>) +t1          ; c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+jj-<span class=\"hljs-number\">1</span>) = c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+jj-<span class=\"hljs-number\">1</span>) + t2<br>               c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">1</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">1</span>+jj-<span class=\"hljs-number\">1</span>) + t5     ; c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">1</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">1</span>+jj-<span class=\"hljs-number\">1</span>) + t6<br>               c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">2</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">2</span>+jj-<span class=\"hljs-number\">1</span>) + t9     ; c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">2</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">2</span>+jj-<span class=\"hljs-number\">1</span>) + t10<br>               c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">3</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">3</span>+jj-<span class=\"hljs-number\">1</span>) + t13    ; c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">3</span>+jj-<span class=\"hljs-number\">1</span>) = c(i+<span class=\"hljs-number\">1</span>+ii-<span class=\"hljs-number\">1</span>,j+<span class=\"hljs-number\">3</span>+jj-<span class=\"hljs-number\">1</span>) + t14<br>             <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>           <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>         <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>       <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br>     <span class=\"hljs-keyword\">end</span> <span class=\"hljs-keyword\">do</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"Take-Aways\"><a href=\"#Take-Aways\" class=\"headerlink\" title=\"Take Aways\"></a>Take Aways</h3><p>缓存分块是一种重新安排数据访问的技术，将数据子集(块)拉入缓存，并对这个块进行操作，以避免不得不重复从主存中获取数据。正如上面的示例所示，可以以这种方式手动分块循环数据以重用缓存。</p>\n<p>对于性能关键的循环，其中性能分析表明内存带宽限制，而-opt-report显示编译器没有以最佳方式分块循环，您可以考虑手动展开循环，以便更好地分块数据以实现缓存重用。</p>\n<h3 id=\"NEXT-STEPS\"><a href=\"#NEXT-STEPS\" class=\"headerlink\" title=\"NEXT STEPS\"></a>NEXT STEPS</h3><p>您必须从头到尾阅读本指南，使用内置的超链接来指导您在Intel®Xeon处理器上成功地移植和调优应用程序。本指南中提供的路径反映了获得最佳应用程序性能所需的步骤。</p>\n",
            "tags": [
                "Cache",
                "Blocking"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/26/openmp008/",
            "url": "https://xingyuanjie.top/2023/02/26/openmp008/",
            "title": "OpenMP:Internal Control Variables",
            "date_published": "2023-02-26T09:36:54.000Z",
            "content_html": "<h2 id=\"2-5-Internal-Control-Variables\"><a href=\"#2-5-Internal-Control-Variables\" class=\"headerlink\" title=\"2.5 Internal Control Variables\"></a>2.5 Internal Control Variables</h2><p>OpenMP实现必须像内部控制变量(icv)一样控制OpenMP程序的行为。这些icv存储的信息包括用于未来并行区域的线程数、用于工作共享循环的调度以及是否启用嵌套并行。在程序执行期间，icv在不同的时间被赋予值(如下所述)。它们是由实现本身初始化的，并且可以通过OpenMP环境变量和调用OpenMP API例程来赋值。程序只能通过OpenMP API例程检索这些icv的值。</p>\n<p>出于说明的目的，本文档使用特定的名称来引用icv，但是实现不需要使用这些名称，也不需要提供访问变量的任何方法，除非通过第<a href=\"https://www.openmp.org/spec-html/5.0/openmpsu31.html#x50-680002.5.2\">189</a>页第<a href=\"https://www.openmp.org/spec-html/5.0/openmpsu31.html#x50-680002.5.2\">2.5.2节</a>所示的方法。</p>\n<p>2.5.1 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu30.html#x49-670002.5.1\">ICV Descriptions</a></p>\n<p>2.5.2 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu31.html#x50-680002.5.2\">ICV Initialization</a></p>\n<p>2.5.3 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu32.html#x51-710002.5.3\">Modifying and Retrieving ICV Values</a></p>\n<p>2.5.4 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu33.html#x52-740002.5.4\">How ICVs are Scoped</a></p>\n<p>​\t\t 2.5.4.1 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu33.html#x52-760002.5.4.1\">How the Per-Data Environment ICVs Work</a></p>\n<p>2.5.5 <a href=\"https://www.openmp.org/spec-html/5.0/openmpsu34.html#x53-770002.5.5\">ICV Override Relationships</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.openmp.org/spec-html/5.0/openmpse13.html#x48-660002.5\">Internal Control Variables (openmp.org)</a></p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/26/openmp007/",
            "url": "https://xingyuanjie.top/2023/02/26/openmp007/",
            "title": "OpenMP线程绑定【未完结】",
            "date_published": "2023-02-26T09:06:59.000Z",
            "content_html": "<h2 id=\"OpenMP线程绑定\"><a href=\"#OpenMP线程绑定\" class=\"headerlink\" title=\"OpenMP线程绑定\"></a>OpenMP线程绑定</h2><h3 id=\"OpenMP相关环境变量与指令\"><a href=\"#OpenMP相关环境变量与指令\" class=\"headerlink\" title=\"OpenMP相关环境变量与指令\"></a>OpenMP相关环境变量与指令</h3><h4 id=\"OMP-PROC-BIND\"><a href=\"#OMP-PROC-BIND\" class=\"headerlink\" title=\"OMP_PROC_BIND\"></a>OMP_PROC_BIND</h4><p>OMP_PROC_BIND环境变量设置bind-var ICV的初始值。这个环境变量的值可以是true、false，或者用逗号分隔的master、close或spread列表。列表的值设置了对应嵌套级别的并行区域要使用的线程亲和策略。</p>\n<p>如果环境变量设置为false，则执行环境可能会在OpenMP位置之间移动OpenMP线程，线程相关性将被禁用，并行构造上的proc_bind子句将被忽略。</p>\n<p>否则，执行环境不应该在OpenMP位置之间移动OpenMP线程，线程亲和性被启用，并且初始线程被绑定到OpenMP位置列表中的第一个位置，先于第一个活动并行区域。</p>\n<p>如果OMP_PROC_BIND环境变量中的值不是true、false或master、close或spread的逗号分隔列表，则程序的行为是实现定义的。如果初始线程不能绑定到OpenMP位置列表中的第一个位置，则该行为也是实现定义的。</p>\n<p>例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">setenv OMP_PROC_BIND false<br>setenv OMP_PROC_BIND &quot;spread,\tspread, close&quot;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://harrychen.xyz/2022/05/08/numa-processor-and-cpu-binding/\">NUMA 处理器与进程绑定 - Harry Chen’s Blog</a></p>\n<p><a href=\"https://www.openmp.org/spec-html/5.0/openmpse52.html\">OMP_PROC_BIND (openmp.org)</a></p>\n<p><a href=\"https://www.openmp.org/spec-html/5.0/openmpsu36.html#x56-900002.6.2\">Controlling OpenMP Thread Affinity</a></p>\n<p><a href=\"https://www.openmp.org/spec-html/5.0/openmpse53.html\">OMP_PLACES (openmp.org)</a></p>\n<p><a href=\"https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/optimization-and-programming/openmp-support/openmp-library-support/thread-affinity-interface.html\">Thread Affinity Interface (intel.com)</a></p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/24/Linux003/",
            "url": "https://xingyuanjie.top/2023/02/24/Linux003/",
            "title": "基于GDB的程序调试",
            "date_published": "2023-02-24T08:50:20.000Z",
            "content_html": "<h2 id=\"基于GDB的程序调试\"><a href=\"#基于GDB的程序调试\" class=\"headerlink\" title=\"基于GDB的程序调试\"></a>基于GDB的程序调试</h2><h3 id=\"程序调试工具GDB\"><a href=\"#程序调试工具GDB\" class=\"headerlink\" title=\"程序调试工具GDB\"></a>程序调试工具GDB</h3><p>编译器GCC，项目构建工具Make（又称gmake），以及GDB。</p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224165344672.png\" alt=\"image-20230224165344672\"></p>\n<p><strong>GDB是什么？</strong></p>\n<p>GDB：GNU symbolic debugger是Linux下常用的程序调试器</p>\n<p><strong>GDB可以做什么？</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224165606636.png\" alt=\"image-20230224165606636\"></p>\n<p><strong>GDB官网：</strong><a href=\"https://www.sourceware.org/gdb/\">GDB: The GNU Project Debugger (sourceware.org)</a></p>\n<h3 id=\"调试案例一\"><a href=\"#调试案例一\" class=\"headerlink\" title=\"调试案例一\"></a>调试案例一</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">int</span> n,sum;<br>    n = <span class=\"hljs-number\">1</span>;<br>    sum = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>( n &lt;= <span class=\"hljs-number\">100</span>)<br>    &#123;<br>        sum = sum + n;<br>        n = n + <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在编译程序的时候，需要加调试选项： -g</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">gcc gdb001.c -g -o ex1<br></code></pre></div></td></tr></table></figure>\n\n<p>使用gdb启动程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">gdb ./ex1<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>进入gdb调试环境</strong>：</p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224170419171.png\" alt=\"image-20230224170419171\"></p>\n<p><strong>在调试环境中：使用l选项会显示带行号的源代码</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224170620617.png\" alt=\"image-20230224170620617\"></p>\n<p><strong>但是默认情况下，l选项只显示10行源代码，如果查看后续代码，在调试界面Enter回车即可</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224170804048.png\" alt=\"image-20230224170804048\"></p>\n<p><strong>在第7行源代码处打断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224171858691.png\" alt=\"image-20230224171858691\"></p>\n<p><strong>运行程序，遇到断点停止：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172105514.png\" alt=\"image-20230224172105514\"></p>\n<p><strong>查看代码中变量n的值</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172200662.png\" alt=\"image-20230224172200662\"></p>\n<p>当前n的值为1，$1表示该变量所在存储区的名称</p>\n<p><strong>在程序第12行处打断点</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172321002.png\" alt=\"image-20230224172321002\"></p>\n<p><strong>继续执行程序</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172356622.png\" alt=\"image-20230224172356622\"></p>\n<p><strong>查看当前n变量的值</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172422998.png\" alt=\"image-20230224172422998\"></p>\n<p>当前n的值为101</p>\n<p><strong>退出调试</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172456626.png\" alt=\"image-20230224172456626\"></p>\n<p><strong>查看调试环境所有断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172650422.png\" alt=\"image-20230224172650422\"></p>\n<p><strong>删除第7行的断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172745323.png\" alt=\"image-20230224172745323\"></p>\n<p><strong>禁用编号为2的断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172832507.png\" alt=\"image-20230224172832507\"></p>\n<p>注意断点状态Enb(enable)由y变成n，代表禁用</p>\n<p><strong>恢复编号为2的断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224173006975.png\" alt=\"image-20230224173006975\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>GDB有三种调试模式：</p>\n<p><strong>调试执行程序：</strong>（前面的案例），注意编译加调试信息(-g)</p>\n<p><strong>调试core文件   ：</strong>需要对系统设置的core文件大小作调整（ulimit - c unlimlited），否则可能无法\t\t\t\t\t\t\t  产生core文件</p>\n<p><strong>调试正在执行的程序（gdb attach） ：</strong>Top找到进程编号pid，Gdb attach pid</p>\n<p><strong>GDB结构组成：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224173613247.png\" alt=\"image-20230224173613247\"></p>\n<h3 id=\"常用调试指令：\"><a href=\"#常用调试指令：\" class=\"headerlink\" title=\"常用调试指令：\"></a>常用调试指令：</h3><h4 id=\"启动指令\"><a href=\"#启动指令\" class=\"headerlink\" title=\"启动指令\"></a>启动指令</h4><p>调试程序：gdb program</p>\n<p>根据core文件调试程序：gdb program corefile</p>\n<p>跟踪调试进程：gdb attach pid</p>\n<h4 id=\"程序运行\"><a href=\"#程序运行\" class=\"headerlink\" title=\"程序运行\"></a>程序运行</h4><p>run，该命令会运行至程序结束，除非遇到断点或报错</p>\n<h4 id=\"单步执行\"><a href=\"#单步执行\" class=\"headerlink\" title=\"单步执行\"></a>单步执行</h4><p>步进执行不进栈？next</p>\n<p>步进执行，进栈step</p>\n<h4 id=\"代码查看\"><a href=\"#代码查看\" class=\"headerlink\" title=\"代码查看\"></a>代码查看</h4><p>列出断点附近或程序所有代码list</p>\n<p>设置现实代码的行数 set listsize &lt;n&gt;</p>\n<h4 id=\"退出调试\"><a href=\"#退出调试\" class=\"headerlink\" title=\"退出调试\"></a>退出调试</h4><p>quit</p>\n<h4 id=\"查看栈信息\"><a href=\"#查看栈信息\" class=\"headerlink\" title=\"查看栈信息\"></a>查看栈信息</h4><p>bt\t打印当前的函数调用栈的所有信息</p>\n<p>bt &lt;n&gt;\tn是一个正整数，表示只打印栈顶上n层的栈信息</p>\n<p>bt &lt;-n&gt;\t表示只打印栈底下n层的栈信息</p>\n<h4 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h4><p><strong>代码断点：</strong></p>\n<ul>\n<li>break lineNumber | functionName</li>\n<li>break lineNumber | functionName if condition</li>\n<li>tbreak lineNumber | functionName  临时断点，仅能使用一次</li>\n</ul>\n<p><strong>内存断点（观察点）：</strong></p>\n<ul>\n<li>监控内存值改变 watch expr [if condition]</li>\n<li>监控内存值被读取 rwatch expr [if condition]</li>\n<li>监控内存值被读取和写入 awatch wxpr [if condition]</li>\n</ul>\n<p><strong>事件断点：</strong></p>\n<ul>\n<li>C++ exception，使用catch exception [name]</li>\n<li>Ada exception，使用catch handlers [name]</li>\n<li>exec事件，使用catch exec</li>\n<li>fork事件，使用catch fork 或者 catch vfork</li>\n<li>加载和卸载动态so事件，使用catch load|unload [regexp]</li>\n<li>监听系统信号，使用catch signal [signal]</li>\n<li>监听系统调用，使用catch syscall[name|number|group:groupname|g:groupname]…</li>\n</ul>\n<p><strong>打印变量：</strong></p>\n<ul>\n<li>Print [file | func]::variable 查看局部变量或全局变量</li>\n<li>Print *array@len  数组首地址@查看长度</li>\n<li>x&#x2F;[n | u] &lt;addr&gt;\tx命令查看内存地址钟的值，n：表示显示内存的长度，u：表示从当前地址往后请求的字节数</li>\n</ul>\n<p><strong>打印寄存器：</strong></p>\n<p>info register\t查看寄存器（除了浮点寄存器）</p>\n<p>all-registers\t查看所有寄存器</p>\n<p>info registers &lt;reg_name …&gt;查看所指定寄存器</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><strong>来源培训PPT 作者：Relax  邮箱：<a href=\"mailto:&#x77;&#x61;&#x6e;&#x67;&#119;&#x31;&#x31;&#49;&#x40;&#105;&#x63;&#x6c;&#111;&#x75;&#x64;&#46;&#99;&#111;&#x6d;\">&#x77;&#x61;&#x6e;&#x67;&#119;&#x31;&#x31;&#49;&#x40;&#105;&#x63;&#x6c;&#111;&#x75;&#x64;&#46;&#99;&#111;&#x6d;</a></strong></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/19/Matrix002/",
            "url": "https://xingyuanjie.top/2023/02/19/Matrix002/",
            "title": "矩阵乘法计算拆分展示",
            "date_published": "2023-02-19T09:04:23.000Z",
            "content_html": "<h2 id=\"矩阵乘法计算拆分展示\"><a href=\"#矩阵乘法计算拆分展示\" class=\"headerlink\" title=\"矩阵乘法计算拆分展示\"></a>矩阵乘法计算拆分展示</h2><h3 id=\"通用矩阵乘概念\"><a href=\"#通用矩阵乘概念\" class=\"headerlink\" title=\"通用矩阵乘概念\"></a>通用矩阵乘概念</h3><p><img src=\"/2023/02/19/Matrix002/image-20230219171156738.png\" alt=\"image-20230219171156738\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i行j列</span><br>        c[i][j] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>           C[i][j] += A[i][p] * B[p][j];\t\t<span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n\n\n<h3 id=\"计算拆分展示\"><a href=\"#计算拆分展示\" class=\"headerlink\" title=\"计算拆分展示\"></a>计算拆分展示</h3><p>图四将输出计算拆分为 <strong>1 × 4</strong> 的小块，即将 <strong>N</strong> 维度拆分为两部分。计算该块输出时，需要使用 <strong>A</strong> 矩阵的1行，和 <strong>B</strong> 矩阵的4列 。</p>\n<p><img src=\"/2023/02/19/Matrix002/image-20230219171904249.png\" alt=\"image-20230219171904249\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j +=<span class=\"hljs-number\">4</span>)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵j-j+3列</span><br>        c[i][j + <span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i][j + <span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i][j + <span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i][j + <span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>            <span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>           C[i][j + <span class=\"hljs-number\">0</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">0</span>];    <br>           C[i][j + <span class=\"hljs-number\">1</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">1</span>];<br>           C[i][j + <span class=\"hljs-number\">2</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">2</span>];<br>           C[i][j + <span class=\"hljs-number\">3</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>最内侧计算使用的矩阵<strong>A</strong>的元素是一致的。因此可以将**A[i][p]**读取到寄存器中，从而实现4次数据复用。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> temp = A[i][p];<br></code></pre></div></td></tr></table></figure>\n\n<p>一般将最内侧循环称作计算核(micro kernel)</p>\n<p>类似地，我们可以继续拆分输出<strong>M</strong>维度，从而在内测循环中计算 <strong>4 × 4</strong> 输出，如图五。</p>\n<p><img src=\"/2023/02/19/Matrix002/image-20230219174355047.png\" alt=\"image-20230219174355047\"></p>\n<p>同样的，将计算核心展开，可以得到下面的伪代码。这里我们将 <strong>1 × 4</strong> 中展示过的N维度的计算简化表示。这种拆分可看成是<strong>4 × 1 × 4</strong>，这样A和B的访存均可复用四次。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i-i+3行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j +=<span class=\"hljs-number\">4</span>)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵第j-j+3列</span><br>        c[i + <span class=\"hljs-number\">0</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">1</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">2</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>            <span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>           C[i + <span class=\"hljs-number\">0</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];    <br>           C[i + <span class=\"hljs-number\">1</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">1</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">2</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">2</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">3</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>到目前为止。我们都是在输出的两个维度上展开，而整个计算还包含一个规约(Reduction)维度K。图六展示了在计算<strong>4 × 4</strong>输出时，将维度K拆分，从而每次最内侧循环计算出输出矩阵C的<strong>4&#x2F;K</strong>的部分和。</p>\n<p><img src=\"/2023/02/19/Matrix002/image-20230219180147184.png\" alt=\"image-20230219180147184\"></p>\n<p>下面展示的是这部分计算的展开伪代码，其中维度M和N已经被简写。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i-i+3行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j +=<span class=\"hljs-number\">4</span>)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵第j-j+3列</span><br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p+=<span class=\"hljs-number\">4</span>)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">0</span>] * B[p + <span class=\"hljs-number\">0</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];    <br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">1</span>] * B[p + <span class=\"hljs-number\">1</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">2</span>] * B[p + <span class=\"hljs-number\">2</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">3</span>] * B[p + <span class=\"hljs-number\">3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在对M和N展开式，我们可以分别复用B和A的数据；在对K展开时，其局部使用的C的内存是一致的，那么K迭代时可以将部分和累加在寄存器中——最内层循环整个迭代一次写到C的内存中。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://zhenhuaw.me/blog/2019/gemm-optimization.html\">通用矩阵乘（GEMM）优化算法 | 黎明灰烬 博客 (zhenhuaw.me)</a></p>\n",
            "tags": [
                "Matrix",
                "GEMM"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/18/leetcode11/",
            "url": "https://xingyuanjie.top/2023/02/18/leetcode11/",
            "title": "11. 盛最多水的容器",
            "date_published": "2023-02-18T08:27:01.000Z",
            "content_html": "<h2 id=\"11-盛最多水的容器\"><a href=\"#11-盛最多水的容器\" class=\"headerlink\" title=\"11.盛最多水的容器\"></a>11.盛最多水的容器</h2><h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><h4 id=\"11-盛最多水的容器-1\"><a href=\"#11-盛最多水的容器-1\" class=\"headerlink\" title=\"11. 盛最多水的容器\"></a><a href=\"https://leetcode.cn/problems/container-with-most-water/\">11. 盛最多水的容器</a></h4><h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">maxArea</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class=\"hljs-comment\">//双指针；</span><br>        <span class=\"hljs-keyword\">int</span> ans =<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> right=height.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">while</span>(left&lt;right)&#123;<br>            <span class=\"hljs-keyword\">int</span> temp=<span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">if</span>(height[left]&lt;=height[right])&#123;<br>                temp = height[left]*(right-left);<br>                ans = std::<span class=\"hljs-built_in\">max</span>(ans,temp);<br>                left++;<br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                temp = height[right]*(right-left);<br>                ans = std::<span class=\"hljs-built_in\">max</span>(ans,temp);<br>                right--;<br>            &#125;<br>            <br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> ans;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://leetcode.cn/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/\">盛最多水的容器 - 盛最多水的容器 - 力扣（LeetCode）</a></p>\n",
            "tags": [
                "C++",
                "LeetCode",
                "双指针"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/17/leetcode001/",
            "url": "https://xingyuanjie.top/2023/02/17/leetcode001/",
            "title": "146.LRU cache",
            "date_published": "2023-02-17T06:31:45.000Z",
            "content_html": "<h2 id=\"146-LRU-cache\"><a href=\"#146-LRU-cache\" class=\"headerlink\" title=\"146.LRU cache\"></a>146.LRU cache</h2><h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"https://leetcode.cn/problems/lru-cache/\">146. LRU 缓存 - 力扣（LeetCode）</a></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LRUCache</span> &#123;</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">int</span> cap=<span class=\"hljs-number\">0</span>;<br>    list&lt;pair&lt;<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-keyword\">int</span>&gt;&gt; lru;   <span class=\"hljs-comment\">//真正的cache</span><br>    unordered_map&lt;<span class=\"hljs-keyword\">int</span>,list&lt;pair&lt;<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-keyword\">int</span>&gt;&gt;::iterator&gt; mp;   <span class=\"hljs-comment\">//主要用处就是查找</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LRUCache</span>(<span class=\"hljs-keyword\">int</span> capacity) &#123;<br>        cap = capacity;\t\t\t\t\t\t<span class=\"hljs-comment\">//容量</span><br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> key)</span> </span>&#123;\t\t\t\t\t\t<span class=\"hljs-comment\">//作为就是把最近访问的放在表头</span><br>        <span class=\"hljs-keyword\">if</span>(mp.<span class=\"hljs-built_in\">find</span>(key)!=mp.<span class=\"hljs-built_in\">end</span>())&#123;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//有这个元素</span><br>            lru.<span class=\"hljs-built_in\">splice</span>(lru.<span class=\"hljs-built_in\">begin</span>(),lru,mp[key]);\t\t\t<span class=\"hljs-comment\">//将一个 list 容器中的元素插入到另一个容器的指定位置</span><br>            <span class=\"hljs-keyword\">return</span> lru.<span class=\"hljs-built_in\">begin</span>()-&gt;second;\t\t\t\t<span class=\"hljs-comment\">//返回元素</span><br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//没有这个元素</span><br>        &#125;<br>    &#125;<br><br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> key, <span class=\"hljs-keyword\">int</span> value)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">get</span>(key)!=<span class=\"hljs-number\">-1</span>)&#123;\t\t\t\t<span class=\"hljs-comment\">//cache中有key，调用get后自动插入到表头【key存在】</span><br>            lru.<span class=\"hljs-built_in\">begin</span>()-&gt;second = value;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;\t\t\t<span class=\"hljs-comment\">//【key不存在】</span><br>            <span class=\"hljs-keyword\">if</span>(lru.<span class=\"hljs-built_in\">size</span>()==cap)&#123;\t\t\t<span class=\"hljs-comment\">//如果容量满了</span><br>                <span class=\"hljs-keyword\">int</span> delkey = lru.<span class=\"hljs-built_in\">back</span>().first;\t\t <span class=\"hljs-comment\">//记录最久未访问的key</span><br>                lru.<span class=\"hljs-built_in\">pop_back</span>();\t\t\t\t\t\t <span class=\"hljs-comment\">//pop掉，置换</span><br>                mp.<span class=\"hljs-built_in\">erase</span>(delkey);\t\t\t\t\t <span class=\"hljs-comment\">//查找表中也删除\t</span><br>            &#125;<br>            lru.<span class=\"hljs-built_in\">emplace_front</span>(key,value);\t\t\t<span class=\"hljs-comment\">//头部生成一个元素</span><br>            mp[key]=lru.<span class=\"hljs-built_in\">begin</span>();\t\t\t\t\t<span class=\"hljs-comment\">//加入查找表</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Your LRUCache object will be instantiated and called as such:</span><br><span class=\"hljs-comment\"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class=\"hljs-comment\"> * int param_1 = obj-&gt;get(key);</span><br><span class=\"hljs-comment\"> * obj-&gt;put(key,value);</span><br><span class=\"hljs-comment\"> */</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.jianshu.com/p/bbea4b2410e6\">C++实现LRU缓存——LeetCode146 - 简书 (jianshu.com)</a></p>\n",
            "tags": [
                "C++",
                "LeetCode"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/15/blislab003/",
            "url": "https://xingyuanjie.top/2023/02/15/blislab003/",
            "title": "BLISlab中C矩阵初始化速度测试",
            "date_published": "2023-02-15T03:48:16.000Z",
            "content_html": "<h2 id=\"BLISlab中C矩阵初始化速度测试\"><a href=\"#BLISlab中C矩阵初始化速度测试\" class=\"headerlink\" title=\"BLISlab中C矩阵初始化速度测试\"></a>BLISlab中C矩阵初始化速度测试</h2><p><strong>假设我们想把C中的所有元素都设为0。</strong></p>\n<p><strong>统一编译命令：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">g++  xxx.cpp -O0 -std=c++11 -o xxx<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本一：\"><a href=\"#版本一：\" class=\"headerlink\" title=\"版本一：\"></a>版本一：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\t\t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>    \t\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123; <br>        \t\t<span class=\"hljs-built_in\">C</span>(i,j) = <span class=\"hljs-number\">0.0</span>;<br>   \t\t \t&#125;<br>\t\t&#125;<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：\"><a href=\"#实测结果：\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">10776901341</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">10776901</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">10776</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">10</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本二：\"><a href=\"#版本二：\" class=\"headerlink\" title=\"版本二：\"></a>版本二：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\t<span class=\"hljs-keyword\">double</span> *cp;<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    \tcp = &amp;C[ j*ldc ];\t\t\t<span class=\"hljs-comment\">//point cp to top of ith column</span><br>    \t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>        \t*cp++ = <span class=\"hljs-number\">0.0</span>;\t\t<span class=\"hljs-comment\">//set element that cp points to to zero and</span><br>    \t&#125;\t\t<span class=\"hljs-comment\">//advance the pointer</span><br>\t&#125;<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：-1\"><a href=\"#实测结果：-1\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">3455968000</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">3455968</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">3455</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">3</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本三：\"><a href=\"#版本三：\" class=\"headerlink\" title=\"版本三：\"></a>版本三：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\t<span class=\"hljs-keyword\">double</span> *cp;<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    \tcp = &amp;C[ j * ldc ];<br>    \t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>       \t\t*(cp+<span class=\"hljs-number\">0</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \t*(cp+<span class=\"hljs-number\">1</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \t*(cp+<span class=\"hljs-number\">2</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \t*(cp+<span class=\"hljs-number\">3</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \tcp+=<span class=\"hljs-number\">4</span>;<br>   \t\t&#125;<br>\t&#125;\t<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：-2\"><a href=\"#实测结果：-2\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">2581347801</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">2581347</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">2581</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">2</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本四：\"><a href=\"#版本四：\" class=\"headerlink\" title=\"版本四：\"></a>版本四：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\t<span class=\"hljs-keyword\">double</span> *cp;<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>    <span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> c0 =<span class=\"hljs-number\">0.0</span>,c1=<span class=\"hljs-number\">0.0</span>,c2=<span class=\"hljs-number\">0.0</span>,c3=<span class=\"hljs-number\">0.0</span>;<br>\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    \tcp = &amp;C[ j * ldc ];<br>    \t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>        \t*(cp+<span class=\"hljs-number\">0</span>) = c0;<br>        \t*(cp+<span class=\"hljs-number\">1</span>) = c1;<br>        \t*(cp+<span class=\"hljs-number\">2</span>) = c2;<br>        \t*(cp+<span class=\"hljs-number\">3</span>) = c3;<br>        \tcp+=<span class=\"hljs-number\">4</span>;<br>   \t\t &#125;<br>\t&#125;<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：-3\"><a href=\"#实测结果：-3\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">2269606428</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">2269606</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">2269</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">2</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://gukaifeng.cn/posts/c-11-chrono-gao-jing-du-ji-shi-fang-fa/\">C++11 chrono 高精度计时方法 | GuKaifeng’s Blog</a></p>\n",
            "tags": [
                "Linux",
                "dgemm"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/12/blislib002/",
            "url": "https://xingyuanjie.top/2023/02/12/blislib002/",
            "title": "BLISlab tutoril阅读",
            "date_published": "2023-02-12T13:11:56.000Z",
            "content_html": "<h1 id=\"BLISlab-tutoril阅读\"><a href=\"#BLISlab-tutoril阅读\" class=\"headerlink\" title=\"BLISlab tutoril阅读\"></a>BLISlab tutoril阅读</h1><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><p><strong>Git地址：</strong><a href=\"https://github.com/flame/blislab\">https://github.com/flame/blislab</a> 【代码包包含tutoril.pdf】</p>\n<h2 id=\"BLISlab-A-Sandbox-for-Optimizing-GEMM\"><a href=\"#BLISlab-A-Sandbox-for-Optimizing-GEMM\" class=\"headerlink\" title=\"BLISlab: A Sandbox for Optimizing GEMM\"></a>BLISlab: A Sandbox for Optimizing GEMM</h2><h2 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h2><p>矩阵-矩阵乘法是科学计算中非常重要的基本运算，机器学习也越来越重要。这是一个非常简单的概念，可以在典型的高中代数课程中引入，但在实践中又非常重要，它在计算机上的实现仍然是一个活跃的研究主题。本笔记描述了一组使用该操作的练习，如何在具有分层内存(多个缓存)的现代cpu上获得高性能。它是基于blas类库实例化软件(BLIS)框架下的见解，通过公开一个模仿BLIS实现的简化“沙盒”来实现的。因此，它也成为BLIS优化的“众包”工具。</p>\n<h2 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1.Introduction\"></a>1.Introduction</h2><p>矩阵-矩阵乘法(Gemm)经常被用作一个简单的例子，以提高如何在现代处理器上优化代码的意识。原因是该操作描述简单，很难完全优化，而且具有实际意义。在本文档中，我们将带领读者了解目前CPU架构中最快实现的技术。</p>\n<h3 id=\"1-1-Basic-Linear-Algebra-Subprograms-BLAS\"><a href=\"#1-1-Basic-Linear-Algebra-Subprograms-BLAS\" class=\"headerlink\" title=\"1.1 Basic Linear Algebra Subprograms (BLAS)\"></a>1.1 Basic Linear Algebra Subprograms (BLAS)</h3><p>基本线性代数子程序(BLAS)[10,5,4,14]为一组线性代数操作形成了一个接口，在此基础上构建了更高级别的线性代数库，如LAPACK[2]和libflame[19]。其思想是，如果有人针对给定的体系结构优化BLAS，那么所有以调用BLAS的方式编写的应用程序和库都将受益于这种优化。</p>\n<p>BLAS被分为三组:一级BLAS(矢量-矢量操作)、二级BLAS(矩阵-矢量操作)和三级BLAS(矩阵-矩阵操作)。最后一组得益于这样一个事实:如果所有矩阵操作数的大小都是n × n，则O(n3)浮点运算对O(n)个数据执行，因此在内存层(主存、缓存和寄存器)之间移动数据的成本可以在很多次计算中平摊。因此，如果仔细执行这些操作，原则上可以实现高性能。</p>\n<h3 id=\"1-2-Matrix-matrix-multiplication\"><a href=\"#1-2-Matrix-matrix-multiplication\" class=\"headerlink\" title=\"1.2 Matrix-matrix multiplication\"></a>1.2 Matrix-matrix multiplication</h3><p>特别地，BLAS通过(Fortran)调用支持具有双精度浮点数的Gemm:</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\">dgemm( transa, transb, m, n, k alpha, A,lda, B, ldb, beta, C, ldc)<br></code></pre></div></td></tr></table></figure>\n\n<p>通过适当地选择转置a和转置b来计算:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230212215656711.png\" alt=\"image-20230212215656711\"></p>\n<p>这里C是m × n, k是“第三维”。参数dla, dlb和dlc将在本文档后面进行解释。</p>\n<p>在我们的练习中，我们考虑Gemm的简化版本:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230212215836596.png\" alt=\"image-20230212215836596\"></p>\n<p>其中C是m × n, A是m × k, B是k × n。如果了解如何优化dgemm的这种特殊情况，那么可以很容易地将此知识扩展到所有3级BLAS功能。</p>\n<h3 id=\"1-3-High-performance-implementation\"><a href=\"#1-3-High-performance-implementation\" class=\"headerlink\" title=\"1.3 High-performance implementation\"></a>1.3 High-performance implementation</h3><p>高性能实现的复杂性使得BLAS(尤其是Gemm)的实现通常都是由默默无闻的专家来完成的，这些专家为硬件供应商开发数字库，例如IBM的ESSL、Intel的MKL、Cray的LibSci和AMD的ACML库。这些库通常是用汇编代码编写的(至少是部分)，并且针对特定的处理器高度专门化。</p>\n<p>一篇关键论文[1]展示了“算法和体系结构”方法如何携手设计ar体系结构、编译器和算法，使BLAS能够用高级语言(Fortan)为IBM Power体系结构编写，并解释了在这些处理器上实现高性能的复杂性。便携式高性能ANSI C (PHiPAC)[3]项目随后提供了用C编写高性能代码的指南，并建议如何自动生成和优化以这种方式编写的Gemm。Au tomatatically tuning Linear Algebra Software (ATLAS)[17,18]建立在这些见解的基础上，使BLAS库的自动调优和自动生成成为主流。</p>\n<p>在本文档的一部分中，我们讨论了有关该主题的最新论文，包括引入了实施Gemm[6]的Goto方法和该方法[16]的BLIS重构的论文，以及其他更直接相关的论文。</p>\n<h3 id=\"1-4-Other-similar-exercises\"><a href=\"#1-4-Other-similar-exercises\" class=\"headerlink\" title=\"1.4 Other similar exercises\"></a>1.4 Other similar exercises</h3><p>还有一些人基于Gemm组合了练习。与本文相关的最新成果有:乌尔姆大学Michael Lehn所作的“优化微内核:从纯C到SSE”，以及我们自己整理的关于“优化微内核”的维基。</p>\n<h3 id=\"1-5-We-need-you\"><a href=\"#1-5-We-need-you\" class=\"headerlink\" title=\"1.5 We need you!\"></a>1.5 We need you!</h3><p>本文的目的是指导您实现Gemm的高性能实现。我们的别有用心是，用于实现BLAS的BLIS框架需要针对各种cpu高度优化的所谓微内核。在教你基本技巧的过程中，我们希望找到“那个人”将贡献最好的微内核。就把它当做我们版的高性能计算机达人秀吧。虽然我们在描述中关注的是Intel Haswell架构的优化，但是设置可以很容易地修改，从而帮助您(和我们)优化其他cpu。事实上，BLIS本身支持的体系结构包括AMD和Intel的x86处理器，IBM的Power处理器，ARM处理器和德州仪器的DSP处理器[15,12,8]。</p>\n<h2 id=\"2-Step-1-The-Basics\"><a href=\"#2-Step-1-The-Basics\" class=\"headerlink\" title=\"2 Step 1: The Basics\"></a>2 Step 1: The Basics</h2><h3 id=\"2-1-Simple-matrix-matrix-multiplication\"><a href=\"#2-1-Simple-matrix-matrix-multiplication\" class=\"headerlink\" title=\"2.1 Simple matrix-matrix multiplication\"></a>2.1 Simple matrix-matrix multiplication</h3><p>在我们的讨论中，我们将考虑计算：</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213165803939.png\" alt=\"image-20230213165803939\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213165826084.png\" alt=\"image-20230213165826084\"></p>\n<p>其中，A、B、C分别为m × k、k × n、m × n矩阵。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213165920897.png\" alt=\"image-20230213165920897\"></p>\n<p>如果A、B和C存储在二维数组A、B和C中，下面的伪代码计算C:&#x3D;<br>AB + C:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213170125083.png\" alt=\"image-20230213170125083\"></p>\n<p>分别计算乘法和加法，计算需要2mnk个浮点运算(flop)。</p>\n<h3 id=\"2-2-Setup\"><a href=\"#2-2-Setup\" class=\"headerlink\" title=\"2.2 Setup\"></a>2.2 Setup</h3><p>为了让您高效地学习如何高效地进行计算，您可以在启动项目时准备好大部分基础设施。我们已经构造了子目录step1，有点像实现真正库might的项目。对于我们的目的来说，这可能是多余的，但是如何构建软件项目是一项值得学习的有用技能。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214173819349.png\" alt=\"image-20230214173819349\"></p>\n<p>考虑图4，它演示了子目录step1的目录结构:</p>\n<p><strong>README</strong>是一个描述目录内容以及如何编译和执行代码的文件。</p>\n<p><strong>source .sh</strong>配置环境变量的文件。在那个文件中</p>\n<p><strong>BLISLAB USE INTEL</strong>设置是否使用INTEL编译器(true)或GNU编译器(false)。</p>\n<p><strong>BLISLAB USE BLAS</strong>指示您的参考dgemm是否使用外部BLAS库实现(如果您的机器上安装了这样的BLAS库，则为true)，还是简单的三重循环实现(false)。</p>\n<p><strong>COMPILER OPT LEVEL</strong>设置GNU或Intel编译器的优化级别(O0, O1, O2, O3)。<br>(请注意，例如，O3由大写字母“O”和数字“3”组成。)</p>\n<p><strong>OMP NUM THREADS</strong> and <strong>BLISLAB IC NT</strong>设置用于并行版本的线程数<br>代码。对于第1步，将它们都设置为1。</p>\n<p><strong>dgemm</strong>是实现dgemm的例程存在的子目录。在其中</p>\n<p><strong>bl_dgemm_ref.c</strong>包含例程<strong>dgemm ref</strong>，它是dgemm的一个简单实现，如果<strong>BLISLAB_use_BLAS &#x3D; false</strong>，您将使用它来检查实现的正确性。</p>\n<p><strong>my_dgemm.c</strong>包含例程<strong>dgemm</strong>，它最初是dgemm的一个简单实现，您将优化它作为掌握如何优化gemm的第一步的一部分。</p>\n<p><strong>Bl_dgemm_util.c</strong>包含稍后会派上用场的实用程序例程</p>\n<p><strong>include</strong>这个目录包含包含各种宏定义和其他头信息的文件。</p>\n<p><strong>lib</strong>此目录将保存由您实现的源文件(libblislab. lib)生成的库。libblislab.a)您还可以在此目录中安装参考库(例如OpenBLAS)以比较性能。</p>\n<p><strong>test</strong> 这个目录包含“测试驱动程序”和各种实现的正确性&#x2F;性能检查脚本。</p>\n<p><strong>test_bl_demm .c</strong>包含测试例程bl_demm的“测试驱动程序”。</p>\n<p><strong>test_bl_dgemm.x</strong>是<strong>test_bl_dgemm.c</strong>的可执行文件。</p>\n<p><strong>Run_bl_dgemm.sh</strong>包含一个bash脚本，用于收集性能结果。</p>\n<p><strong>tacc_run_bl_dgemm.sh</strong> contains a <strong>SLURM</strong> script for you to (optionally) submit the job to the Texas Advanced Computing Center (TACC) machines if you have an account there.</p>\n<h3 id=\"2-3-Getting-started\"><a href=\"#2-3-Getting-started\" class=\"headerlink\" title=\"2.3 Getting started\"></a>2.3 Getting started</h3><p>我们希望您从my_dgemm.c中的实现开始，并通过应用各种标准优化技术对其进行优化。该文件中的初始实现是具有图2中给出的三个循环的简单实现。首先要注意的是二维数组如何以所谓的列-主序映射到内存。这种选择的原因是最初的BLAS假定数组的列主存储，因为该接口首先是为Fortran用户提供的。检查</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214185803699.png\" alt=\"image-20230214185803699\"></p>\n<p>我们注意到，每个操作数都是一个宏。考虑文件的早期</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214185849594.png\" alt=\"image-20230214185849594\"></p>\n<p>地址C处的线性数组用于存储元素Ci,j，因此i,j元素被映射到位置j * ldc + i。查看它的方法是C的每一列都是连续存储的。但是，可以把矩阵C看作是嵌入在一个更大的数组中，该数组有ldc行，因此访问一行就意味着跨ldc遍历数组C。二维数组C的前维数通常是指这个较大数组的行维数，因此变量ldc (C的前维数)。下图说明了这三个矩阵:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214190409172.png\" alt=\"image-20230214190409172\"></p>\n<p>其中箭头表示列是连续存储的。</p>\n<h4 id=\"2-3-1-Configure-the-default-implementation\"><a href=\"#2-3-1-Configure-the-default-implementation\" class=\"headerlink\" title=\"2.3.1 Configure the default implementation\"></a>2.3.1 Configure the default implementation</h4><p>默认情况下，练习编译并链接到Intel的icc编译器，该编译器将对代码应用编译器优化(O3级)。您需要通过以下命令设置环境变量:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">source sourceme.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在终端中，您将看到输出:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL = TRUE<br>COMPILER_OPT_LEVEL = O3<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-3-2-Compile-execute-and-collect-results\"><a href=\"#2-3-2-Compile-execute-and-collect-results\" class=\"headerlink\" title=\"2.3.2 Compile, execute and collect results\"></a>2.3.2 Compile, execute and collect results</h4><p>如果您无法访问Intel的编译器(icc)，请阅读第2.3.2小节和2.3.3小节，并继续阅读第2.3.5小节。</p>\n<p>您可以编译、执行代码并通过执行收集性能结果</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">make clean<br>make<br>cd test<br>./run_bl_dgemm.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在子目录step1中。您将看到性能结果输出:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214231134260.png\" alt=\"image-20230214231134260\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214231142311.png\" alt=\"image-20230214231142311\"></p>\n<p>您可以在run_bl_dgemm.sh中更改采样块大小。请注意，如果代码中有错误，这些错误将被报告为，例如，</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214231406465.png\" alt=\"image-20230214231406465\"></p>\n<h4 id=\"2-3-3-Draw-the-performance-graph\"><a href=\"#2-3-3-Draw-the-performance-graph\" class=\"headerlink\" title=\"2.3.3 Draw the performance graph\"></a>2.3.3 Draw the performance graph</h4><p>最后，您可以使用<strong>MATLAB</strong>用我们的脚本绘制性能图。在<strong>test</strong>子目录下，执行后</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">./collect_result_step1<br></code></pre></div></td></tr></table></figure>\n\n<p>你会得到一个MATLAB文件“step1_result.m”，具有性能结果。然后你可以执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">bl_dgemm_plot.m<br></code></pre></div></td></tr></table></figure>\n\n<p>在MATLAB中，然后生成性能图。</p>\n<h4 id=\"2-3-4-Change-to-the-GNU-compiler\"><a href=\"#2-3-4-Change-to-the-GNU-compiler\" class=\"headerlink\" title=\"2.3.4 Change to the GNU compiler\"></a>2.3.4 Change to the GNU compiler</h4><p>由于我们希望您明确地了解什么样的技巧可以带来高性能，并且由于有些人可能无法访问Intel编译器，因此接下来应该改为使用GNU C编译器。为此，你必须编辑<strong>sourceme.sh</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL=false<br></code></pre></div></td></tr></table></figure>\n\n<p>然后，类似于默认设置，您需要通过执行以下命令来设置环境变量:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">source sourceme.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在终端，你会观察到:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL = false<br>COMILER_OPT_LEVEL = O3<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-3-5-Turn-off-optimization\"><a href=\"#2-3-5-Turn-off-optimization\" class=\"headerlink\" title=\"2.3.5 Turn off optimization\"></a>2.3.5 Turn off optimization</h4><p>接下来，我们希望您关闭编译器执行的优化。这有三个目的:首先，这意味着您将必须显式地执行优化，这将允许您了解架构和算法如何交互。其次，优化编译器很可能会试图“撤销”您显式试图完成的任务。第三，在代码中构建的技巧越多，编译器就越难找出优化的方法。</p>\n<p>你需要先编辑<strong>sourceme.sh:</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">COMILER_OPT_LEVEL = O0<br></code></pre></div></td></tr></table></figure>\n\n<p>然后，类似于默认设置，您需要通过执行以下命令来设置环境变量:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">source sourceme.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在终端中，您将看到输出:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL = false<br>COMILER_OPT_LEVEL =O0<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-3-6-Optional-Use-optimized-BLAS-library-as-reference-implementation\"><a href=\"#2-3-6-Optional-Use-optimized-BLAS-library-as-reference-implementation\" class=\"headerlink\" title=\"2.3.6 (Optional) Use optimized BLAS library as reference implementation\"></a>2.3.6 (Optional) Use optimized BLAS library as reference implementation</h4><p>默认情况下，您的参考Gemm实现是一个非常缓慢的三循环实现。如果你在测试机器上安装了BLAS库，你可以通过设置该库中的dgemm作为你的参考实现:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_BLAS=true<br></code></pre></div></td></tr></table></figure>\n\n<p>在sourceme.sh。如果使用Intel编译器，则不需要显式指定MKL的路径。但是，如果使用GNU编译器，则需要指定BLAS库的路径。例如，您可能希望从<a href=\"https://github.com/flame/blis%E5%AE%89%E8%A3%85%E6%88%91%E4%BB%AC%E7%9A%84BLIS%E5%BA%93%E5%88%B0/home/lib/blis%E7%9B%AE%E5%BD%95%E5%90%8C%E6%97%B6%E5%9C%A8sourceme\">https://github.com/flame/blis安装我们的BLIS库到/home/lib/blis目录同时在sourceme</a> .sh中设置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLAS_DIR=/home/lib/blis<br></code></pre></div></td></tr></table></figure>\n\n<p>执行**$ source sourceme .sh**后，你会看到:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_BLAS = true<br>BLAS_DIR = /home/lib/blis<br></code></pre></div></td></tr></table></figure>\n\n<p>现在，您的实现的性能和准确性将与这个优化的库例程进行比较。</p>\n<h3 id=\"2-4-Basic-techniques\"><a href=\"#2-4-Basic-techniques\" class=\"headerlink\" title=\"2.4 Basic techniques\"></a>2.4 Basic techniques</h3><p>在本小节中，我们将介绍一些基本的交易技巧。</p>\n<h4 id=\"2-4-1-Using-pointers\"><a href=\"#2-4-1-Using-pointers\" class=\"headerlink\" title=\"2.4.1 Using pointers\"></a>2.4.1 Using pointers</h4><p>既然优化被关闭了，那么矩阵元素所在地址的计算将显式地公开。(优化编译器可以消除这种开销。)您要做的是更改my_gemm.c中的实现，以便它使用指针。在这样做之前，您可能需要备份原始的my_gemm.c，以防需要从头开始重新启动。实际上，在每个步骤中，您可能都希望在单独的文件中备份前面的实现</p>\n<p>这是基本的想法。假设我们想把C中的所有元素都设为0。一个基本的循环，按照在my_gemm.c中找到的内容来设计</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>        <span class=\"hljs-built_in\">C</span>(i,j) =<span class=\"hljs-number\">0.0</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>Using pointers, we might implement this as</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> *cp;<br><span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j*ldc ];\t\t\t<span class=\"hljs-comment\">//point cp to top of ith column</span><br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>        *cp++ = <span class=\"hljs-number\">0.0</span>;\t\t<span class=\"hljs-comment\">//set element that cp points to to zero and</span><br>    &#125;\t\t<span class=\"hljs-comment\">//advance the pointer</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>注意，我们有意地交换了循环的顺序，以便向前移动指针将我们带到C的列中。</p>\n<h4 id=\"2-4-2-Loop-unrolling\"><a href=\"#2-4-2-Loop-unrolling\" class=\"headerlink\" title=\"2.4.2 Loop unrolling\"></a>2.4.2 Loop unrolling</h4><p>每次通过内部循环更新循环索引i和指针cp都会产生相当大的开销。</p>\n<p>因此，编译器将执行循环展开。使用展开因子4，我们将C设置为0的简单循环变成</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> *cp;<br><br><span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j * ldc ];<br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>        *(cp+<span class=\"hljs-number\">0</span>) = <span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">1</span>) = <span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">2</span>) = <span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">3</span>) = <span class=\"hljs-number\">0.0</span>;<br>        cp+=<span class=\"hljs-number\">4</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>重要的</p>\n<ul>\n<li>i和cp现在每四次迭代才更新一次。</li>\n<li><em>(cp+0)使用称为间接寻址的机器指令，这比使用</em>(cp+k)计算更有效，其中k是变量。</li>\n<li>当它从内存中输入数据到缓存中时，每次输入一条64字节的缓存线。这意味着以64字节的块访问连续数据可以减少内存层之间的内存移动成本。</li>\n</ul>\n<p>请注意，在展开时，如果m不是4的倍数，则可能必须处理“边缘”。</p>\n<p>为了这个练习，你不需要担心这个边缘，只要你明智地选择你的采样块大小，就像第2.5节重申的那样。</p>\n<h4 id=\"2-4-3-Register-variables\"><a href=\"#2-4-3-Register-variables\" class=\"headerlink\" title=\"2.4.3 Register variables\"></a>2.4.3 Register variables</h4><p>注意，只有当数据存储在寄存器中时，计算才会发生。编译器将自动转换代码，以便插入将某些数据放入寄存器的中间步骤。可以给编译器一个提示，将某些数据保存在寄存器中是很好的，如下面的例子所示:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> *cp;<br><br><span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j * ldc ];<br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>        <span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> c0 =<span class=\"hljs-number\">0.0</span>,c1=<span class=\"hljs-number\">0.0</span>,c2=<span class=\"hljs-number\">0.0</span>,c3=<span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">0</span>) = c0;<br>        *(cp+<span class=\"hljs-number\">1</span>) = c1;<br>        *(cp+<span class=\"hljs-number\">2</span>) = c2;<br>        *(cp+<span class=\"hljs-number\">3</span>) = c3;<br>        cp+=<span class=\"hljs-number\">4</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-5-A-modest-first-goal\"><a href=\"#2-5-A-modest-first-goal\" class=\"headerlink\" title=\"2.5 A modest first goal\"></a>2.5 A modest first goal</h4><p>现在我们要求您使用上面讨论的技术来优化my_dgemm.c。现在，只需要考虑如何为较小的矩阵获得更好的性能。具体来说，请看下面这张图:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230215110352304.png\" alt=\"image-20230215110352304\"></p>\n<p>我们想让你做的是编写你的代码，使C的mR × nR块保存在寄存器中。你可以选择mR和nR，但是你需要用这些选项更新文件<strong>include&#x2F;bl_config.h</strong>。这确保了测试驱动程序只尝试这些块大小的倍数的问题大小，所以您不必担心“边缘”。</p>\n<p>您将注意到，即使对于可以放入某个缓存内存中的较小的矩阵，您的实现(比您可能已安装的MKL或其他优化的BLAS库的实现差得多)。原因是编译器没有为浮点运算使用最快的指令。可以通过使用向量intrinsic funtions函数(允许您从C显式地利用它们)或通过在汇编代码中编码来访问这些函数。现在，我们还没到那一步。我们将<br>在步骤3中讨论更多。</p>\n<h2 id=\"3-Step-2-Blocking\"><a href=\"#3-Step-2-Blocking\" class=\"headerlink\" title=\"3 Step 2: Blocking\"></a>3 Step 2: Blocking</h2><h3 id=\"3-1-Poorman’s-BLAS\"><a href=\"#3-1-Poorman’s-BLAS\" class=\"headerlink\" title=\"3.1 Poorman’s BLAS\"></a>3.1 Poorman’s BLAS</h3><p>本练习的第1步使您认识到，随着基于缓存的体系结构的出现，Gemm的高性能实现需要仔细注意数据在内存层之间移动的成本和对该数据的计算的摊薄。为了保持这种可管理性，认识到只有使用相对较小的矩阵执行矩阵-矩阵乘法的“内核”需要高度优化，这是有帮助的，因为使用较大的矩阵的计算可以被分块，然后使用这样的内核而不会对整体性能产生不利影响。这一见解在[9]中得到了明确的提倡。</p>\n<p>这有时被称为“穷人的BLAS”，因为如果一个人只能负担得起优化矩阵-矩阵乘法(使用子矩阵)，那么就可以构建Gemm，以及其他重要的矩阵-矩阵运算，即三级BLAS。我们稍后将看到的是，从模块化和性能的角度来看，这实际上是一个好主意。</p>\n<p>在上一节中，您已经看到了分块的示例。</p>\n<h3 id=\"3-2-Blocked-matrix-matrix-multiplication\"><a href=\"#3-2-Blocked-matrix-matrix-multiplication\" class=\"headerlink\" title=\"3.2 Blocked matrix-matrix multiplication\"></a>3.2 Blocked matrix-matrix multiplication</h3><p>分块Gemm以利用处理器的分层内存的关键是理解当这些矩阵被分块时如何计算C:&#x3D; AB + C。分块</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216130352894.png\" alt=\"image-20230216130352894\"></p>\n<h3 id=\"3-3-Your-mission-if-you-choose-to-accept-it\"><a href=\"#3-3-Your-mission-if-you-choose-to-accept-it\" class=\"headerlink\" title=\"3.3 Your mission, if you choose to accept it\"></a>3.3 Your mission, if you choose to accept it</h3><p>我们现在要求您在my_dgemm中实现分块矩阵-矩阵乘法。具体来说，对于小矩阵，您可以获得比大矩阵更好的性能，因为小矩阵适合缓存。将矩阵划分为能够获得更高性能的子矩阵，您将看到，即使对于更大的矩阵，所得到的实现也能保持更好的性能</p>\n<h2 id=\"4-Step-3-Blocking-for-Multiple-Levels-of-Cache\"><a href=\"#4-Step-3-Blocking-for-Multiple-Levels-of-Cache\" class=\"headerlink\" title=\"4 Step 3: Blocking for Multiple Levels of Cache\"></a>4 Step 3: Blocking for Multiple Levels of Cache</h2><h3 id=\"4-1-The-Goto-Approach-to-Implementing-gemm\"><a href=\"#4-1-The-Goto-Approach-to-Implementing-gemm\" class=\"headerlink\" title=\"4.1 The Goto Approach to Implementing gemm\"></a>4.1 The Goto Approach to Implementing gemm</h3><p>2000年左右，Kazushige Goto用他的技术彻底改变了Gemm在当前cpu上的实现方式，该技术首次发表在论文[6]上。</p>\n<p>最近在[16]中描述了这种方法的进一步“重构”。</p>\n<p>BLIS框架的优点是它将必须高度优化的内核(可能使用向量intrinsic或在汇编代码中)减少为微内核。在本节中，我们将简要描述该方法的重点。然而，我们强烈建议读者熟悉以上两篇论文本身。</p>\n<p>图3(左)说明了Goto方法为三层缓存(L1、L2和L3)构建分块的方式。在BLIS框架中，实现就是这样结构的，因此只有底层的微内核需要针对给定的体系结构进行高度优化和定制。在最初的GotoBLAS实现(现在维护为OpenBLAS[11])中，从围绕微内核的第二个循环开始的操作是定制的。为了获得最佳性能，所有数据都是连续访问的，这就是为什么在到达微内核之前的某个时刻，数据是按照箭头所示的顺序打包的:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216131649371.png\" alt=\"image-20230216131649371\"></p>\n<p>现在，注意上图中A块的每一列都乘以B块对应行中的每个元素(我们称这些A块和B块为微面板)。这意味着L2缓存的延迟(从缓存中引入A微面板元素所需的时间)可以平摊到2nR flop上。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216131916807.png\" alt=\"image-20230216131916807\"></p>\n<p>出于这个原因，我们可以组织计算，使A的微面板通常驻留在L2缓存中。实际上，我们可以做得更好:当A和B的微面板的一列发生排名1的更新时，A的微面板的下一列可以被带入寄存器，这样计算就可以掩盖数据移动的成本。事实上，我们希望将B的微面板保留在L1缓存中(因为它将被A的许多微面板重用)，这限制了分块参数kC。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216132839380.png\" alt=\"image-20230216132839380\"></p>\n<p>有人可能会问，上述方案是否是最优方案。在[7]中给出了一个理论，表明在一个理想化的模型下，上述是局部最优的(在某种意义上，假设数据在层次结构中的某个内存层中，在该级别上提出的阻塞最优地与下一个内存层平摊数据移动的成本)。[13]给出了指导各种分块参数选择的理论。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216133142749.png\" alt=\"image-20230216133142749\"></p>\n<h3 id=\"4-2-Setup\"><a href=\"#4-2-Setup\" class=\"headerlink\" title=\"4.2 Setup\"></a>4.2 Setup</h3><p>图4说明了子目录step3的目录结构。与步骤1相比，我们对以下目录&#x2F;文件进行了修改&#x2F;添加:</p>\n<p><strong>kernels</strong> 这个目录包含各种架构的微内核实现</p>\n<p><strong>bd_gemm_ukr.c</strong>给出了一个原生的C实现</p>\n<p><strong>bl_dgemm_int_kernel.c</strong> gives an <strong>AVX&#x2F;AVX2</strong> intrinsics micro-kernel implementation for Haswell architecture.</p>\n<p><strong>bl_dgemm_asm_kernel.c</strong> gives an <strong>AVX&#x2F;AVX2</strong> assembly micro-kernel implementation for Haswell architecture.</p>\n<h3 id=\"4-3-Advanced-techniques\"><a href=\"#4-3-Advanced-techniques\" class=\"headerlink\" title=\"4.3 Advanced techniques\"></a>4.3 Advanced techniques</h3><p>You can find the vector instructions online:</p>\n<p><strong>Intel Intrinsics Guide</strong></p>\n<p><strong>Intel ISA Extensions</strong></p>\n<h4 id=\"4-3-1-An-introduction-example-for-“axpy”\"><a href=\"#4-3-1-An-introduction-example-for-“axpy”\" class=\"headerlink\" title=\"4.3.1 An introduction example for “axpy”\"></a>4.3.1 An introduction example for “axpy”</h4><p>我们提供了一个实现“axpy”的示例，以演示如何使用Intel AVX intrinsic和Assembly(在misc&#x2F;examples子目录中)。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216134020439.png\" alt=\"image-20230216134020439\"></p>\n<p>这个例子可以作为学习基本broacast&#x2F;fma&#x2F;load&#x2F;store指令的一个很好的起点。此外，这个示例实际上是4×4 rank-1更新的“broadcast”实现的原语。</p>\n<h4 id=\"4-3-2-4×4-rank-1-update\"><a href=\"#4-3-2-4×4-rank-1-update\" class=\"headerlink\" title=\"4.3.2 4×4 rank-1 update\"></a>4.3.2 4×4 rank-1 update</h4><p>微内核实现可以归结为4×4级别1的更新。有两种可能的实现:一种基于广播(图5)，另一种是蝴蝶排列(图6)。您还可以尝试其他可能的实现。</p>\n<h3 id=\"4-4-Your-mission-if-you-choose-to-accept-it\"><a href=\"#4-4-Your-mission-if-you-choose-to-accept-it\" class=\"headerlink\" title=\"4.4 Your mission, if you choose to accept it\"></a>4.4 Your mission, if you choose to accept it</h3><p>我们在my_dgemm中为您提供了简化BLIS框架的参考实现。代码的组织方式与图3所示相同。但是，每个循环中的步长并没有很好地选择，并且微内核实现是一个简单的C版本。因此。您不会期望代码具有高性能。我们要你做的就是:</p>\n<ul>\n<li>在include&#x2F;bl_config.h文件中指定分块参数mC, nC, kC和微内核大小参数mR, nR;</li>\n<li>使用矢量intrinsic或汇编代码实现高效的微内核。将代码放在kernels&#x2F;bl_dgemm_int_kernel.c(用于向量intrinsic)或kernels&#x2F;bl_dgemm_asm_kernel.c(用于as汇编)中。需要在“include&#x2F; BL_config.h”中修改“BL_MICRO_KERNEL”，指定微内核的函数名。</li>\n</ul>\n<p><img src=\"/2023/02/12/blislib002/image-20230216140558800.png\" alt=\"image-20230216140558800\"></p>\n<h2 id=\"5-Step-4-Parallelizing-with-OpenMP\"><a href=\"#5-Step-4-Parallelizing-with-OpenMP\" class=\"headerlink\" title=\"5 Step 4: Parallelizing with OpenMP\"></a>5 Step 4: Parallelizing with OpenMP</h2><p>BLIS构造GotoBLAS方法实现Gemm的好处是，它在tt C中公开了5个循环，这些循环可以很容易地与OpenMP指令并行。</p>\n<h3 id=\"5-1-To-parallelize-or-not-to-parallelize-that’s-the-question\"><a href=\"#5-1-To-parallelize-or-not-to-parallelize-that’s-the-question\" class=\"headerlink\" title=\"5.1 To parallelize or not to parallelize, that’s the question\"></a>5.1 To parallelize or not to parallelize, that’s the question</h3><p>最基本的问题是要并行化哪个循环。在[12]中详细讨论了每个循环的并行化的优点和缺点。对于多核体系结构(具有相对较少核的多线程体系结构)，可以在早期的论文[15]中找到结果。</p>\n<h2 id=\"6-Conclusion\"><a href=\"#6-Conclusion\" class=\"headerlink\" title=\"6 Conclusion\"></a>6 Conclusion</h2><p>我们使用GEMM作为案例研究来展示如何为性能进行编程</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216141029854.png\" alt=\"image-20230216141029854\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216141041389.png\" alt=\"image-20230216141041389\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216141057850.png\" alt=\"image-20230216141057850\"></p>\n",
            "tags": [
                "Linux",
                "dgemm"
            ]
        }
    ]
}