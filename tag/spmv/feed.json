{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"spmv\" tag",
    "description": "",
    "home_page_url": "https://xingyuanjie.top",
    "items": [
        {
            "id": "https://xingyuanjie.top/2023/07/03/gemm0009/",
            "url": "https://xingyuanjie.top/2023/07/03/gemm0009/",
            "title": "论文阅读：稀疏矩阵向量乘法在申威众核架构上的性能优化",
            "date_published": "2023-07-03T13:56:03.000Z",
            "content_html": "<h2 id=\"稀疏矩阵向量乘法在申威众核架构上的性能优化\"><a href=\"#稀疏矩阵向量乘法在申威众核架构上的性能优化\" class=\"headerlink\" title=\"稀疏矩阵向量乘法在申威众核架构上的性能优化\"></a>稀疏矩阵向量乘法在申威众核架构上的性能优化</h2><h2 id=\"文章链接：\"><a href=\"#文章链接：\" class=\"headerlink\" title=\"文章链接：\"></a>文章链接：</h2><p><a href=\"https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C44YLTlOAiTRKibYlV5Vjs7i8oRR1PAr7RxjuAJk4dHXos_BuYfGFXVp2oi-VeHUWWPMdimPFvuCr6UTXzh1QasE&uniplatform=NZKPT\">稀疏矩阵向量乘法在申威众核架构上的性能优化 - 中国知网 (cnki.net)</a></p>\n<h2 id=\"文章总结\"><a href=\"#文章总结\" class=\"headerlink\" title=\"文章总结\"></a>文章总结</h2><h3 id=\"固定划分方法\"><a href=\"#固定划分方法\" class=\"headerlink\" title=\"固定划分方法\"></a>固定划分方法</h3><ol>\n<li>所有计算完再写回</li>\n<li>子矩阵(任务)-&gt;子矩阵小块(核心计算)</li>\n<li>将子矩阵小块中的非零元存储在一起，以适应申威处理器上的DMA操作。(Packing)</li>\n<li>核心：寄存器通信-&gt;RMA</li>\n<li>根据LDM大小提前计算，充分利用LDM空间，换句话说就是保证计算所需都在LDM中</li>\n<li>加载冗余X，避免DMA隔断</li>\n</ol>\n<h3 id=\"一维负载均衡划分方法\"><a href=\"#一维负载均衡划分方法\" class=\"headerlink\" title=\"一维负载均衡划分方法\"></a>一维负载均衡划分方法</h3><ol>\n<li>尽量使从核处理非零元数量相当</li>\n<li>4个层次：原矩阵-&gt;矩阵带-&gt;子矩阵-&gt;小块</li>\n<li>交替分配矩阵带给从核行</li>\n<li>核心计算依然是子矩阵小块，同固定划分方法</li>\n</ol>\n<h3 id=\"二维负载均衡划分方法\"><a href=\"#二维负载均衡划分方法\" class=\"headerlink\" title=\"二维负载均衡划分方法\"></a>二维负载均衡划分方法</h3><ol>\n<li>矩阵带分配采取贪心的方法，尽可能保证不同行之间的负载均衡</li>\n<li>解决一维负载均衡方法带来的细粒度同步问题</li>\n<li>非零元过少的矩阵带，交给一个从核完成，而不再均分给同行上的几个从核</li>\n<li>一维和二维主要解决预处理，计算还是固定划分中的子矩阵小块</li>\n<li>排序-&gt;根据矩阵带非零元数量从大到小排序(逻辑排序)</li>\n<li>Select函数会在所有ROWS行的从核中，选择出目前非零元数量最少的一行，并将当前的矩阵带i分配给它</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">输入：tiles,nnz_tile，ROWS<br>输出：set<br>nnz_set&lt;<span class=\"hljs-number\">-0</span><br><span class=\"hljs-keyword\">for</span> i = <span class=\"hljs-number\">0</span> to tiles - <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">do</span><br>    Select id <span class=\"hljs-keyword\">if</span> nnz_set[id] is minimal   <span class=\"hljs-comment\">//注意：这里是选从核行，不是矩阵带</span><br>    nnz_set[id] += nnz_tiles[i]<br>    set[id] =  set[id]U&#123;i&#125;   <span class=\"hljs-comment\">//任务分配</span><br>end <span class=\"hljs-keyword\">for</span> <br></code></pre></div></td></tr></table></figure>\n\n<p>这里注意，我们再固定划分那里解决了数据局部性差等问题，之后的一二维划分，都是在做任务分配，核心计算子矩阵小块一直未改变</p>\n",
            "tags": [
                "blas",
                "spmv"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/06/09/gemm0008/",
            "url": "https://xingyuanjie.top/2023/06/09/gemm0008/",
            "title": "论文阅读：面向国产申威 26010 众核处理器的 SpMV 实现与优化",
            "date_published": "2023-06-08T16:20:37.000Z",
            "content_html": "<h2 id=\"面向国产申威-26010-众核处理器的-SpMV-实现与优化\"><a href=\"#面向国产申威-26010-众核处理器的-SpMV-实现与优化\" class=\"headerlink\" title=\"面向国产申威 26010 众核处理器的 SpMV 实现与优化\"></a>面向国产申威 26010 众核处理器的 SpMV 实现与优化</h2><h2 id=\"文章链接：\"><a href=\"#文章链接：\" class=\"headerlink\" title=\"文章链接：\"></a>文章链接：</h2><p><a href=\"https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C44YLTlOAiTRKibYlV5Vjs7iLik5jEcCI09uHa3oBxtWoDjpNvZMhBwTwYhU5_aacU5_o2Scyx5dsHMxE0wqndQa&uniplatform=NZKPT\">面向国产申威26010众核处理器的SpMV实现与优化 - 中国知网 (cnki.net)</a></p>\n<h2 id=\"文章总结\"><a href=\"#文章总结\" class=\"headerlink\" title=\"文章总结\"></a>文章总结</h2><p>存储格式：CSR</p>\n<p>数据名称定义：</p>\n<ul>\n<li>col:非零元的列号</li>\n<li>data:非零元数值，连续存放</li>\n<li>row_off:x数组，每行第一个元素前面的非零元素，最后一个rowoff代表总的非零元素</li>\n<li>vec:计算向量</li>\n<li>y:结果向量</li>\n<li>rows:行号</li>\n<li>srow:为当前申威处理器一个从核的 LDM 可以容纳的最多稀疏行大小</li>\n</ul>\n<h3 id=\"X动静态buffer\"><a href=\"#X动静态buffer\" class=\"headerlink\" title=\"X动静态buffer\"></a>X动静态buffer</h3><p>x静态buffer，初始化后一直不改变。(论文中有两种初始化方法)</p>\n<p>x动态buffer，未命中，则用dma更新x动态buffer</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//slave.c</span><br>LDM-&gt;malloc   x_sbuffer   <span class=\"hljs-comment\">//x静态buffer</span><br>LDM-&gt;malloc   x_dbuffer   <span class=\"hljs-comment\">//x动态buffer</span><br>sstart,send,dstart,<span class=\"hljs-function\">dend</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">dma</span><span class=\"hljs-params\">(vec-&gt;x_sbuffer,sstart,send)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">dma</span><span class=\"hljs-params\">(vec-&gt;x_dbuffer,dstart,dend)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">for</span> srow</span><br><span class=\"hljs-function\">    <span class=\"hljs-keyword\">for</span> row</span><br><span class=\"hljs-function\">        <span class=\"hljs-title\">if</span><span class=\"hljs-params\">(in x_sbuffer)</span></span><br><span class=\"hljs-function\">            cal</span><br><span class=\"hljs-function\">        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-title\">if</span><span class=\"hljs-params\">(in x_dbuffer)</span></span><br><span class=\"hljs-function\">            cal</span><br><span class=\"hljs-function\">        <span class=\"hljs-keyword\">else</span></span><br><span class=\"hljs-function\">            <span class=\"hljs-title\">update_dma</span><span class=\"hljs-params\">(vec-&gt;x_dbuffer,dstart,dend)</span></span><br><span class=\"hljs-function\">            cal</span><br><span class=\"hljs-function\">     store</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><p>动静态划分</p>\n<p>第一轮静态：每个从核分配相同的任务量即srow</p>\n<p>后续采用动态：哪个从核先计算完，就先从任务池里面拿新的任务</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//slave.c</span><br>eg:<span class=\"hljs-number\">64</span>个从核<br>task_num <span class=\"hljs-comment\">//任务数</span><br>now_addr <span class=\"hljs-comment\">//当前任务计算到哪里了</span><br><span class=\"hljs-comment\">//第一轮  每个从核执行相同的任务量即srow</span><br>    <br>cal srow<br><br><span class=\"hljs-comment\">//其余任务保存到任务池，用锁保护，实现互斥操作</span><br><br><span class=\"hljs-comment\">//任务池，当task_num为0时计算完毕</span><br>mutex = <span class=\"hljs-number\">1</span><br><span class=\"hljs-built_in\">P</span>(mutex)<br><span class=\"hljs-comment\">//互斥区</span><br>task_num<br>now_addr<br><span class=\"hljs-built_in\">V</span>(mutex)<br><span class=\"hljs-comment\">//取now_addr</span><br>cal  srow<br><span class=\"hljs-comment\">//随后 继续loop，直到task_num为0</span><br></code></pre></div></td></tr></table></figure>\n\n",
            "tags": [
                "blas",
                "spmv"
            ]
        }
    ]
}