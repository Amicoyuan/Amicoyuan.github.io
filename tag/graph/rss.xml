<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan • Posts by &#34;graph&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Fri, 06 May 2022 16:38:38 +0800</pubDate>
        <lastBuildDate>Fri, 06 May 2022 16:38:38 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>Map</category>
        <category>并查集</category>
        <category>Pair</category>
        <category>线索二叉树</category>
        <category>KMP</category>
        <category>Tree</category>
        <category>森林</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Numactl</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/05/06/Algorithm037/</guid>
            <title>图的存储</title>
            <link>http://example.com/2022/05/06/Algorithm037/</link>
            <category>Data Structure</category>
            <category>Graph</category>
            <pubDate>Fri, 06 May 2022 16:38:38 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;图的存储&#34;&gt;&lt;a href=&#34;#图的存储&#34; class=&#34;headerlink&#34; title=&#34;图的存储&#34;&gt;&lt;/a&gt;图的存储&lt;/h2&gt;&lt;h3 id=&#34;邻接矩阵法&#34;&gt;&lt;a href=&#34;#邻接矩阵法&#34; class=&#34;headerlink&#34; title=&#34;邻接矩阵法&#34;&gt;&lt;/a&gt;邻接矩阵法&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#define MaxVertexNum 100									//顶点数目的最大值
typedef char VertexType;									//顶点的数据类型
typedef int EdgeType;										//带权图中边上权值的数据类型
typedef struct&amp;#123;
    VertexType Vex[MaxVertexNum];							//顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];				//邻接矩阵，边表
    int vexnum,arcnum;										//图中当前顶点数和弧数
&amp;#125;MGraph;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;邻接表法&#34;&gt;&lt;a href=&#34;#邻接表法&#34; class=&#34;headerlink&#34; title=&#34;邻接表法&#34;&gt;&lt;/a&gt;邻接表法&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#define MaxVertexNum 100									//图中顶点数目的最大值
typedef struct ArcNode&amp;#123;										//边表结点
    int adjvex;												//该弧所指向的顶点的位置
    struct ArcNode *next;									//指向下一条弧的指针
    //InfoType infp;										//网的边权值
&amp;#125;ArcNode;
typedef struct VNode&amp;#123;										//顶点表结点
    VertexType data;										//顶点信息
    ArcNode *first;											//指向第一条依附该顶点的弧的指针
&amp;#125;VNode,AdjList[MaxVertexNum];
typedef struct&amp;#123;
    AdjList vertices;										//邻接表
    int vexnum,arcnum;										//图的顶点数和弧数
&amp;#125;ALGraph;													//ALGraph是以邻接表存储的图的类型
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/23/Algorithm032/</guid>
            <title>L2-036 网红点打卡攻略 (25 分)</title>
            <link>http://example.com/2022/04/23/Algorithm032/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Graph</category>
            <category>邻接矩阵</category>
            <pubDate>Sat, 23 Apr 2022 21:50:27 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-036-网红点打卡攻略-25-分&#34;&gt;&lt;a href=&#34;#L2-036-网红点打卡攻略-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-036 网红点打卡攻略 (25 分)&#34;&gt;&lt;/a&gt;L2-036 网红点打卡攻略 (25 分)&lt;/h2&gt;&lt;p&gt;一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;首先第一行给出两个正整数：网红点的个数 &lt;em&gt;N&lt;/em&gt;（1&amp;lt;&lt;em&gt;N&lt;/em&gt;≤200）和网红点之间通路的条数 &lt;em&gt;M&lt;/em&gt;。随后 &lt;em&gt;M&lt;/em&gt; 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 &lt;em&gt;N&lt;/em&gt; 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再下一行给出一个正整数 &lt;em&gt;K&lt;/em&gt;，是待检验的攻略的数量。随后 &lt;em&gt;K&lt;/em&gt; 行，每行给出一条待检攻略，格式为：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;n&lt;/em&gt; &lt;em&gt;V&lt;/em&gt;1 &lt;em&gt;V&lt;/em&gt;2 ⋯ Vn&lt;/p&gt;
&lt;p&gt;其中 &lt;em&gt;n&lt;/em&gt;(≤200) 是攻略中的网红点数，&lt;em&gt;Vi&lt;/em&gt; 是路径上的网红点编号。这里假设你从家里出发，从 &lt;em&gt;V&lt;/em&gt;1 开始打卡，最后从 &lt;em&gt;Vn&lt;/em&gt; 回家。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在第一行输出满足要求的攻略的个数。&lt;/p&gt;
&lt;p&gt;在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。&lt;/p&gt;
&lt;p&gt;题目保证至少存在一个有效攻略，并且总路费不超过 109。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;6 13
0 5 2
6 2 2
6 0 1
3 4 2
1 5 2
2 5 1
3 1 1
4 1 2
1 6 1
6 3 2
1 2 1
4 5 3
2 0 2
7
6 5 1 4 3 6 2
6 5 2 1 6 3 4
8 6 2 1 6 3 4 5 2
3 2 1 5
6 6 1 3 4 5 2
7 6 2 1 3 4 5 2
6 5 2 1 4 3 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;3
5 11
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;样例说明：&#34;&gt;&lt;a href=&#34;#样例说明：&#34; class=&#34;headerlink&#34; title=&#34;样例说明：&#34;&gt;&lt;/a&gt;样例说明：&lt;/h3&gt;&lt;p&gt;第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。&lt;/p&gt;
&lt;p&gt;第 1 条攻略的总路费是：(0-&amp;gt;5) 2 + (5-&amp;gt;1) 2 + (1-&amp;gt;4) 2 + (4-&amp;gt;3) 2 + (3-&amp;gt;6) 2 + (6-&amp;gt;2) 2 + (2-&amp;gt;0) 2 &amp;#x3D; 14；&lt;/p&gt;
&lt;p&gt;第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &amp;#x3D; 11，是一条更省钱的攻略；&lt;/p&gt;
&lt;p&gt;第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &amp;#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。&lt;/p&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
int g[205][205];
int minsize=INT_MAX;			//初始化为INT_MAX
int minid=0;
int main()
&amp;#123;
    cin&gt;&gt;n&gt;&gt;m;
    int cnt=0;
    memset(g,0,sizeof(g));
    for (int i = 0; i &lt;m ; ++i) &amp;#123;
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        g[a][b]=c;
        g[b][a]=c;
    &amp;#125;
    int time;
    cin&gt;&gt;time;
    for (int j = 0; j &lt;time ; ++j) &amp;#123;
        int k;
        cin&gt;&gt;k;
        int roll[k+5];
        int has[k+5];
        memset(has,0,sizeof(has));
        roll[0]=roll[k+1]=0;					//起点和终点必定是家
        for (int i = 1; i &lt;=k ; ++i) &amp;#123;
            cin&gt;&gt;roll[i];
            if(has[roll[i]]) has[0]=1;			//每个打卡点仅能打卡一次
            else has[roll[i]]=1;
        &amp;#125;
        int flag=1;
        int tmpsize=0;
        if(k!=n||has[0]) continue;
        for (int l = 1; l &lt;=k+1 ; ++l) &amp;#123;
            if(g[roll[l-1]][roll[l]]==0)
            &amp;#123;
                flag=0;
                break;
            &amp;#125;
            tmpsize+=g[roll[l-1]][roll[l]];
        &amp;#125;
        if(flag==1)
        &amp;#123;
            if(tmpsize&lt;minsize)&amp;#123;
                minsize=tmpsize;
                minid=j+1;

            &amp;#125;
            cnt++;
        &amp;#125;
    &amp;#125;
    cout&lt;&lt;cnt&lt;&lt;endl;
    cout&lt;&lt;minid&lt;&lt;&#34; &#34;&lt;&lt;minsize&lt;&lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059&#34;&gt;题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/16/Algorithm028/</guid>
            <title>L2-010 排座位 (25 分)</title>
            <link>http://example.com/2022/04/16/Algorithm028/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Graph</category>
            <category>邻接矩阵</category>
            <category>并查集</category>
            <pubDate>Sat, 16 Apr 2022 14:57:46 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-010-排座位-25-分&#34;&gt;&lt;a href=&#34;#L2-010-排座位-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-010 排座位 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-010 排座位 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出3个正整数：&lt;code&gt;N&lt;/code&gt;（≤100），即前来参宴的宾客总人数，则这些人从1到&lt;code&gt;N&lt;/code&gt;编号；&lt;code&gt;M&lt;/code&gt;为已知两两宾客之间的关系数；&lt;code&gt;K&lt;/code&gt;为查询的条数。随后&lt;code&gt;M&lt;/code&gt;行，每行给出一对宾客之间的关系，格式为：&lt;code&gt;宾客1 宾客2 关系&lt;/code&gt;，其中&lt;code&gt;关系&lt;/code&gt;为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后&lt;code&gt;K&lt;/code&gt;行，每行给出一对需要查询的宾客编号。&lt;/p&gt;
&lt;p&gt;这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出&lt;code&gt;No problem&lt;/code&gt;；如果他们之间并不是朋友，但也不敌对，则输出&lt;code&gt;OK&lt;/code&gt;；如果他们之间有敌对，然而也有共同的朋友，则输出&lt;code&gt;OK but...&lt;/code&gt;；如果他们之间只有敌对关系，则输出&lt;code&gt;No way&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;7 8 4
5 6 1
2 7 -1
1 3 1
3 4 1
6 7 -1
1 2 1
1 4 1
2 3 -1
3 4
5 7
2 3
7 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;No problem
OK
OK but...
No way
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接矩阵 + 并查集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并查集具体链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/01/04/Algorithm004/&#34;&gt;并查集 - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
int pre[100];				//父节点
int deep[100];				//深度
int g[101][101];			//邻接矩阵建图
void init(int n)&amp;#123;
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        pre[i]=i;
        deep[i]=0;
    &amp;#125;
&amp;#125;
int find(int x)&amp;#123;
    if(pre[x]==x)&amp;#123;
        return x;
    &amp;#125; else&amp;#123;
        return pre[x]=find(pre[x]);
    &amp;#125;
&amp;#125;
void unit(int x,int y)&amp;#123;
    x=find(x);
    y=find(y);
    if(x==y) return;
    if(deep[x]&lt;deep[y])&amp;#123;
        pre[x]=y;
    &amp;#125;else&amp;#123;
        pre[y]=x;
        if(deep[x]==deep[y])&amp;#123;
            deep[x]++;
        &amp;#125;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    int n,m,k;
    init(105);
    memset(g,0,sizeof(g));
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    for (int i = 0; i &lt;m ; ++i) &amp;#123;
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        g[a][b]=g[b][a]=c;
        if(c==1) unit(a,b);					//如果是朋友则合并
    &amp;#125;
    for (int j = 0; j &lt;k ; ++j) &amp;#123;
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        if(g[a][b]==1&amp;&amp;g[b][a]==1) cout&lt;&lt;&#34;No problem&#34;&lt;&lt;endl;
        else if(g[a][b]==0&amp;&amp;g[b][a]==0) cout&lt;&lt;&#34;OK&#34;&lt;&lt;endl;			//两人毫无关系
        else if(g[a][b]==-1&amp;&amp;g[b][a]==-1&amp;&amp;find(a)==find(b)) cout&lt;&lt;&#34;OK but...&#34;&lt;&lt;endl;	//敌对且有共同朋友
        else if(g[a][b]==-1&amp;&amp;g[b][a]==-1) cout&lt;&lt;&#34;No way&#34;&lt;&lt;endl;		//仅敌对
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_45260385/article/details/109752008&#34;&gt;(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680&#34;&gt;题目详情 - L2-010 排座位 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/15/Algorithm025/</guid>
            <title>L2-013 红色警报 (25 分)</title>
            <link>http://example.com/2022/04/15/Algorithm025/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Graph</category>
            <category>邻接矩阵</category>
            <category>DFS</category>
            <pubDate>Fri, 15 Apr 2022 21:09:30 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-013-红色警报-25-分&#34;&gt;&lt;a href=&#34;#L2-013-红色警报-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-013 红色警报 (25 分)&#34;&gt;&lt;/a&gt;L2-013 红色警报 (25 分)&lt;/h2&gt;&lt;p&gt;战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出两个整数&lt;code&gt;N&lt;/code&gt;（0 &amp;lt; &lt;code&gt;N&lt;/code&gt; ≤ 500）和&lt;code&gt;M&lt;/code&gt;（≤ 5000），分别为城市个数（于是默认城市从0到&lt;code&gt;N&lt;/code&gt;-1编号）和连接两城市的通路条数。随后&lt;code&gt;M&lt;/code&gt;行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数&lt;code&gt;K&lt;/code&gt;和随后的&lt;code&gt;K&lt;/code&gt;个被攻占的城市的编号。&lt;/p&gt;
&lt;p&gt;注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个被攻占的城市，如果它会改变整个国家的连通性，则输出&lt;code&gt;Red Alert: City k is lost!&lt;/code&gt;，其中&lt;code&gt;k&lt;/code&gt;是该城市的编号；否则只输出&lt;code&gt;City k is lost.&lt;/code&gt;即可。如果该国失去了最后一个城市，则增加一行输出&lt;code&gt;Game Over.&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;5 4
0 1
1 3
3 0
0 4
5
1 2 0 4 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;City 1 is lost.
City 2 is lost.
Red Alert: City 0 is lost!
City 4 is lost.
City 3 is lost.
Game Over.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接矩阵建图 + DFS统计连通分量数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无向图中的极大连通子图称为连通分量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极大连通子图必须连通，且包含尽可能多的顶点和边&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
int g[505][505];						//邻接矩阵存图
int visit[505];							//标记访问数组
int lost[505];							//记录被攻占的城市
void dfs(int node)&amp;#123;						//正常的DFS
    visit[node]=1;
    for(int i=0;i&lt;n;i++)
    &amp;#123;
        if(visit[i]==0&amp;&amp;g[node][i]==1)
        &amp;#123;
            dfs(i);
        &amp;#125;
    &amp;#125;
&amp;#125;
int dfstrave()&amp;#123;
    int cnt=0;
    memset(visit,0,sizeof(visit));			//初始化访问数组
    for(int i=0;i&lt;n;i++)&amp;#123;
        if(lost[i]==1) visit[i]=1;			//如果该城市被攻占，则标记他为以访问
    &amp;#125;
    for(int i=0;i&lt;n;i++)&amp;#123;
        if(visit[i]==0)&amp;#123;
            dfs(i);
            cnt++;      					//统计连通分量数
        &amp;#125;
    &amp;#125;
    return cnt;
&amp;#125;
int main()
&amp;#123;
    cin&gt;&gt;n&gt;&gt;m;
    memset(lost,0,sizeof(lost));			//初始化
    memset(g,0,sizeof(g));					//初始化
    for(int i=0;i&lt;m;i++)&amp;#123;
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        g[a][b]=g[b][a]=1;					//存储无向图
    &amp;#125;
    int cnt=dfstrave();						//获得初始的连通分量数
    int k;
    cin&gt;&gt;k;
    for(int w=0;w&lt;k;w++)&amp;#123;
        int city;
        cin&gt;&gt;city;
        lost[city]=1;						//记录该城市被攻占
        for(int i=0;i&lt;n;i++)&amp;#123;
            if(g[city][i]==1)&amp;#123;				
                g[city][i]=g[i][city]=0;	//标记和他相连的城市不再相连
            &amp;#125;
        &amp;#125;
        int tempcnt=dfstrave();				//当前的连通分量
        if(tempcnt&lt;=cnt)&amp;#123;					//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变
            printf(&#34;City %d is lost.\n&#34;, city);
        &amp;#125;else&amp;#123;								//否则，连通性被改变了
            printf(&#34;Red Alert: City %d is lost!\n&#34;, city);
        &amp;#125;
        cnt=tempcnt;						//更新连通分量
        if(w==n-1)&amp;#123;							//城市已经被攻占完毕
            printf(&#34;Game Over.\n&#34;);
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208&#34;&gt;题目详情 - L2-013 红色警报 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/12/Algorithm018/</guid>
            <title>L2-023 图着色问题 (25 分)</title>
            <link>http://example.com/2022/04/12/Algorithm018/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>Set</category>
            <category>团体程序设计天梯赛</category>
            <category>Graph</category>
            <category>邻接表</category>
            <category>Vector</category>
            <pubDate>Tue, 12 Apr 2022 18:59:52 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-023-图着色问题-25-分&#34;&gt;&lt;a href=&#34;#L2-023-图着色问题-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-023 图着色问题 (25 分)&#34;&gt;&lt;/a&gt;L2-023 图着色问题 (25 分)&lt;/h2&gt;&lt;p&gt;图着色问题是一个著名的NP完全问题。给定无向图&lt;em&gt;G&lt;/em&gt;&amp;#x3D;(&lt;em&gt;V&lt;/em&gt;,&lt;em&gt;E&lt;/em&gt;)，问可否用&lt;em&gt;K&lt;/em&gt;种颜色为&lt;em&gt;V&lt;/em&gt;中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？&lt;/p&gt;
&lt;p&gt;但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出3个整数&lt;em&gt;V&lt;/em&gt;（0&amp;lt;&lt;em&gt;V&lt;/em&gt;≤500）、&lt;em&gt;E&lt;/em&gt;（≥0）和&lt;em&gt;K&lt;/em&gt;（0&amp;lt;&lt;em&gt;K&lt;/em&gt;≤&lt;em&gt;V&lt;/em&gt;），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到&lt;em&gt;V&lt;/em&gt;编号。随后&lt;em&gt;E&lt;/em&gt;行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数&lt;em&gt;N&lt;/em&gt;（≤20），是待检查的颜色分配方案的个数。随后&lt;em&gt;N&lt;/em&gt;行，每行顺次给出&lt;em&gt;V&lt;/em&gt;个顶点的颜色（第&lt;em&gt;i&lt;/em&gt;个数字表示第&lt;em&gt;i&lt;/em&gt;个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每种颜色分配方案，如果是图着色问题的一个解则输出&lt;code&gt;Yes&lt;/code&gt;，否则输出&lt;code&gt;No&lt;/code&gt;，每句占一行。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;img src=&#34;/2022/04/12/Algorithm018/graph.png&#34; alt=&#34;graph&#34; style=&#34;zoom: 67%;&#34;&gt;

&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;6 8 3
2 1
1 3
4 6
2 5
2 4
5 4
5 6
3 6
4
1 2 3 3 1 2
4 5 6 6 4 5
1 2 3 4 5 6
2 3 4 2 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;Yes
Yes
No
No
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Set + 邻接表&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
&amp;#123;
    int v,e,k;
    cin&gt;&gt;v&gt;&gt;e&gt;&gt;k;
    vector&lt;int&gt; g[505];			//邻接表
    int color[505];				//记录颜色
    for (int i = 0; i &lt;e ; ++i) &amp;#123;       //建立邻接表
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        g[a].push_back(b);
        g[b].push_back(a);
    &amp;#125;
    int time;
    cin&gt;&gt;time;
    for (int j = 0; j &lt;time ; ++j) &amp;#123;
        int flag=1;
        set&lt;int&gt; s;					//用来统计颜色总数
        s.clear();
        for (int i = 1; i &lt;=v; ++i) &amp;#123;
            int num;
            cin&gt;&gt;num;
            color[i]=num;
            s.insert(num);
        &amp;#125;
        if(s.size()!=k)&amp;#123;			//如果颜色数不等于k即非法
            cout&lt;&lt;&#34;No&#34;&lt;&lt;endl;
            continue;
        &amp;#125;
        for (int l = 1; l &lt;=v ; ++l) &amp;#123;						//遍历邻接表
            for (int i = 0; i &lt;g[l].size(); ++i) &amp;#123;
                if(color[l]==color[g[l][i]])&amp;#123;				//如果相邻结点颜色一样则为假
                    flag=0;
                    break;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        if(flag==1)&amp;#123;
            cout&lt;&lt;&#34;Yes&#34;&lt;&lt;endl;
        &amp;#125;else&amp;#123;
            cout&lt;&lt;&#34;No&#34;&lt;&lt;endl;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805057298481152&#34;&gt;题目详情 - L2-023 图着色问题 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/12/22/algorithm002/</guid>
            <title>Graph-Data Structure</title>
            <link>http://example.com/2021/12/22/algorithm002/</link>
            <category>Data Structure</category>
            <category>Graph</category>
            <pubDate>Wed, 22 Dec 2021 21:25:36 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Graph-Data-Structure&#34;&gt;&lt;a href=&#34;#Graph-Data-Structure&#34; class=&#34;headerlink&#34; title=&#34;Graph-Data Structure&#34;&gt;&lt;/a&gt;Graph-Data Structure&lt;/h1&gt;&lt;h2 id=&#34;1-邻接表的应用&#34;&gt;&lt;a href=&#34;#1-邻接表的应用&#34; class=&#34;headerlink&#34; title=&#34;1.邻接表的应用&#34;&gt;&lt;/a&gt;1.邻接表的应用&lt;/h2&gt;&lt;h3 id=&#34;样题一：L2-025-分而治之-25-分&#34;&gt;&lt;a href=&#34;#样题一：L2-025-分而治之-25-分&#34; class=&#34;headerlink&#34; title=&#34;样题一：L2-025 分而治之 (25 分)&#34;&gt;&lt;/a&gt;样题一：L2-025 分而治之 (25 分)&lt;/h3&gt;&lt;h4 id=&#34;题目描述：&#34;&gt;&lt;a href=&#34;#题目描述：&#34; class=&#34;headerlink&#34; title=&#34;题目描述：&#34;&gt;&lt;/a&gt;题目描述：&lt;/h4&gt;&lt;p&gt;分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。&lt;/p&gt;
&lt;h4 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h4&gt;&lt;p&gt;输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Np v[1] v[2] ... v[Np]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;Np&lt;/code&gt; 是该方案中计划攻下的城市数量，后面的系列 &lt;code&gt;v[i]&lt;/code&gt; 是计划攻下的城市编号。&lt;/p&gt;
&lt;h4 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h4&gt;&lt;p&gt;对每一套方案，如果可行就输出&lt;code&gt;YES&lt;/code&gt;，否则输出&lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h4&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() &amp;#123;
    vector&lt;int&gt; v[10005]; //声明邻接表
    int n,num;
    cin&gt;&gt;n&gt;&gt;num;
    for (int i = 0; i &lt;num ; ++i) &amp;#123;
        int start,end;
        cin&gt;&gt;start&gt;&gt;end;
        //创建邻接表
        v[start].push_back(end); 
        v[end].push_back(start);
    &amp;#125;
    
    int k;
    cin&gt;&gt;k;
    
    for (int j = 0; j &lt;k ; ++j) &amp;#123;
        int np;
        cin&gt;&gt;np;
        int flag=1;
        int book[10005]=&amp;#123;0&amp;#125;;//每轮炸毁城市初始化
        
        for (int i = 1; i &lt;=np ; ++i) &amp;#123;
            int dead;
            cin&gt;&gt;dead;
            book[dead]=1; //被炸毁的城市标记为1
        &amp;#125;
        
        for (int l = 1; l &lt;=n ; ++l) &amp;#123;
            
            if(book[l]==0)//没有被炸毁的城市
            &amp;#123;
                for (int i = 0; i &lt;v[l].size() ; ++i) &amp;#123; //遍历该城市的邻接表
                    
                    if(book[v[l][i]]==0) //存在着还连通的城市
                    &amp;#123;
                        flag=0;//说明方案不可行
                        break;
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        if(flag==1)
        &amp;#123;
            cout&lt;&lt;&#34;YES&#34;&lt;&lt;endl;
        &amp;#125;
        else&amp;#123;
            cout&lt;&lt;&#34;NO&#34;&lt;&lt;endl;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;程序输入：&#34;&gt;&lt;a href=&#34;#程序输入：&#34; class=&#34;headerlink&#34; title=&#34;程序输入：&#34;&gt;&lt;/a&gt;程序输入：&lt;/h4&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;10 11
8 7
6 8
4 5
8 4
8 1
1 2
1 4
9 8
9 1
1 10
2 4
5
4 10 3 8 4
6 6 1 7 5 4 9
3 1 8 4
2 2 8
7 9 8 7 6 5 4 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;程序输出：&#34;&gt;&lt;a href=&#34;#程序输出：&#34; class=&#34;headerlink&#34; title=&#34;程序输出：&#34;&gt;&lt;/a&gt;程序输出：&lt;/h4&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;NO
YES
YES
NO
NO
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;题目相关链接：&#34;&gt;&lt;a href=&#34;#题目相关链接：&#34; class=&#34;headerlink&#34; title=&#34;题目相关链接：&#34;&gt;&lt;/a&gt;题目相关链接：&lt;/h2&gt;&lt;p&gt;[&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]&#34;&gt;https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]&lt;/a&gt;: 	“样例一:L2-025 分而治之 (25 分)”&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
