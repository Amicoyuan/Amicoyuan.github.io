{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"graph\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/05/06/Algorithm037/",
            "url": "http://example.com/2022/05/06/Algorithm037/",
            "title": "图的存储",
            "date_published": "2022-05-06T08:38:38.000Z",
            "content_html": "<h2 id=\"图的存储\"><a href=\"#图的存储\" class=\"headerlink\" title=\"图的存储\"></a>图的存储</h2><h3 id=\"邻接矩阵法\"><a href=\"#邻接矩阵法\" class=\"headerlink\" title=\"邻接矩阵法\"></a>邻接矩阵法</h3><pre class=\" language-c++\"><code class=\"language-c++\">#define MaxVertexNum 100\t\t\t\t\t\t\t\t\t//顶点数目的最大值\ntypedef char VertexType;\t\t\t\t\t\t\t\t\t//顶点的数据类型\ntypedef int EdgeType;\t\t\t\t\t\t\t\t\t\t//带权图中边上权值的数据类型\ntypedef struct&#123;\n    VertexType Vex[MaxVertexNum];\t\t\t\t\t\t\t//顶点表\n    EdgeType Edge[MaxVertexNum][MaxVertexNum];\t\t\t\t//邻接矩阵，边表\n    int vexnum,arcnum;\t\t\t\t\t\t\t\t\t\t//图中当前顶点数和弧数\n&#125;MGraph;\n</code></pre>\n<h3 id=\"邻接表法\"><a href=\"#邻接表法\" class=\"headerlink\" title=\"邻接表法\"></a>邻接表法</h3><pre class=\" language-c++\"><code class=\"language-c++\">#define MaxVertexNum 100\t\t\t\t\t\t\t\t\t//图中顶点数目的最大值\ntypedef struct ArcNode&#123;\t\t\t\t\t\t\t\t\t\t//边表结点\n    int adjvex;\t\t\t\t\t\t\t\t\t\t\t\t//该弧所指向的顶点的位置\n    struct ArcNode *next;\t\t\t\t\t\t\t\t\t//指向下一条弧的指针\n    //InfoType infp;\t\t\t\t\t\t\t\t\t\t//网的边权值\n&#125;ArcNode;\ntypedef struct VNode&#123;\t\t\t\t\t\t\t\t\t\t//顶点表结点\n    VertexType data;\t\t\t\t\t\t\t\t\t\t//顶点信息\n    ArcNode *first;\t\t\t\t\t\t\t\t\t\t\t//指向第一条依附该顶点的弧的指针\n&#125;VNode,AdjList[MaxVertexNum];\ntypedef struct&#123;\n    AdjList vertices;\t\t\t\t\t\t\t\t\t\t//邻接表\n    int vexnum,arcnum;\t\t\t\t\t\t\t\t\t\t//图的顶点数和弧数\n&#125;ALGraph;\t\t\t\t\t\t\t\t\t\t\t\t\t//ALGraph是以邻接表存储的图的类型\n</code></pre>\n",
            "tags": [
                "Data Structure",
                "Graph"
            ]
        },
        {
            "id": "http://example.com/2022/04/23/Algorithm032/",
            "url": "http://example.com/2022/04/23/Algorithm032/",
            "title": "L2-036 网红点打卡攻略 (25 分)",
            "date_published": "2022-04-23T13:50:27.000Z",
            "content_html": "<h2 id=\"L2-036-网红点打卡攻略-25-分\"><a href=\"#L2-036-网红点打卡攻略-25-分\" class=\"headerlink\" title=\"L2-036 网红点打卡攻略 (25 分)\"></a>L2-036 网红点打卡攻略 (25 分)</h2><p>一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>首先第一行给出两个正整数：网红点的个数 <em>N</em>（1&lt;<em>N</em>≤200）和网红点之间通路的条数 <em>M</em>。随后 <em>M</em> 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 <em>N</em> 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 <code>0</code>。</p>\n<p>再下一行给出一个正整数 <em>K</em>，是待检验的攻略的数量。随后 <em>K</em> 行，每行给出一条待检攻略，格式为：</p>\n<p><em>n</em> <em>V</em>1 <em>V</em>2 ⋯ Vn</p>\n<p>其中 <em>n</em>(≤200) 是攻略中的网红点数，<em>Vi</em> 是路径上的网红点编号。这里假设你从家里出发，从 <em>V</em>1 开始打卡，最后从 <em>Vn</em> 回家。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在第一行输出满足要求的攻略的个数。</p>\n<p>在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。</p>\n<p>题目保证至少存在一个有效攻略，并且总路费不超过 109。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">6 13\n0 5 2\n6 2 2\n6 0 1\n3 4 2\n1 5 2\n2 5 1\n3 1 1\n4 1 2\n1 6 1\n6 3 2\n1 2 1\n4 5 3\n2 0 2\n7\n6 5 1 4 3 6 2\n6 5 2 1 6 3 4\n8 6 2 1 6 3 4 5 2\n3 2 1 5\n6 6 1 3 4 5 2\n7 6 2 1 3 4 5 2\n6 5 2 1 4 3 6\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">3\n5 11\n</code></pre>\n<h3 id=\"样例说明：\"><a href=\"#样例说明：\" class=\"headerlink\" title=\"样例说明：\"></a>样例说明：</h3><p>第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。</p>\n<p>第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 &#x3D; 14；</p>\n<p>第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &#x3D; 11，是一条更省钱的攻略；</p>\n<p>第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。</p>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><pre class=\" language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint g[205][205];\nint minsize=INT_MAX;\t\t\t//初始化为INT_MAX\nint minid=0;\nint main()\n&#123;\n    cin>>n>>m;\n    int cnt=0;\n    memset(g,0,sizeof(g));\n    for (int i = 0; i <m ; ++i) &#123;\n        int a,b,c;\n        cin>>a>>b>>c;\n        g[a][b]=c;\n        g[b][a]=c;\n    &#125;\n    int time;\n    cin>>time;\n    for (int j = 0; j <time ; ++j) &#123;\n        int k;\n        cin>>k;\n        int roll[k+5];\n        int has[k+5];\n        memset(has,0,sizeof(has));\n        roll[0]=roll[k+1]=0;\t\t\t\t\t//起点和终点必定是家\n        for (int i = 1; i <=k ; ++i) &#123;\n            cin>>roll[i];\n            if(has[roll[i]]) has[0]=1;\t\t\t//每个打卡点仅能打卡一次\n            else has[roll[i]]=1;\n        &#125;\n        int flag=1;\n        int tmpsize=0;\n        if(k!=n||has[0]) continue;\n        for (int l = 1; l <=k+1 ; ++l) &#123;\n            if(g[roll[l-1]][roll[l]]==0)\n            &#123;\n                flag=0;\n                break;\n            &#125;\n            tmpsize+=g[roll[l-1]][roll[l]];\n        &#125;\n        if(flag==1)\n        &#123;\n            if(tmpsize<minsize)&#123;\n                minsize=tmpsize;\n                minid=j+1;\n\n            &#125;\n            cnt++;\n        &#125;\n    &#125;\n    cout<<cnt<<endl;\n    cout<<minid<<\" \"<<minsize<<endl;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059\">题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Graph",
                "邻接矩阵"
            ]
        },
        {
            "id": "http://example.com/2022/04/16/Algorithm028/",
            "url": "http://example.com/2022/04/16/Algorithm028/",
            "title": "L2-010 排座位 (25 分)",
            "date_published": "2022-04-16T06:57:46.000Z",
            "content_html": "<h2 id=\"L2-010-排座位-25-分\"><a href=\"#L2-010-排座位-25-分\" class=\"headerlink\" title=\"L2-010 排座位 (25 分)\"></a><strong>L2-010 排座位 (25 分)</strong></h2><p>布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入第一行给出3个正整数：<code>N</code>（≤100），即前来参宴的宾客总人数，则这些人从1到<code>N</code>编号；<code>M</code>为已知两两宾客之间的关系数；<code>K</code>为查询的条数。随后<code>M</code>行，每行给出一对宾客之间的关系，格式为：<code>宾客1 宾客2 关系</code>，其中<code>关系</code>为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后<code>K</code>行，每行给出一对需要查询的宾客编号。</p>\n<p>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出<code>No problem</code>；如果他们之间并不是朋友，但也不敌对，则输出<code>OK</code>；如果他们之间有敌对，然而也有共同的朋友，则输出<code>OK but...</code>；如果他们之间只有敌对关系，则输出<code>No way</code>。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">7 8 4\n5 6 1\n2 7 -1\n1 3 1\n3 4 1\n6 7 -1\n1 2 1\n1 4 1\n2 3 -1\n3 4\n5 7\n2 3\n7 2\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">No problem\nOK\nOK but...\nNo way\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接矩阵 + 并查集</strong></p>\n<p><strong>并查集具体链接：</strong></p>\n<p><a href=\"https://xingyuanjie.top/2022/01/04/Algorithm004/\">并查集 - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nint pre[100];\t\t\t\t//父节点\nint deep[100];\t\t\t\t//深度\nint g[101][101];\t\t\t//邻接矩阵建图\nvoid init(int n)&#123;\n    for (int i = 0; i <n ; ++i) &#123;\n        pre[i]=i;\n        deep[i]=0;\n    &#125;\n&#125;\nint find(int x)&#123;\n    if(pre[x]==x)&#123;\n        return x;\n    &#125; else&#123;\n        return pre[x]=find(pre[x]);\n    &#125;\n&#125;\nvoid unit(int x,int y)&#123;\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n    if(deep[x]<deep[y])&#123;\n        pre[x]=y;\n    &#125;else&#123;\n        pre[y]=x;\n        if(deep[x]==deep[y])&#123;\n            deep[x]++;\n        &#125;\n    &#125;\n&#125;\nint main()\n&#123;\n    int n,m,k;\n    init(105);\n    memset(g,0,sizeof(g));\n    cin>>n>>m>>k;\n    for (int i = 0; i <m ; ++i) &#123;\n        int a,b,c;\n        cin>>a>>b>>c;\n        g[a][b]=g[b][a]=c;\n        if(c==1) unit(a,b);\t\t\t\t\t//如果是朋友则合并\n    &#125;\n    for (int j = 0; j <k ; ++j) &#123;\n        int a,b;\n        cin>>a>>b;\n        if(g[a][b]==1&&g[b][a]==1) cout<<\"No problem\"<<endl;\n        else if(g[a][b]==0&&g[b][a]==0) cout<<\"OK\"<<endl;\t\t\t//两人毫无关系\n        else if(g[a][b]==-1&&g[b][a]==-1&&find(a)==find(b)) cout<<\"OK but...\"<<endl;\t//敌对且有共同朋友\n        else if(g[a][b]==-1&&g[b][a]==-1) cout<<\"No way\"<<endl;\t\t//仅敌对\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://blog.csdn.net/weixin_45260385/article/details/109752008\">(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客</a></p>\n<p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680\">题目详情 - L2-010 排座位 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Graph",
                "邻接矩阵",
                "并查集"
            ]
        },
        {
            "id": "http://example.com/2022/04/15/Algorithm025/",
            "url": "http://example.com/2022/04/15/Algorithm025/",
            "title": "L2-013 红色警报 (25 分)",
            "date_published": "2022-04-15T13:09:30.000Z",
            "content_html": "<h2 id=\"L2-013-红色警报-25-分\"><a href=\"#L2-013-红色警报-25-分\" class=\"headerlink\" title=\"L2-013 红色警报 (25 分)\"></a>L2-013 红色警报 (25 分)</h2><p>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出两个整数<code>N</code>（0 &lt; <code>N</code> ≤ 500）和<code>M</code>（≤ 5000），分别为城市个数（于是默认城市从0到<code>N</code>-1编号）和连接两城市的通路条数。随后<code>M</code>行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数<code>K</code>和随后的<code>K</code>个被攻占的城市的编号。</p>\n<p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出<code>Red Alert: City k is lost!</code>，其中<code>k</code>是该城市的编号；否则只输出<code>City k is lost.</code>即可。如果该国失去了最后一个城市，则增加一行输出<code>Game Over.</code>。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">5 4\n0 1\n1 3\n3 0\n0 4\n5\n1 2 0 4 3\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">City 1 is lost.\nCity 2 is lost.\nRed Alert: City 0 is lost!\nCity 4 is lost.\nCity 3 is lost.\nGame Over.\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接矩阵建图 + DFS统计连通分量数</strong></p>\n<p><strong>对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数</strong></p>\n<p><strong>无向图中的极大连通子图称为连通分量</strong></p>\n<p><strong>极大连通子图必须连通，且包含尽可能多的顶点和边</strong></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint g[505][505];\t\t\t\t\t\t//邻接矩阵存图\nint visit[505];\t\t\t\t\t\t\t//标记访问数组\nint lost[505];\t\t\t\t\t\t\t//记录被攻占的城市\nvoid dfs(int node)&#123;\t\t\t\t\t\t//正常的DFS\n    visit[node]=1;\n    for(int i=0;i<n;i++)\n    &#123;\n        if(visit[i]==0&&g[node][i]==1)\n        &#123;\n            dfs(i);\n        &#125;\n    &#125;\n&#125;\nint dfstrave()&#123;\n    int cnt=0;\n    memset(visit,0,sizeof(visit));\t\t\t//初始化访问数组\n    for(int i=0;i<n;i++)&#123;\n        if(lost[i]==1) visit[i]=1;\t\t\t//如果该城市被攻占，则标记他为以访问\n    &#125;\n    for(int i=0;i<n;i++)&#123;\n        if(visit[i]==0)&#123;\n            dfs(i);\n            cnt++;      \t\t\t\t\t//统计连通分量数\n        &#125;\n    &#125;\n    return cnt;\n&#125;\nint main()\n&#123;\n    cin>>n>>m;\n    memset(lost,0,sizeof(lost));\t\t\t//初始化\n    memset(g,0,sizeof(g));\t\t\t\t\t//初始化\n    for(int i=0;i<m;i++)&#123;\n        int a,b;\n        cin>>a>>b;\n        g[a][b]=g[b][a]=1;\t\t\t\t\t//存储无向图\n    &#125;\n    int cnt=dfstrave();\t\t\t\t\t\t//获得初始的连通分量数\n    int k;\n    cin>>k;\n    for(int w=0;w<k;w++)&#123;\n        int city;\n        cin>>city;\n        lost[city]=1;\t\t\t\t\t\t//记录该城市被攻占\n        for(int i=0;i<n;i++)&#123;\n            if(g[city][i]==1)&#123;\t\t\t\t\n                g[city][i]=g[i][city]=0;\t//标记和他相连的城市不再相连\n            &#125;\n        &#125;\n        int tempcnt=dfstrave();\t\t\t\t//当前的连通分量\n        if(tempcnt<=cnt)&#123;\t\t\t\t\t//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变\n            printf(\"City %d is lost.\\n\", city);\n        &#125;else&#123;\t\t\t\t\t\t\t\t//否则，连通性被改变了\n            printf(\"Red Alert: City %d is lost!\\n\", city);\n        &#125;\n        cnt=tempcnt;\t\t\t\t\t\t//更新连通分量\n        if(w==n-1)&#123;\t\t\t\t\t\t\t//城市已经被攻占完毕\n            printf(\"Game Over.\\n\");\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208\">题目详情 - L2-013 红色警报 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Graph",
                "邻接矩阵",
                "DFS"
            ]
        },
        {
            "id": "http://example.com/2022/04/12/Algorithm018/",
            "url": "http://example.com/2022/04/12/Algorithm018/",
            "title": "L2-023 图着色问题 (25 分)",
            "date_published": "2022-04-12T10:59:52.000Z",
            "content_html": "<h2 id=\"L2-023-图着色问题-25-分\"><a href=\"#L2-023-图着色问题-25-分\" class=\"headerlink\" title=\"L2-023 图着色问题 (25 分)\"></a>L2-023 图着色问题 (25 分)</h2><p>图着色问题是一个著名的NP完全问题。给定无向图<em>G</em>&#x3D;(<em>V</em>,<em>E</em>)，问可否用<em>K</em>种颜色为<em>V</em>中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？</p>\n<p>但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出3个整数<em>V</em>（0&lt;<em>V</em>≤500）、<em>E</em>（≥0）和<em>K</em>（0&lt;<em>K</em>≤<em>V</em>），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到<em>V</em>编号。随后<em>E</em>行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数<em>N</em>（≤20），是待检查的颜色分配方案的个数。随后<em>N</em>行，每行顺次给出<em>V</em>个顶点的颜色（第<em>i</em>个数字表示第<em>i</em>个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每种颜色分配方案，如果是图着色问题的一个解则输出<code>Yes</code>，否则输出<code>No</code>，每句占一行。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><img src=\"/2022/04/12/Algorithm018/graph.png\" alt=\"graph\" style=\"zoom: 67%;\">\n\n<pre class=\" language-in\"><code class=\"language-in\">6 8 3\n2 1\n1 3\n4 6\n2 5\n2 4\n5 4\n5 6\n3 6\n4\n1 2 3 3 1 2\n4 5 6 6 4 5\n1 2 3 4 5 6\n2 3 4 2 3 4\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">Yes\nYes\nNo\nNo\n</code></pre>\n<h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><p><strong>Set + 邻接表</strong></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nint main()\n&#123;\n    int v,e,k;\n    cin>>v>>e>>k;\n    vector<int> g[505];\t\t\t//邻接表\n    int color[505];\t\t\t\t//记录颜色\n    for (int i = 0; i <e ; ++i) &#123;       //建立邻接表\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    &#125;\n    int time;\n    cin>>time;\n    for (int j = 0; j <time ; ++j) &#123;\n        int flag=1;\n        set<int> s;\t\t\t\t\t//用来统计颜色总数\n        s.clear();\n        for (int i = 1; i <=v; ++i) &#123;\n            int num;\n            cin>>num;\n            color[i]=num;\n            s.insert(num);\n        &#125;\n        if(s.size()!=k)&#123;\t\t\t//如果颜色数不等于k即非法\n            cout<<\"No\"<<endl;\n            continue;\n        &#125;\n        for (int l = 1; l <=v ; ++l) &#123;\t\t\t\t\t\t//遍历邻接表\n            for (int i = 0; i <g[l].size(); ++i) &#123;\n                if(color[l]==color[g[l][i]])&#123;\t\t\t\t//如果相邻结点颜色一样则为假\n                    flag=0;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        if(flag==1)&#123;\n            cout<<\"Yes\"<<endl;\n        &#125;else&#123;\n            cout<<\"No\"<<endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805057298481152\">题目详情 - L2-023 图着色问题 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "Set",
                "团体程序设计天梯赛",
                "Graph",
                "邻接表",
                "Vector"
            ]
        },
        {
            "id": "http://example.com/2021/12/22/algorithm002/",
            "url": "http://example.com/2021/12/22/algorithm002/",
            "title": "Graph-Data Structure",
            "date_published": "2021-12-22T13:25:36.000Z",
            "content_html": "<h1 id=\"Graph-Data-Structure\"><a href=\"#Graph-Data-Structure\" class=\"headerlink\" title=\"Graph-Data Structure\"></a>Graph-Data Structure</h1><h2 id=\"1-邻接表的应用\"><a href=\"#1-邻接表的应用\" class=\"headerlink\" title=\"1.邻接表的应用\"></a>1.邻接表的应用</h2><h3 id=\"样题一：L2-025-分而治之-25-分\"><a href=\"#样题一：L2-025-分而治之-25-分\" class=\"headerlink\" title=\"样题一：L2-025 分而治之 (25 分)\"></a>样题一：L2-025 分而治之 (25 分)</h3><h4 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h4><p>分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。</p>\n<h4 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h4><p>输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：</p>\n<pre><code>Np v[1] v[2] ... v[Np]\n</code></pre>\n<p>其中 <code>Np</code> 是该方案中计划攻下的城市数量，后面的系列 <code>v[i]</code> 是计划攻下的城市编号。</p>\n<h4 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h4><p>对每一套方案，如果可行就输出<code>YES</code>，否则输出<code>NO</code>。</p>\n<h4 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h4><pre class=\" language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nint main() &#123;\n    vector<int> v[10005]; //声明邻接表\n    int n,num;\n    cin>>n>>num;\n    for (int i = 0; i <num ; ++i) &#123;\n        int start,end;\n        cin>>start>>end;\n        //创建邻接表\n        v[start].push_back(end); \n        v[end].push_back(start);\n    &#125;\n    \n    int k;\n    cin>>k;\n    \n    for (int j = 0; j <k ; ++j) &#123;\n        int np;\n        cin>>np;\n        int flag=1;\n        int book[10005]=&#123;0&#125;;//每轮炸毁城市初始化\n        \n        for (int i = 1; i <=np ; ++i) &#123;\n            int dead;\n            cin>>dead;\n            book[dead]=1; //被炸毁的城市标记为1\n        &#125;\n        \n        for (int l = 1; l <=n ; ++l) &#123;\n            \n            if(book[l]==0)//没有被炸毁的城市\n            &#123;\n                for (int i = 0; i <v[l].size() ; ++i) &#123; //遍历该城市的邻接表\n                    \n                    if(book[v[l][i]]==0) //存在着还连通的城市\n                    &#123;\n                        flag=0;//说明方案不可行\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        if(flag==1)\n        &#123;\n            cout<<\"YES\"<<endl;\n        &#125;\n        else&#123;\n            cout<<\"NO\"<<endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"程序输入：\"><a href=\"#程序输入：\" class=\"headerlink\" title=\"程序输入：\"></a>程序输入：</h4><pre class=\" language-c++\"><code class=\"language-c++\">10 11\n8 7\n6 8\n4 5\n8 4\n8 1\n1 2\n1 4\n9 8\n9 1\n1 10\n2 4\n5\n4 10 3 8 4\n6 6 1 7 5 4 9\n3 1 8 4\n2 2 8\n7 9 8 7 6 5 4 2\n</code></pre>\n<h4 id=\"程序输出：\"><a href=\"#程序输出：\" class=\"headerlink\" title=\"程序输出：\"></a>程序输出：</h4><pre class=\" language-c++\"><code class=\"language-c++\">NO\nYES\nYES\nNO\nNO\n</code></pre>\n<h2 id=\"题目相关链接：\"><a href=\"#题目相关链接：\" class=\"headerlink\" title=\"题目相关链接：\"></a>题目相关链接：</h2><p>[<a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]\">https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200]</a>: \t“样例一:L2-025 分而治之 (25 分)”</p>\n",
            "tags": [
                "Data Structure",
                "Graph"
            ]
        }
    ]
}