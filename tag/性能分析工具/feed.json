{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"性能分析工具\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/posts/e1c9d847.html",
            "url": "http://example.com/posts/e1c9d847.html",
            "title": "gcov代码覆盖率测试-完整样例-SLIC",
            "date_published": "2022-05-08T02:34:59.000Z",
            "content_html": "<h2 id=\"gcov代码覆盖率测试-完整样例-SLIC\"><a href=\"#gcov代码覆盖率测试-完整样例-SLIC\" class=\"headerlink\" title=\"gcov代码覆盖率测试-完整样例-SLIC\"></a>gcov代码覆盖率测试-完整样例-SLIC</h2><h3 id=\"gcov代码覆盖率测试介绍：\"><a href=\"#gcov代码覆盖率测试介绍：\" class=\"headerlink\" title=\"gcov代码覆盖率测试介绍：\"></a>gcov代码覆盖率测试介绍：</h3><p><a href=\"https://xingyuanjie.top/2022/01/18/tool002/\">gcov代码覆盖率测试 - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n<h3 id=\"完整样例-SLIC：\"><a href=\"#完整样例-SLIC：\" class=\"headerlink\" title=\"完整样例-SLIC：\"></a>完整样例-SLIC：</h3><p><a href=\"https://xingyuanjie.top/2022/05/08/tool004/result.zip\">https://xingyuanjie.top/2022/05/08/tool004/result.zip</a></p>\n",
            "tags": [
                "性能分析工具",
                "gcov"
            ]
        },
        {
            "id": "http://example.com/posts/36bfc6de.html",
            "url": "http://example.com/posts/36bfc6de.html",
            "title": "perf-系统级性能分析工具",
            "date_published": "2022-01-19T03:56:40.000Z",
            "content_html": "<p>系统级性能优化通常包括两个阶段：性能剖析（performance profiling）和代码优化。</p>\n<p>性能剖析的目标是寻找性能瓶颈，查找引发性能问题的原因及热点代码。</p>\n<p>代码优化的目标是针对具体性能问题而优化代码或编译选项，以改善软件性能。</p>\n<p>在性能剖析阶段，需要借助于现有的profiling工具，如perf等。在代码优化阶段往往需要借助开发者的经验，编写简洁高效的代码，甚至在汇编级别合理使用各种指令，合理安排各种指令的执行顺序。</p>\n<p>perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。<br>通过perf，应用程序可以利用PMU、tracepoint和内核中的计数器来进行性能统计。它不但可以分析制定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用程序和内核，从而全面理解应用程序中的性能瓶颈。</p>\n<p>使用perf，可以分析程序运行期间发生的硬件事件，比如instructions retired、processor clock cycles等；也可以分析软件时间，比如page fault和进程切换。</p>\n<p>perf是一款综合性分析工具，大到系统全局性性能，再小到进程线程级别，甚至到函数及汇编级别。</p>\n<p>perf提供了十八般武器，可以拿大刀大卸八块，也可以拿起手术刀细致分析。</p>\n<h1 id=\"1-背景知识\"><a href=\"#1-背景知识\" class=\"headerlink\" title=\"1. 背景知识\"></a>1. 背景知识</h1><h2 id=\"1-1-tracepoints\"><a href=\"#1-1-tracepoints\" class=\"headerlink\" title=\"1.1 tracepoints\"></a>1.1 tracepoints</h2><p>tracepoints是散落在内核源码中的一些hook，它们可以在特定的代码被执行到时触发，这一特定可以被各种trace&#x2F;debug工具所使用。</p>\n<p>perf将tracepoint产生的时间记录下来，生成报告，通过分析这些报告，便可以了解程序运行期间内核的各种细节，对性能症状做出准确的诊断。</p>\n<p>这些tracepint的对应的sysfs节点在&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events目录下。</p>\n<h2 id=\"1-2-硬件特性之cache\"><a href=\"#1-2-硬件特性之cache\" class=\"headerlink\" title=\"1.2 硬件特性之cache\"></a>1.2 硬件特性之cache</h2><p>内存读写是很快的，但是还是无法和处理器指令执行速度相比。为了从内存中读取指令和数据，处理器需要等待，用处理器时间来衡量，这种等待非常漫长。cache是一种SRAM，读写速度非常快，能和处理器相匹配。因此将常用的数据保存在cache中，处理器便无需等待，从而提高性能。cache的尺寸一般都很小，充分利用cache是软件调优非常重要部分。</p>\n<h1 id=\"2-主要关注点\"><a href=\"#2-主要关注点\" class=\"headerlink\" title=\"2. 主要关注点\"></a>2. 主要关注点</h1><p>基于性能分析，可以进行算法优化（空间复杂度和时间复杂度权衡）、代码优化（提高执行速度、减少内存占用）。</p>\n<p>评估程序对硬件资源的使用情况，例如各级cache的访问次数、各级cache的丢失次数、流水线停顿周期、前端总线访问次数等。</p>\n<p>评估程序对操作系统资源的使用情况，系统调用次数、上下文切换次数、任务迁移次数。</p>\n<p>事件可以分为三种：</p>\n<ol>\n<li>Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。</li>\n<li>Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如进程切换，tick数等。</li>\n<li>Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。</li>\n</ol>\n<h1 id=\"3-perf的使用\"><a href=\"#3-perf的使用\" class=\"headerlink\" title=\"3. perf的使用\"></a>3. perf的使用</h1><p>perf –help后可以看到perf的二级命令</p>\n<p><img src=\"/posts/36bfc6de.htm/image-20220119120817508.png\"></p>\n<h2 id=\"3-1perf-list\"><a href=\"#3-1perf-list\" class=\"headerlink\" title=\"3.1perf list\"></a>3.1perf list</h2><p>perf list查看支持的事件类型</p>\n<p><img src=\"/posts/36bfc6de.htm/image-20220119121131231.png\"></p>\n<h2 id=\"3-2perf-top\"><a href=\"#3-2perf-top\" class=\"headerlink\" title=\"3.2perf top\"></a>3.2perf top</h2><p>即可以正常显示perf top如下：</p>\n<p>第一列：符号引发的性能事件的比例，指占用的cpu周期比例。</p>\n<p>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。</p>\n<p>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库；[k]表述此符号属于内核或模块。</p>\n<p>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p>\n<p><img src=\"/posts/36bfc6de.htm/image-20220119121453395.png\"></p>\n<h2 id=\"3-3-perf-stat\"><a href=\"#3-3-perf-stat\" class=\"headerlink\" title=\"3.3 perf stat\"></a>3.3 perf stat</h2><p>perf stat用于运行指令，并分析其统计结果。虽然perf top也可以指定pid，但是必须先启动应用才能查看信息。</p>\n<p>perf stat能完整统计应用整个生命周期的信息。</p>\n<p>命令格式为：</p>\n<blockquote>\n<p>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] <command><br>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] — <command> [<options>]</options></EVENT></EVENT></p>\n</blockquote>\n<p><img src=\"/posts/36bfc6de.htm/image-20220119122351095.png\" alt=\"image-20220119122351095\"></p>\n<p><img src=\"/posts/36bfc6de.htm/C2DDB2280E83453D6D8FE0D11A4380C3.png\"></p>\n<p>cpu-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized &#x3D; task-clock &#x2F; time elapsed，CPU的占用率。</p>\n<p>context-switches：程序在运行过程中上下文的切换次数。</p>\n<p>CPU-migrations：程序在运行过程中发生的处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。</p>\n<p>CPU迁移和上下文切换：发生上下文切换不一定会发生CPU迁移，而发生CPU迁移时肯定会发生上下文切换。发生上下文切换有可能只是把上下文从当前CPU中换出，下一次调度器还是将进程安排在这个CPU上执行。</p>\n<p>page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。</p>\n<p>cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles &#x2F; task-clock算出。</p>\n<p>stalled-cycles-frontend：指令读取或解码的质量步骤，未能按理想状态发挥并行左右，发生停滞的时钟周期。</p>\n<p>stalled-cycles-backend：指令执行步骤，发生停滞的时钟周期。</p>\n<p>instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。</p>\n<p>branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p>\n<h2 id=\"3-4-perf-record-amp-report\"><a href=\"#3-4-perf-record-amp-report\" class=\"headerlink\" title=\"3.4 perf record &amp; report\"></a>3.4 perf record &amp; report</h2><p>运行一个命令，并将其数据保存到perf.data中。随后，可以使用perf report进行分析。</p>\n<p>perf record和perf report可以更精确的分析一个应用，perf record可以精确到函数级别。并且在函数里面混合显示汇编语言和代码。</p>\n<p><img src=\"/posts/36bfc6de.htm/image-20220119123152290.png\"></p>\n<p>1.编译程序(这里以test.c为例子)</p>\n<p><img src=\"/posts/36bfc6de.htm/image-20220119124049654.png\"></p>\n<p>2.perf record</p>\n<p><img src=\"/posts/36bfc6de.htm/image-20220119124217563.png\"></p>\n<p>3.perf report</p>\n<p><img src=\"/posts/36bfc6de.htm/image-20220119124149337.png\"></p>\n<p><img src=\"/posts/36bfc6de.htm/image-20220119124013315.png\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.cnblogs.com/arnoldlu/p/6241297.html\">系统级性能分析工具perf的介绍与使用 - ArnoldLu - 博客园 (cnblogs.com)</a>-系统性能分析工具perf的介绍与使用</p>\n<p><a href=\"https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=11304698501320722134&spm_id_from=333.337.0.0\">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>\n",
            "tags": [
                "性能分析工具"
            ]
        },
        {
            "id": "http://example.com/posts/738721a6.html",
            "url": "http://example.com/posts/738721a6.html",
            "title": "gcov代码覆盖率测试",
            "date_published": "2022-01-18T06:35:05.000Z",
            "content_html": "<h1 id=\"gcov代码覆盖率测试\"><a href=\"#gcov代码覆盖率测试\" class=\"headerlink\" title=\"gcov代码覆盖率测试\"></a>gcov代码覆盖率测试</h1><h2 id=\"gcov的简单介绍\"><a href=\"#gcov的简单介绍\" class=\"headerlink\" title=\"gcov的简单介绍\"></a>gcov的简单介绍</h2><p>1.gcov是一个测试代码覆盖率的工具。与GCC一起使用来分析程序，以帮助创建更高效、更快的运行代码，并发现程序的未测试部分<br>2.是一个命令行方式的控制台程序。需要结合lcov,gcovr等前端图形工具才能实现统计数据图形化<br>3.伴随GCC发布，不需要单独下载gcov工具。配合GCC共同实现对c&#x2F;c++文件的语句覆盖和分支覆盖测试<br>4.与程序概要分析工具（profiling tool，例如gprof）一起工作，可以估计程序中哪段代码最耗时</p>\n<h2 id=\"gcov能做什么\"><a href=\"#gcov能做什么\" class=\"headerlink\" title=\"gcov能做什么\"></a>gcov能做什么</h2><p>使用像gcov或gprof这样的分析器，您可以找到一些基本的性能统计数据：</p>\n<ul>\n<li>每一行代码执行的频率是多少</li>\n<li>实际执行了哪些行代码，配合测试用例达到满意的覆盖率和预期工作</li>\n<li>每段代码使用了多少计算时间，从而找到热点优化代码</li>\n<li>gcov创建一个sourcefile.gcov的日志文件，此文件标识源文件sourcefile.c每一行执行的次数,您可以与gprof一起使用这些日志文件来帮助优化程序的性能。gprof提供了您可以使用的时间信息以及从gcov获得的信息。</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>1.通过将一些代码行合并到一个函数中，可能不会提供足够的信息来查找代码使用大量计算机时间的“热点”。同样地，由于gcov按行(在最低的分辨率下)积累统计数据，它最适合于只在每行上放置一个语句的编程风格。如果您使用扩展到循环或其他控制结构的复杂宏，那么统计信息就没有那么有用了——它们只报告出现宏调用的行。如果您的复杂宏的行为类似于函数，那么您可以用inline fu替换它们。<br>2.gcov只在使用GCC编译的代码上工作。它与任何其他概要或测试覆盖机制不兼容。</p>\n<h2 id=\"使用gcov的3个阶段\"><a href=\"#使用gcov的3个阶段\" class=\"headerlink\" title=\"使用gcov的3个阶段\"></a>使用gcov的3个阶段</h2><h3 id=\"1-编译阶段\"><a href=\"#1-编译阶段\" class=\"headerlink\" title=\"1.编译阶段\"></a>1.编译阶段</h3><p>要开启gcov功能，需要在源码编译参数中加入-fprofile-arcs -ftest-coverage</p>\n<ul>\n<li>-ftest-coverage：在编译的时候产生.gcno文件，它包含了重建基本块图和相应的块的源码的行号的信息。</li>\n<li>-fprofile-arcs：在运行编译过的程序的时候，会产生.gcda文件，它包含了弧跳变的次数等信息。</li>\n</ul>\n<p>以下我们以test.c这个程序为例子，源码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> n=<span class=\"hljs-number\">4</span>;<br>\t<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>\t&#123;<br>\t   <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello World!\\n&quot;</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">int</span> a =<span class=\"hljs-number\">20220118</span>;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>,a);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>编译阶段：</strong></p>\n<p><img src=\"/posts/738721a6.htm/image-20220118145007919.png\"></p>\n<h3 id=\"2-gcov收集代码运行信息\"><a href=\"#2-gcov收集代码运行信息\" class=\"headerlink\" title=\"2. gcov收集代码运行信息\"></a>2. gcov收集代码运行信息</h3><ul>\n<li>运行<code>./test</code>产生<code>test.gcda</code>文件，其中包含了代码基本块和狐跳变次数统计信息</li>\n</ul>\n<p><img src=\"/posts/738721a6.htm/image-20220118145103922.png\"></p>\n<h4 id=\"3-生成gcov代码覆盖率报告\"><a href=\"#3-生成gcov代码覆盖率报告\" class=\"headerlink\" title=\"3. 生成gcov代码覆盖率报告\"></a>3. 生成gcov代码覆盖率报告</h4><ul>\n<li>再次运行<code>gcov test.c</code>产生的<code>test.c.gcov</code>中包含了代码覆盖率数据,其数据的来源为<code>test.gcda</code></li>\n</ul>\n<p><img src=\"/posts/738721a6.htm/image-20220118145303290.png\"></p>\n<h3 id=\"4-查看生成gcov代码覆盖率报告\"><a href=\"#4-查看生成gcov代码覆盖率报告\" class=\"headerlink\" title=\"4.查看生成gcov代码覆盖率报告\"></a>4.查看生成gcov代码覆盖率报告</h3><p><img src=\"/posts/738721a6.htm/image-20220118145514099.png\"></p>\n<p>可以看到以下结果：</p>\n<ul>\n<li>其中<code>#####</code>表示未运行的行</li>\n<li>每行前面的数字表示行运行的次数</li>\n<li>—代表不必执行</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c\">-:    <span class=\"hljs-number\">0</span>:Source:test.c<br>-:    <span class=\"hljs-number\">0</span>:Graph:test.gcno<br>-:    <span class=\"hljs-number\">0</span>:Data:test.gcda<br>-:    <span class=\"hljs-number\">0</span>:Runs:<span class=\"hljs-number\">1</span><br>-:    <span class=\"hljs-number\">0</span>:Programs:<span class=\"hljs-number\">1</span><br>-:    <span class=\"hljs-number\">1</span>:<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-number\">1</span>:    <span class=\"hljs-number\">2</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">-:    3:</span>&#123;<br><span class=\"hljs-number\">1</span>:    <span class=\"hljs-number\">4</span>:        <span class=\"hljs-keyword\">int</span> n=<span class=\"hljs-number\">4</span>;<br><span class=\"hljs-number\">1</span>:    <span class=\"hljs-number\">5</span>:        <span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-number\">5</span>:    <span class=\"hljs-number\">6</span>:        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>-:    <span class=\"hljs-number\">7</span>:        &#123;<br><span class=\"hljs-number\">4</span>:    <span class=\"hljs-number\">8</span>:           <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello World!\\n&quot;</span>);<br>-:    <span class=\"hljs-number\">9</span>:        &#125;<br><span class=\"hljs-number\">1</span>:   <span class=\"hljs-number\">10</span>:        <span class=\"hljs-keyword\">int</span> a =<span class=\"hljs-number\">20220118</span>;<br><span class=\"hljs-number\">1</span>:   <span class=\"hljs-number\">11</span>:        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>,a);<br><span class=\"hljs-number\">1</span>:   <span class=\"hljs-number\">12</span>:        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>-:   <span class=\"hljs-number\">13</span>:&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"配合lcov使用，图形化显示\"><a href=\"#配合lcov使用，图形化显示\" class=\"headerlink\" title=\"配合lcov使用，图形化显示\"></a>配合lcov使用，图形化显示</h2><p><strong>1.centos安装lcov:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">yum install lcov<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>2.运行lcov，生成相应信息</strong></p>\n<p><img src=\"/posts/738721a6.htm/image-20220118151526665.png\"></p>\n<p>运行结果：</p>\n<p><img src=\"/posts/738721a6.htm/image-20220118151553801.png\"></p>\n<p><strong>3.生成web可视化信息</strong></p>\n<p><img src=\"/posts/738721a6.htm/image-20220118151821325.png\"></p>\n<p>运行结果：</p>\n<p><img src=\"/posts/738721a6.htm/image-20220118151853477.png\"></p>\n<p><strong>4.打包result文件</strong></p>\n<p><img src=\"/posts/738721a6.htm/image-20220118152629648.png\"></p>\n<p><strong>5.从服务器下载到本地</strong></p>\n<p><img src=\"/posts/738721a6.htm/image-20220118152705023.png\"></p>\n<p><strong>6.查看web</strong></p>\n<p>​\t\t\t\t\t1）查看index.html：</p>\n<p><img src=\"/posts/738721a6.htm/image-20220118152825105.png\"></p>\n<p>​\t\t\t\t\t\t2）详细信息：</p>\n<p><img src=\"/posts/738721a6.htm/image-20220118152908078.png\"></p>\n<p>上述界面包含：</p>\n<ul>\n<li>函数覆盖率（执行率）</li>\n<li>代码行数覆盖率（执行率）</li>\n<li>语句执行次数</li>\n<li>源码级的详细信息</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/yanxiangyfg/article/details/80989680\">(6条消息) gcov代码覆盖率测试-原理和实践总结_yanxiangyfg的专栏-CSDN博客_gcov代码覆盖率</a>-gcov代码覆盖率测试-原理和实践总结</p>\n<p><a href=\"https://blog.csdn.net/u012247418/article/details/90137291\">(6条消息) 代码覆盖率测试工具：gcov和lcov的使用_ARM-Linux-CSDN博客</a>-代码覆盖率测试工具：gcov和lcov的使用</p>\n<p><a href=\"https://www.cnblogs.com/haoshine/p/5777735.html\">linux文件夹打包命令 - 小作一个 - 博客园 (cnblogs.com)</a>-Linux文件打包命令</p>\n<p><a href=\"https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=16561916178807634748&spm_id_from=333.337.0.0\">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>\n",
            "tags": [
                "性能分析工具"
            ]
        },
        {
            "id": "http://example.com/posts/a13e6ad5.html",
            "url": "http://example.com/posts/a13e6ad5.html",
            "title": "gprof、gprof2dot.py、dot使用方法简介",
            "date_published": "2022-01-09T08:33:37.000Z",
            "content_html": "<h1 id=\"gprof、gprof2dot-py、dot使用方法简介\"><a href=\"#gprof、gprof2dot-py、dot使用方法简介\" class=\"headerlink\" title=\"gprof、gprof2dot.py、dot使用方法简介\"></a>gprof、gprof2dot.py、dot使用方法简介</h1><h2 id=\"1-：gprof使用步骤如下，以SLIC为例：\"><a href=\"#1-：gprof使用步骤如下，以SLIC为例：\" class=\"headerlink\" title=\"(1)：gprof使用步骤如下，以SLIC为例：\"></a>(1)：gprof使用步骤如下，以SLIC为例：</h2><h3 id=\"1-在编译过程中添加-pg选项，命令如下：\"><a href=\"#1-在编译过程中添加-pg选项，命令如下：\" class=\"headerlink\" title=\"1 在编译过程中添加-pg选项，命令如下：\"></a>1 在编译过程中添加-pg选项，命令如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">gcc -pg SLIC.cpp -o SLIC<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-运行程序，运行结束之后会形成文件gmon-out，命令如下\"><a href=\"#2-运行程序，运行结束之后会形成文件gmon-out，命令如下\" class=\"headerlink\" title=\"2 运行程序，运行结束之后会形成文件gmon.out，命令如下:\"></a>2 运行程序，运行结束之后会形成文件gmon.out，命令如下:</h3><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-string\">./SLIC</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下：\"><a href=\"#3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下：\" class=\"headerlink\" title=\"3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下：\"></a>3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下：</h3><figure class=\"highlight vim\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs vim\">gprof ./SLIC &gt; <span class=\"hljs-keyword\">prof</span>.<span class=\"hljs-built_in\">log</span><br></code></pre></div></td></tr></table></figure>\n\n<p>分析prof.log就可以获得程序的调用关系、函数执行时间等信息。对gprof的分析方法见以下blog</p>\n<p><a href=\"http://blog.csdn.net/macky0668/article/details/6839517\">http://blog.csdn.net/macky0668/article/details/6839517</a></p>\n<h2 id=\"2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台\"><a href=\"#2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台\" class=\"headerlink\" title=\"(2)：配合gprof2dot.py与dot工具的使用(我是安装在了Win10平台)\"></a>(2)：配合<em>gprof2dot.py</em>与dot工具的使用(我是安装在了Win10平台)</h2><p>以上方法仍然存在一个问题就是分析结果不够直观，特别是函数的调用关系。因此为解决以上问题，可以配合<em>gprof2dot.py</em>与dot工具的使用。</p>\n<h3 id=\"1-安装gprof2dot-py与dot\"><a href=\"#1-安装gprof2dot-py与dot\" class=\"headerlink\" title=\"1.安装gprof2dot.py与dot\"></a>1.安装<em>gprof2dot.py</em>与dot</h3><p><a href=\"https://github.com/jrfonseca/gprof2dot\">GitHub - jrfonseca&#x2F;gprof2dot: Converts profiling output to a dot graph.</a></p>\n<h3 id=\"2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具\"><a href=\"#2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具\" class=\"headerlink\" title=\"2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具\"></a>2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具</h3><p><a href=\"https://graphviz.org/download/source/\">Source Code | Graphviz</a></p>\n<p>在使用上述工具前，还需要先产生prof.log文件，prof.log文件的产生方法见上文。</p>\n<h3 id=\"3-首先通过命令行进入你安装gprof2dot-py的根目录：\"><a href=\"#3-首先通过命令行进入你安装gprof2dot-py的根目录：\" class=\"headerlink\" title=\"3.首先通过命令行进入你安装gprof2dot.py的根目录：\"></a>3.首先通过命令行进入你安装gprof2dot.py的根目录：</h3><p><img src=\"/posts/a13e6ad5.htm/image-20220109165659998.png\"></p>\n<h3 id=\"4-通过以下命令即可得到函数调用图：\"><a href=\"#4-通过以下命令即可得到函数调用图：\" class=\"headerlink\" title=\"4.通过以下命令即可得到函数调用图：\"></a>4.通过以下命令即可得到函数调用图：</h3><p><img src=\"/posts/a13e6ad5.htm/image-20220109170212157.png\"></p>\n<h3 id=\"5-结果如下：\"><a href=\"#5-结果如下：\" class=\"headerlink\" title=\"5.结果如下：\"></a>5.结果如下：</h3><p><img src=\"/posts/a13e6ad5.htm/image-20220109170315471.png\"></p>\n<h2 id=\"3-：接上文补充几点可能无法产生gmon-out文件的情况：\"><a href=\"#3-：接上文补充几点可能无法产生gmon-out文件的情况：\" class=\"headerlink\" title=\"(3)：接上文补充几点可能无法产生gmon.out文件的情况：\"></a>(3)：接上文补充几点可能无法产生gmon.out文件的情况：</h2><p>  1.程序不是从main return或exit()退出，则可能不生成gmon.out。<br>  2.程序如果崩溃，可能不生成gmon.out。<br>  3.测试发现在虚拟机上运行，可能不生成gmon.out。<br>  4.程序忽略SIGPROF信号！一定不能捕获、忽略SIGPROF信号。man手册对SIGPROF的解释是：profiling timer expired. 如果忽略这个信号，gprof的输出则是：Each sample counts as 0.01 seconds. no time accumulated.<br>  5.如果程序运行时间非常短，则gprof可能无效</p>\n<h2 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h2><p><a href=\"https://blog.csdn.net/u012927281/article/details/51132064\">(4条消息) gprof、gprof2dot.py、dot使用方法简介_Andy.Wang的博客-CSDN博客_gprof2dot</a></p>\n",
            "tags": [
                "性能分析工具"
            ]
        }
    ]
}