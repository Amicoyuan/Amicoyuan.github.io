{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"gemm\" tag",
    "description": "",
    "home_page_url": "https://xingyuanjie.top",
    "items": [
        {
            "id": "https://xingyuanjie.top/2023/02/19/Matrix002/",
            "url": "https://xingyuanjie.top/2023/02/19/Matrix002/",
            "title": "矩阵乘法计算拆分展示",
            "date_published": "2023-02-19T09:04:23.000Z",
            "content_html": "<h2 id=\"矩阵乘法计算拆分展示\"><a href=\"#矩阵乘法计算拆分展示\" class=\"headerlink\" title=\"矩阵乘法计算拆分展示\"></a>矩阵乘法计算拆分展示</h2><h3 id=\"通用矩阵乘概念\"><a href=\"#通用矩阵乘概念\" class=\"headerlink\" title=\"通用矩阵乘概念\"></a>通用矩阵乘概念</h3><p><img src=\"/2023/02/19/Matrix002/image-20230219171156738.png\" alt=\"image-20230219171156738\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i行j列</span><br>        c[i][j] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>           C[i][j] += A[i][p] * B[p][j];\t\t<span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n\n\n<h3 id=\"计算拆分展示\"><a href=\"#计算拆分展示\" class=\"headerlink\" title=\"计算拆分展示\"></a>计算拆分展示</h3><p>图四将输出计算拆分为 <strong>1 × 4</strong> 的小块，即将 <strong>N</strong> 维度拆分为两部分。计算该块输出时，需要使用 <strong>A</strong> 矩阵的1行，和 <strong>B</strong> 矩阵的4列 。</p>\n<p><img src=\"/2023/02/19/Matrix002/image-20230219171904249.png\" alt=\"image-20230219171904249\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j +=<span class=\"hljs-number\">4</span>)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵j-j+3列</span><br>        c[i][j + <span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i][j + <span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i][j + <span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i][j + <span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>            <span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>           C[i][j + <span class=\"hljs-number\">0</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">0</span>];    <br>           C[i][j + <span class=\"hljs-number\">1</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">1</span>];<br>           C[i][j + <span class=\"hljs-number\">2</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">2</span>];<br>           C[i][j + <span class=\"hljs-number\">3</span>] += A[i][p] * B[p][j + <span class=\"hljs-number\">3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>最内侧计算使用的矩阵<strong>A</strong>的元素是一致的。因此可以将**A[i][p]**读取到寄存器中，从而实现4次数据复用。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> temp = A[i][p];<br></code></pre></div></td></tr></table></figure>\n\n<p>一般将最内侧循环称作计算核(micro kernel)</p>\n<p>类似地，我们可以继续拆分输出<strong>M</strong>维度，从而在内测循环中计算 <strong>4 × 4</strong> 输出，如图五。</p>\n<p><img src=\"/2023/02/19/Matrix002/image-20230219174355047.png\" alt=\"image-20230219174355047\"></p>\n<p>同样的，将计算核心展开，可以得到下面的伪代码。这里我们将 <strong>1 × 4</strong> 中展示过的N维度的计算简化表示。这种拆分可看成是<strong>4 × 1 × 4</strong>，这样A和B的访存均可复用四次。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i-i+3行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j +=<span class=\"hljs-number\">4</span>)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵第j-j+3列</span><br>        c[i + <span class=\"hljs-number\">0</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">1</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">2</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>            <span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>           C[i + <span class=\"hljs-number\">0</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];    <br>           C[i + <span class=\"hljs-number\">1</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">1</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">2</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">2</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">3</span>][p] * B[p][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>到目前为止。我们都是在输出的两个维度上展开，而整个计算还包含一个规约(Reduction)维度K。图六展示了在计算<strong>4 × 4</strong>输出时，将维度K拆分，从而每次最内侧循环计算出输出矩阵C的<strong>4&#x2F;K</strong>的部分和。</p>\n<p><img src=\"/2023/02/19/Matrix002/image-20230219180147184.png\" alt=\"image-20230219180147184\"></p>\n<p>下面展示的是这部分计算的展开伪代码，其中维度M和N已经被简写。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i-i+3行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j +=<span class=\"hljs-number\">4</span>)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵第j-j+3列</span><br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        c[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p+=<span class=\"hljs-number\">4</span>)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">0</span>] * B[p + <span class=\"hljs-number\">0</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];    <br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">1</span>] * B[p + <span class=\"hljs-number\">1</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">2</span>] * B[p + <span class=\"hljs-number\">2</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>           C[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>] += A[i + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>][p + <span class=\"hljs-number\">3</span>] * B[p + <span class=\"hljs-number\">3</span>][j + <span class=\"hljs-number\">0.</span><span class=\"hljs-number\">.3</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在对M和N展开式，我们可以分别复用B和A的数据；在对K展开时，其局部使用的C的内存是一致的，那么K迭代时可以将部分和累加在寄存器中——最内层循环整个迭代一次写到C的内存中。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://zhenhuaw.me/blog/2019/gemm-optimization.html\">通用矩阵乘（GEMM）优化算法 | 黎明灰烬 博客 (zhenhuaw.me)</a></p>\n",
            "tags": [
                "Matrix",
                "GEMM"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/06/matrix001/",
            "url": "https://xingyuanjie.top/2023/02/06/matrix001/",
            "title": "矩阵乘法最基础版本",
            "date_published": "2023-02-06T14:00:14.000Z",
            "content_html": "<h2 id=\"矩阵乘法最基础版本\"><a href=\"#矩阵乘法最基础版本\" class=\"headerlink\" title=\"矩阵乘法最基础版本\"></a>矩阵乘法最基础版本</h2><h3 id=\"数学原理示例\"><a href=\"#数学原理示例\" class=\"headerlink\" title=\"数学原理示例\"></a>数学原理示例</h3><p><img src=\"/2023/02/06/matrix001/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pYW5uaWFueGk=,size_16,color_FFFFFF,t_70.png\" alt=\"img\"></p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><p>用A的第i行分别和B的第j列的各个元素相乘求和，求得C的第i行j列的元素，这种算法中，B的访问是按列进行访问的，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//m是A矩阵的行,k是A矩阵的列,n是B矩阵的列</span><br><span class=\"hljs-keyword\">double</span> temp=<span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;\t\t\t\t<span class=\"hljs-comment\">//遍历C矩阵各行，其行数与A的行数相等 </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;\t\t\t<span class=\"hljs-comment\">//遍历C矩阵i行j列</span><br>        temp = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++)&#123;\t\t<span class=\"hljs-comment\">//用p循环累加和计算C[i][j] </span><br>            <span class=\"hljs-comment\">//计算区域</span><br>            temp += A[i][p] * B[p][j];\t\t<span class=\"hljs-comment\">//遍历A矩阵各行与B矩阵各列</span><br>        &#125;<br>        C[i][j] = temp;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">//结果C矩阵m行n列</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/niannianxi/article/details/104028215\">(64条消息) C语言实现矩阵的乘法_꧁年年曦꧂的博客-CSDN博客_c语言矩阵乘法</a></p>\n<p><a href=\"https://www.jb51.net/article/75750.htm\">C语言科学计算入门之矩阵乘法的相关计算_C 语言_脚本之家 (jb51.net)</a></p>\n",
            "tags": [
                "Matrix",
                "GEMM"
            ]
        }
    ]
}