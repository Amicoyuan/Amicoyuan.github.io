<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan • Posts by &#34;邻接矩阵&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sat, 23 Apr 2022 21:50:27 +0800</pubDate>
        <lastBuildDate>Sat, 23 Apr 2022 21:50:27 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>并查集</category>
        <category>Map</category>
        <category>Pair</category>
        <category>KMP</category>
        <category>线索二叉树</category>
        <category>Tree</category>
        <category>森林</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Numactl</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/23/Algorithm032/</guid>
            <title>L2-036 网红点打卡攻略 (25 分)</title>
            <link>http://example.com/2022/04/23/Algorithm032/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Graph</category>
            <category>邻接矩阵</category>
            <pubDate>Sat, 23 Apr 2022 21:50:27 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-036-网红点打卡攻略-25-分&#34;&gt;&lt;a href=&#34;#L2-036-网红点打卡攻略-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-036 网红点打卡攻略 (25 分)&#34;&gt;&lt;/a&gt;L2-036 网红点打卡攻略 (25 分)&lt;/h2&gt;&lt;p&gt;一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;首先第一行给出两个正整数：网红点的个数 &lt;em&gt;N&lt;/em&gt;（1&amp;lt;&lt;em&gt;N&lt;/em&gt;≤200）和网红点之间通路的条数 &lt;em&gt;M&lt;/em&gt;。随后 &lt;em&gt;M&lt;/em&gt; 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 &lt;em&gt;N&lt;/em&gt; 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再下一行给出一个正整数 &lt;em&gt;K&lt;/em&gt;，是待检验的攻略的数量。随后 &lt;em&gt;K&lt;/em&gt; 行，每行给出一条待检攻略，格式为：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;n&lt;/em&gt; &lt;em&gt;V&lt;/em&gt;1 &lt;em&gt;V&lt;/em&gt;2 ⋯ Vn&lt;/p&gt;
&lt;p&gt;其中 &lt;em&gt;n&lt;/em&gt;(≤200) 是攻略中的网红点数，&lt;em&gt;Vi&lt;/em&gt; 是路径上的网红点编号。这里假设你从家里出发，从 &lt;em&gt;V&lt;/em&gt;1 开始打卡，最后从 &lt;em&gt;Vn&lt;/em&gt; 回家。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在第一行输出满足要求的攻略的个数。&lt;/p&gt;
&lt;p&gt;在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。&lt;/p&gt;
&lt;p&gt;题目保证至少存在一个有效攻略，并且总路费不超过 109。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;6 13
0 5 2
6 2 2
6 0 1
3 4 2
1 5 2
2 5 1
3 1 1
4 1 2
1 6 1
6 3 2
1 2 1
4 5 3
2 0 2
7
6 5 1 4 3 6 2
6 5 2 1 6 3 4
8 6 2 1 6 3 4 5 2
3 2 1 5
6 6 1 3 4 5 2
7 6 2 1 3 4 5 2
6 5 2 1 4 3 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;3
5 11
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;样例说明：&#34;&gt;&lt;a href=&#34;#样例说明：&#34; class=&#34;headerlink&#34; title=&#34;样例说明：&#34;&gt;&lt;/a&gt;样例说明：&lt;/h3&gt;&lt;p&gt;第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。&lt;/p&gt;
&lt;p&gt;第 1 条攻略的总路费是：(0-&amp;gt;5) 2 + (5-&amp;gt;1) 2 + (1-&amp;gt;4) 2 + (4-&amp;gt;3) 2 + (3-&amp;gt;6) 2 + (6-&amp;gt;2) 2 + (2-&amp;gt;0) 2 &amp;#x3D; 14；&lt;/p&gt;
&lt;p&gt;第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &amp;#x3D; 11，是一条更省钱的攻略；&lt;/p&gt;
&lt;p&gt;第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &amp;#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。&lt;/p&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,m;
int g[205][205];
int minsize=INT_MAX;			//初始化为INT_MAX
int minid=0;
int main()
&amp;#123;
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    int cnt=0;
    memset(g,0,sizeof(g));
    for (int i = 0; i &amp;lt;m ; ++i) &amp;#123;
        int a,b,c;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
        g[a][b]=c;
        g[b][a]=c;
    &amp;#125;
    int time;
    cin&amp;gt;&amp;gt;time;
    for (int j = 0; j &amp;lt;time ; ++j) &amp;#123;
        int k;
        cin&amp;gt;&amp;gt;k;
        int roll[k+5];
        int has[k+5];
        memset(has,0,sizeof(has));
        roll[0]=roll[k+1]=0;					//起点和终点必定是家
        for (int i = 1; i &amp;lt;=k ; ++i) &amp;#123;
            cin&amp;gt;&amp;gt;roll[i];
            if(has[roll[i]]) has[0]=1;			//每个打卡点仅能打卡一次
            else has[roll[i]]=1;
        &amp;#125;
        int flag=1;
        int tmpsize=0;
        if(k!=n||has[0]) continue;
        for (int l = 1; l &amp;lt;=k+1 ; ++l) &amp;#123;
            if(g[roll[l-1]][roll[l]]==0)
            &amp;#123;
                flag=0;
                break;
            &amp;#125;
            tmpsize+=g[roll[l-1]][roll[l]];
        &amp;#125;
        if(flag==1)
        &amp;#123;
            if(tmpsize&amp;lt;minsize)&amp;#123;
                minsize=tmpsize;
                minid=j+1;

            &amp;#125;
            cnt++;
        &amp;#125;
    &amp;#125;
    cout&amp;lt;&amp;lt;cnt&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;minid&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;minsize&amp;lt;&amp;lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059&#34;&gt;题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/16/Algorithm028/</guid>
            <title>L2-010 排座位 (25 分)</title>
            <link>http://example.com/2022/04/16/Algorithm028/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Graph</category>
            <category>邻接矩阵</category>
            <category>并查集</category>
            <pubDate>Sat, 16 Apr 2022 14:57:46 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-010-排座位-25-分&#34;&gt;&lt;a href=&#34;#L2-010-排座位-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-010 排座位 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-010 排座位 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出3个正整数：&lt;code&gt;N&lt;/code&gt;（≤100），即前来参宴的宾客总人数，则这些人从1到&lt;code&gt;N&lt;/code&gt;编号；&lt;code&gt;M&lt;/code&gt;为已知两两宾客之间的关系数；&lt;code&gt;K&lt;/code&gt;为查询的条数。随后&lt;code&gt;M&lt;/code&gt;行，每行给出一对宾客之间的关系，格式为：&lt;code&gt;宾客1 宾客2 关系&lt;/code&gt;，其中&lt;code&gt;关系&lt;/code&gt;为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后&lt;code&gt;K&lt;/code&gt;行，每行给出一对需要查询的宾客编号。&lt;/p&gt;
&lt;p&gt;这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出&lt;code&gt;No problem&lt;/code&gt;；如果他们之间并不是朋友，但也不敌对，则输出&lt;code&gt;OK&lt;/code&gt;；如果他们之间有敌对，然而也有共同的朋友，则输出&lt;code&gt;OK but...&lt;/code&gt;；如果他们之间只有敌对关系，则输出&lt;code&gt;No way&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;7 8 4
5 6 1
2 7 -1
1 3 1
3 4 1
6 7 -1
1 2 1
1 4 1
2 3 -1
3 4
5 7
2 3
7 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;No problem
OK
OK but...
No way
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接矩阵 + 并查集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并查集具体链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/01/04/Algorithm004/&#34;&gt;并查集 - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int pre[100];				//父节点
int deep[100];				//深度
int g[101][101];			//邻接矩阵建图
void init(int n)&amp;#123;
    for (int i = 0; i &amp;lt;n ; ++i) &amp;#123;
        pre[i]=i;
        deep[i]=0;
    &amp;#125;
&amp;#125;
int find(int x)&amp;#123;
    if(pre[x]==x)&amp;#123;
        return x;
    &amp;#125; else&amp;#123;
        return pre[x]=find(pre[x]);
    &amp;#125;
&amp;#125;
void unit(int x,int y)&amp;#123;
    x=find(x);
    y=find(y);
    if(x==y) return;
    if(deep[x]&amp;lt;deep[y])&amp;#123;
        pre[x]=y;
    &amp;#125;else&amp;#123;
        pre[y]=x;
        if(deep[x]==deep[y])&amp;#123;
            deep[x]++;
        &amp;#125;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    int n,m,k;
    init(105);
    memset(g,0,sizeof(g));
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;k;
    for (int i = 0; i &amp;lt;m ; ++i) &amp;#123;
        int a,b,c;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
        g[a][b]=g[b][a]=c;
        if(c==1) unit(a,b);					//如果是朋友则合并
    &amp;#125;
    for (int j = 0; j &amp;lt;k ; ++j) &amp;#123;
        int a,b;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
        if(g[a][b]==1&amp;amp;&amp;amp;g[b][a]==1) cout&amp;lt;&amp;lt;&amp;quot;No problem&amp;quot;&amp;lt;&amp;lt;endl;
        else if(g[a][b]==0&amp;amp;&amp;amp;g[b][a]==0) cout&amp;lt;&amp;lt;&amp;quot;OK&amp;quot;&amp;lt;&amp;lt;endl;			//两人毫无关系
        else if(g[a][b]==-1&amp;amp;&amp;amp;g[b][a]==-1&amp;amp;&amp;amp;find(a)==find(b)) cout&amp;lt;&amp;lt;&amp;quot;OK but...&amp;quot;&amp;lt;&amp;lt;endl;	//敌对且有共同朋友
        else if(g[a][b]==-1&amp;amp;&amp;amp;g[b][a]==-1) cout&amp;lt;&amp;lt;&amp;quot;No way&amp;quot;&amp;lt;&amp;lt;endl;		//仅敌对
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_45260385/article/details/109752008&#34;&gt;(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680&#34;&gt;题目详情 - L2-010 排座位 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/15/Algorithm025/</guid>
            <title>L2-013 红色警报 (25 分)</title>
            <link>http://example.com/2022/04/15/Algorithm025/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Graph</category>
            <category>邻接矩阵</category>
            <category>DFS</category>
            <pubDate>Fri, 15 Apr 2022 21:09:30 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-013-红色警报-25-分&#34;&gt;&lt;a href=&#34;#L2-013-红色警报-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-013 红色警报 (25 分)&#34;&gt;&lt;/a&gt;L2-013 红色警报 (25 分)&lt;/h2&gt;&lt;p&gt;战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出两个整数&lt;code&gt;N&lt;/code&gt;（0 &amp;lt; &lt;code&gt;N&lt;/code&gt; ≤ 500）和&lt;code&gt;M&lt;/code&gt;（≤ 5000），分别为城市个数（于是默认城市从0到&lt;code&gt;N&lt;/code&gt;-1编号）和连接两城市的通路条数。随后&lt;code&gt;M&lt;/code&gt;行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数&lt;code&gt;K&lt;/code&gt;和随后的&lt;code&gt;K&lt;/code&gt;个被攻占的城市的编号。&lt;/p&gt;
&lt;p&gt;注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个被攻占的城市，如果它会改变整个国家的连通性，则输出&lt;code&gt;Red Alert: City k is lost!&lt;/code&gt;，其中&lt;code&gt;k&lt;/code&gt;是该城市的编号；否则只输出&lt;code&gt;City k is lost.&lt;/code&gt;即可。如果该国失去了最后一个城市，则增加一行输出&lt;code&gt;Game Over.&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;5 4
0 1
1 3
3 0
0 4
5
1 2 0 4 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;City 1 is lost.
City 2 is lost.
Red Alert: City 0 is lost!
City 4 is lost.
City 3 is lost.
Game Over.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接矩阵建图 + DFS统计连通分量数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无向图中的极大连通子图称为连通分量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极大连通子图必须连通，且包含尽可能多的顶点和边&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,m;
int g[505][505];						//邻接矩阵存图
int visit[505];							//标记访问数组
int lost[505];							//记录被攻占的城市
void dfs(int node)&amp;#123;						//正常的DFS
    visit[node]=1;
    for(int i=0;i&amp;lt;n;i++)
    &amp;#123;
        if(visit[i]==0&amp;amp;&amp;amp;g[node][i]==1)
        &amp;#123;
            dfs(i);
        &amp;#125;
    &amp;#125;
&amp;#125;
int dfstrave()&amp;#123;
    int cnt=0;
    memset(visit,0,sizeof(visit));			//初始化访问数组
    for(int i=0;i&amp;lt;n;i++)&amp;#123;
        if(lost[i]==1) visit[i]=1;			//如果该城市被攻占，则标记他为以访问
    &amp;#125;
    for(int i=0;i&amp;lt;n;i++)&amp;#123;
        if(visit[i]==0)&amp;#123;
            dfs(i);
            cnt++;      					//统计连通分量数
        &amp;#125;
    &amp;#125;
    return cnt;
&amp;#125;
int main()
&amp;#123;
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    memset(lost,0,sizeof(lost));			//初始化
    memset(g,0,sizeof(g));					//初始化
    for(int i=0;i&amp;lt;m;i++)&amp;#123;
        int a,b;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
        g[a][b]=g[b][a]=1;					//存储无向图
    &amp;#125;
    int cnt=dfstrave();						//获得初始的连通分量数
    int k;
    cin&amp;gt;&amp;gt;k;
    for(int w=0;w&amp;lt;k;w++)&amp;#123;
        int city;
        cin&amp;gt;&amp;gt;city;
        lost[city]=1;						//记录该城市被攻占
        for(int i=0;i&amp;lt;n;i++)&amp;#123;
            if(g[city][i]==1)&amp;#123;				
                g[city][i]=g[i][city]=0;	//标记和他相连的城市不再相连
            &amp;#125;
        &amp;#125;
        int tempcnt=dfstrave();				//当前的连通分量
        if(tempcnt&amp;lt;=cnt)&amp;#123;					//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变
            printf(&amp;quot;City %d is lost.\n&amp;quot;, city);
        &amp;#125;else&amp;#123;								//否则，连通性被改变了
            printf(&amp;quot;Red Alert: City %d is lost!\n&amp;quot;, city);
        &amp;#125;
        cnt=tempcnt;						//更新连通分量
        if(w==n-1)&amp;#123;							//城市已经被攻占完毕
            printf(&amp;quot;Game Over.\n&amp;quot;);
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208&#34;&gt;题目详情 - L2-013 红色警报 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
