{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"set\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/04/23/Algorithm030/",
            "url": "http://example.com/2022/04/23/Algorithm030/",
            "title": "L2-005 集合相似度 (25 分)",
            "date_published": "2022-04-23T13:39:53.000Z",
            "content_html": "<h2 id=\"L2-005-集合相似度-25-分\"><a href=\"#L2-005-集合相似度-25-分\" class=\"headerlink\" title=\"L2-005 集合相似度 (25 分)\"></a>L2-005 集合相似度 (25 分)</h2><p>给定两个整数集合，它们的相似度定义为：Nc&#x2F;Nt×100%。其中Nc是两个集合都有的不相等整数的个数，Nt是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入第一行给出一个正整数<em>N</em>（≤50），是集合的个数。随后<em>N</em>行，每行对应一个集合。每个集合首先给出一个正整数<em>M</em>（≤104），是集合中元素的个数；然后跟<em>M</em>个[0,109]区间内的整数。</p>\n<p>之后一行给出一个正整数<em>K</em>（≤2000），随后<em>K</em>行，每行对应一对需要计算相似度的集合的编号（集合从1到<em>N</em>编号）。数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">3\n3 99 87 101\n4 87 101 5 87\n7 99 101 18 5 135 18 99\n2\n1 2\n1 3\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">50.00%\n33.33%\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>双set模拟</strong></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nint main()\n&#123;\n    int n;\n    set<int> s[55];\n    cin>>n;\n    for (int i = 0; i <n ; ++i) &#123;\n        int time;\n        cin>>time;\n        for (int j = 0; j <time ; ++j) &#123;\n            int num;\n            cin>>num;\n            s[i].insert(num);\n        &#125;\n    &#125;\n    int find;\n    cin>>find;\n    for (int l = 0; l <find ; ++l) &#123;\n        int a,b;\n        cin>>a>>b;\n        int sum=0;\n        set<int>::iterator it;\t\t\t\t\t\t\t\t//迭代器\n        int cnt=0;\n        for (it=s[a-1].begin(); it!=s[a-1].end() ; it++) &#123;\n            if(s[b-1].find(*it)!=s[b-1].end())&#123;\t\t\t\t//找到了\n                cnt++;\t\t\t\t\t\t\t\t\t\t//Nc\n            &#125;\n        &#125;\n        sum=s[a-1].size()+s[b-1].size()-cnt;\t\t\t\t//Nt=两个集合的总个数-相同个数\n        double ans=double(double(cnt)/double(sum))*100.0;\n        printf(\"%.2lf%\\n\",ans);\n\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805070149828608\">题目详情 - L2-005 集合相似度 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "C++",
                "Set",
                "团体程序设计天梯赛",
                "模拟"
            ]
        },
        {
            "id": "http://example.com/2022/04/12/Algorithm018/",
            "url": "http://example.com/2022/04/12/Algorithm018/",
            "title": "L2-023 图着色问题 (25 分)",
            "date_published": "2022-04-12T10:59:52.000Z",
            "content_html": "<h2 id=\"L2-023-图着色问题-25-分\"><a href=\"#L2-023-图着色问题-25-分\" class=\"headerlink\" title=\"L2-023 图着色问题 (25 分)\"></a>L2-023 图着色问题 (25 分)</h2><p>图着色问题是一个著名的NP完全问题。给定无向图<em>G</em>&#x3D;(<em>V</em>,<em>E</em>)，问可否用<em>K</em>种颜色为<em>V</em>中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？</p>\n<p>但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出3个整数<em>V</em>（0&lt;<em>V</em>≤500）、<em>E</em>（≥0）和<em>K</em>（0&lt;<em>K</em>≤<em>V</em>），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到<em>V</em>编号。随后<em>E</em>行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数<em>N</em>（≤20），是待检查的颜色分配方案的个数。随后<em>N</em>行，每行顺次给出<em>V</em>个顶点的颜色（第<em>i</em>个数字表示第<em>i</em>个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每种颜色分配方案，如果是图着色问题的一个解则输出<code>Yes</code>，否则输出<code>No</code>，每句占一行。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><img src=\"/2022/04/12/Algorithm018/graph.png\" alt=\"graph\" style=\"zoom: 67%;\">\n\n<pre class=\" language-in\"><code class=\"language-in\">6 8 3\n2 1\n1 3\n4 6\n2 5\n2 4\n5 4\n5 6\n3 6\n4\n1 2 3 3 1 2\n4 5 6 6 4 5\n1 2 3 4 5 6\n2 3 4 2 3 4\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">Yes\nYes\nNo\nNo\n</code></pre>\n<h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><p><strong>Set + 邻接表</strong></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nint main()\n&#123;\n    int v,e,k;\n    cin>>v>>e>>k;\n    vector<int> g[505];\t\t\t//邻接表\n    int color[505];\t\t\t\t//记录颜色\n    for (int i = 0; i <e ; ++i) &#123;       //建立邻接表\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    &#125;\n    int time;\n    cin>>time;\n    for (int j = 0; j <time ; ++j) &#123;\n        int flag=1;\n        set<int> s;\t\t\t\t\t//用来统计颜色总数\n        s.clear();\n        for (int i = 1; i <=v; ++i) &#123;\n            int num;\n            cin>>num;\n            color[i]=num;\n            s.insert(num);\n        &#125;\n        if(s.size()!=k)&#123;\t\t\t//如果颜色数不等于k即非法\n            cout<<\"No\"<<endl;\n            continue;\n        &#125;\n        for (int l = 1; l <=v ; ++l) &#123;\t\t\t\t\t\t//遍历邻接表\n            for (int i = 0; i <g[l].size(); ++i) &#123;\n                if(color[l]==color[g[l][i]])&#123;\t\t\t\t//如果相邻结点颜色一样则为假\n                    flag=0;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        if(flag==1)&#123;\n            cout<<\"Yes\"<<endl;\n        &#125;else&#123;\n            cout<<\"No\"<<endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805057298481152\">题目详情 - L2-023 图着色问题 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "Set",
                "团体程序设计天梯赛",
                "Graph",
                "邻接表",
                "Vector"
            ]
        },
        {
            "id": "http://example.com/2022/04/11/Algorithm016/",
            "url": "http://example.com/2022/04/11/Algorithm016/",
            "title": "L2-021 点赞狂魔 (25 分)",
            "date_published": "2022-04-11T11:21:06.000Z",
            "content_html": "<h1 id=\"L2-021-点赞狂魔-25-分\"><a href=\"#L2-021-点赞狂魔-25-分\" class=\"headerlink\" title=\"L2-021 点赞狂魔 (25 分)\"></a>L2-021 点赞狂魔 (25 分)</h1><p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤100），是待统计的用户数。随后<em>N</em>行，每行列出一位用户的点赞标签。格式为“<code>Name</code> <em>K</em> <em>F</em>1⋯<em>F**K</em>”，其中<code>Name</code>是不超过8个英文小写字母的非空用户名，1≤<em>K</em>≤1000，<em>F**i</em>（<em>i</em>&#x3D;1,⋯,<em>K</em>）是特性标签的编号，我们将所有特性标签从 1 到 107 编号。数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用<code>-</code>补齐缺失，例如<code>mike jenny -</code>就表示只有2人。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">5\nbob 11 101 102 103 104 105 106 107 108 108 107 107\npeter 8 1 2 3 4 3 2 5 1\nchris 12 1 2 3 4 5 6 7 8 9 1 2 3\njohn 10 8 7 6 5 4 3 2 1 7 5\njack 9 6 7 8 9 10 11 12 13 14\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">jack chris john\n</code></pre>\n<h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><p><strong>结构体数组 + sort排序</strong></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nstruct person&#123;\n    char name[10];\n    set<int> s;\t\t\t\t//set容器中的每个元素值唯一\n    int all=0;\t\t\t\t//记录点赞次数\n&#125;;\nbool cmp(person a,person b)&#123;\n    if(a.s.size()==b.s.size()) return a.all<b.all;\t\t\t//如果有并列，则输出标签出现次数平均值最小的那个\n    return a.s.size()>b.s.size();\t\t\t\t\t\t\t//点赞的不同标签的数量最多的\n&#125;\nint main()\n&#123;\n    int n;\n    cin>>n;\n    person p[n];\n    for (int i = 0; i <n ; ++i) &#123;\n        cin>>p[i].name;\n        int time;\n        cin>>time;\n        p[i].all=time;\t\t\t\t\t\t\t\t\t\t//记录点赞次数\n        for (int j = 0; j < time; ++j) &#123;\n            int tmp;\n            cin>>tmp;\n            p[i].s.insert(tmp);\t\t\t\t\t\t\t\t//插入set容器\n        &#125;\n    &#125;\n    sort(p,p+n,cmp);\t\t\t\t\t\t\t\t\t\t//排序\n    if(n>=3)&#123;\n        cout<<p[0].name<<\" \"<<p[1].name<<\" \"<<p[2].name<<endl;\n    &#125; else if(n==2)&#123;\n        cout<<p[0].name<<\" \"<<p[1].name<<\" \"<<\"-\"<<endl;\n    &#125;else if(n==1)&#123;\n        cout<<p[0].name<<\" \"<<\"-\"<<\" \"<<\"-\"<<endl;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805058485469184\">题目详情 - L2-021 点赞狂魔 (25 分) (pintia.cn)</a></p>\n<p><a href=\"https://blog.csdn.net/changjiale110/article/details/79108447\">(19条消息) STL中的set使用方法详细！！！！_知足–常乐的博客-CSDN博客_set stl</a></p>\n",
            "tags": [
                "STL",
                "C++",
                "Set",
                "团体程序设计天梯赛",
                "Sort"
            ]
        }
    ]
}