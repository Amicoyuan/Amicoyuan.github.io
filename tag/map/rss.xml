<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan • Posts by &#34;map&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sat, 23 Apr 2022 21:44:47 +0800</pubDate>
        <lastBuildDate>Sat, 23 Apr 2022 21:44:47 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>并查集</category>
        <category>Map</category>
        <category>Pair</category>
        <category>线索二叉树</category>
        <category>KMP</category>
        <category>Tree</category>
        <category>森林</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Numactl</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/23/Algorithm031/</guid>
            <title>L2-039 清点代码库 (25 分)</title>
            <link>http://example.com/2022/04/23/Algorithm031/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Sort</category>
            <category>Vector</category>
            <category>Map</category>
            <category>Pair</category>
            <pubDate>Sat, 23 Apr 2022 21:44:47 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-039-清点代码库-25-分&#34;&gt;&lt;a href=&#34;#L2-039-清点代码库-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-039 清点代码库 (25 分)&#34;&gt;&lt;/a&gt;L2-039 清点代码库 (25 分)&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg&#34; alt=&#34;code.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”&lt;/p&gt;
&lt;p&gt;这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 &lt;strong&gt;int&lt;/strong&gt; 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行中给出 2 个正整数，依次为 &lt;em&gt;N&lt;/em&gt;（≤104）和 &lt;em&gt;M&lt;/em&gt;（≤102），对应功能模块的个数和系列测试输入的个数。&lt;/p&gt;
&lt;p&gt;随后 &lt;em&gt;N&lt;/em&gt; 行，每行给出一个功能模块的 &lt;em&gt;M&lt;/em&gt; 个对应输出，数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先在第一行输出不同功能的个数 &lt;em&gt;K&lt;/em&gt;。随后 &lt;em&gt;K&lt;/em&gt; 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。&lt;/p&gt;
&lt;p&gt;注：所谓数列 { &lt;em&gt;A&lt;/em&gt;1, …, &lt;em&gt;A&lt;/em&gt;M } 比 { &lt;em&gt;B&lt;/em&gt;1, …, &lt;em&gt;B&lt;/em&gt;M } 大，是指存在 1≤i&amp;lt;*M*，使得 *A*1&amp;#x3D;*B*1，…，*Ai*&amp;#x3D;*Bi* 成立，且 *Ai*+1&amp;gt;&lt;em&gt;B&lt;/em&gt;+1。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;7 3
35 28 74
-1 -1 22
28 74 35
-1 -1 22
11 66 0
35 28 74
35 28 74
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;4
3 35 28 74
2 -1 -1 22
1 11 66 0
1 28 74 35
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;利用map的映射关系&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;vector&lt;int&gt;,int&gt; mp;   //key，value
vector&lt;int&gt; tmp;
int n,m;
bool cmp(pair&lt;vector&lt;int&gt;,int&gt; a,pair&lt;vector&lt;int&gt;,int&gt; b)
&amp;#123;
    if(a.second==b.second)
    &amp;#123;
        return a.first&lt;b.first;
    &amp;#125;
    return a.second&gt;b.second;

&amp;#125;
int main()
&amp;#123;
    cin&gt;&gt;n&gt;&gt;m;
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        for (int j = 0; j &lt; m; ++j) &amp;#123;
            int num;
            cin&gt;&gt;num;
            tmp.push_back(num);
        &amp;#125;
        mp[tmp]++;
        tmp.clear();
    &amp;#125;
    vector&lt;pair&lt;vector&lt;int&gt;,int&gt;&gt; v(mp.begin(),mp.end());		//把map类型转化成vector
    cout&lt;&lt;v.size()&lt;&lt;endl;
    sort(v.begin(),v.end(),cmp);								//sort排序，注意终点和起点
    for (int k = 0; k &lt;v.size() ; ++k) &amp;#123;
        cout&lt;&lt;v[k].second&lt;&lt;&#34; &#34;;
        for (int i = 0; i &lt;m ; ++i) &amp;#123;
            if(i!=m-1)&amp;#123;
                cout&lt;&lt;v[k].first[i]&lt;&lt;&#34; &#34;;
            &amp;#125; else&amp;#123;
                cout&lt;&lt;v[k].first[i]&lt;&lt;endl;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362&#34;&gt;题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/16/Algorithm029/</guid>
            <title>STL中map的使用</title>
            <link>http://example.com/2022/04/16/Algorithm029/</link>
            <category>STL</category>
            <category>Map</category>
            <pubDate>Sat, 16 Apr 2022 16:26:03 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;STL中map的使用&#34;&gt;&lt;a href=&#34;#STL中map的使用&#34; class=&#34;headerlink&#34; title=&#34;STL中map的使用&#34;&gt;&lt;/a&gt;STL中map的使用&lt;/h2&gt;&lt;h3 id=&#34;简介&#34;&gt;&lt;a href=&#34;#简介&#34; class=&#34;headerlink&#34; title=&#34;简介&#34;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;map 是 STL 的一个关联容器，它提供一对一的数据处理能力。&lt;/p&gt;
&lt;p&gt;map 对象是&lt;strong&gt;模板类&lt;/strong&gt;，需要&lt;strong&gt;关键字&lt;/strong&gt;和&lt;strong&gt;存储对象&lt;/strong&gt;两个模板参数：其中第一个参数称为关键字，每个关键字只能在 map 中出现一次；第二个参数称为该关键字的值。可以将关键字和存储对象理解为“{键，值}对”。&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;map&lt;int,string&gt; mp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;map的数据插入操作&#34;&gt;&lt;a href=&#34;#map的数据插入操作&#34; class=&#34;headerlink&#34; title=&#34;map的数据插入操作&#34;&gt;&lt;/a&gt;map的数据插入操作&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;//使用insert函数插入pair数据
mp.insert(pair&lt;int,string&gt;(3,&#34;xingyuanjie&#34;));
//使用数组方式插入数据
mp[2]=&#34;wangzhouyang&#34;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：上面的两种方法是有区别的，用 insert 函数插入数据，涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能实现数据插入的；但是数组方式能够插入数据，插入的数据会覆盖该关键字之前对应的值。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;map中数据的遍历&#34;&gt;&lt;a href=&#34;#map中数据的遍历&#34; class=&#34;headerlink&#34; title=&#34;map中数据的遍历&#34;&gt;&lt;/a&gt;map中数据的遍历&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;map&lt;int,string&gt;::iterator it;					//迭代器
for (it=mp.begin();it!=mp.end();it++) &amp;#123;
    cout&lt;&lt;it-&gt;first&lt;&lt;&#34; &#34;&lt;&lt;it-&gt;second&lt;&lt;endl;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;map中数据的查找&#34;&gt;&lt;a href=&#34;#map中数据的查找&#34; class=&#34;headerlink&#34; title=&#34;map中数据的查找&#34;&gt;&lt;/a&gt;map中数据的查找&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;map&lt;int,string&gt;::iterator it;					//迭代器
it=mp.find(1);
if(it!=mp.end())&amp;#123;
        cout &lt;&lt; &#34;Find it, the relative value is: &#34; &lt;&lt; it-&gt;second &lt;&lt; endl;
&amp;#125;
else&amp;#123;
           cout &lt;&lt; &#34;Can not find the relative value.&#34; &lt;&lt; endl;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;map中数据的删除&#34;&gt;&lt;a href=&#34;#map中数据的删除&#34; class=&#34;headerlink&#34; title=&#34;map中数据的删除&#34;&gt;&lt;/a&gt;map中数据的删除&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;map&lt;int,string&gt;::iterator it;					//迭代器
it = mp.find(2);
mp.erase(it);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;map中数据的排序&#34;&gt;&lt;a href=&#34;#map中数据的排序&#34; class=&#34;headerlink&#34; title=&#34;map中数据的排序&#34;&gt;&lt;/a&gt;map中数据的排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;map 中的所有元素都会根据元素的键值，自动进行升序排序。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;完整操作&#34;&gt;&lt;a href=&#34;#完整操作&#34; class=&#34;headerlink&#34; title=&#34;完整操作&#34;&gt;&lt;/a&gt;完整操作&lt;/h3&gt;&lt;h4 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h4&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;int,string&gt; mp;
int main()
&amp;#123;
    //使用insert函数插入pair数据
    mp.insert(pair&lt;int,string&gt;(3,&#34;xingyuanjie&#34;));
    mp.insert(pair&lt;int,string&gt;(1,&#34;shicheng&#34;));
    mp.insert(pair&lt;int,string&gt;(4,&#34;tanghaipeng&#34;));
    mp.insert(pair&lt;int,string&gt;(6,&#34;zhouyuhao&#34;));
    mp.insert(pair&lt;int,string&gt;(5,&#34;heqichuan&#34;));
    //使用数组方式插入数据
    mp[2]=&#34;wangzhouyang&#34;;
    //map的遍历
    map&lt;int,string&gt;::iterator it;
    for (it=mp.begin();it!=mp.end();it++) &amp;#123;
        cout&lt;&lt;it-&gt;first&lt;&lt;&#34; &#34;&lt;&lt;it-&gt;second&lt;&lt;endl;
    &amp;#125;
    //查找操作
    it=mp.find(1);
    if(it!=mp.end())&amp;#123;
        cout &lt;&lt; &#34;Find it, the relative value is: &#34; &lt;&lt; it-&gt;second &lt;&lt; endl;
    &amp;#125;
    else &amp;#123;
        cout &lt;&lt; &#34;Can not find the relative value.&#34; &lt;&lt; endl;
    &amp;#125;
    //删除操作
    it = mp.find(2);
    mp.erase(it);
    for (it=mp.begin();it!=mp.end();it++) &amp;#123;
        cout&lt;&lt;it-&gt;first&lt;&lt;&#34; &#34;&lt;&lt;it-&gt;second&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;程序输出：&#34;&gt;&lt;a href=&#34;#程序输出：&#34; class=&#34;headerlink&#34; title=&#34;程序输出：&#34;&gt;&lt;/a&gt;程序输出：&lt;/h4&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;1 shicheng
2 wangzhouyang
3 xingyuanjie
4 tanghaipeng
5 heqichuan
6 zhouyuhao
Find it, the relative value is: shicheng
1 shicheng
3 xingyuanjie
4 tanghaipeng
5 heqichuan
6 zhouyuhao
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/liitdar/article/details/80009712&#34;&gt;(20条消息) STL中map介绍_liitdar的博客-CSDN博客_stlmap&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
