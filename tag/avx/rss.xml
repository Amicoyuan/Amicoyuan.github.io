<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan • Posts by &#34;avx&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sun, 12 Jun 2022 15:11:29 +0800</pubDate>
        <lastBuildDate>Sun, 12 Jun 2022 15:11:29 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>并查集</category>
        <category>Map</category>
        <category>Pair</category>
        <category>KMP</category>
        <category>线索二叉树</category>
        <category>Tree</category>
        <category>森林</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Numactl</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
            <title>AVX向量化学习(二)-内存对齐的应用</title>
            <link>http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/</link>
            <category>AVX</category>
            <pubDate>Sun, 12 Jun 2022 15:11:29 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;AVX指令集的简单操作-内存对齐版&#34;&gt;&lt;a href=&#34;#AVX指令集的简单操作-内存对齐版&#34; class=&#34;headerlink&#34; title=&#34;AVX指令集的简单操作(内存对齐版)&#34;&gt;&lt;/a&gt;AVX指令集的简单操作(内存对齐版)&lt;/h1&gt;&lt;p&gt;使用AVX指令集进行2个double型的数组相加操作&lt;/p&gt;
&lt;h2 id=&#34;常用的内存对齐函数&#34;&gt;&lt;a href=&#34;#常用的内存对齐函数&#34; class=&#34;headerlink&#34; title=&#34;常用的内存对齐函数&#34;&gt;&lt;/a&gt;常用的内存对齐函数&lt;/h2&gt;&lt;p&gt;因为AVX中要求mem__addr必须在32字节边界上对齐，否则可能会产生通用保护异常。  &lt;/p&gt;
&lt;h3 id=&#34;1&#34;&gt;&lt;a href=&#34;#1&#34; class=&#34;headerlink&#34; title=&#34;1.&#34;&gt;&lt;/a&gt;1.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;double*	a =(double*)memalign(32,9*sizeof(double));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2&#34;&gt;&lt;a href=&#34;#2&#34; class=&#34;headerlink&#34; title=&#34;2.&#34;&gt;&lt;/a&gt;2.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;double*	a =(double*)_mm_malloc(9*sizeof(double),32);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3&#34;&gt;&lt;a href=&#34;#3&#34; class=&#34;headerlink&#34; title=&#34;3.&#34;&gt;&lt;/a&gt;3.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;double*	a =(double*)aligned_alloc(32,9*sizeof(double));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4&#34;&gt;&lt;a href=&#34;#4&#34; class=&#34;headerlink&#34; title=&#34;4.&#34;&gt;&lt;/a&gt;4.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__attribute__ ((aligned(32)))double a[9]  =&amp;#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用到的AVX函数介绍&#34;&gt;&lt;a href=&#34;#使用到的AVX函数介绍&#34; class=&#34;headerlink&#34; title=&#34;使用到的AVX函数介绍&#34;&gt;&lt;/a&gt;使用到的AVX函数介绍&lt;/h2&gt;&lt;h3 id=&#34;1-1&#34;&gt;&lt;a href=&#34;#1-1&#34; class=&#34;headerlink&#34; title=&#34;1.&#34;&gt;&lt;/a&gt;1.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256d _mm256_load_pd (double const * mem_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-1&#34;&gt;&lt;a href=&#34;#2-1&#34; class=&#34;headerlink&#34; title=&#34;2.&#34;&gt;&lt;/a&gt;2.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256 _mm256_add_ps (__m256 a, __m256 b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FOR j := 0 to 7
    i := j*32
    dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-stream的作用：绕过缓存直接写入内存&#34;&gt;&lt;a href=&#34;#3-stream的作用：绕过缓存直接写入内存&#34; class=&#34;headerlink&#34; title=&#34;3.stream的作用：绕过缓存直接写入内存&#34;&gt;&lt;/a&gt;3.stream的作用：绕过缓存直接写入内存&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void _mm256_stream_pd (double * mem_addr, __m256d a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;MEM[mem_addr+255:mem_addr] := a[255:0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;样例程序举例：&#34;&gt;&lt;a href=&#34;#样例程序举例：&#34; class=&#34;headerlink&#34; title=&#34;样例程序举例：&#34;&gt;&lt;/a&gt;样例程序举例：&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;malloc.h&amp;gt;
#include &amp;lt;immintrin.h&amp;gt;
int main()
&amp;#123;
    double*	a =(double*)memalign(32,9*sizeof(double));
    double*	b =(double*)memalign(32,4*sizeof(double));
    double af[9]=&amp;#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&amp;#125; ;
    double bf[9]=&amp;#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&amp;#125;;
    double*	c =(double*)memalign(32,4*sizeof(double));
    for(int i =0;i&amp;lt;9;i++)
    &amp;#123;
        a[i]=af[i];
        b[i]=bf[i];
    &amp;#125;
    int i=0;
    __m256d v0;
    __m256d v1;
    __m256d v2;
    for(;i&amp;lt;9-4;i+=4)
    &amp;#123;	
            v0 = _mm256_load_pd(a+i);
            v1 = _mm256_load_pd(b+i);
            v2=_mm256_add_pd(v0,v1);
         	_mm256_stream_pd(c+i,v2);
            
    &amp;#125;
    for(;i&amp;lt;9;i++)
    &amp;#123;
        c[i]=a[i]+b[i];
    
    &amp;#125;
    printf(&amp;quot;this is c.\n&amp;quot;);
        for(int i=0;i&amp;lt;9;i++)
    &amp;#123;
        printf(&amp;quot;%lf\n&amp;quot;,c[i]);
    &amp;#125;
    return 0;
 &amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;样例程序输出：&#34;&gt;&lt;a href=&#34;#样例程序输出：&#34; class=&#34;headerlink&#34; title=&#34;样例程序输出：&#34;&gt;&lt;/a&gt;样例程序输出：&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;this is c.
3.200000
5.400000
9.700000
13.000000
9.200000
16.500000
12.800000
13.000000
8.700000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;相关链接&#34;&gt;&lt;a href=&#34;#相关链接&#34; class=&#34;headerlink&#34; title=&#34;相关链接&#34;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;p&gt;[&lt;a href=&#34;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&#34;&gt;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&lt;/a&gt;: 	“Intel® Intrinsics Guide”&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</guid>
            <title>AVX向量化学习(一)</title>
            <link>http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</link>
            <category>AVX</category>
            <pubDate>Sun, 12 Jun 2022 15:11:29 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;AVX指令集的简单操作&#34;&gt;&lt;a href=&#34;#AVX指令集的简单操作&#34; class=&#34;headerlink&#34; title=&#34;AVX指令集的简单操作&#34;&gt;&lt;/a&gt;AVX指令集的简单操作&lt;/h1&gt;&lt;p&gt;使用AVX指令集进行2个double型的数组相加操作&lt;/p&gt;
&lt;h2 id=&#34;使用到的AVX函数介绍&#34;&gt;&lt;a href=&#34;#使用到的AVX函数介绍&#34; class=&#34;headerlink&#34; title=&#34;使用到的AVX函数介绍&#34;&gt;&lt;/a&gt;使用到的AVX函数介绍&lt;/h2&gt;&lt;h3 id=&#34;1&#34;&gt;&lt;a href=&#34;#1&#34; class=&#34;headerlink&#34; title=&#34;1.&#34;&gt;&lt;/a&gt;1.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256 _mm256_loadu_ps (float const * mem_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Description&#34;&gt;&lt;a href=&#34;#Description&#34; class=&#34;headerlink&#34; title=&#34;Description&#34;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr does not need to be aligned on any particular boundary.&lt;/p&gt;
&lt;h3 id=&#34;Operation&#34;&gt;&lt;a href=&#34;#Operation&#34; class=&#34;headerlink&#34; title=&#34;Operation&#34;&gt;&lt;/a&gt;Operation&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;dst[255:0] := MEM[mem_addr+255:mem_addr]
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2&#34;&gt;&lt;a href=&#34;#2&#34; class=&#34;headerlink&#34; title=&#34;2.&#34;&gt;&lt;/a&gt;2.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256d _mm256_add_pd (__m256d a, __m256d b)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Description-1&#34;&gt;&lt;a href=&#34;#Description-1&#34; class=&#34;headerlink&#34; title=&#34;Description&#34;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.&lt;/p&gt;
&lt;h3 id=&#34;Operation-1&#34;&gt;&lt;a href=&#34;#Operation-1&#34; class=&#34;headerlink&#34; title=&#34;Operation&#34;&gt;&lt;/a&gt;Operation&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;FOR j := 0 to 3
    i := j*64
    dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3&#34;&gt;&lt;a href=&#34;#3&#34; class=&#34;headerlink&#34; title=&#34;3.&#34;&gt;&lt;/a&gt;3.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void _mm256_storeu_pd (double * mem_addr, __m256d a)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Description-2&#34;&gt;&lt;a href=&#34;#Description-2&#34; class=&#34;headerlink&#34; title=&#34;Description&#34;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr does not need to be aligned on any particular boundary.&lt;/p&gt;
&lt;h3 id=&#34;Operation-2&#34;&gt;&lt;a href=&#34;#Operation-2&#34; class=&#34;headerlink&#34; title=&#34;Operation&#34;&gt;&lt;/a&gt;Operation&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;MEM[mem_addr+255:mem_addr] := a[255:0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;未进行AVX向量化的情况&#34;&gt;&lt;a href=&#34;#未进行AVX向量化的情况&#34; class=&#34;headerlink&#34; title=&#34;未进行AVX向量化的情况&#34;&gt;&lt;/a&gt;未进行AVX向量化的情况&lt;/h2&gt;&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
int main()
&amp;#123;
    double a[9] = &amp;#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&amp;#125;;
    double b[9] = &amp;#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&amp;#125;;
    double c[9] = &amp;#123;0&amp;#125;;
    
    for(int i=0 ;i&amp;lt;9;i++)	
    &amp;#123;
        c[i]=a[i]+b[i];
        
    &amp;#125;
    
    printf(&amp;quot;this is c.\n&amp;quot;);
    for(int i=0;i&amp;lt;9;i++)
    &amp;#123;
        printf(&amp;quot;%lf\n&amp;quot;,c[i]);
    &amp;#125;
    
    return 0;
 &amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出&#34;&gt;&lt;a href=&#34;#程序输出&#34; class=&#34;headerlink&#34; title=&#34;程序输出&#34;&gt;&lt;/a&gt;程序输出&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;this is c.
3.200000
5.400000
9.700000
13.000000
9.200000
16.500000
12.800000
13.000000
8.700000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;进行AVX向量化的情况&#34;&gt;&lt;a href=&#34;#进行AVX向量化的情况&#34; class=&#34;headerlink&#34; title=&#34;进行AVX向量化的情况&#34;&gt;&lt;/a&gt;进行AVX向量化的情况&lt;/h2&gt;&lt;h3 id=&#34;程序源代码-1&#34;&gt;&lt;a href=&#34;#程序源代码-1&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include &amp;lt;immintrin.h&amp;gt;
int main()
&amp;#123;
    double a[9] = &amp;#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&amp;#125;;
    double b[9] = &amp;#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&amp;#125;;
    double c[9] = &amp;#123;0&amp;#125;;
    __m256d v0;
    __m256d v1;
    __m256d v2;
    int i=0;
    for(;i&amp;lt;9-4;i+=4)
    &amp;#123;	
            v0 = _mm256_loadu_pd(a+i);
            v1 = _mm256_loadu_pd(b+i);
            v2=_mm256_add_pd(v0,v1);
         	_mm256_storeu_pd(c+i,v2);
            
    &amp;#125;
    for(;i&amp;lt;9;i++)
    &amp;#123;
        c[i]=a[i]+b[i];
    
    &amp;#125;
    printf(&amp;quot;this is c with AVX.\n&amp;quot;);
        for(int i=0;i&amp;lt;9;i++)
    &amp;#123;
        printf(&amp;quot;%lf\n&amp;quot;,c[i]);
    &amp;#125;

    return 0;
 &amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出-1&#34;&gt;&lt;a href=&#34;#程序输出-1&#34; class=&#34;headerlink&#34; title=&#34;程序输出&#34;&gt;&lt;/a&gt;程序输出&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;this is c with AVX.
3.200000
5.400000
9.700000
13.000000
9.200000
16.500000
12.800000
13.000000
8.700000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;相关链接&#34;&gt;&lt;a href=&#34;#相关链接&#34; class=&#34;headerlink&#34; title=&#34;相关链接&#34;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;p&gt;[&lt;a href=&#34;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&#34;&gt;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&lt;/a&gt;: 	“ Intel® Intrinsics Guide”&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/01/17/AVX005/</guid>
            <title>AVX向量化学习(五)-INT型数组相加操作</title>
            <link>http://example.com/2022/01/17/AVX005/</link>
            <category>AVX</category>
            <pubDate>Mon, 17 Jan 2022 21:28:22 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;AVX向量化学习-五-INT型数组相加操作&#34;&gt;&lt;a href=&#34;#AVX向量化学习-五-INT型数组相加操作&#34; class=&#34;headerlink&#34; title=&#34;AVX向量化学习(五)-INT型数组相加操作&#34;&gt;&lt;/a&gt;AVX向量化学习(五)-INT型数组相加操作&lt;/h1&gt;&lt;p&gt;使用AVX指令集进行2个INT型的数组相加操作&lt;/p&gt;
&lt;h2 id=&#34;使用到的AVX函数介绍&#34;&gt;&lt;a href=&#34;#使用到的AVX函数介绍&#34; class=&#34;headerlink&#34; title=&#34;使用到的AVX函数介绍&#34;&gt;&lt;/a&gt;使用到的AVX函数介绍&lt;/h2&gt;&lt;h3 id=&#34;1&#34;&gt;&lt;a href=&#34;#1&#34; class=&#34;headerlink&#34; title=&#34;1.&#34;&gt;&lt;/a&gt;1.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256i _mm256_loadu_si256 (__m256i const * mem_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Synopsis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;m256i _mm256_loadu_si256 (m256i const * mem_addr)&lt;br&gt;#include &amp;lt;immintrin.h&amp;gt;&lt;br&gt;Instruction: vmovdqu ymm, m256&lt;br&gt;CPUID Flags: AVX&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Load 256-bits of integer data from memory into dst. mem_addr does not need to be aligned on any particular boundary.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;dst[255:0] := MEM[mem_addr+255:mem_addr] 
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Performance&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Architecture&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Latency&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Throughput (CPI)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Icelake&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Skylake&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Broadwell&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Haswell&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Ivy Bridge&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;2&#34;&gt;&lt;a href=&#34;#2&#34; class=&#34;headerlink&#34; title=&#34;2.&#34;&gt;&lt;/a&gt;2.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256i _mm256_add_epi32 (__m256i a, __m256i b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Synopsis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;m256i _mm256_add_epi32 (m256i a, __m256i b)&lt;br&gt;#include &amp;lt;immintrin.h&amp;gt;&lt;br&gt;Instruction: vpaddd ymm, ymm, ymm&lt;br&gt;CPUID Flags: AVX2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Add packed 32-bit integers in a and b, and store the results in dst.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FOR j := 0 to 7 
         i := j*32 
         dst[i+31:i] := a[i+31:i] + b[i+31:i] 
ENDFOR 
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Performance&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Architecture&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Latency&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Throughput (CPI)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Icelake&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.33&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Skylake&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.33&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Broadwell&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Haswell&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include &amp;lt;immintrin.h&amp;gt;
int main()
&amp;#123;
    int a[40];
    int b[40];
    int i=0;
    int ans1[40];    //记录串行结果 
    int ans2[40];	 //记录AVX向量化后的结果
    for (i=0;i&amp;lt;40;i++)
    &amp;#123;
        a[i]=i;
        b[i]=2*i;
    &amp;#125;
    for (i=0;i&amp;lt;40;i++)
    &amp;#123;
        ans1[i]=a[i]+b[i];
    &amp;#125;
    printf(&amp;quot;串行计算结果：\n&amp;quot;);
    for (i=0;i&amp;lt;40;i++)
    &amp;#123;
        printf(&amp;quot;%d &amp;quot;,ans1[i]);
    &amp;#125;
    printf(&amp;quot;\n&amp;quot;);
    __m256i v0;
    __m256i v1;
    __m256i v2;
    for (i=0;i&amp;lt;40-8;i+=8)
    &amp;#123;	
        v0 = _mm256_loadu_si256((const __m256i*)(a+i));	 //强制类型转换
        v1 = _mm256_loadu_si256((const __m256i*)(b+i));	 //强制类型转化
        v2 = _mm256_add_epi32(v0,v1);     //v0+v1
        _mm256_storeu_si256((__m256i*)(ans2+i),v2);
        
    &amp;#125;//边界处理
    for (;i&amp;lt;40;i++)
    &amp;#123;
        ans2[i]=a[i]+b[i];
    &amp;#125;
    printf(&amp;quot;并行计算结果：\n&amp;quot;);
    for (i=0;i&amp;lt;40;i++)
    &amp;#123;
        printf(&amp;quot;%d &amp;quot;,ans2[i]);
    &amp;#125;
    return 0; 
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;程序输出&#34;&gt;&lt;a href=&#34;#程序输出&#34; class=&#34;headerlink&#34; title=&#34;程序输出&#34;&gt;&lt;/a&gt;程序输出&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;串行计算结果：
0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117
并行计算结果：
0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;相关链接&#34;&gt;&lt;a href=&#34;#相关链接&#34; class=&#34;headerlink&#34; title=&#34;相关链接&#34;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;p&gt;[&lt;a href=&#34;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&#34;&gt;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&lt;/a&gt;: 	“ Intel® Intrinsics Guide”&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/01/17/AVX004/</guid>
            <title>AVX向量化学习(四)-INT类型转化成DOUBLE类型</title>
            <link>http://example.com/2022/01/17/AVX004/</link>
            <category>AVX</category>
            <pubDate>Mon, 17 Jan 2022 20:41:56 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;AVX向量化学习-四-INT类型转化成DOUBLE类型&#34;&gt;&lt;a href=&#34;#AVX向量化学习-四-INT类型转化成DOUBLE类型&#34; class=&#34;headerlink&#34; title=&#34;AVX向量化学习(四)-INT类型转化成DOUBLE类型&#34;&gt;&lt;/a&gt;AVX向量化学习(四)-INT类型转化成DOUBLE类型&lt;/h1&gt;&lt;p&gt;使用AVX指令集把INT类型转化为DOUBLE类型&lt;/p&gt;
&lt;h2 id=&#34;使用到的AVX函数介绍&#34;&gt;&lt;a href=&#34;#使用到的AVX函数介绍&#34; class=&#34;headerlink&#34; title=&#34;使用到的AVX函数介绍&#34;&gt;&lt;/a&gt;使用到的AVX函数介绍&lt;/h2&gt;&lt;h3 id=&#34;1&#34;&gt;&lt;a href=&#34;#1&#34; class=&#34;headerlink&#34; title=&#34;1.&#34;&gt;&lt;/a&gt;1.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m128i _mm_setr_epi32 (int e3, int e2, int e1, int e0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Synopsis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;__m128i _mm_setr_epi32 (int e3, int e2, int e1, int e0)&lt;br&gt;#include &amp;lt;emmintrin.h&amp;gt;&lt;br&gt;Instruction: &lt;strong&gt;Sequence&lt;/strong&gt;&lt;br&gt;CPUID Flags: SSE2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Set packed 32-bit integers in dst with the supplied values in reverse order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;dst[31:0] := e3 
dst[63:32] := e2 
dst[95:64] := e1 
dst[127:96] := e0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2&#34;&gt;&lt;a href=&#34;#2&#34; class=&#34;headerlink&#34; title=&#34;2.&#34;&gt;&lt;/a&gt;2.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256d _mm256_cvtepi32_pd (__m128i a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Synopsis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;m256d _mm256_cvtepi32_pd (m128i a)&lt;br&gt;#include &amp;lt;immintrin.h&amp;gt;&lt;br&gt;Instruction: vcvtdq2pd ymm, xmm&lt;br&gt;CPUID Flags: AVX&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;FOR j := 0 to 3 
    i := j*32 
    m := j*64 
    dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i]) 
ENDFOR 
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Performance&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Architecture&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Latency&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Throughput (CPI)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Icelake&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Skylake&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Broadwell&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Haswell&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Ivy Bridge&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;程序运行平台&#34;&gt;&lt;a href=&#34;#程序运行平台&#34; class=&#34;headerlink&#34; title=&#34;程序运行平台&#34;&gt;&lt;/a&gt;程序运行平台&lt;/h2&gt;&lt;p&gt;北京超级云计算中心A3分区&lt;/p&gt;
&lt;h2 id=&#34;编译指令&#34;&gt;&lt;a href=&#34;#编译指令&#34; class=&#34;headerlink&#34; title=&#34;编译指令&#34;&gt;&lt;/a&gt;编译指令&lt;/h2&gt;&lt;p&gt;g++ int_to_double.cpp -msse2 -mavx -o test01&lt;/p&gt;
&lt;h2 id=&#34;运行指令&#34;&gt;&lt;a href=&#34;#运行指令&#34; class=&#34;headerlink&#34; title=&#34;运行指令&#34;&gt;&lt;/a&gt;运行指令&lt;/h2&gt;&lt;p&gt;.&amp;#x2F;test01&lt;/p&gt;
&lt;h2 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;immintrin.h&amp;gt;
using namespace std;
int main()
&amp;#123;
    int a[4]=&amp;#123;1,2,3,4&amp;#125;;
    double b[9]=&amp;#123;0&amp;#125;;
    __m128i x = _mm_setr_epi32(a[0], a[1], a[2],a[3]);   //load
     __m256d v5=_mm256_cvtepi32_pd(x);       //convert
    _mm256_storeu_pd(b,v5);
    for(int i=0;i&amp;lt;9;i++)
    &amp;#123;
        cout&amp;lt;&amp;lt;b[i]&amp;lt;&amp;lt;endl;
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;程序输出&#34;&gt;&lt;a href=&#34;#程序输出&#34; class=&#34;headerlink&#34; title=&#34;程序输出&#34;&gt;&lt;/a&gt;程序输出&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;1
2
3
4
0
0
0
0
0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;相关链接&#34;&gt;&lt;a href=&#34;#相关链接&#34; class=&#34;headerlink&#34; title=&#34;相关链接&#34;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;p&gt;[&lt;a href=&#34;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&#34;&gt;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&lt;/a&gt;: 	“ Intel® Intrinsics Guide”&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/11/24/AVX003/</guid>
            <title>AVX向量化学习(三)-if判断的处理</title>
            <link>http://example.com/2021/11/24/AVX003/</link>
            <category>AVX</category>
            <pubDate>Wed, 24 Nov 2021 17:42:35 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;AVX-if判断的处理&#34;&gt;&lt;a href=&#34;#AVX-if判断的处理&#34; class=&#34;headerlink&#34; title=&#34;AVX-if判断的处理&#34;&gt;&lt;/a&gt;AVX-if判断的处理&lt;/h1&gt;&lt;p&gt;使用AVX指令集对if判断进行处理&lt;/p&gt;
&lt;h2 id=&#34;使用到的AVX函数介绍&#34;&gt;&lt;a href=&#34;#使用到的AVX函数介绍&#34; class=&#34;headerlink&#34; title=&#34;使用到的AVX函数介绍&#34;&gt;&lt;/a&gt;使用到的AVX函数介绍&lt;/h2&gt;&lt;h3 id=&#34;1&#34;&gt;&lt;a href=&#34;#1&#34; class=&#34;headerlink&#34; title=&#34;1.&#34;&gt;&lt;/a&gt;1.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Blend packed double-precision (64-bit) floating-point elements from a and b using mask, and store the results in dst.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;FOR j := 0 to 3
    i := j*64
    IF mask[i+63]
        dst[i+63:i] := b[i+63:i]
    ELSE
        dst[i+63:i] := a[i+63:i]
    FI
ENDFOR
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2&#34;&gt;&lt;a href=&#34;#2&#34; class=&#34;headerlink&#34; title=&#34;2.&#34;&gt;&lt;/a&gt;2.&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;__m256d _mm256_cmp_pd (__m256d a, __m256d b, const int imm8)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in dst.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;CASE (imm8[4:0]) OF
0: OP := _CMP_EQ_OQ
1: OP := _CMP_LT_OS
2: OP := _CMP_LE_OS
3: OP := _CMP_UNORD_Q 
4: OP := _CMP_NEQ_UQ
5: OP := _CMP_NLT_US
6: OP := _CMP_NLE_US
7: OP := _CMP_ORD_Q
8: OP := _CMP_EQ_UQ
9: OP := _CMP_NGE_US
10: OP := _CMP_NGT_US
11: OP := _CMP_FALSE_OQ
12: OP := _CMP_NEQ_OQ
13: OP := _CMP_GE_OS
14: OP := _CMP_GT_OS
15: OP := _CMP_TRUE_UQ
16: OP := _CMP_EQ_OS
17: OP := _CMP_LT_OQ
18: OP := _CMP_LE_OQ
19: OP := _CMP_UNORD_S
20: OP := _CMP_NEQ_US
21: OP := _CMP_NLT_UQ
22: OP := _CMP_NLE_UQ
23: OP := _CMP_ORD_S
24: OP := _CMP_EQ_US
25: OP := _CMP_NGE_UQ 
26: OP := _CMP_NGT_UQ 
27: OP := _CMP_FALSE_OS 
28: OP := _CMP_NEQ_OS 
29: OP := _CMP_GE_OQ
30: OP := _CMP_GT_OQ
31: OP := _CMP_TRUE_US
ESAC
FOR j := 0 to 3
    i := j*64
    dst[i+63:i] := ( a[i+63:i] OP b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include &amp;lt;immintrin.h&amp;gt;
int main()
&amp;#123;
    double a[9]=&amp;#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&amp;#125;;
    double b[9]=&amp;#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&amp;#125;;
    double d[9]=&amp;#123;0&amp;#125;;     //记录原始if判断后的值
    double e[9]=&amp;#123;0&amp;#125;;     //记录AVX-if判断后的值
    
    __m256d v0;
    __m256d v1;
    __m256d v2,v3;
    __m256d v4;
    
    for(int i=0;i&amp;lt;9;i++)
    &amp;#123;
        if(a[i]&amp;gt;b[i])
        &amp;#123;
            d[i] = a[i];
        &amp;#125;
        else
        &amp;#123;
            d[i]=b[i];
        &amp;#125;
    &amp;#125;

    int i=0;
    
    for(;i&amp;lt;9-4;i+=4)
    &amp;#123;	
            v0 = _mm256_loadu_pd(a+i);
            v1 = _mm256_loadu_pd(b+i);
            v2=_mm256_add_pd(v0,v1);
            v3 =_mm256_blendv_pd(v0,v1,_mm256_cmp_pd(v0,v1,_CMP_LE_OQ));
            _mm256_storeu_pd(e+i,v3);
            
    &amp;#125;
    
    for(;i&amp;lt;9;i++)
    &amp;#123;
        if(a[i]&amp;gt;b[i])
        &amp;#123;
            e[i] = a[i];
        &amp;#125;
        else
        &amp;#123;
            e[i]=b[i];
        &amp;#125;
    &amp;#125;
    
    printf(&amp;quot;this is d.\n&amp;quot;);
        for(int i=0;i&amp;lt;9;i++)
    &amp;#123;
        printf(&amp;quot;%lf\n&amp;quot;,d[i]);
    &amp;#125;
    
    printf(&amp;quot;this is e with AVX.\n&amp;quot;);
        for(int i=0;i&amp;lt;9;i++)
    &amp;#123;
        printf(&amp;quot;%lf\n&amp;quot;,e[i]);
    &amp;#125;
    return 0;
 &amp;#125; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;程序输出&#34;&gt;&lt;a href=&#34;#程序输出&#34; class=&#34;headerlink&#34; title=&#34;程序输出&#34;&gt;&lt;/a&gt;程序输出&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;this is d.
2.100000
3.200000
6.400000
8.600000
5.500000
9.900000
7.700000
8.800000
6.600000
this is e with AVX.
2.100000
3.200000
6.400000
8.600000
5.500000
9.900000
7.700000
8.800000
6.600000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;相关链接&#34;&gt;&lt;a href=&#34;#相关链接&#34; class=&#34;headerlink&#34; title=&#34;相关链接&#34;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;p&gt;[&lt;a href=&#34;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&#34;&gt;https://software.intel.com/sites/landingpage/IntrinsicsGuide/]&lt;/a&gt;: 	“ Intel® Intrinsics Guide”&lt;/p&gt;
&lt;p&gt;[&lt;a href=&#34;https://stackoverflow.com/questions/16988199/how-to-choose-avx-compare-predicate-variants&#34;&gt;simd - How to choose AVX compare predicate variants - Stack Overflow&lt;/a&gt;]: 	“Stack Overflow”&lt;/p&gt;
&lt;p&gt;[&lt;a href=&#34;https://www.officedaytime.com/simd512e/simdimg/si.php?f=blendvpd&#34;&gt;blendvpd (officedaytime.com)&lt;/a&gt;]: 	“_mm256_Blendv_pd()原理解释”&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
