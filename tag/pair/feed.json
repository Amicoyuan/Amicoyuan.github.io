{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"pair\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/04/23/Algorithm031/",
            "url": "http://example.com/2022/04/23/Algorithm031/",
            "title": "L2-039 清点代码库 (25 分)",
            "date_published": "2022-04-23T13:44:47.000Z",
            "content_html": "<h2 id=\"L2-039-清点代码库-25-分\"><a href=\"#L2-039-清点代码库-25-分\" class=\"headerlink\" title=\"L2-039 清点代码库 (25 分)\"></a>L2-039 清点代码库 (25 分)</h2><p><img src=\"/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg\" alt=\"code.jpg\"></p>\n<p>上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”</p>\n<p>这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 <strong>int</strong> 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行中给出 2 个正整数，依次为 <em>N</em>（≤104）和 <em>M</em>（≤102），对应功能模块的个数和系列测试输入的个数。</p>\n<p>随后 <em>N</em> 行，每行给出一个功能模块的 <em>M</em> 个对应输出，数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>首先在第一行输出不同功能的个数 <em>K</em>。随后 <em>K</em> 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。</p>\n<p>注：所谓数列 { <em>A</em>1, …, <em>A</em>M } 比 { <em>B</em>1, …, <em>B</em>M } 大，是指存在 1≤i&lt;*M*，使得 *A*1&#x3D;*B*1，…，*Ai*&#x3D;*Bi* 成立，且 *Ai*+1&gt;<em>B</em>+1。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">7 3\n35 28 74\n-1 -1 22\n28 74 35\n-1 -1 22\n11 66 0\n35 28 74\n35 28 74\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">4\n3 35 28 74\n2 -1 -1 22\n1 11 66 0\n1 28 74 35\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>利用map的映射关系</strong></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nmap<vector<int>,int> mp;   //key，value\nvector<int> tmp;\nint n,m;\nbool cmp(pair<vector<int>,int> a,pair<vector<int>,int> b)\n&#123;\n    if(a.second==b.second)\n    &#123;\n        return a.first<b.first;\n    &#125;\n    return a.second>b.second;\n\n&#125;\nint main()\n&#123;\n    cin>>n>>m;\n    for (int i = 0; i <n ; ++i) &#123;\n        for (int j = 0; j < m; ++j) &#123;\n            int num;\n            cin>>num;\n            tmp.push_back(num);\n        &#125;\n        mp[tmp]++;\n        tmp.clear();\n    &#125;\n    vector<pair<vector<int>,int>> v(mp.begin(),mp.end());\t\t//把map类型转化成vector\n    cout<<v.size()<<endl;\n    sort(v.begin(),v.end(),cmp);\t\t\t\t\t\t\t\t//sort排序，注意终点和起点\n    for (int k = 0; k <v.size() ; ++k) &#123;\n        cout<<v[k].second<<\" \";\n        for (int i = 0; i <m ; ++i) &#123;\n            if(i!=m-1)&#123;\n                cout<<v[k].first[i]<<\" \";\n            &#125; else&#123;\n                cout<<v[k].first[i]<<endl;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362\">题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Sort",
                "Vector",
                "Map",
                "Pair"
            ]
        }
    ]
}