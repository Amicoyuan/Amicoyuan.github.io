<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>Amicoyuan • Posts by &#34;pair&#34; tag</title>
    <link href="http://example.com" />
    <updated>2022-04-23T13:44:47.000Z</updated>
    <category term="AVX" />
    <category term="Data Structure" />
    <category term="String" />
    <category term="Find" />
    <category term="STL" />
    <category term="C++" />
    <category term="Set" />
    <category term="团体程序设计天梯赛" />
    <category term="Sort" />
    <category term="LinkList" />
    <category term="双向链表" />
    <category term="Graph" />
    <category term="邻接表" />
    <category term="Vector" />
    <category term="Binary tree" />
    <category term="BFS" />
    <category term="模拟" />
    <category term="邻接矩阵" />
    <category term="DFS" />
    <category term="结构体" />
    <category term="贪心" />
    <category term="Double类型相等比较" />
    <category term="Map" />
    <category term="并查集" />
    <category term="Pair" />
    <category term="线索二叉树" />
    <category term="KMP" />
    <category term="Tree" />
    <category term="森林" />
    <category term="Linux" />
    <category term="MPI" />
    <category term="Numactl" />
    <category term="Slurm" />
    <category term="Tensorflow" />
    <category term="性能分析工具" />
    <category term="gcov" />
    <entry>
        <id>http://example.com/2022/04/23/Algorithm031/</id>
        <title>L2-039 清点代码库 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/23/Algorithm031/"/>
        <content type="html">&lt;h2 id=&#34;L2-039-清点代码库-25-分&#34;&gt;&lt;a href=&#34;#L2-039-清点代码库-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-039 清点代码库 (25 分)&#34;&gt;&lt;/a&gt;L2-039 清点代码库 (25 分)&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg&#34; alt=&#34;code.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”&lt;/p&gt;
&lt;p&gt;这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 &lt;strong&gt;int&lt;/strong&gt; 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行中给出 2 个正整数，依次为 &lt;em&gt;N&lt;/em&gt;（≤104）和 &lt;em&gt;M&lt;/em&gt;（≤102），对应功能模块的个数和系列测试输入的个数。&lt;/p&gt;
&lt;p&gt;随后 &lt;em&gt;N&lt;/em&gt; 行，每行给出一个功能模块的 &lt;em&gt;M&lt;/em&gt; 个对应输出，数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先在第一行输出不同功能的个数 &lt;em&gt;K&lt;/em&gt;。随后 &lt;em&gt;K&lt;/em&gt; 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。&lt;/p&gt;
&lt;p&gt;注：所谓数列 { &lt;em&gt;A&lt;/em&gt;1, …, &lt;em&gt;A&lt;/em&gt;M } 比 { &lt;em&gt;B&lt;/em&gt;1, …, &lt;em&gt;B&lt;/em&gt;M } 大，是指存在 1≤i&amp;lt;*M*，使得 *A*1&amp;#x3D;*B*1，…，*Ai*&amp;#x3D;*Bi* 成立，且 *Ai*+1&amp;gt;&lt;em&gt;B&lt;/em&gt;+1。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;7 3
35 28 74
-1 -1 22
28 74 35
-1 -1 22
11 66 0
35 28 74
35 28 74
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;4
3 35 28 74
2 -1 -1 22
1 11 66 0
1 28 74 35
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;利用map的映射关系&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;vector&lt;int&gt;,int&gt; mp;   //key，value
vector&lt;int&gt; tmp;
int n,m;
bool cmp(pair&lt;vector&lt;int&gt;,int&gt; a,pair&lt;vector&lt;int&gt;,int&gt; b)
&amp;#123;
    if(a.second==b.second)
    &amp;#123;
        return a.first&lt;b.first;
    &amp;#125;
    return a.second&gt;b.second;

&amp;#125;
int main()
&amp;#123;
    cin&gt;&gt;n&gt;&gt;m;
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        for (int j = 0; j &lt; m; ++j) &amp;#123;
            int num;
            cin&gt;&gt;num;
            tmp.push_back(num);
        &amp;#125;
        mp[tmp]++;
        tmp.clear();
    &amp;#125;
    vector&lt;pair&lt;vector&lt;int&gt;,int&gt;&gt; v(mp.begin(),mp.end());		//把map类型转化成vector
    cout&lt;&lt;v.size()&lt;&lt;endl;
    sort(v.begin(),v.end(),cmp);								//sort排序，注意终点和起点
    for (int k = 0; k &lt;v.size() ; ++k) &amp;#123;
        cout&lt;&lt;v[k].second&lt;&lt;&#34; &#34;;
        for (int i = 0; i &lt;m ; ++i) &amp;#123;
            if(i!=m-1)&amp;#123;
                cout&lt;&lt;v[k].first[i]&lt;&lt;&#34; &#34;;
            &amp;#125; else&amp;#123;
                cout&lt;&lt;v[k].first[i]&lt;&lt;endl;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362&#34;&gt;题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Sort" />
        <category term="Vector" />
        <category term="Map" />
        <category term="Pair" />
        <updated>2022-04-23T13:44:47.000Z</updated>
    </entry>
</feed>
