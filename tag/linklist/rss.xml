<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan • Posts by &#34;linklist&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Tue, 12 Apr 2022 09:50:11 +0800</pubDate>
        <lastBuildDate>Tue, 12 Apr 2022 09:50:11 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>Map</category>
        <category>并查集</category>
        <category>Pair</category>
        <category>线索二叉树</category>
        <category>KMP</category>
        <category>Tree</category>
        <category>森林</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Numactl</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/12/Algorithm017/</guid>
            <title>L2-022 重排链表 (25 分)</title>
            <link>http://example.com/2022/04/12/Algorithm017/</link>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>LinkList</category>
            <category>双向链表</category>
            <pubDate>Tue, 12 Apr 2022 09:50:11 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-022-重排链表-25-分&#34;&gt;&lt;a href=&#34;#L2-022-重排链表-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-022 重排链表 (25 分)&#34;&gt;&lt;/a&gt;L2-022 重排链表 (25 分)&lt;/h2&gt;&lt;p&gt;给定一个单链表 &lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;L&lt;/em&gt;2→⋯→&lt;em&gt;Ln&lt;/em&gt;−1→&lt;em&gt;Ln&lt;/em&gt;，请编写程序将链表重新排列为 &lt;em&gt;Ln&lt;/em&gt;→&lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;Ln&lt;/em&gt;−1→&lt;em&gt;L&lt;/em&gt;2→⋯。例如：给定&lt;em&gt;L&lt;/em&gt;为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数&lt;em&gt;N&lt;/em&gt; (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。&lt;/p&gt;
&lt;p&gt;接下来有&lt;em&gt;N&lt;/em&gt;行，每行格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Address Data Next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;Address&lt;/code&gt;是结点地址；&lt;code&gt;Data&lt;/code&gt;是该结点保存的数据，为不超过105的正整数；&lt;code&gt;Next&lt;/code&gt;是下一结点的地址。题目保证给出的链表上至少有两个结点。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;00100 6
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;68237 6 00100
00100 1 99999
99999 5 12309
12309 2 00000
00000 4 33218
33218 3 -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;利用双向链表，头尾指针来模拟&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
struct linklist&amp;#123;
    int address=0;			//记录当前结点的地址，虽然也没用到
    int data=0;				//记录数据域
    int next=0;				//指向下一个结点的地址
    int pre=0;				//指向上一个结点的地址
&amp;#125;l[100005];
int main()
&amp;#123;
    int start,back=-1;		//头尾指针
    int tmp;				//用来遍历当前链表用于统计链表的长度
    int n;
    cin&gt;&gt;start&gt;&gt;n;
    tmp=start;
    int address, data, next;
    l[start].pre=-1;	   //初始化第一个结点的前一个结点位置为-1
    int cnt=0;			  	//记录链表长
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
       cin&gt;&gt;address&gt;&gt;data&gt;&gt;next;
       l[address].address=address;
       l[address].data=data;
       l[address].next=next;
       if(next!=-1)&amp;#123;
           l[next].pre=address;				//设值上一个结点的地址
       &amp;#125;
    &amp;#125;
    //这道题比较坑的地方是会出现不是这个链表的结点，所以n不是真正的链表长，需要统计真正的链表长
    //如果没注意这点，第三个测试点会不通过，不过也能得到21分
    while (true) &amp;#123;
        cnt++;				//统计链表长	
        if(l[tmp].next==-1)&amp;#123;
            back=tmp;       //尾指针
            break;
        &amp;#125;
        tmp=l[tmp].next;
    &amp;#125;
    int flag=0;
    //flag=0动尾指针,flag=1动头指针。我并没有改变原来链表！
    for (int k = 0; k &lt;cnt ; ++k) &amp;#123;
            if(flag==0)&amp;#123;
                if(k==cnt-1)&amp;#123;
                    printf(&#34;%05d %d %d\n&#34;,l[back].address,l[back].data,-1);
                &amp;#125;else&amp;#123;
                    printf(&#34;%05d %d %05d\n&#34;,l[back].address,l[back].data,start);
                &amp;#125;
                back=l[back].pre;
                flag=1;
            &amp;#125;
            else if(flag==1)&amp;#123;
                if(k==cnt-1)&amp;#123;
                    printf(&#34;%05d %d %d\n&#34;,l[start].address,l[start].data,-1);
                &amp;#125;else&amp;#123;
                    printf(&#34;%05d %d %05d\n&#34;,l[start].address,l[start].data,back);
                &amp;#125;
                start=l[start].next;
                flag=0;
            &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805057860517888&#34;&gt;题目详情 - L2-022 重排链表 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
