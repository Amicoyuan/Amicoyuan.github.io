<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan • Posts by &#34;dfs&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Fri, 15 Apr 2022 21:09:30 +0800</pubDate>
        <lastBuildDate>Fri, 15 Apr 2022 21:09:30 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>并查集</category>
        <category>Map</category>
        <category>Pair</category>
        <category>KMP</category>
        <category>线索二叉树</category>
        <category>Tree</category>
        <category>森林</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Numactl</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/15/Algorithm025/</guid>
            <title>L2-013 红色警报 (25 分)</title>
            <link>http://example.com/2022/04/15/Algorithm025/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Graph</category>
            <category>邻接矩阵</category>
            <category>DFS</category>
            <pubDate>Fri, 15 Apr 2022 21:09:30 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-013-红色警报-25-分&#34;&gt;&lt;a href=&#34;#L2-013-红色警报-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-013 红色警报 (25 分)&#34;&gt;&lt;/a&gt;L2-013 红色警报 (25 分)&lt;/h2&gt;&lt;p&gt;战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出两个整数&lt;code&gt;N&lt;/code&gt;（0 &amp;lt; &lt;code&gt;N&lt;/code&gt; ≤ 500）和&lt;code&gt;M&lt;/code&gt;（≤ 5000），分别为城市个数（于是默认城市从0到&lt;code&gt;N&lt;/code&gt;-1编号）和连接两城市的通路条数。随后&lt;code&gt;M&lt;/code&gt;行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数&lt;code&gt;K&lt;/code&gt;和随后的&lt;code&gt;K&lt;/code&gt;个被攻占的城市的编号。&lt;/p&gt;
&lt;p&gt;注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个被攻占的城市，如果它会改变整个国家的连通性，则输出&lt;code&gt;Red Alert: City k is lost!&lt;/code&gt;，其中&lt;code&gt;k&lt;/code&gt;是该城市的编号；否则只输出&lt;code&gt;City k is lost.&lt;/code&gt;即可。如果该国失去了最后一个城市，则增加一行输出&lt;code&gt;Game Over.&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;5 4
0 1
1 3
3 0
0 4
5
1 2 0 4 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;City 1 is lost.
City 2 is lost.
Red Alert: City 0 is lost!
City 4 is lost.
City 3 is lost.
Game Over.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接矩阵建图 + DFS统计连通分量数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无向图中的极大连通子图称为连通分量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极大连通子图必须连通，且包含尽可能多的顶点和边&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,m;
int g[505][505];						//邻接矩阵存图
int visit[505];							//标记访问数组
int lost[505];							//记录被攻占的城市
void dfs(int node)&amp;#123;						//正常的DFS
    visit[node]=1;
    for(int i=0;i&amp;lt;n;i++)
    &amp;#123;
        if(visit[i]==0&amp;amp;&amp;amp;g[node][i]==1)
        &amp;#123;
            dfs(i);
        &amp;#125;
    &amp;#125;
&amp;#125;
int dfstrave()&amp;#123;
    int cnt=0;
    memset(visit,0,sizeof(visit));			//初始化访问数组
    for(int i=0;i&amp;lt;n;i++)&amp;#123;
        if(lost[i]==1) visit[i]=1;			//如果该城市被攻占，则标记他为以访问
    &amp;#125;
    for(int i=0;i&amp;lt;n;i++)&amp;#123;
        if(visit[i]==0)&amp;#123;
            dfs(i);
            cnt++;      					//统计连通分量数
        &amp;#125;
    &amp;#125;
    return cnt;
&amp;#125;
int main()
&amp;#123;
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    memset(lost,0,sizeof(lost));			//初始化
    memset(g,0,sizeof(g));					//初始化
    for(int i=0;i&amp;lt;m;i++)&amp;#123;
        int a,b;
        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
        g[a][b]=g[b][a]=1;					//存储无向图
    &amp;#125;
    int cnt=dfstrave();						//获得初始的连通分量数
    int k;
    cin&amp;gt;&amp;gt;k;
    for(int w=0;w&amp;lt;k;w++)&amp;#123;
        int city;
        cin&amp;gt;&amp;gt;city;
        lost[city]=1;						//记录该城市被攻占
        for(int i=0;i&amp;lt;n;i++)&amp;#123;
            if(g[city][i]==1)&amp;#123;				
                g[city][i]=g[i][city]=0;	//标记和他相连的城市不再相连
            &amp;#125;
        &amp;#125;
        int tempcnt=dfstrave();				//当前的连通分量
        if(tempcnt&amp;lt;=cnt)&amp;#123;					//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变
            printf(&amp;quot;City %d is lost.\n&amp;quot;, city);
        &amp;#125;else&amp;#123;								//否则，连通性被改变了
            printf(&amp;quot;Red Alert: City %d is lost!\n&amp;quot;, city);
        &amp;#125;
        cnt=tempcnt;						//更新连通分量
        if(w==n-1)&amp;#123;							//城市已经被攻占完毕
            printf(&amp;quot;Game Over.\n&amp;quot;);
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208&#34;&gt;题目详情 - L2-013 红色警报 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/12/21/algorithm001/</guid>
            <title>DFS-深度优先搜索</title>
            <link>http://example.com/2021/12/21/algorithm001/</link>
            <category>DFS</category>
            <pubDate>Tue, 21 Dec 2021 21:25:36 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;DFS-深度优先搜索&#34;&gt;&lt;a href=&#34;#DFS-深度优先搜索&#34; class=&#34;headerlink&#34; title=&#34;DFS-深度优先搜索&#34;&gt;&lt;/a&gt;DFS-深度优先搜索&lt;/h1&gt;&lt;h2 id=&#34;样题1-全排列&#34;&gt;&lt;a href=&#34;#样题1-全排列&#34; class=&#34;headerlink&#34; title=&#34;样题1-全排列&#34;&gt;&lt;/a&gt;样题1-全排列&lt;/h2&gt;&lt;h3 id=&#34;题目描述：&#34;&gt;&lt;a href=&#34;#题目描述：&#34; class=&#34;headerlink&#34; title=&#34;题目描述：&#34;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;输入一个数n，输出n的全排列&lt;/p&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n;
int a[100];
int book[100];
void dfs(int step)
&amp;#123;
    int i;
    if(step==n+1)  //这里表示dfs结束,没有可以排的数字了
    &amp;#123;
        for (i = 1;  i&amp;lt;=n ; i++) &amp;#123;
            cout&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        &amp;#125;
        cout&amp;lt;&amp;lt;endl;
        return ;
    &amp;#125;
    for(int i=1;i&amp;lt;=n;i++)
    &amp;#123;
        if(book[i]==0)  //说明数字i还没有被使用,可以用来排列
        &amp;#123;
            a[step]=i;//排列数字i
            book[i]=1;//标记数字i为已使用
            dfs(step+1);
            //继续排列没有使用的数字
            book[i]=0;
            //这里表示dfs调用结束了,意思是数字i已经全部排列完了，但还需要
            //按照顺序将数字i收回，重新排列。
        &amp;#125;
    &amp;#125;
    return;
&amp;#125;
int main() &amp;#123;
    cin&amp;gt;&amp;gt;n;
    dfs(1); //dfs函数的开始
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输入：&#34;&gt;&lt;a href=&#34;#程序输入：&#34; class=&#34;headerlink&#34; title=&#34;程序输入：&#34;&gt;&lt;/a&gt;程序输入：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出：&#34;&gt;&lt;a href=&#34;#程序输出：&#34; class=&#34;headerlink&#34; title=&#34;程序输出：&#34;&gt;&lt;/a&gt;程序输出：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;样题二-自然数的拆分问题&#34;&gt;&lt;a href=&#34;#样题二-自然数的拆分问题&#34; class=&#34;headerlink&#34; title=&#34;样题二-自然数的拆分问题&#34;&gt;&lt;/a&gt;样题二-自然数的拆分问题&lt;/h2&gt;&lt;h3 id=&#34;题目描述：-1&#34;&gt;&lt;a href=&#34;#题目描述：-1&#34; class=&#34;headerlink&#34; title=&#34;题目描述：&#34;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。现在给你一个自然数n，要求你求出n的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。&lt;/p&gt;
&lt;h3 id=&#34;程序源代码：-1&#34;&gt;&lt;a href=&#34;#程序源代码：-1&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int num;
int a[100000]=&amp;#123;1&amp;#125;;
void dfs(int n,int t)
&amp;#123;
    if(n==0)
    &amp;#123;
        for(int i=1;i&amp;lt;=t-1;i++)//输出一种拆分方案

            if(i!=t-1) cout&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;&amp;quot;+&amp;quot;;
            else cout&amp;lt;&amp;lt;a[i];
        cout&amp;lt;&amp;lt;endl;
        return ;
    &amp;#125;
    for (int i=a[t-1];i&amp;lt;=n;i++) &amp;#123;
        if(i&amp;lt;num)//当前数i要大于等于前一位数，且不超过n
        &amp;#123;
            a[t]=i;//保存当前拆分的数i
            n-=i;//n减去数i，n的值将继续拆分
            dfs(n,t+1);
            n+=i;//回溯：加上拆分的数，以便产生所有可能的拆分
        &amp;#125;
    &amp;#125;
    return ;

&amp;#125;
int main()
&amp;#123;
    cin&amp;gt;&amp;gt;num;
    dfs(num,1);
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输入：-1&#34;&gt;&lt;a href=&#34;#程序输入：-1&#34; class=&#34;headerlink&#34; title=&#34;程序输入：&#34;&gt;&lt;/a&gt;程序输入：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出：-1&#34;&gt;&lt;a href=&#34;#程序输出：-1&#34; class=&#34;headerlink&#34; title=&#34;程序输出：&#34;&gt;&lt;/a&gt;程序输出：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;1+1+1+1+1+1+1
1+1+1+1+1+2
1+1+1+1+3
1+1+1+2+2
1+1+1+4
1+1+2+3
1+1+5
1+2+2+2
1+2+4
1+3+3
1+6
2+2+3
2+5
3+4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;样例三：L2-038-病毒溯源-25-分&#34;&gt;&lt;a href=&#34;#样例三：L2-038-病毒溯源-25-分&#34; class=&#34;headerlink&#34; title=&#34;样例三：L2-038 病毒溯源 (25 分)&#34;&gt;&lt;/a&gt;样例三：&lt;strong&gt;L2-038 病毒溯源 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&#34;题目描述：-2&#34;&gt;&lt;a href=&#34;#题目描述：-2&#34; class=&#34;headerlink&#34; title=&#34;题目描述：&#34;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;病毒容易发生变异。某种病毒可以通过突变产生若干变异的毒株，而这些变异的病毒又可能被诱发突变产生第二代变异，如此继续不断变化。&lt;/p&gt;
&lt;p&gt;现给定一些病毒之间的变异关系，要求你找出其中最长的一条变异链。&lt;/p&gt;
&lt;p&gt;在此假设给出的变异都是由突变引起的，不考虑复杂的基因重组变异问题 —— 即每一种病毒都是由唯一的一种病毒突变而来，并且不存在循环变异的情况。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行中给出一个正整数 &lt;em&gt;N&lt;/em&gt;（≤104），即病毒种类的总数。于是我们将所有病毒从 0 到 &lt;em&gt;N&lt;/em&gt;−1 进行编号。&lt;/p&gt;
&lt;p&gt;随后 &lt;em&gt;N&lt;/em&gt; 行，每行按以下格式描述一种病毒的变异情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;k 变异株1 …… 变异株k
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;k&lt;/code&gt; 是该病毒产生的变异毒株的种类数，后面跟着每种变异株的编号。第 &lt;em&gt;i&lt;/em&gt; 行对应编号为 &lt;em&gt;i&lt;/em&gt; 的病毒（0≤&lt;em&gt;i&lt;/em&gt;&amp;lt;&lt;em&gt;N&lt;/em&gt;）。题目保证病毒源头有且仅有一个。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先输出从源头开始最长变异链的长度。&lt;/p&gt;
&lt;p&gt;在第二行中输出从源头开始最长的一条变异链，编号间以 1 个空格分隔，行首尾不得有多余空格。如果最长链不唯一，则输出最小序列。&lt;/p&gt;
&lt;p&gt;注：我们称序列 { &lt;em&gt;a&lt;/em&gt;1,⋯,&lt;em&gt;a**n&lt;/em&gt; } 比序列 { &lt;em&gt;b&lt;/em&gt;1,⋯,&lt;em&gt;b**n&lt;/em&gt; } “小”，如果存在 1≤&lt;em&gt;k&lt;/em&gt;≤&lt;em&gt;n&lt;/em&gt; 满足 &lt;em&gt;a**i&lt;/em&gt;&amp;#x3D;&lt;em&gt;b**i&lt;/em&gt; 对所有 &lt;em&gt;i&lt;/em&gt;&amp;lt;&lt;em&gt;k&lt;/em&gt; 成立，且 &lt;em&gt;a**k&lt;/em&gt;&amp;lt;&lt;em&gt;b**k&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;10
3 6 4 8
0
0
0
2 5 9
0
1 7
1 2
0
2 3 1结尾无空行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;4
0 4 9 1结尾无空行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：-2&#34;&gt;&lt;a href=&#34;#程序源代码：-2&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
vector&amp;lt;int&amp;gt; ans, tmp;
bool a[10005][10005];
bool book[10005];
int maxn;
int n;
void dfs(int root,int len)
&amp;#123;
    if(len&amp;gt;maxn)
    &amp;#123;
        maxn =len;
        ans = tmp;

    &amp;#125;
    else if(len == maxn &amp;amp;&amp;amp; tmp &amp;lt; ans)
    &amp;#123;
        ans = tmp;
    &amp;#125;
    for (int i = 0; i &amp;lt;n ; ++i)
    &amp;#123;
        if(a[root][i]) //连通
        &amp;#123;
            tmp.push_back(i);
            dfs(i,len+1);
            tmp.pop_back();
        &amp;#125;
    &amp;#125;
    return ;
&amp;#125;
int main() &amp;#123;

    cin&amp;gt;&amp;gt;n;
    int root=0;
    for (int i = 0; i &amp;lt;n ; ++i) &amp;#123;
        int k;
        cin&amp;gt;&amp;gt;k;
        for (int j = 0; j &amp;lt;k ; ++j) &amp;#123;
            int x;
            cin&amp;gt;&amp;gt;x;
            book[x]=true;    //用来判断谁是病毒源头，题目给出病毒源头有且仅有一个
            a[i][x]=true;    //使用邻接矩阵来储存图，连通为true，否则为false
        &amp;#125;
    &amp;#125;
    while(book[root]) root++;  //寻找病毒源头
    tmp.push_back(root);
    dfs(root,1); //从病毒源头开始dfs
    cout&amp;lt;&amp;lt;ans.size()&amp;lt;&amp;lt;endl;
    //输出格式控制
    for(int i=0; i &amp;lt; ans.size(); i++)&amp;#123;
       if(i!=ans.size()-1)
       &amp;#123;
           cout&amp;lt;&amp;lt;ans[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
       &amp;#125;
       else
       &amp;#123;
           cout&amp;lt;&amp;lt;ans[i];
       &amp;#125;
        
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;样题四：L2-020-功夫传人-25-分&#34;&gt;&lt;a href=&#34;#样题四：L2-020-功夫传人-25-分&#34; class=&#34;headerlink&#34; title=&#34;样题四：L2-020 功夫传人 (25 分)&#34;&gt;&lt;/a&gt;样题四：&lt;strong&gt;L2-020 功夫传人 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&#34;题目描述：-3&#34;&gt;&lt;a href=&#34;#题目描述：-3&#34; class=&#34;headerlink&#34; title=&#34;题目描述：&#34;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。&lt;/p&gt;
&lt;p&gt;这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第&lt;code&gt;i&lt;/code&gt;代传人只能在第&lt;code&gt;i-1&lt;/code&gt;代传人中拜1个师傅。我们假设已知祖师爷的功力值为&lt;code&gt;Z&lt;/code&gt;，每向下传承一代，就会减弱&lt;code&gt;r%&lt;/code&gt;，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：-1&#34;&gt;&lt;a href=&#34;#输入格式：-1&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出3个正整数，分别是：&lt;em&gt;N&lt;/em&gt;（≤105）——整个师门的总人数（于是每个人从0到&lt;em&gt;N&lt;/em&gt;−1编号，祖师爷的编号为0）；&lt;em&gt;Z&lt;/em&gt;——祖师爷的功力值（不一定是整数，但起码是正数）；&lt;em&gt;r&lt;/em&gt; ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有&lt;em&gt;N&lt;/em&gt;行，第&lt;em&gt;i&lt;/em&gt;行（&lt;em&gt;i&lt;/em&gt;&amp;#x3D;0,⋯,&lt;em&gt;N&lt;/em&gt;−1）描述编号为&lt;em&gt;i&lt;/em&gt;的人所传的徒弟，格式为：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;K**i&lt;/em&gt; ID[1] ID[2] ⋯ ID[&lt;em&gt;K**i&lt;/em&gt;]&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;K**i&lt;/em&gt;是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。&lt;em&gt;K**i&lt;/em&gt;为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：-1&#34;&gt;&lt;a href=&#34;#输出格式：-1&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过1010。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：-1&#34;&gt;&lt;a href=&#34;#输入样例：-1&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;10 18.0 1.00
3 2 3 5
1 9
1 4
1 7
0 7
2 6 1
1 8
0 9
0 4
0 3结尾无空行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：-1&#34;&gt;&lt;a href=&#34;#输出样例：-1&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;404
结尾无空行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：-3&#34;&gt;&lt;a href=&#34;#程序源代码：-3&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
vector&amp;lt;int&amp;gt; tree[100000];  //用于邻接表建树
int book[100000];
double sum;
double r;
void dfs(int index,double power)
&amp;#123;
    if(book[index]) //是得道者就乘他的倍数 
    &amp;#123;
        sum += power * book[index];
        return ;
    &amp;#125;
    for(int i=0;i&amp;lt;tree[index].size();i++)  //遍历整个树
    &amp;#123;
        dfs(tree[index][i],power*r);
    &amp;#125;
&amp;#125;
int main() &amp;#123;
    int n;
    double z;
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;z&amp;gt;&amp;gt;r;
    r=(100-r)/100.0;
    for(int i=0;i&amp;lt;n;i++)
    &amp;#123;
        int k;
        cin&amp;gt;&amp;gt;k;
        if(k==0)   //这个弟子是否为得道者
        &amp;#123;
            int power;
            cin&amp;gt;&amp;gt;power;
            book[i]=power;   //记录得道者放大倍数
        &amp;#125;
        else&amp;#123;
            for(int j=0;j&amp;lt;k;j++)
            &amp;#123;
                int id;
                cin&amp;gt;&amp;gt;id;
                tree[i].push_back(id);      //使用邻接表建树
            &amp;#125;
        &amp;#125;
    &amp;#125;
    dfs(0,z);
    cout&amp;lt;&amp;lt;(int)sum&amp;lt;&amp;lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;题目相关链接：&#34;&gt;&lt;a href=&#34;#题目相关链接：&#34; class=&#34;headerlink&#34; title=&#34;题目相关链接：&#34;&gt;&lt;/a&gt;题目相关链接：&lt;/h2&gt;&lt;p&gt;[&lt;a href=&#34;https://www.luogu.com.cn/problem/P2404&#34;&gt;P2404 自然数的拆分问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)&lt;/a&gt;]: 	“ 样例二-自然数的拆分问题”&lt;/p&gt;
&lt;p&gt;[&lt;a href=&#34;https://www.luogu.com.cn/problem/P2404&#34;&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652361&#34;&gt;题目详情 - L2-038 病毒溯源 (25 分) (pintia.cn)&lt;/a&gt;&lt;/a&gt;]: 	“ 样例三-L2-038 病毒溯源 (25 分)”&lt;/p&gt;
&lt;p&gt;[&lt;a href=&#34;https://www.luogu.com.cn/problem/P2404&#34;&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805059118809088&#34;&gt;题目详情 - L2-020 功夫传人 (25 分) (pintia.cn)&lt;/a&gt;&lt;/a&gt;]: 	“ 样例四-L2-020 功夫传人 (25 分)”&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
