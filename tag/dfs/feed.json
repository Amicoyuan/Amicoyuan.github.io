{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"dfs\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/04/15/Algorithm025/",
            "url": "http://example.com/2022/04/15/Algorithm025/",
            "title": "L2-013 红色警报 (25 分)",
            "date_published": "2022-04-15T13:09:30.000Z",
            "content_html": "<h2 id=\"L2-013-红色警报-25-分\"><a href=\"#L2-013-红色警报-25-分\" class=\"headerlink\" title=\"L2-013 红色警报 (25 分)\"></a>L2-013 红色警报 (25 分)</h2><p>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出两个整数<code>N</code>（0 &lt; <code>N</code> ≤ 500）和<code>M</code>（≤ 5000），分别为城市个数（于是默认城市从0到<code>N</code>-1编号）和连接两城市的通路条数。随后<code>M</code>行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数<code>K</code>和随后的<code>K</code>个被攻占的城市的编号。</p>\n<p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出<code>Red Alert: City k is lost!</code>，其中<code>k</code>是该城市的编号；否则只输出<code>City k is lost.</code>即可。如果该国失去了最后一个城市，则增加一行输出<code>Game Over.</code>。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">5 4\n0 1\n1 3\n3 0\n0 4\n5\n1 2 0 4 3\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">City 1 is lost.\nCity 2 is lost.\nRed Alert: City 0 is lost!\nCity 4 is lost.\nCity 3 is lost.\nGame Over.\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接矩阵建图 + DFS统计连通分量数</strong></p>\n<p><strong>对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数</strong></p>\n<p><strong>无向图中的极大连通子图称为连通分量</strong></p>\n<p><strong>极大连通子图必须连通，且包含尽可能多的顶点和边</strong></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint g[505][505];\t\t\t\t\t\t//邻接矩阵存图\nint visit[505];\t\t\t\t\t\t\t//标记访问数组\nint lost[505];\t\t\t\t\t\t\t//记录被攻占的城市\nvoid dfs(int node)&#123;\t\t\t\t\t\t//正常的DFS\n    visit[node]=1;\n    for(int i=0;i<n;i++)\n    &#123;\n        if(visit[i]==0&&g[node][i]==1)\n        &#123;\n            dfs(i);\n        &#125;\n    &#125;\n&#125;\nint dfstrave()&#123;\n    int cnt=0;\n    memset(visit,0,sizeof(visit));\t\t\t//初始化访问数组\n    for(int i=0;i<n;i++)&#123;\n        if(lost[i]==1) visit[i]=1;\t\t\t//如果该城市被攻占，则标记他为以访问\n    &#125;\n    for(int i=0;i<n;i++)&#123;\n        if(visit[i]==0)&#123;\n            dfs(i);\n            cnt++;      \t\t\t\t\t//统计连通分量数\n        &#125;\n    &#125;\n    return cnt;\n&#125;\nint main()\n&#123;\n    cin>>n>>m;\n    memset(lost,0,sizeof(lost));\t\t\t//初始化\n    memset(g,0,sizeof(g));\t\t\t\t\t//初始化\n    for(int i=0;i<m;i++)&#123;\n        int a,b;\n        cin>>a>>b;\n        g[a][b]=g[b][a]=1;\t\t\t\t\t//存储无向图\n    &#125;\n    int cnt=dfstrave();\t\t\t\t\t\t//获得初始的连通分量数\n    int k;\n    cin>>k;\n    for(int w=0;w<k;w++)&#123;\n        int city;\n        cin>>city;\n        lost[city]=1;\t\t\t\t\t\t//记录该城市被攻占\n        for(int i=0;i<n;i++)&#123;\n            if(g[city][i]==1)&#123;\t\t\t\t\n                g[city][i]=g[i][city]=0;\t//标记和他相连的城市不再相连\n            &#125;\n        &#125;\n        int tempcnt=dfstrave();\t\t\t\t//当前的连通分量\n        if(tempcnt<=cnt)&#123;\t\t\t\t\t//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变\n            printf(\"City %d is lost.\\n\", city);\n        &#125;else&#123;\t\t\t\t\t\t\t\t//否则，连通性被改变了\n            printf(\"Red Alert: City %d is lost!\\n\", city);\n        &#125;\n        cnt=tempcnt;\t\t\t\t\t\t//更新连通分量\n        if(w==n-1)&#123;\t\t\t\t\t\t\t//城市已经被攻占完毕\n            printf(\"Game Over.\\n\");\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208\">题目详情 - L2-013 红色警报 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Graph",
                "邻接矩阵",
                "DFS"
            ]
        },
        {
            "id": "http://example.com/2021/12/21/algorithm001/",
            "url": "http://example.com/2021/12/21/algorithm001/",
            "title": "DFS-深度优先搜索",
            "date_published": "2021-12-21T13:25:36.000Z",
            "content_html": "<h1 id=\"DFS-深度优先搜索\"><a href=\"#DFS-深度优先搜索\" class=\"headerlink\" title=\"DFS-深度优先搜索\"></a>DFS-深度优先搜索</h1><h2 id=\"样题1-全排列\"><a href=\"#样题1-全排列\" class=\"headerlink\" title=\"样题1-全排列\"></a>样题1-全排列</h2><h3 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h3><p>输入一个数n，输出n的全排列</p>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><pre class=\" language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[100];\nint book[100];\nvoid dfs(int step)\n&#123;\n    int i;\n    if(step==n+1)  //这里表示dfs结束,没有可以排的数字了\n    &#123;\n        for (i = 1;  i<=n ; i++) &#123;\n            cout<<a[i]<<\" \";\n        &#125;\n        cout<<endl;\n        return ;\n    &#125;\n    for(int i=1;i<=n;i++)\n    &#123;\n        if(book[i]==0)  //说明数字i还没有被使用,可以用来排列\n        &#123;\n            a[step]=i;//排列数字i\n            book[i]=1;//标记数字i为已使用\n            dfs(step+1);\n            //继续排列没有使用的数字\n            book[i]=0;\n            //这里表示dfs调用结束了,意思是数字i已经全部排列完了，但还需要\n            //按照顺序将数字i收回，重新排列。\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    cin>>n;\n    dfs(1); //dfs函数的开始\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"程序输入：\"><a href=\"#程序输入：\" class=\"headerlink\" title=\"程序输入：\"></a>程序输入：</h3><pre class=\" language-c++\"><code class=\"language-c++\">3\n</code></pre>\n<h3 id=\"程序输出：\"><a href=\"#程序输出：\" class=\"headerlink\" title=\"程序输出：\"></a>程序输出：</h3><pre class=\" language-c++\"><code class=\"language-c++\">1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1\n</code></pre>\n<h2 id=\"样题二-自然数的拆分问题\"><a href=\"#样题二-自然数的拆分问题\" class=\"headerlink\" title=\"样题二-自然数的拆分问题\"></a>样题二-自然数的拆分问题</h2><h3 id=\"题目描述：-1\"><a href=\"#题目描述：-1\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h3><p>任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。现在给你一个自然数n，要求你求出n的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。</p>\n<h3 id=\"程序源代码：-1\"><a href=\"#程序源代码：-1\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><pre class=\" language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nint num;\nint a[100000]=&#123;1&#125;;\nvoid dfs(int n,int t)\n&#123;\n    if(n==0)\n    &#123;\n        for(int i=1;i<=t-1;i++)//输出一种拆分方案\n\n            if(i!=t-1) cout<<a[i]<<\"+\";\n            else cout<<a[i];\n        cout<<endl;\n        return ;\n    &#125;\n    for (int i=a[t-1];i<=n;i++) &#123;\n        if(i<num)//当前数i要大于等于前一位数，且不超过n\n        &#123;\n            a[t]=i;//保存当前拆分的数i\n            n-=i;//n减去数i，n的值将继续拆分\n            dfs(n,t+1);\n            n+=i;//回溯：加上拆分的数，以便产生所有可能的拆分\n        &#125;\n    &#125;\n    return ;\n\n&#125;\nint main()\n&#123;\n    cin>>num;\n    dfs(num,1);\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"程序输入：-1\"><a href=\"#程序输入：-1\" class=\"headerlink\" title=\"程序输入：\"></a>程序输入：</h3><pre class=\" language-c++\"><code class=\"language-c++\">7\n</code></pre>\n<h3 id=\"程序输出：-1\"><a href=\"#程序输出：-1\" class=\"headerlink\" title=\"程序输出：\"></a>程序输出：</h3><pre class=\" language-c++\"><code class=\"language-c++\">1+1+1+1+1+1+1\n1+1+1+1+1+2\n1+1+1+1+3\n1+1+1+2+2\n1+1+1+4\n1+1+2+3\n1+1+5\n1+2+2+2\n1+2+4\n1+3+3\n1+6\n2+2+3\n2+5\n3+4\n</code></pre>\n<h2 id=\"样例三：L2-038-病毒溯源-25-分\"><a href=\"#样例三：L2-038-病毒溯源-25-分\" class=\"headerlink\" title=\"样例三：L2-038 病毒溯源 (25 分)\"></a>样例三：<strong>L2-038 病毒溯源 (25 分)</strong></h2><h3 id=\"题目描述：-2\"><a href=\"#题目描述：-2\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h3><p>病毒容易发生变异。某种病毒可以通过突变产生若干变异的毒株，而这些变异的病毒又可能被诱发突变产生第二代变异，如此继续不断变化。</p>\n<p>现给定一些病毒之间的变异关系，要求你找出其中最长的一条变异链。</p>\n<p>在此假设给出的变异都是由突变引起的，不考虑复杂的基因重组变异问题 —— 即每一种病毒都是由唯一的一种病毒突变而来，并且不存在循环变异的情况。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行中给出一个正整数 <em>N</em>（≤104），即病毒种类的总数。于是我们将所有病毒从 0 到 <em>N</em>−1 进行编号。</p>\n<p>随后 <em>N</em> 行，每行按以下格式描述一种病毒的变异情况：</p>\n<pre><code>k 变异株1 …… 变异株k\n</code></pre>\n<p>其中 <code>k</code> 是该病毒产生的变异毒株的种类数，后面跟着每种变异株的编号。第 <em>i</em> 行对应编号为 <em>i</em> 的病毒（0≤<em>i</em>&lt;<em>N</em>）。题目保证病毒源头有且仅有一个。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>首先输出从源头开始最长变异链的长度。</p>\n<p>在第二行中输出从源头开始最长的一条变异链，编号间以 1 个空格分隔，行首尾不得有多余空格。如果最长链不唯一，则输出最小序列。</p>\n<p>注：我们称序列 { <em>a</em>1,⋯,<em>a**n</em> } 比序列 { <em>b</em>1,⋯,<em>b**n</em> } “小”，如果存在 1≤<em>k</em>≤<em>n</em> 满足 <em>a**i</em>&#x3D;<em>b**i</em> 对所有 <em>i</em>&lt;<em>k</em> 成立，且 <em>a**k</em>&lt;<em>b**k</em>。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">10\n3 6 4 8\n0\n0\n0\n2 5 9\n0\n1 7\n1 2\n0\n2 3 1结尾无空行\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">4\n0 4 9 1结尾无空行\n</code></pre>\n<h3 id=\"程序源代码：-2\"><a href=\"#程序源代码：-2\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><pre class=\" language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nvector<int> ans, tmp;\nbool a[10005][10005];\nbool book[10005];\nint maxn;\nint n;\nvoid dfs(int root,int len)\n&#123;\n    if(len>maxn)\n    &#123;\n        maxn =len;\n        ans = tmp;\n\n    &#125;\n    else if(len == maxn && tmp < ans)\n    &#123;\n        ans = tmp;\n    &#125;\n    for (int i = 0; i <n ; ++i)\n    &#123;\n        if(a[root][i]) //连通\n        &#123;\n            tmp.push_back(i);\n            dfs(i,len+1);\n            tmp.pop_back();\n        &#125;\n    &#125;\n    return ;\n&#125;\nint main() &#123;\n\n    cin>>n;\n    int root=0;\n    for (int i = 0; i <n ; ++i) &#123;\n        int k;\n        cin>>k;\n        for (int j = 0; j <k ; ++j) &#123;\n            int x;\n            cin>>x;\n            book[x]=true;    //用来判断谁是病毒源头，题目给出病毒源头有且仅有一个\n            a[i][x]=true;    //使用邻接矩阵来储存图，连通为true，否则为false\n        &#125;\n    &#125;\n    while(book[root]) root++;  //寻找病毒源头\n    tmp.push_back(root);\n    dfs(root,1); //从病毒源头开始dfs\n    cout<<ans.size()<<endl;\n    //输出格式控制\n    for(int i=0; i < ans.size(); i++)&#123;\n       if(i!=ans.size()-1)\n       &#123;\n           cout<<ans[i]<<\" \";\n       &#125;\n       else\n       &#123;\n           cout<<ans[i];\n       &#125;\n        \n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"样题四：L2-020-功夫传人-25-分\"><a href=\"#样题四：L2-020-功夫传人-25-分\" class=\"headerlink\" title=\"样题四：L2-020 功夫传人 (25 分)\"></a>样题四：<strong>L2-020 功夫传人 (25 分)</strong></h2><h3 id=\"题目描述：-3\"><a href=\"#题目描述：-3\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h3><p>一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。</p>\n<p>这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第<code>i</code>代传人只能在第<code>i-1</code>代传人中拜1个师傅。我们假设已知祖师爷的功力值为<code>Z</code>，每向下传承一代，就会减弱<code>r%</code>，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。</p>\n<h3 id=\"输入格式：-1\"><a href=\"#输入格式：-1\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出3个正整数，分别是：<em>N</em>（≤105）——整个师门的总人数（于是每个人从0到<em>N</em>−1编号，祖师爷的编号为0）；<em>Z</em>——祖师爷的功力值（不一定是整数，但起码是正数）；<em>r</em> ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有<em>N</em>行，第<em>i</em>行（<em>i</em>&#x3D;0,⋯,<em>N</em>−1）描述编号为<em>i</em>的人所传的徒弟，格式为：</p>\n<p><em>K**i</em> ID[1] ID[2] ⋯ ID[<em>K**i</em>]</p>\n<p>其中<em>K**i</em>是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。<em>K**i</em>为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。</p>\n<h3 id=\"输出格式：-1\"><a href=\"#输出格式：-1\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过1010。</p>\n<h3 id=\"输入样例：-1\"><a href=\"#输入样例：-1\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">10 18.0 1.00\n3 2 3 5\n1 9\n1 4\n1 7\n0 7\n2 6 1\n1 8\n0 9\n0 4\n0 3结尾无空行\n</code></pre>\n<h3 id=\"输出样例：-1\"><a href=\"#输出样例：-1\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">404\n结尾无空行\n</code></pre>\n<h3 id=\"程序源代码：-3\"><a href=\"#程序源代码：-3\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><pre class=\" language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nvector<int> tree[100000];  //用于邻接表建树\nint book[100000];\ndouble sum;\ndouble r;\nvoid dfs(int index,double power)\n&#123;\n    if(book[index]) //是得道者就乘他的倍数 \n    &#123;\n        sum += power * book[index];\n        return ;\n    &#125;\n    for(int i=0;i<tree[index].size();i++)  //遍历整个树\n    &#123;\n        dfs(tree[index][i],power*r);\n    &#125;\n&#125;\nint main() &#123;\n    int n;\n    double z;\n    cin>>n>>z>>r;\n    r=(100-r)/100.0;\n    for(int i=0;i<n;i++)\n    &#123;\n        int k;\n        cin>>k;\n        if(k==0)   //这个弟子是否为得道者\n        &#123;\n            int power;\n            cin>>power;\n            book[i]=power;   //记录得道者放大倍数\n        &#125;\n        else&#123;\n            for(int j=0;j<k;j++)\n            &#123;\n                int id;\n                cin>>id;\n                tree[i].push_back(id);      //使用邻接表建树\n            &#125;\n        &#125;\n    &#125;\n    dfs(0,z);\n    cout<<(int)sum<<endl;\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"题目相关链接：\"><a href=\"#题目相关链接：\" class=\"headerlink\" title=\"题目相关链接：\"></a>题目相关链接：</h2><p>[<a href=\"https://www.luogu.com.cn/problem/P2404\">P2404 自然数的拆分问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>]: \t“ 样例二-自然数的拆分问题”</p>\n<p>[<a href=\"https://www.luogu.com.cn/problem/P2404\"><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652361\">题目详情 - L2-038 病毒溯源 (25 分) (pintia.cn)</a></a>]: \t“ 样例三-L2-038 病毒溯源 (25 分)”</p>\n<p>[<a href=\"https://www.luogu.com.cn/problem/P2404\"><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805059118809088\">题目详情 - L2-020 功夫传人 (25 分) (pintia.cn)</a></a>]: \t“ 样例四-L2-020 功夫传人 (25 分)”</p>\n",
            "tags": [
                "DFS"
            ]
        }
    ]
}