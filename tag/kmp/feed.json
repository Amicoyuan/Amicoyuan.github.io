{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"kmp\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/04/27/Algorithm034/",
            "url": "http://example.com/2022/04/27/Algorithm034/",
            "title": "串的模式匹配算法-KMP算法",
            "date_published": "2022-04-27T11:39:05.000Z",
            "content_html": "<h2 id=\"串的模式匹配算法-KMP算法\"><a href=\"#串的模式匹配算法-KMP算法\" class=\"headerlink\" title=\"串的模式匹配算法-KMP算法\"></a>串的模式匹配算法-KMP算法</h2><h3 id=\"求next数组\"><a href=\"#求next数组\" class=\"headerlink\" title=\"求next数组\"></a>求next数组</h3><pre><code class=\"c++\">void get_next(SSting t,int next[])\n&#123;\n    int i=1,j=0;\n    next[1]=0;\n    while(i&lt;t.length)\n    &#123;\n        if(j==0||t.ch[i]==t.ch[j])\n        &#123;\n            i++;\n            j++;\n            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1\n        &#125;else&#123;\n            j=next[j];      //否则令j=next[j]，循环继续\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"KMP匹配算法\"><a href=\"#KMP匹配算法\" class=\"headerlink\" title=\"KMP匹配算法\"></a>KMP匹配算法</h3><pre><code class=\"c++\">int Index_KMP(SSting s,SSting t,int next[])&#123;\n    int i=1,j=1;\n    while (i&lt;=s.length&amp;&amp;j&lt;=t.length)&#123;\n        if(j==0||s.ch[i]==t.ch[j])\n        &#123;\n            j++;                    //继续比较后续字符\n            i++;\n        &#125;else&#123;\n            j=next[j];              //模式串向右移动\n        &#125;\n    &#125;\n    if(j&gt;t.length)\n    &#123;\n        return i-t.length;          //匹配成功\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"完整代码：\"><a href=\"#完整代码：\" class=\"headerlink\" title=\"完整代码：\"></a>完整代码：</h3><pre><code class=\"c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define MAXLEN 255\t\t\t\t\t//预定义最大串长\ntypedef struct&#123;\n    char ch[MAXLEN];\t\t\t\t//每个分量存储一个字符\n    int length;\t\t\t\t\t\t//串的实际长度\n&#125;SSting;\nvoid get_next(SSting t,int next[])\n&#123;\n    int i=1,j=0;\n    next[1]=0;\n    while(i&lt;t.length)\n    &#123;\n        if(j==0||t.ch[i]==t.ch[j])\n        &#123;\n            i++;\n            j++;\n            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1\n        &#125;else&#123;\n            j=next[j];      //否则令j=next[j]，循环继续\n        &#125;\n    &#125;\n&#125;\nint Index_KMP(SSting s,SSting t,int next[])&#123;\n    int i=1,j=1;\n    while (i&lt;=s.length&amp;&amp;j&lt;=t.length)&#123;\n        if(j==0||s.ch[i]==t.ch[j])\n        &#123;\n            j++;                    //继续比较后续字符\n            i++;\n        &#125;else&#123;\n            j=next[j];              //模式串向右移动\n        &#125;\n    &#125;\n    if(j&gt;t.length)\n    &#123;\n        return i-t.length;          //匹配成功\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\nint main()\n&#123;\n    SSting a,b;\n    string s1=&quot;ababcabcacbab&quot;;\n    string s2=&quot;abcac&quot;;\n    a.length=s1.size();\n    b.length=s2.size();\n    int next[s2.size()+1];\n    get_next(b,next);\n    for (int i = 0; i &lt;s1.size(); ++i) &#123;\t//初始化\n        a.ch[i+1]=s1[i];\n    &#125;\n    for (int j = 0; j &lt;s2.size() ; ++j) &#123;\t//初始化\n        b.ch[j+1]=s2[j];\n    &#125;\n    int x=Index_KMP(a,b,next);\n    if(x!=0)\n    &#123;\n        cout&lt;&lt;&quot;找到了位置是：&quot;&lt;&lt;x&lt;&lt;endl;\n    &#125;else&#123;\n        cout&lt;&lt;&quot;没有找到&quot;&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"程序输出：\"><a href=\"#程序输出：\" class=\"headerlink\" title=\"程序输出：\"></a>程序输出：</h3><pre><code class=\"c++\">找到了位置是：6\n</code></pre>\n",
            "tags": [
                "Data Structure",
                "String",
                "KMP"
            ]
        }
    ]
}