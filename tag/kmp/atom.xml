<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>Amicoyuan • Posts by &#34;kmp&#34; tag</title>
    <link href="http://example.com" />
    <updated>2022-04-27T11:39:05.000Z</updated>
    <category term="AVX" />
    <category term="Data Structure" />
    <category term="String" />
    <category term="Find" />
    <category term="STL" />
    <category term="C++" />
    <category term="Set" />
    <category term="团体程序设计天梯赛" />
    <category term="Sort" />
    <category term="LinkList" />
    <category term="双向链表" />
    <category term="Graph" />
    <category term="邻接表" />
    <category term="Vector" />
    <category term="Binary tree" />
    <category term="BFS" />
    <category term="模拟" />
    <category term="邻接矩阵" />
    <category term="DFS" />
    <category term="结构体" />
    <category term="贪心" />
    <category term="Double类型相等比较" />
    <category term="Map" />
    <category term="并查集" />
    <category term="Pair" />
    <category term="线索二叉树" />
    <category term="KMP" />
    <category term="Tree" />
    <category term="森林" />
    <category term="Linux" />
    <category term="MPI" />
    <category term="Numactl" />
    <category term="Slurm" />
    <category term="Tensorflow" />
    <category term="性能分析工具" />
    <category term="gcov" />
    <entry>
        <id>http://example.com/2022/04/27/Algorithm034/</id>
        <title>串的模式匹配算法-KMP算法</title>
        <link rel="alternate" href="http://example.com/2022/04/27/Algorithm034/"/>
        <content type="html">&lt;h2 id=&#34;串的模式匹配算法-KMP算法&#34;&gt;&lt;a href=&#34;#串的模式匹配算法-KMP算法&#34; class=&#34;headerlink&#34; title=&#34;串的模式匹配算法-KMP算法&#34;&gt;&lt;/a&gt;串的模式匹配算法-KMP算法&lt;/h2&gt;&lt;h3 id=&#34;求next数组&#34;&gt;&lt;a href=&#34;#求next数组&#34; class=&#34;headerlink&#34; title=&#34;求next数组&#34;&gt;&lt;/a&gt;求next数组&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;void get_next(SSting t,int next[])
&amp;#123;
    int i=1,j=0;
    next[1]=0;
    while(i&lt;t.length)
    &amp;#123;
        if(j==0||t.ch[i]==t.ch[j])
        &amp;#123;
            i++;
            j++;
            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1
        &amp;#125;else&amp;#123;
            j=next[j];      //否则令j=next[j]，循环继续
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;KMP匹配算法&#34;&gt;&lt;a href=&#34;#KMP匹配算法&#34; class=&#34;headerlink&#34; title=&#34;KMP匹配算法&#34;&gt;&lt;/a&gt;KMP匹配算法&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;int Index_KMP(SSting s,SSting t,int next[])&amp;#123;
    int i=1,j=1;
    while (i&lt;=s.length&amp;&amp;j&lt;=t.length)&amp;#123;
        if(j==0||s.ch[i]==t.ch[j])
        &amp;#123;
            j++;                    //继续比较后续字符
            i++;
        &amp;#125;else&amp;#123;
            j=next[j];              //模式串向右移动
        &amp;#125;
    &amp;#125;
    if(j&gt;t.length)
    &amp;#123;
        return i-t.length;          //匹配成功
    &amp;#125;else&amp;#123;
        return 0;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;完整代码：&#34;&gt;&lt;a href=&#34;#完整代码：&#34; class=&#34;headerlink&#34; title=&#34;完整代码：&#34;&gt;&lt;/a&gt;完整代码：&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
#define MAXLEN 255					//预定义最大串长
typedef struct&amp;#123;
    char ch[MAXLEN];				//每个分量存储一个字符
    int length;						//串的实际长度
&amp;#125;SSting;
void get_next(SSting t,int next[])
&amp;#123;
    int i=1,j=0;
    next[1]=0;
    while(i&lt;t.length)
    &amp;#123;
        if(j==0||t.ch[i]==t.ch[j])
        &amp;#123;
            i++;
            j++;
            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1
        &amp;#125;else&amp;#123;
            j=next[j];      //否则令j=next[j]，循环继续
        &amp;#125;
    &amp;#125;
&amp;#125;
int Index_KMP(SSting s,SSting t,int next[])&amp;#123;
    int i=1,j=1;
    while (i&lt;=s.length&amp;&amp;j&lt;=t.length)&amp;#123;
        if(j==0||s.ch[i]==t.ch[j])
        &amp;#123;
            j++;                    //继续比较后续字符
            i++;
        &amp;#125;else&amp;#123;
            j=next[j];              //模式串向右移动
        &amp;#125;
    &amp;#125;
    if(j&gt;t.length)
    &amp;#123;
        return i-t.length;          //匹配成功
    &amp;#125;else&amp;#123;
        return 0;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    SSting a,b;
    string s1=&#34;ababcabcacbab&#34;;
    string s2=&#34;abcac&#34;;
    a.length=s1.size();
    b.length=s2.size();
    int next[s2.size()+1];
    get_next(b,next);
    for (int i = 0; i &lt;s1.size(); ++i) &amp;#123;	//初始化
        a.ch[i+1]=s1[i];
    &amp;#125;
    for (int j = 0; j &lt;s2.size() ; ++j) &amp;#123;	//初始化
        b.ch[j+1]=s2[j];
    &amp;#125;
    int x=Index_KMP(a,b,next);
    if(x!=0)
    &amp;#123;
        cout&lt;&lt;&#34;找到了位置是：&#34;&lt;&lt;x&lt;&lt;endl;
    &amp;#125;else&amp;#123;
        cout&lt;&lt;&#34;没有找到&#34;&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出：&#34;&gt;&lt;a href=&#34;#程序输出：&#34; class=&#34;headerlink&#34; title=&#34;程序输出：&#34;&gt;&lt;/a&gt;程序输出：&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;找到了位置是：6
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Data Structure" />
        <category term="String" />
        <category term="KMP" />
        <updated>2022-04-27T11:39:05.000Z</updated>
    </entry>
</feed>
