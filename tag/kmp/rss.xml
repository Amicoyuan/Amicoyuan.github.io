<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan • Posts by &#34;kmp&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Wed, 27 Apr 2022 19:39:05 +0800</pubDate>
        <lastBuildDate>Wed, 27 Apr 2022 19:39:05 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>并查集</category>
        <category>Map</category>
        <category>Pair</category>
        <category>KMP</category>
        <category>线索二叉树</category>
        <category>Tree</category>
        <category>森林</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Numactl</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/27/Algorithm034/</guid>
            <title>串的模式匹配算法-KMP算法</title>
            <link>http://example.com/2022/04/27/Algorithm034/</link>
            <category>Data Structure</category>
            <category>String</category>
            <category>KMP</category>
            <pubDate>Wed, 27 Apr 2022 19:39:05 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;串的模式匹配算法-KMP算法&#34;&gt;&lt;a href=&#34;#串的模式匹配算法-KMP算法&#34; class=&#34;headerlink&#34; title=&#34;串的模式匹配算法-KMP算法&#34;&gt;&lt;/a&gt;串的模式匹配算法-KMP算法&lt;/h2&gt;&lt;h3 id=&#34;求next数组&#34;&gt;&lt;a href=&#34;#求next数组&#34; class=&#34;headerlink&#34; title=&#34;求next数组&#34;&gt;&lt;/a&gt;求next数组&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void get_next(SSting t,int next[])
&amp;#123;
    int i=1,j=0;
    next[1]=0;
    while(i&amp;lt;t.length)
    &amp;#123;
        if(j==0||t.ch[i]==t.ch[j])
        &amp;#123;
            i++;
            j++;
            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1
        &amp;#125;else&amp;#123;
            j=next[j];      //否则令j=next[j]，循环继续
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;KMP匹配算法&#34;&gt;&lt;a href=&#34;#KMP匹配算法&#34; class=&#34;headerlink&#34; title=&#34;KMP匹配算法&#34;&gt;&lt;/a&gt;KMP匹配算法&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;int Index_KMP(SSting s,SSting t,int next[])&amp;#123;
    int i=1,j=1;
    while (i&amp;lt;=s.length&amp;amp;&amp;amp;j&amp;lt;=t.length)&amp;#123;
        if(j==0||s.ch[i]==t.ch[j])
        &amp;#123;
            j++;                    //继续比较后续字符
            i++;
        &amp;#125;else&amp;#123;
            j=next[j];              //模式串向右移动
        &amp;#125;
    &amp;#125;
    if(j&amp;gt;t.length)
    &amp;#123;
        return i-t.length;          //匹配成功
    &amp;#125;else&amp;#123;
        return 0;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;完整代码：&#34;&gt;&lt;a href=&#34;#完整代码：&#34; class=&#34;headerlink&#34; title=&#34;完整代码：&#34;&gt;&lt;/a&gt;完整代码：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define MAXLEN 255					//预定义最大串长
typedef struct&amp;#123;
    char ch[MAXLEN];				//每个分量存储一个字符
    int length;						//串的实际长度
&amp;#125;SSting;
void get_next(SSting t,int next[])
&amp;#123;
    int i=1,j=0;
    next[1]=0;
    while(i&amp;lt;t.length)
    &amp;#123;
        if(j==0||t.ch[i]==t.ch[j])
        &amp;#123;
            i++;
            j++;
            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1
        &amp;#125;else&amp;#123;
            j=next[j];      //否则令j=next[j]，循环继续
        &amp;#125;
    &amp;#125;
&amp;#125;
int Index_KMP(SSting s,SSting t,int next[])&amp;#123;
    int i=1,j=1;
    while (i&amp;lt;=s.length&amp;amp;&amp;amp;j&amp;lt;=t.length)&amp;#123;
        if(j==0||s.ch[i]==t.ch[j])
        &amp;#123;
            j++;                    //继续比较后续字符
            i++;
        &amp;#125;else&amp;#123;
            j=next[j];              //模式串向右移动
        &amp;#125;
    &amp;#125;
    if(j&amp;gt;t.length)
    &amp;#123;
        return i-t.length;          //匹配成功
    &amp;#125;else&amp;#123;
        return 0;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    SSting a,b;
    string s1=&amp;quot;ababcabcacbab&amp;quot;;
    string s2=&amp;quot;abcac&amp;quot;;
    a.length=s1.size();
    b.length=s2.size();
    int next[s2.size()+1];
    get_next(b,next);
    for (int i = 0; i &amp;lt;s1.size(); ++i) &amp;#123;	//初始化
        a.ch[i+1]=s1[i];
    &amp;#125;
    for (int j = 0; j &amp;lt;s2.size() ; ++j) &amp;#123;	//初始化
        b.ch[j+1]=s2[j];
    &amp;#125;
    int x=Index_KMP(a,b,next);
    if(x!=0)
    &amp;#123;
        cout&amp;lt;&amp;lt;&amp;quot;找到了位置是：&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl;
    &amp;#125;else&amp;#123;
        cout&amp;lt;&amp;lt;&amp;quot;没有找到&amp;quot;&amp;lt;&amp;lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出：&#34;&gt;&lt;a href=&#34;#程序输出：&#34; class=&#34;headerlink&#34; title=&#34;程序输出：&#34;&gt;&lt;/a&gt;程序输出：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;找到了位置是：6
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>
