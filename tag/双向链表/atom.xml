<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>Amicoyuan • Posts by &#34;双向链表&#34; tag</title>
    <link href="http://example.com" />
    <updated>2022-04-12T01:50:11.000Z</updated>
    <category term="AVX" />
    <category term="Data Structure" />
    <category term="String" />
    <category term="Find" />
    <category term="STL" />
    <category term="C++" />
    <category term="Set" />
    <category term="团体程序设计天梯赛" />
    <category term="Sort" />
    <category term="LinkList" />
    <category term="双向链表" />
    <category term="Graph" />
    <category term="邻接表" />
    <category term="Vector" />
    <category term="Binary tree" />
    <category term="BFS" />
    <category term="模拟" />
    <category term="邻接矩阵" />
    <category term="DFS" />
    <category term="结构体" />
    <category term="贪心" />
    <category term="Double类型相等比较" />
    <category term="并查集" />
    <category term="Map" />
    <category term="Pair" />
    <category term="线索二叉树" />
    <category term="KMP" />
    <category term="Tree" />
    <category term="森林" />
    <category term="Linux" />
    <category term="MPI" />
    <category term="Numactl" />
    <category term="Slurm" />
    <category term="Tensorflow" />
    <category term="性能分析工具" />
    <category term="gcov" />
    <entry>
        <id>http://example.com/2022/04/12/Algorithm017/</id>
        <title>L2-022 重排链表 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/12/Algorithm017/"/>
        <content type="html">&lt;h2 id=&#34;L2-022-重排链表-25-分&#34;&gt;&lt;a href=&#34;#L2-022-重排链表-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-022 重排链表 (25 分)&#34;&gt;&lt;/a&gt;L2-022 重排链表 (25 分)&lt;/h2&gt;&lt;p&gt;给定一个单链表 &lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;L&lt;/em&gt;2→⋯→&lt;em&gt;Ln&lt;/em&gt;−1→&lt;em&gt;Ln&lt;/em&gt;，请编写程序将链表重新排列为 &lt;em&gt;Ln&lt;/em&gt;→&lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;Ln&lt;/em&gt;−1→&lt;em&gt;L&lt;/em&gt;2→⋯。例如：给定&lt;em&gt;L&lt;/em&gt;为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数&lt;em&gt;N&lt;/em&gt; (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。&lt;/p&gt;
&lt;p&gt;接下来有&lt;em&gt;N&lt;/em&gt;行，每行格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Address Data Next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;Address&lt;/code&gt;是结点地址；&lt;code&gt;Data&lt;/code&gt;是该结点保存的数据，为不超过105的正整数；&lt;code&gt;Next&lt;/code&gt;是下一结点的地址。题目保证给出的链表上至少有两个结点。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;00100 6
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;68237 6 00100
00100 1 99999
99999 5 12309
12309 2 00000
00000 4 33218
33218 3 -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;利用双向链表，头尾指针来模拟&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
struct linklist&amp;#123;
    int address=0;			//记录当前结点的地址，虽然也没用到
    int data=0;				//记录数据域
    int next=0;				//指向下一个结点的地址
    int pre=0;				//指向上一个结点的地址
&amp;#125;l[100005];
int main()
&amp;#123;
    int start,back=-1;		//头尾指针
    int tmp;				//用来遍历当前链表用于统计链表的长度
    int n;
    cin&gt;&gt;start&gt;&gt;n;
    tmp=start;
    int address, data, next;
    l[start].pre=-1;	   //初始化第一个结点的前一个结点位置为-1
    int cnt=0;			  	//记录链表长
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
       cin&gt;&gt;address&gt;&gt;data&gt;&gt;next;
       l[address].address=address;
       l[address].data=data;
       l[address].next=next;
       if(next!=-1)&amp;#123;
           l[next].pre=address;				//设值上一个结点的地址
       &amp;#125;
    &amp;#125;
    //这道题比较坑的地方是会出现不是这个链表的结点，所以n不是真正的链表长，需要统计真正的链表长
    //如果没注意这点，第三个测试点会不通过，不过也能得到21分
    while (true) &amp;#123;
        cnt++;				//统计链表长	
        if(l[tmp].next==-1)&amp;#123;
            back=tmp;       //尾指针
            break;
        &amp;#125;
        tmp=l[tmp].next;
    &amp;#125;
    int flag=0;
    //flag=0动尾指针,flag=1动头指针。我并没有改变原来链表！
    for (int k = 0; k &lt;cnt ; ++k) &amp;#123;
            if(flag==0)&amp;#123;
                if(k==cnt-1)&amp;#123;
                    printf(&#34;%05d %d %d\n&#34;,l[back].address,l[back].data,-1);
                &amp;#125;else&amp;#123;
                    printf(&#34;%05d %d %05d\n&#34;,l[back].address,l[back].data,start);
                &amp;#125;
                back=l[back].pre;
                flag=1;
            &amp;#125;
            else if(flag==1)&amp;#123;
                if(k==cnt-1)&amp;#123;
                    printf(&#34;%05d %d %d\n&#34;,l[start].address,l[start].data,-1);
                &amp;#125;else&amp;#123;
                    printf(&#34;%05d %d %05d\n&#34;,l[start].address,l[start].data,back);
                &amp;#125;
                start=l[start].next;
                flag=0;
            &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805057860517888&#34;&gt;题目详情 - L2-022 重排链表 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="LinkList" />
        <category term="双向链表" />
        <updated>2022-04-12T01:50:11.000Z</updated>
    </entry>
</feed>
