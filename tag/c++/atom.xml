<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>Amicoyuan • Posts by &#34;c++&#34; tag</title>
    <link href="http://example.com" />
    <updated>2022-04-23T13:50:27.000Z</updated>
    <category term="AVX" />
    <category term="Data Structure" />
    <category term="String" />
    <category term="Find" />
    <category term="STL" />
    <category term="C++" />
    <category term="Set" />
    <category term="团体程序设计天梯赛" />
    <category term="Sort" />
    <category term="LinkList" />
    <category term="双向链表" />
    <category term="Graph" />
    <category term="邻接表" />
    <category term="Vector" />
    <category term="Binary tree" />
    <category term="BFS" />
    <category term="模拟" />
    <category term="邻接矩阵" />
    <category term="DFS" />
    <category term="结构体" />
    <category term="贪心" />
    <category term="Double类型相等比较" />
    <category term="Map" />
    <category term="并查集" />
    <category term="Pair" />
    <category term="线索二叉树" />
    <category term="KMP" />
    <category term="Tree" />
    <category term="森林" />
    <category term="Linux" />
    <category term="MPI" />
    <category term="Numactl" />
    <category term="Slurm" />
    <category term="Tensorflow" />
    <category term="性能分析工具" />
    <category term="gcov" />
    <entry>
        <id>http://example.com/2022/04/23/Algorithm032/</id>
        <title>L2-036 网红点打卡攻略 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/23/Algorithm032/"/>
        <content type="html">&lt;h2 id=&#34;L2-036-网红点打卡攻略-25-分&#34;&gt;&lt;a href=&#34;#L2-036-网红点打卡攻略-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-036 网红点打卡攻略 (25 分)&#34;&gt;&lt;/a&gt;L2-036 网红点打卡攻略 (25 分)&lt;/h2&gt;&lt;p&gt;一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;首先第一行给出两个正整数：网红点的个数 &lt;em&gt;N&lt;/em&gt;（1&amp;lt;&lt;em&gt;N&lt;/em&gt;≤200）和网红点之间通路的条数 &lt;em&gt;M&lt;/em&gt;。随后 &lt;em&gt;M&lt;/em&gt; 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 &lt;em&gt;N&lt;/em&gt; 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再下一行给出一个正整数 &lt;em&gt;K&lt;/em&gt;，是待检验的攻略的数量。随后 &lt;em&gt;K&lt;/em&gt; 行，每行给出一条待检攻略，格式为：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;n&lt;/em&gt; &lt;em&gt;V&lt;/em&gt;1 &lt;em&gt;V&lt;/em&gt;2 ⋯ Vn&lt;/p&gt;
&lt;p&gt;其中 &lt;em&gt;n&lt;/em&gt;(≤200) 是攻略中的网红点数，&lt;em&gt;Vi&lt;/em&gt; 是路径上的网红点编号。这里假设你从家里出发，从 &lt;em&gt;V&lt;/em&gt;1 开始打卡，最后从 &lt;em&gt;Vn&lt;/em&gt; 回家。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在第一行输出满足要求的攻略的个数。&lt;/p&gt;
&lt;p&gt;在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。&lt;/p&gt;
&lt;p&gt;题目保证至少存在一个有效攻略，并且总路费不超过 109。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;6 13
0 5 2
6 2 2
6 0 1
3 4 2
1 5 2
2 5 1
3 1 1
4 1 2
1 6 1
6 3 2
1 2 1
4 5 3
2 0 2
7
6 5 1 4 3 6 2
6 5 2 1 6 3 4
8 6 2 1 6 3 4 5 2
3 2 1 5
6 6 1 3 4 5 2
7 6 2 1 3 4 5 2
6 5 2 1 4 3 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;3
5 11
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;样例说明：&#34;&gt;&lt;a href=&#34;#样例说明：&#34; class=&#34;headerlink&#34; title=&#34;样例说明：&#34;&gt;&lt;/a&gt;样例说明：&lt;/h3&gt;&lt;p&gt;第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。&lt;/p&gt;
&lt;p&gt;第 1 条攻略的总路费是：(0-&amp;gt;5) 2 + (5-&amp;gt;1) 2 + (1-&amp;gt;4) 2 + (4-&amp;gt;3) 2 + (3-&amp;gt;6) 2 + (6-&amp;gt;2) 2 + (2-&amp;gt;0) 2 &amp;#x3D; 14；&lt;/p&gt;
&lt;p&gt;第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &amp;#x3D; 11，是一条更省钱的攻略；&lt;/p&gt;
&lt;p&gt;第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &amp;#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。&lt;/p&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
int g[205][205];
int minsize=INT_MAX;			//初始化为INT_MAX
int minid=0;
int main()
&amp;#123;
    cin&gt;&gt;n&gt;&gt;m;
    int cnt=0;
    memset(g,0,sizeof(g));
    for (int i = 0; i &lt;m ; ++i) &amp;#123;
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        g[a][b]=c;
        g[b][a]=c;
    &amp;#125;
    int time;
    cin&gt;&gt;time;
    for (int j = 0; j &lt;time ; ++j) &amp;#123;
        int k;
        cin&gt;&gt;k;
        int roll[k+5];
        int has[k+5];
        memset(has,0,sizeof(has));
        roll[0]=roll[k+1]=0;					//起点和终点必定是家
        for (int i = 1; i &lt;=k ; ++i) &amp;#123;
            cin&gt;&gt;roll[i];
            if(has[roll[i]]) has[0]=1;			//每个打卡点仅能打卡一次
            else has[roll[i]]=1;
        &amp;#125;
        int flag=1;
        int tmpsize=0;
        if(k!=n||has[0]) continue;
        for (int l = 1; l &lt;=k+1 ; ++l) &amp;#123;
            if(g[roll[l-1]][roll[l]]==0)
            &amp;#123;
                flag=0;
                break;
            &amp;#125;
            tmpsize+=g[roll[l-1]][roll[l]];
        &amp;#125;
        if(flag==1)
        &amp;#123;
            if(tmpsize&lt;minsize)&amp;#123;
                minsize=tmpsize;
                minid=j+1;

            &amp;#125;
            cnt++;
        &amp;#125;
    &amp;#125;
    cout&lt;&lt;cnt&lt;&lt;endl;
    cout&lt;&lt;minid&lt;&lt;&#34; &#34;&lt;&lt;minsize&lt;&lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059&#34;&gt;题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Graph" />
        <category term="邻接矩阵" />
        <updated>2022-04-23T13:50:27.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/23/Algorithm031/</id>
        <title>L2-039 清点代码库 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/23/Algorithm031/"/>
        <content type="html">&lt;h2 id=&#34;L2-039-清点代码库-25-分&#34;&gt;&lt;a href=&#34;#L2-039-清点代码库-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-039 清点代码库 (25 分)&#34;&gt;&lt;/a&gt;L2-039 清点代码库 (25 分)&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg&#34; alt=&#34;code.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”&lt;/p&gt;
&lt;p&gt;这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 &lt;strong&gt;int&lt;/strong&gt; 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行中给出 2 个正整数，依次为 &lt;em&gt;N&lt;/em&gt;（≤104）和 &lt;em&gt;M&lt;/em&gt;（≤102），对应功能模块的个数和系列测试输入的个数。&lt;/p&gt;
&lt;p&gt;随后 &lt;em&gt;N&lt;/em&gt; 行，每行给出一个功能模块的 &lt;em&gt;M&lt;/em&gt; 个对应输出，数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先在第一行输出不同功能的个数 &lt;em&gt;K&lt;/em&gt;。随后 &lt;em&gt;K&lt;/em&gt; 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。&lt;/p&gt;
&lt;p&gt;注：所谓数列 { &lt;em&gt;A&lt;/em&gt;1, …, &lt;em&gt;A&lt;/em&gt;M } 比 { &lt;em&gt;B&lt;/em&gt;1, …, &lt;em&gt;B&lt;/em&gt;M } 大，是指存在 1≤i&amp;lt;*M*，使得 *A*1&amp;#x3D;*B*1，…，*Ai*&amp;#x3D;*Bi* 成立，且 *Ai*+1&amp;gt;&lt;em&gt;B&lt;/em&gt;+1。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;7 3
35 28 74
-1 -1 22
28 74 35
-1 -1 22
11 66 0
35 28 74
35 28 74
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;4
3 35 28 74
2 -1 -1 22
1 11 66 0
1 28 74 35
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;利用map的映射关系&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;vector&lt;int&gt;,int&gt; mp;   //key，value
vector&lt;int&gt; tmp;
int n,m;
bool cmp(pair&lt;vector&lt;int&gt;,int&gt; a,pair&lt;vector&lt;int&gt;,int&gt; b)
&amp;#123;
    if(a.second==b.second)
    &amp;#123;
        return a.first&lt;b.first;
    &amp;#125;
    return a.second&gt;b.second;

&amp;#125;
int main()
&amp;#123;
    cin&gt;&gt;n&gt;&gt;m;
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        for (int j = 0; j &lt; m; ++j) &amp;#123;
            int num;
            cin&gt;&gt;num;
            tmp.push_back(num);
        &amp;#125;
        mp[tmp]++;
        tmp.clear();
    &amp;#125;
    vector&lt;pair&lt;vector&lt;int&gt;,int&gt;&gt; v(mp.begin(),mp.end());		//把map类型转化成vector
    cout&lt;&lt;v.size()&lt;&lt;endl;
    sort(v.begin(),v.end(),cmp);								//sort排序，注意终点和起点
    for (int k = 0; k &lt;v.size() ; ++k) &amp;#123;
        cout&lt;&lt;v[k].second&lt;&lt;&#34; &#34;;
        for (int i = 0; i &lt;m ; ++i) &amp;#123;
            if(i!=m-1)&amp;#123;
                cout&lt;&lt;v[k].first[i]&lt;&lt;&#34; &#34;;
            &amp;#125; else&amp;#123;
                cout&lt;&lt;v[k].first[i]&lt;&lt;endl;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362&#34;&gt;题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Sort" />
        <category term="Vector" />
        <category term="Map" />
        <category term="Pair" />
        <updated>2022-04-23T13:44:47.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/23/Algorithm030/</id>
        <title>L2-005 集合相似度 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/23/Algorithm030/"/>
        <content type="html">&lt;h2 id=&#34;L2-005-集合相似度-25-分&#34;&gt;&lt;a href=&#34;#L2-005-集合相似度-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-005 集合相似度 (25 分)&#34;&gt;&lt;/a&gt;L2-005 集合相似度 (25 分)&lt;/h2&gt;&lt;p&gt;给定两个整数集合，它们的相似度定义为：Nc&amp;#x2F;Nt×100%。其中Nc是两个集合都有的不相等整数的个数，Nt是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出一个正整数&lt;em&gt;N&lt;/em&gt;（≤50），是集合的个数。随后&lt;em&gt;N&lt;/em&gt;行，每行对应一个集合。每个集合首先给出一个正整数&lt;em&gt;M&lt;/em&gt;（≤104），是集合中元素的个数；然后跟&lt;em&gt;M&lt;/em&gt;个[0,109]区间内的整数。&lt;/p&gt;
&lt;p&gt;之后一行给出一个正整数&lt;em&gt;K&lt;/em&gt;（≤2000），随后&lt;em&gt;K&lt;/em&gt;行，每行对应一对需要计算相似度的集合的编号（集合从1到&lt;em&gt;N&lt;/em&gt;编号）。数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每一对需要计算的集合，在一行中输出它们的相似度，为保留小数点后2位的百分比数字。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;3
3 99 87 101
4 87 101 5 87
7 99 101 18 5 135 18 99
2
1 2
1 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;50.00%
33.33%
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;双set模拟&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
&amp;#123;
    int n;
    set&lt;int&gt; s[55];
    cin&gt;&gt;n;
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        int time;
        cin&gt;&gt;time;
        for (int j = 0; j &lt;time ; ++j) &amp;#123;
            int num;
            cin&gt;&gt;num;
            s[i].insert(num);
        &amp;#125;
    &amp;#125;
    int find;
    cin&gt;&gt;find;
    for (int l = 0; l &lt;find ; ++l) &amp;#123;
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        int sum=0;
        set&lt;int&gt;::iterator it;								//迭代器
        int cnt=0;
        for (it=s[a-1].begin(); it!=s[a-1].end() ; it++) &amp;#123;
            if(s[b-1].find(*it)!=s[b-1].end())&amp;#123;				//找到了
                cnt++;										//Nc
            &amp;#125;
        &amp;#125;
        sum=s[a-1].size()+s[b-1].size()-cnt;				//Nt=两个集合的总个数-相同个数
        double ans=double(double(cnt)/double(sum))*100.0;
        printf(&#34;%.2lf%\n&#34;,ans);

    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805070149828608&#34;&gt;题目详情 - L2-005 集合相似度 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="C++" />
        <category term="Set" />
        <category term="团体程序设计天梯赛" />
        <category term="模拟" />
        <updated>2022-04-23T13:39:53.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/16/Algorithm028/</id>
        <title>L2-010 排座位 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/16/Algorithm028/"/>
        <content type="html">&lt;h2 id=&#34;L2-010-排座位-25-分&#34;&gt;&lt;a href=&#34;#L2-010-排座位-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-010 排座位 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-010 排座位 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出3个正整数：&lt;code&gt;N&lt;/code&gt;（≤100），即前来参宴的宾客总人数，则这些人从1到&lt;code&gt;N&lt;/code&gt;编号；&lt;code&gt;M&lt;/code&gt;为已知两两宾客之间的关系数；&lt;code&gt;K&lt;/code&gt;为查询的条数。随后&lt;code&gt;M&lt;/code&gt;行，每行给出一对宾客之间的关系，格式为：&lt;code&gt;宾客1 宾客2 关系&lt;/code&gt;，其中&lt;code&gt;关系&lt;/code&gt;为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后&lt;code&gt;K&lt;/code&gt;行，每行给出一对需要查询的宾客编号。&lt;/p&gt;
&lt;p&gt;这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出&lt;code&gt;No problem&lt;/code&gt;；如果他们之间并不是朋友，但也不敌对，则输出&lt;code&gt;OK&lt;/code&gt;；如果他们之间有敌对，然而也有共同的朋友，则输出&lt;code&gt;OK but...&lt;/code&gt;；如果他们之间只有敌对关系，则输出&lt;code&gt;No way&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;7 8 4
5 6 1
2 7 -1
1 3 1
3 4 1
6 7 -1
1 2 1
1 4 1
2 3 -1
3 4
5 7
2 3
7 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;No problem
OK
OK but...
No way
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接矩阵 + 并查集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并查集具体链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/01/04/Algorithm004/&#34;&gt;并查集 - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
int pre[100];				//父节点
int deep[100];				//深度
int g[101][101];			//邻接矩阵建图
void init(int n)&amp;#123;
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        pre[i]=i;
        deep[i]=0;
    &amp;#125;
&amp;#125;
int find(int x)&amp;#123;
    if(pre[x]==x)&amp;#123;
        return x;
    &amp;#125; else&amp;#123;
        return pre[x]=find(pre[x]);
    &amp;#125;
&amp;#125;
void unit(int x,int y)&amp;#123;
    x=find(x);
    y=find(y);
    if(x==y) return;
    if(deep[x]&lt;deep[y])&amp;#123;
        pre[x]=y;
    &amp;#125;else&amp;#123;
        pre[y]=x;
        if(deep[x]==deep[y])&amp;#123;
            deep[x]++;
        &amp;#125;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    int n,m,k;
    init(105);
    memset(g,0,sizeof(g));
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    for (int i = 0; i &lt;m ; ++i) &amp;#123;
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        g[a][b]=g[b][a]=c;
        if(c==1) unit(a,b);					//如果是朋友则合并
    &amp;#125;
    for (int j = 0; j &lt;k ; ++j) &amp;#123;
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        if(g[a][b]==1&amp;&amp;g[b][a]==1) cout&lt;&lt;&#34;No problem&#34;&lt;&lt;endl;
        else if(g[a][b]==0&amp;&amp;g[b][a]==0) cout&lt;&lt;&#34;OK&#34;&lt;&lt;endl;			//两人毫无关系
        else if(g[a][b]==-1&amp;&amp;g[b][a]==-1&amp;&amp;find(a)==find(b)) cout&lt;&lt;&#34;OK but...&#34;&lt;&lt;endl;	//敌对且有共同朋友
        else if(g[a][b]==-1&amp;&amp;g[b][a]==-1) cout&lt;&lt;&#34;No way&#34;&lt;&lt;endl;		//仅敌对
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_45260385/article/details/109752008&#34;&gt;(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680&#34;&gt;题目详情 - L2-010 排座位 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Graph" />
        <category term="邻接矩阵" />
        <category term="并查集" />
        <updated>2022-04-16T06:57:46.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/16/Algorithm027/</id>
        <title>L2-009 抢红包 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/16/Algorithm027/"/>
        <content type="html">&lt;h2 id=&#34;L2-009-抢红包-25-分&#34;&gt;&lt;a href=&#34;#L2-009-抢红包-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-009 抢红包 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-009 抢红包 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;没有人没抢过红包吧…… 这里给出&lt;em&gt;N&lt;/em&gt;个人之间互相发红包、抢红包的记录，请你统计一下他们抢红包的收获。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出一个正整数&lt;em&gt;N&lt;/em&gt;（≤104），即参与发红包和抢红包的总人数，则这些人从1到&lt;em&gt;N&lt;/em&gt;编号。随后&lt;em&gt;N&lt;/em&gt;行，第&lt;em&gt;i&lt;/em&gt;行给出编号为&lt;em&gt;i&lt;/em&gt;的人发红包的记录，格式如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;K     N&lt;/em&gt;1 &lt;em&gt;P&lt;/em&gt;1⋯ NK PK&lt;/p&gt;
&lt;p&gt;其中&lt;em&gt;K&lt;/em&gt;（0≤&lt;em&gt;K&lt;/em&gt;≤20）是发出去的红包个数，&lt;em&gt;N&lt;/em&gt;i&lt;em&gt;是抢到红包的人的编号，&lt;/em&gt;Pi（&amp;gt;0）是其抢到的红包金额（以分为单位）。注意：对于同一个人发出的红包，每人最多只能抢1次，不能重复抢。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;按照收入金额从高到低的递减顺序输出每个人的编号和收入金额（以元为单位，输出小数点后2位）。每个人的信息占一行，两数字间有1个空格。如果收入金额有并列，则按抢到红包的个数递减输出；如果还有并列，则按个人编号递增输出。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;10
3 2 22 10 58 8 125
5 1 345 3 211 5 233 7 13 8 101
1 7 8800
2 1 1000 2 1000
2 4 250 10 320
6 5 11 9 22 8 33 7 44 10 55 4 2
1 3 8800
2 1 23 2 123
1 8 250
4 2 121 4 516 7 112 9 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;1 11.63
2 3.63
8 3.63
3 2.11
7 1.69
6 -1.67
9 -2.18
10 -3.26
5 -3.26
4 -12.32
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;结构体 + Sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的就是double类型相等的比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，浮点数在计算机中并不能精确的表示，所以在判断两个double类型的数时需要其他的手段，而不是直接 a&amp;#x3D;&amp;#x3D; b&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
struct student&amp;#123;
    int id=0;
    double money=0;
    int cnt=0;
&amp;#125;;
double dis=1e-6;				//定义一个误差
bool cmp(student a,student b)&amp;#123;
    if(abs(a.money-b.money)&lt;dis)&amp;#123;				//如果两个double型相减在误差的范围内，我们认定这两个double类型相等
        if(a.cnt==b.cnt)&amp;#123;
            return a.id&lt;b.id;
        &amp;#125;else&amp;#123;
            return a.cnt&gt;b.cnt;
        &amp;#125;
    &amp;#125;
    return a.money&gt;b.money;
&amp;#125;
int main()
&amp;#123;
    int n;
    cin&gt;&gt;n;
    student st[n+5];
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        int time;
        cin&gt;&gt;time;
        st[i].id=i+1;
        for (int j = 0; j &lt;time ; ++j) &amp;#123;
            int p;
            double x;
            cin&gt;&gt;p&gt;&gt;x;
            st[p-1].money+=x/100;
            st[i].money-=x/100;
            st[p-1].cnt++;					//记录抢到的红包数
        &amp;#125;
    &amp;#125;
    sort(st,st+n,cmp);						//sort从数组下标0开始排序，左闭右开
    for (int k = 0; k &lt;n ; ++k) &amp;#123;
        printf(&#34;%d %.2lf\n&#34;,st[k].id,st[k].money);
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/dingpiao190/article/details/73512811?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=1&#34;&gt;(20条消息) double类型是否相等的判断方法_dingpiao190的博客-CSDN博客_double判断相等&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/patrick_star_cowboy/article/details/82083392&#34;&gt;(20条消息) 如何判断两个double类型的数是否相等？_Patrick-Star的博客-CSDN博客_两个double怎么判断相等&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805066890854400&#34;&gt;题目详情 - L2-009 抢红包 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Sort" />
        <category term="结构体" />
        <category term="Double类型相等比较" />
        <updated>2022-04-16T06:57:38.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/15/Algorithm026/</id>
        <title>L2-003 月饼 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/15/Algorithm026/"/>
        <content type="html">&lt;h2 id=&#34;L2-003-月饼-25-分&#34;&gt;&lt;a href=&#34;#L2-003-月饼-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-003 月饼 (25 分)&#34;&gt;&lt;/a&gt;L2-003 月饼 (25 分)&lt;/h2&gt;&lt;p&gt;月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。&lt;/p&gt;
&lt;p&gt;注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45&amp;#x2F;2 &amp;#x3D; 94.5（亿元）。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 &lt;em&gt;N&lt;/em&gt; 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 &lt;em&gt;D&lt;/em&gt; 表示市场最大需求量。随后一行给出 &lt;em&gt;N&lt;/em&gt; 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 &lt;em&gt;N&lt;/em&gt; 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;3 20
18 15 10
75 72 45
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;94.50
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;贪心 + Sort&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
struct mooncake&amp;#123;
    double pow;
    double price;
&amp;#125;;
bool cmp(mooncake a,mooncake b)&amp;#123;
    return a.price*1.0/a.pow&gt;b.price*1.0/b.pow;				//返回单价高的
&amp;#125;
int main()
&amp;#123;
    int n;
    double d;
    cin&gt;&gt;n&gt;&gt;d;
    mooncake m[n];
    for (int i = 0; i &lt; n; ++i) &amp;#123;
        cin&gt;&gt;m[i].pow;
    &amp;#125;
    for (int j = 0; j &lt;n ; ++j) &amp;#123;
        cin&gt;&gt;m[j].price;
    &amp;#125;
    sort(m,m+n,cmp);
    double price=0.0;
    double tmpd=d;
    for (int k = 0; k &lt;n ; ++k) &amp;#123;						//模拟求解
        if(m[k].pow&lt;=tmpd)&amp;#123;
            tmpd-=m[k].pow;
            price+=m[k].price;
        &amp;#125;else if(m[k].pow&gt;tmpd)&amp;#123;
            price+=tmpd*(m[k].price/m[k].pow);
            break;
        &amp;#125;
    &amp;#125;
    printf(&#34;%.2f\n&#34;,price);
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805071789801472&#34;&gt;题目详情 - L2-003 月饼 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Sort" />
        <category term="结构体" />
        <category term="贪心" />
        <updated>2022-04-15T14:03:52.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/15/Algorithm025/</id>
        <title>L2-013 红色警报 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/15/Algorithm025/"/>
        <content type="html">&lt;h2 id=&#34;L2-013-红色警报-25-分&#34;&gt;&lt;a href=&#34;#L2-013-红色警报-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-013 红色警报 (25 分)&#34;&gt;&lt;/a&gt;L2-013 红色警报 (25 分)&lt;/h2&gt;&lt;p&gt;战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出两个整数&lt;code&gt;N&lt;/code&gt;（0 &amp;lt; &lt;code&gt;N&lt;/code&gt; ≤ 500）和&lt;code&gt;M&lt;/code&gt;（≤ 5000），分别为城市个数（于是默认城市从0到&lt;code&gt;N&lt;/code&gt;-1编号）和连接两城市的通路条数。随后&lt;code&gt;M&lt;/code&gt;行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数&lt;code&gt;K&lt;/code&gt;和随后的&lt;code&gt;K&lt;/code&gt;个被攻占的城市的编号。&lt;/p&gt;
&lt;p&gt;注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个被攻占的城市，如果它会改变整个国家的连通性，则输出&lt;code&gt;Red Alert: City k is lost!&lt;/code&gt;，其中&lt;code&gt;k&lt;/code&gt;是该城市的编号；否则只输出&lt;code&gt;City k is lost.&lt;/code&gt;即可。如果该国失去了最后一个城市，则增加一行输出&lt;code&gt;Game Over.&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;5 4
0 1
1 3
3 0
0 4
5
1 2 0 4 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;City 1 is lost.
City 2 is lost.
Red Alert: City 0 is lost!
City 4 is lost.
City 3 is lost.
Game Over.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接矩阵建图 + DFS统计连通分量数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无向图中的极大连通子图称为连通分量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极大连通子图必须连通，且包含尽可能多的顶点和边&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
int g[505][505];						//邻接矩阵存图
int visit[505];							//标记访问数组
int lost[505];							//记录被攻占的城市
void dfs(int node)&amp;#123;						//正常的DFS
    visit[node]=1;
    for(int i=0;i&lt;n;i++)
    &amp;#123;
        if(visit[i]==0&amp;&amp;g[node][i]==1)
        &amp;#123;
            dfs(i);
        &amp;#125;
    &amp;#125;
&amp;#125;
int dfstrave()&amp;#123;
    int cnt=0;
    memset(visit,0,sizeof(visit));			//初始化访问数组
    for(int i=0;i&lt;n;i++)&amp;#123;
        if(lost[i]==1) visit[i]=1;			//如果该城市被攻占，则标记他为以访问
    &amp;#125;
    for(int i=0;i&lt;n;i++)&amp;#123;
        if(visit[i]==0)&amp;#123;
            dfs(i);
            cnt++;      					//统计连通分量数
        &amp;#125;
    &amp;#125;
    return cnt;
&amp;#125;
int main()
&amp;#123;
    cin&gt;&gt;n&gt;&gt;m;
    memset(lost,0,sizeof(lost));			//初始化
    memset(g,0,sizeof(g));					//初始化
    for(int i=0;i&lt;m;i++)&amp;#123;
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        g[a][b]=g[b][a]=1;					//存储无向图
    &amp;#125;
    int cnt=dfstrave();						//获得初始的连通分量数
    int k;
    cin&gt;&gt;k;
    for(int w=0;w&lt;k;w++)&amp;#123;
        int city;
        cin&gt;&gt;city;
        lost[city]=1;						//记录该城市被攻占
        for(int i=0;i&lt;n;i++)&amp;#123;
            if(g[city][i]==1)&amp;#123;				
                g[city][i]=g[i][city]=0;	//标记和他相连的城市不再相连
            &amp;#125;
        &amp;#125;
        int tempcnt=dfstrave();				//当前的连通分量
        if(tempcnt&lt;=cnt)&amp;#123;					//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变
            printf(&#34;City %d is lost.\n&#34;, city);
        &amp;#125;else&amp;#123;								//否则，连通性被改变了
            printf(&#34;Red Alert: City %d is lost!\n&#34;, city);
        &amp;#125;
        cnt=tempcnt;						//更新连通分量
        if(w==n-1)&amp;#123;							//城市已经被攻占完毕
            printf(&#34;Game Over.\n&#34;);
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208&#34;&gt;题目详情 - L2-013 红色警报 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Graph" />
        <category term="邻接矩阵" />
        <category term="DFS" />
        <updated>2022-04-15T13:09:30.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/14/Algorithm024/</id>
        <title>L2-011 玩转二叉树 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/14/Algorithm024/"/>
        <content type="html">&lt;h2 id=&#34;L2-011-玩转二叉树-25-分&#34;&gt;&lt;a href=&#34;#L2-011-玩转二叉树-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-011 玩转二叉树 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-011 玩转二叉树 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出一个正整数&lt;code&gt;N&lt;/code&gt;（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;7
1 2 3 4 5 6 7
4 1 3 2 6 5 7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;4 6 1 7 5 3 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;镜面反转即为在层序遍历时交换左右子树的遍历顺序，左-&amp;gt;右变成右-&amp;gt;左&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前序 + 中序 建树 + BFS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建树详细过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/04/07/Algorithm014/&#34;&gt;由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef struct BiTNode&amp;#123;
    int data;
    struct BiTNode *lchild,*rchild;
&amp;#125;BiTNode,*BiTree;
int n;
int in[35];
int pre[35];
BiTree PostCreate(int prel,int prer,int inl,int inr)&amp;#123;					//前序加中序建树
    if(prel&gt;prer)&amp;#123;
        return NULL;
    &amp;#125;
    BiTNode *root;
    root=(BiTNode*)malloc(sizeof(BiTNode));
    root-&gt;data=pre[prel];
    int index=0;
    for (int i = inl; i &lt;=inr; ++i) &amp;#123;
        if(pre[prel]==in[i])&amp;#123;
            index=i;
            break;
        &amp;#125;
    &amp;#125;
    int numleft=index-inl;
    root-&gt;lchild=PostCreate(prel+1,prel+numleft,inl,index-1);
    root-&gt;rchild=PostCreate(prel+numleft+1,prer,index+1,inr);
    return root;
&amp;#125;
void LevelOrder(BiTree T)
&amp;#123;
    queue&lt;BiTree&gt; q;
    q.push(T);
    int i=0;
    while (!q.empty())&amp;#123;
        BiTNode *tmp =q.front();
        q.pop();
        if(i!=n-1)&amp;#123;										//输出格式控制
            cout&lt;&lt;tmp-&gt;data&lt;&lt;&#34; &#34;;
        &amp;#125;else&amp;#123;
            cout&lt;&lt;tmp-&gt;data;
        &amp;#125;
        i++;
        if(tmp-&gt;rchild!=NULL)&amp;#123;							//镜面反转，左-&gt;右变成右-&gt;左
            q.push(tmp-&gt;rchild);
        &amp;#125;
        if(tmp-&gt;lchild!=NULL)&amp;#123;
            q.push(tmp-&gt;lchild);
        &amp;#125;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    BiTree tree;
    tree=NULL;
    cin&gt;&gt;n;
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        cin&gt;&gt;in[i];
    &amp;#125;
    for (int j = 0; j &lt;n ; ++j) &amp;#123;
        cin&gt;&gt;pre[j];
    &amp;#125;
    tree=PostCreate(0,n-1,0,n-1);
    LevelOrder(tree);
    cout&lt;&lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784&#34;&gt;题目详情 - L2-011 玩转二叉树 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/04/07/Algorithm014/&#34;&gt;由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Binary tree" />
        <category term="BFS" />
        <updated>2022-04-14T06:01:10.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/14/Algorithm023/</id>
        <title>L2-035 完全二叉树的层序遍历 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/14/Algorithm023/"/>
        <content type="html">&lt;h2 id=&#34;L2-035-完全二叉树的层序遍历-25-分&#34;&gt;&lt;a href=&#34;#L2-035-完全二叉树的层序遍历-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-035 完全二叉树的层序遍历 (25 分)&#34;&gt;&lt;/a&gt;L2-035 完全二叉树的层序遍历 (25 分)&lt;/h2&gt;&lt;p&gt;一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是&lt;strong&gt;完美二叉树&lt;/strong&gt;。对于深度为 &lt;em&gt;D&lt;/em&gt; 的，有 &lt;em&gt;N&lt;/em&gt; 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 &lt;em&gt;N&lt;/em&gt; 个结点，这样的树就是&lt;strong&gt;完全二叉树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行中给出正整数 &lt;em&gt;N&lt;/em&gt;（≤30），即树中结点个数。第二行给出后序遍历序列，为 &lt;em&gt;N&lt;/em&gt; 个不超过 100 的正整数。同一行中所有数字都以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;8
91 71 2 34 10 15 55 18
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;18 34 55 71 2 10 15 91
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;后序遍历建树 + 完全二叉树性质&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
int tree[10001];
int n;
void post(int i)&amp;#123;		//根据后序遍历建树
    if(2*i&lt;=n)&amp;#123;			//当2*i&lt;=n时，结点i的左孩子编号为2*i，否则无左孩子
        post(2*i);
    &amp;#125;
    if(2*i+1&lt;=n)&amp;#123;		//当2*i+1&lt;=n时，结点i的右孩子编号为2*i+1，否则无右孩子
        post(2*i+1);
    &amp;#125;
    cin&gt;&gt;tree[i];
&amp;#125;
int main()
&amp;#123;

    cin&gt;&gt;n;
    post(1);           //后序遍历建树
    for (int i = 1; i &lt;=n ; ++i) &amp;#123;						//顺序输出即为层序遍历
        if(i!=n)&amp;#123;
            cout&lt;&lt;tree[i]&lt;&lt;&#34; &#34;;
        &amp;#125;else&amp;#123;
            cout&lt;&lt;tree[i];
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058&#34;&gt;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Binary tree" />
        <updated>2022-04-14T06:01:05.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/13/Algorithm022/</id>
        <title>L2-031 深入虎穴 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/13/Algorithm022/"/>
        <content type="html">&lt;p&gt;著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。&lt;/p&gt;
&lt;p&gt;内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入首先在一行中给出正整数 &lt;em&gt;N&lt;/em&gt;（&amp;lt;105），是门的数量。最后 &lt;em&gt;N&lt;/em&gt; 行，第 &lt;em&gt;i&lt;/em&gt; 行（1≤&lt;em&gt;i&lt;/em&gt;≤&lt;em&gt;N&lt;/em&gt;）按以下格式描述编号为 &lt;em&gt;i&lt;/em&gt; 的那扇门背后能通向的门：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;K D[1] D[2] ... D[K]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;K&lt;/code&gt; 是通道的数量，其后是每扇门的编号。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;13
3 2 3 4
2 5 6
1 7
1 8
1 9
0
2 11 10
1 13
0
0
1 12
0
0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;12
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接表 + BFS&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;int&gt; v[100005];
int book[100005];
int start=0;
int bfs()&amp;#123;								//BFS
    queue&lt;int&gt; q;
    q.push(start);						//根节点入队
    int x;
    while(!q.empty())&amp;#123;
        x=q.front();
        q.pop();
        for (int i = 0; i &lt;v[x].size() ; ++i) &amp;#123;				
            q.push(v[x][i]);
        &amp;#125;
    &amp;#125;									//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。
    return x;							//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门
&amp;#125;
int main()
&amp;#123;
    int n;
    cin&gt;&gt;n;
    for (int i = 1; i &lt;=n ; ++i) &amp;#123;
        int time;
        cin&gt;&gt;time;
        for (int j = 1; j &lt;=time ; ++j) &amp;#123;
            int num;
            cin&gt;&gt;num;
            book[num]=1;
            v[i].push_back(num);

        &amp;#125;
    &amp;#125;
    for (int k = 1; k &lt;=n ; ++k) &amp;#123;			//找入口
        if(book[k]==0) start=k;				//没有门通向的门，即为入口
    &amp;#125;
    int ans=bfs();
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888&#34;&gt;题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="邻接表" />
        <category term="Vector" />
        <category term="Binary tree" />
        <category term="BFS" />
        <updated>2022-04-13T11:09:46.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/13/Algorithm021/</id>
        <title>L2-040 哲哲打游戏 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/13/Algorithm021/"/>
        <content type="html">&lt;h2 id=&#34;L2-040-哲哲打游戏-25-分&#34;&gt;&lt;a href=&#34;#L2-040-哲哲打游戏-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-040 哲哲打游戏 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-040 哲哲打游戏 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;哲哲是一位硬核游戏玩家。最近一款名叫《达诺达诺》的新游戏刚刚上市，哲哲自然要快速攻略游戏，守护硬核游戏玩家的一切！&lt;/p&gt;
&lt;p&gt;为简化模型，我们不妨假设游戏有 &lt;em&gt;N&lt;/em&gt; 个剧情点，通过游戏里不同的操作或选择可以从某个剧情点去往另外一个剧情点。此外，游戏还设置了一些&lt;strong&gt;存档&lt;/strong&gt;，在某个剧情点可以将玩家的游戏进度保存在一个档位上，读取存档后可以回到剧情点，重新进行操作或者选择，到达不同的剧情点。&lt;/p&gt;
&lt;p&gt;为了追踪硬核游戏玩家哲哲的攻略进度，你打算写一个程序来完成这个工作。假设你已经知道了游戏的全部剧情点和流程，以及哲哲的游戏操作，请你输出哲哲的游戏进度。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行是两个正整数 &lt;em&gt;N&lt;/em&gt; 和 &lt;em&gt;M&lt;/em&gt; (1≤&lt;em&gt;N&lt;/em&gt;,&lt;em&gt;M&lt;/em&gt;≤105)，表示总共有 &lt;em&gt;N&lt;/em&gt; 个剧情点，哲哲有 &lt;em&gt;M&lt;/em&gt; 个游戏操作。&lt;/p&gt;
&lt;p&gt;接下来的 &lt;em&gt;N&lt;/em&gt; 行，每行对应一个剧情点的发展设定。第 &lt;em&gt;i&lt;/em&gt; 行的第一个数字是 &lt;em&gt;K**i&lt;/em&gt;，表示剧情点 &lt;em&gt;i&lt;/em&gt; 通过一些操作或选择能去往下面 &lt;em&gt;K**i&lt;/em&gt; 个剧情点；接下来有 &lt;em&gt;K**i&lt;/em&gt; 个数字，第 &lt;em&gt;k&lt;/em&gt; 个数字表示做第 &lt;em&gt;k&lt;/em&gt; 个操作或选择可以去往的剧情点编号。&lt;/p&gt;
&lt;p&gt;最后有 &lt;em&gt;M&lt;/em&gt; 行，每行第一个数字是 0、1 或 2，分别表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 表示哲哲做出了某个操作或选择，后面紧接着一个数字 &lt;em&gt;j&lt;/em&gt;，表示哲哲在当前剧情点做出了第 &lt;em&gt;j&lt;/em&gt; 个选择。我们保证哲哲的选择永远是合法的。&lt;/li&gt;
&lt;li&gt;1 表示哲哲进行了一次存档，后面紧接着是一个数字 &lt;em&gt;j&lt;/em&gt;，表示存档放在了第 &lt;em&gt;j&lt;/em&gt; 个档位上。&lt;/li&gt;
&lt;li&gt;2 表示哲哲进行了一次读取存档的操作，后面紧接着是一个数字 &lt;em&gt;j&lt;/em&gt;，表示读取了放在第 &lt;em&gt;j&lt;/em&gt; 个位置的存档。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;约定：所有操作或选择以及剧情点编号都从 1 号开始。存档的档位不超过 100 个，编号也从 1 开始。游戏默认从 1 号剧情点开始。总的选项数（即 ∑&lt;em&gt;K**i&lt;/em&gt;）不超过 106。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对于每个 1（即存档）操作，在一行中输出存档的剧情点编号。&lt;/p&gt;
&lt;p&gt;最后一行输出哲哲最后到达的剧情点编号。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;10 11
3 2 3 4
1 6
3 4 7 5
1 3
1 9
2 3 5
3 1 8 5
1 9
2 8 10
0
1 1
0 3
0 1
1 2
0 2
0 2
2 2
0 3
0 1
1 1
0 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;1
3
9
10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;样例解释：&#34;&gt;&lt;a href=&#34;#样例解释：&#34; class=&#34;headerlink&#34; title=&#34;样例解释：&#34;&gt;&lt;/a&gt;样例解释：&lt;/h3&gt;&lt;p&gt;简单给出样例中经过的剧情点顺序：&lt;/p&gt;
&lt;p&gt;1 -&amp;gt; 4 -&amp;gt; 3 -&amp;gt; 7 -&amp;gt; 8 -&amp;gt; 3 -&amp;gt; 5 -&amp;gt; 9 -&amp;gt; 10。&lt;/p&gt;
&lt;p&gt;档位 1 开始存的是 1 号剧情点；档位 2 存的是 3 号剧情点；档位 1 后来又存了 9 号剧情点。&lt;/p&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接表 + 模拟，主要是理解题意&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
&amp;#123;
    int n,k;
    cin&gt;&gt;n&gt;&gt;k;
    vector&lt;int&gt; v[n+1];
    int save[105];							//存档点
    int now=1;								//当前剧情点
    for (int i = 1; i &lt;=n ; ++i) &amp;#123;
        int num;
        cin&gt;&gt;num;
        for (int j = 0; j &lt;num ; ++j) &amp;#123;
            int x;
            cin&gt;&gt;x;
            v[i].push_back(x);				//邻接表存操作数
        &amp;#125;
    &amp;#125;
    for (int l = 0; l &lt;k ; ++l) &amp;#123;			//模拟过程
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        if(a==1)&amp;#123;
            save[b]=now;
            cout&lt;&lt;now&lt;&lt;endl;
        &amp;#125;
        if(a==0)&amp;#123;
            now=v[now][b-1];
        &amp;#125;
        if(a==2)&amp;#123;
            now=save[b];
        &amp;#125;
    &amp;#125;
    cout&lt;&lt;now&lt;&lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652363&#34;&gt;题目详情 - L2-040 哲哲打游戏 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="邻接表" />
        <category term="Vector" />
        <category term="模拟" />
        <updated>2022-04-13T11:09:41.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/13/Algorithm020/</id>
        <title>L2-027 名人堂与代金券 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/13/Algorithm020/"/>
        <content type="html">&lt;h2 id=&#34;L2-027-名人堂与代金券-25-分&#34;&gt;&lt;a href=&#34;#L2-027-名人堂与代金券-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-027 名人堂与代金券 (25 分)&#34;&gt;&lt;/a&gt;L2-027 名人堂与代金券 (25 分)&lt;/h2&gt;&lt;p&gt;对于在中国大学MOOC（&lt;a href=&#34;http://www.icourse163.org/&#34;&gt;http://www.icourse163.org/&lt;/a&gt; ）学习“数据结构”课程的学生，想要获得一张合格证书，总评成绩必须达到 60 分及以上，并且有另加福利：总评分在 [G, 100] 区间内者，可以得到 50 元 PAT 代金券；在 [60, G) 区间内者，可以得到 20 元PAT代金券。全国考点通用，一年有效。同时任课老师还会把总评成绩前 K 名的学生列入课程“名人堂”。本题就请你编写程序，帮助老师列出名人堂的学生，并统计一共发出了面值多少元的 PAT 代金券。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出 3 个整数，分别是 N（不超过 10 000 的正整数，为学生总数）、G（在 (60,100) 区间内的整数，为题面中描述的代金券等级分界线）、K（不超过 100 且不超过 N 的正整数，为进入名人堂的最低名次）。接下来 N 行，每行给出一位学生的账号（长度不超过15位、不带空格的字符串）和总评成绩（区间 [0, 100] 内的整数），其间以空格分隔。题目保证没有重复的账号。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先在一行中输出发出的 PAT 代金券的总面值。然后按总评成绩非升序输出进入名人堂的学生的名次、账号和成绩，其间以 1 个空格分隔。需要注意的是：成绩相同的学生享有并列的排名，排名并列时，按账号的字母序升序输出。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;10 80 5
cy@zju.edu.cn 78
cy@pat-edu.com 87
1001@qq.com 65
uh-oh@163.com 96
test@126.com 39
anyone@qq.com 87
zoe@mit.edu 80
jack@ucla.edu 88
bob@cmu.edu 80
ken@163.com 70
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;360
1 uh-oh@163.com 96
2 jack@ucla.edu 88
3 anyone@qq.com 87
3 cy@pat-edu.com 87
5 bob@cmu.edu 80
5 zoe@mit.edu 80
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;结构体数组+sort排序，需要注意输出格式控制&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
struct student&amp;#123;
    int score=0;
    string email;
&amp;#125;;
bool cmp(student a,student b)&amp;#123;
    if(a.score==b.score) return a.email&lt;b.email;		//如果分数相同返回字典序小的
    return a.score&gt;b.score;				//返回分数最大的
&amp;#125;
int main()
&amp;#123;
    int n,g,k;
    cin&gt;&gt;n&gt;&gt;g&gt;&gt;k;
    student st[n];
    int money=0;
    for (int i = 0; i &lt;n ; ++i) &amp;#123;					//输入加存钱
        cin&gt;&gt;st[i].email&gt;&gt;st[i].score;
        if(g&lt;=st[i].score&amp;&amp;st[i].score&lt;=100)&amp;#123;
            money+=50;
        &amp;#125;
        if(60&lt;=st[i].score&amp;&amp;st[i].score&lt;g)&amp;#123;
            money+=20;
        &amp;#125;
    &amp;#125;
    sort(st,st+n,cmp);								//排序
    cout&lt;&lt;money&lt;&lt;endl;
    int cnt =1;										//用来判断用否超过名人堂个数
    int i=0;										//遍历st结构体数组
    int same=1;										//分数相同的个数
    int fscore=st[0].score;							//用来判断分数是否相同
    //这道题就格式输出需要注意下！
    while(true) &amp;#123;

        if(fscore==st[i].score)&amp;#123;
            cout&lt;&lt;cnt&lt;&lt;&#34; &#34;&lt;&lt;st[i].email&lt;&lt;&#34; &#34;&lt;&lt;st[i].score&lt;&lt;endl;	//相同即输出
            if(i!=0) same++;		//不为0号，则same++。
        &amp;#125;
        if(fscore&gt;st[i].score)&amp;#123;
            cnt=cnt+same;			//不等，更新cnt值
            same=1;					//更新same值
            if(cnt&gt;k)&amp;#123; break;&amp;#125;		//大于名人堂个数结束
            cout&lt;&lt;cnt&lt;&lt;&#34; &#34;&lt;&lt;st[i].email&lt;&lt;&#34; &#34;&lt;&lt;st[i].score&lt;&lt;endl;
            fscore=st[i].score;		//更新用来判断分数是否相同的fscore

        &amp;#125;
        i++;

    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805055176163328&#34;&gt;题目详情 - L2-027 名人堂与代金券 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Sort" />
        <updated>2022-04-13T01:45:55.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/13/Algorithm019/</id>
        <title>L2-026 小字辈 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/13/Algorithm019/"/>
        <content type="html">&lt;h2 id=&#34;L2-026-小字辈-25-分&#34;&gt;&lt;a href=&#34;#L2-026-小字辈-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-026 小字辈 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-026 小字辈 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父&amp;#x2F;母。家谱中辈分最高的老祖宗对应的父&amp;#x2F;母编号为 -1。一行中的数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;9
2 6 5 5 -1 5 6 4 7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;4
1 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接表建树+BFS&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;int&gt; tree[100005];				//邻接表建树
int deeptree[100005];					//记录树的深度
int n;
int root;								//根节点
int bfs()&amp;#123;								//bfs
    queue&lt;int&gt; q;
    q.push(root);						//根节点入队
    int x;								
    while(!q.empty())&amp;#123;
        x=q.front();
        q.pop();
        for (int i = 0; i &lt;tree[x].size() ; ++i) &amp;#123;
            deeptree[tree[x][i]]=deeptree[x]+1;						//每一层的深度为上一层加1
            q.push(tree[x][i]);

        &amp;#125;
    &amp;#125;
    return deeptree[x];				//返回最后一个结点的深度，即深度的最大值
&amp;#125;
int main()
&amp;#123;
    n;
    cin&gt;&gt;n;
    int a[n];
    for (int i = 1; i &lt;=n ; ++i) &amp;#123;
        cin&gt;&gt;a[i];
        if(a[i]==-1)&amp;#123;
            root=i;				//找根节点
        &amp;#125;
    &amp;#125;
    for (int j = 1; j &lt;=n ; ++j) &amp;#123;					//建树
        tree[a[j]].push_back(j);					//j是a[j]的孩子节点
        if(a[j]==-1) deeptree[j]=1;					//初始化根节点深度为1
    &amp;#125;
    int ans=bfs();
    cout&lt;&lt;ans&lt;&lt;endl;
    int maxdeepcnt=0;								//记录最大深度的个数
    int tmp[n];										//找最大深度的id
    for (int k = 1; k &lt;=n ; ++k) &amp;#123;					
        if(ans==deeptree[k])&amp;#123;
            maxdeepcnt++;
            tmp[maxdeepcnt]=k;
        &amp;#125;
    &amp;#125;
    //输出格式控制
    for (int l = 1; l &lt;=maxdeepcnt ; ++l) &amp;#123;
        if(l!=maxdeepcnt) cout&lt;&lt;tmp[l]&lt;&lt;&#34; &#34;;
        else cout&lt;&lt;tmp[l]&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808&#34;&gt;题目详情 - L2-026 小字辈 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="邻接表" />
        <category term="Vector" />
        <category term="Binary tree" />
        <category term="BFS" />
        <updated>2022-04-13T01:45:49.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/12/Algorithm018/</id>
        <title>L2-023 图着色问题 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/12/Algorithm018/"/>
        <content type="html">&lt;h2 id=&#34;L2-023-图着色问题-25-分&#34;&gt;&lt;a href=&#34;#L2-023-图着色问题-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-023 图着色问题 (25 分)&#34;&gt;&lt;/a&gt;L2-023 图着色问题 (25 分)&lt;/h2&gt;&lt;p&gt;图着色问题是一个著名的NP完全问题。给定无向图&lt;em&gt;G&lt;/em&gt;&amp;#x3D;(&lt;em&gt;V&lt;/em&gt;,&lt;em&gt;E&lt;/em&gt;)，问可否用&lt;em&gt;K&lt;/em&gt;种颜色为&lt;em&gt;V&lt;/em&gt;中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？&lt;/p&gt;
&lt;p&gt;但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出3个整数&lt;em&gt;V&lt;/em&gt;（0&amp;lt;&lt;em&gt;V&lt;/em&gt;≤500）、&lt;em&gt;E&lt;/em&gt;（≥0）和&lt;em&gt;K&lt;/em&gt;（0&amp;lt;&lt;em&gt;K&lt;/em&gt;≤&lt;em&gt;V&lt;/em&gt;），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到&lt;em&gt;V&lt;/em&gt;编号。随后&lt;em&gt;E&lt;/em&gt;行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数&lt;em&gt;N&lt;/em&gt;（≤20），是待检查的颜色分配方案的个数。随后&lt;em&gt;N&lt;/em&gt;行，每行顺次给出&lt;em&gt;V&lt;/em&gt;个顶点的颜色（第&lt;em&gt;i&lt;/em&gt;个数字表示第&lt;em&gt;i&lt;/em&gt;个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每种颜色分配方案，如果是图着色问题的一个解则输出&lt;code&gt;Yes&lt;/code&gt;，否则输出&lt;code&gt;No&lt;/code&gt;，每句占一行。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;img src=&#34;/2022/04/12/Algorithm018/graph.png&#34; alt=&#34;graph&#34; style=&#34;zoom: 67%;&#34;&gt;

&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;6 8 3
2 1
1 3
4 6
2 5
2 4
5 4
5 6
3 6
4
1 2 3 3 1 2
4 5 6 6 4 5
1 2 3 4 5 6
2 3 4 2 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;Yes
Yes
No
No
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Set + 邻接表&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
&amp;#123;
    int v,e,k;
    cin&gt;&gt;v&gt;&gt;e&gt;&gt;k;
    vector&lt;int&gt; g[505];			//邻接表
    int color[505];				//记录颜色
    for (int i = 0; i &lt;e ; ++i) &amp;#123;       //建立邻接表
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        g[a].push_back(b);
        g[b].push_back(a);
    &amp;#125;
    int time;
    cin&gt;&gt;time;
    for (int j = 0; j &lt;time ; ++j) &amp;#123;
        int flag=1;
        set&lt;int&gt; s;					//用来统计颜色总数
        s.clear();
        for (int i = 1; i &lt;=v; ++i) &amp;#123;
            int num;
            cin&gt;&gt;num;
            color[i]=num;
            s.insert(num);
        &amp;#125;
        if(s.size()!=k)&amp;#123;			//如果颜色数不等于k即非法
            cout&lt;&lt;&#34;No&#34;&lt;&lt;endl;
            continue;
        &amp;#125;
        for (int l = 1; l &lt;=v ; ++l) &amp;#123;						//遍历邻接表
            for (int i = 0; i &lt;g[l].size(); ++i) &amp;#123;
                if(color[l]==color[g[l][i]])&amp;#123;				//如果相邻结点颜色一样则为假
                    flag=0;
                    break;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        if(flag==1)&amp;#123;
            cout&lt;&lt;&#34;Yes&#34;&lt;&lt;endl;
        &amp;#125;else&amp;#123;
            cout&lt;&lt;&#34;No&#34;&lt;&lt;endl;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805057298481152&#34;&gt;题目详情 - L2-023 图着色问题 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="Set" />
        <category term="团体程序设计天梯赛" />
        <category term="Graph" />
        <category term="邻接表" />
        <category term="Vector" />
        <updated>2022-04-12T10:59:52.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/12/Algorithm017/</id>
        <title>L2-022 重排链表 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/12/Algorithm017/"/>
        <content type="html">&lt;h2 id=&#34;L2-022-重排链表-25-分&#34;&gt;&lt;a href=&#34;#L2-022-重排链表-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-022 重排链表 (25 分)&#34;&gt;&lt;/a&gt;L2-022 重排链表 (25 分)&lt;/h2&gt;&lt;p&gt;给定一个单链表 &lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;L&lt;/em&gt;2→⋯→&lt;em&gt;Ln&lt;/em&gt;−1→&lt;em&gt;Ln&lt;/em&gt;，请编写程序将链表重新排列为 &lt;em&gt;Ln&lt;/em&gt;→&lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;Ln&lt;/em&gt;−1→&lt;em&gt;L&lt;/em&gt;2→⋯。例如：给定&lt;em&gt;L&lt;/em&gt;为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数&lt;em&gt;N&lt;/em&gt; (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。&lt;/p&gt;
&lt;p&gt;接下来有&lt;em&gt;N&lt;/em&gt;行，每行格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Address Data Next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;Address&lt;/code&gt;是结点地址；&lt;code&gt;Data&lt;/code&gt;是该结点保存的数据，为不超过105的正整数；&lt;code&gt;Next&lt;/code&gt;是下一结点的地址。题目保证给出的链表上至少有两个结点。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;00100 6
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;68237 6 00100
00100 1 99999
99999 5 12309
12309 2 00000
00000 4 33218
33218 3 -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;利用双向链表，头尾指针来模拟&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
struct linklist&amp;#123;
    int address=0;			//记录当前结点的地址，虽然也没用到
    int data=0;				//记录数据域
    int next=0;				//指向下一个结点的地址
    int pre=0;				//指向上一个结点的地址
&amp;#125;l[100005];
int main()
&amp;#123;
    int start,back=-1;		//头尾指针
    int tmp;				//用来遍历当前链表用于统计链表的长度
    int n;
    cin&gt;&gt;start&gt;&gt;n;
    tmp=start;
    int address, data, next;
    l[start].pre=-1;	   //初始化第一个结点的前一个结点位置为-1
    int cnt=0;			  	//记录链表长
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
       cin&gt;&gt;address&gt;&gt;data&gt;&gt;next;
       l[address].address=address;
       l[address].data=data;
       l[address].next=next;
       if(next!=-1)&amp;#123;
           l[next].pre=address;				//设值上一个结点的地址
       &amp;#125;
    &amp;#125;
    //这道题比较坑的地方是会出现不是这个链表的结点，所以n不是真正的链表长，需要统计真正的链表长
    //如果没注意这点，第三个测试点会不通过，不过也能得到21分
    while (true) &amp;#123;
        cnt++;				//统计链表长	
        if(l[tmp].next==-1)&amp;#123;
            back=tmp;       //尾指针
            break;
        &amp;#125;
        tmp=l[tmp].next;
    &amp;#125;
    int flag=0;
    //flag=0动尾指针,flag=1动头指针。我并没有改变原来链表！
    for (int k = 0; k &lt;cnt ; ++k) &amp;#123;
            if(flag==0)&amp;#123;
                if(k==cnt-1)&amp;#123;
                    printf(&#34;%05d %d %d\n&#34;,l[back].address,l[back].data,-1);
                &amp;#125;else&amp;#123;
                    printf(&#34;%05d %d %05d\n&#34;,l[back].address,l[back].data,start);
                &amp;#125;
                back=l[back].pre;
                flag=1;
            &amp;#125;
            else if(flag==1)&amp;#123;
                if(k==cnt-1)&amp;#123;
                    printf(&#34;%05d %d %d\n&#34;,l[start].address,l[start].data,-1);
                &amp;#125;else&amp;#123;
                    printf(&#34;%05d %d %05d\n&#34;,l[start].address,l[start].data,back);
                &amp;#125;
                start=l[start].next;
                flag=0;
            &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805057860517888&#34;&gt;题目详情 - L2-022 重排链表 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="LinkList" />
        <category term="双向链表" />
        <updated>2022-04-12T01:50:11.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/11/Algorithm016/</id>
        <title>L2-021 点赞狂魔 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/11/Algorithm016/"/>
        <content type="html">&lt;h1 id=&#34;L2-021-点赞狂魔-25-分&#34;&gt;&lt;a href=&#34;#L2-021-点赞狂魔-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-021 点赞狂魔 (25 分)&#34;&gt;&lt;/a&gt;L2-021 点赞狂魔 (25 分)&lt;/h1&gt;&lt;p&gt;微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出一个正整数&lt;em&gt;N&lt;/em&gt;（≤100），是待统计的用户数。随后&lt;em&gt;N&lt;/em&gt;行，每行列出一位用户的点赞标签。格式为“&lt;code&gt;Name&lt;/code&gt; &lt;em&gt;K&lt;/em&gt; &lt;em&gt;F&lt;/em&gt;1⋯&lt;em&gt;F**K&lt;/em&gt;”，其中&lt;code&gt;Name&lt;/code&gt;是不超过8个英文小写字母的非空用户名，1≤&lt;em&gt;K&lt;/em&gt;≤1000，&lt;em&gt;F**i&lt;/em&gt;（&lt;em&gt;i&lt;/em&gt;&amp;#x3D;1,⋯,&lt;em&gt;K&lt;/em&gt;）是特性标签的编号，我们将所有特性标签从 1 到 107 编号。数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用&lt;code&gt;-&lt;/code&gt;补齐缺失，例如&lt;code&gt;mike jenny -&lt;/code&gt;就表示只有2人。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;5
bob 11 101 102 103 104 105 106 107 108 108 107 107
peter 8 1 2 3 4 3 2 5 1
chris 12 1 2 3 4 5 6 7 8 9 1 2 3
john 10 8 7 6 5 4 3 2 1 7 5
jack 9 6 7 8 9 10 11 12 13 14
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;jack chris john
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;结构体数组 + sort排序&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
struct person&amp;#123;
    char name[10];
    set&lt;int&gt; s;				//set容器中的每个元素值唯一
    int all=0;				//记录点赞次数
&amp;#125;;
bool cmp(person a,person b)&amp;#123;
    if(a.s.size()==b.s.size()) return a.all&lt;b.all;			//如果有并列，则输出标签出现次数平均值最小的那个
    return a.s.size()&gt;b.s.size();							//点赞的不同标签的数量最多的
&amp;#125;
int main()
&amp;#123;
    int n;
    cin&gt;&gt;n;
    person p[n];
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        cin&gt;&gt;p[i].name;
        int time;
        cin&gt;&gt;time;
        p[i].all=time;										//记录点赞次数
        for (int j = 0; j &lt; time; ++j) &amp;#123;
            int tmp;
            cin&gt;&gt;tmp;
            p[i].s.insert(tmp);								//插入set容器
        &amp;#125;
    &amp;#125;
    sort(p,p+n,cmp);										//排序
    if(n&gt;=3)&amp;#123;
        cout&lt;&lt;p[0].name&lt;&lt;&#34; &#34;&lt;&lt;p[1].name&lt;&lt;&#34; &#34;&lt;&lt;p[2].name&lt;&lt;endl;
    &amp;#125; else if(n==2)&amp;#123;
        cout&lt;&lt;p[0].name&lt;&lt;&#34; &#34;&lt;&lt;p[1].name&lt;&lt;&#34; &#34;&lt;&lt;&#34;-&#34;&lt;&lt;endl;
    &amp;#125;else if(n==1)&amp;#123;
        cout&lt;&lt;p[0].name&lt;&lt;&#34; &#34;&lt;&lt;&#34;-&#34;&lt;&lt;&#34; &#34;&lt;&lt;&#34;-&#34;&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805058485469184&#34;&gt;题目详情 - L2-021 点赞狂魔 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/changjiale110/article/details/79108447&#34;&gt;(19条消息) STL中的set使用方法详细！！！！_知足–常乐的博客-CSDN博客_set stl&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="STL" />
        <category term="C++" />
        <category term="Set" />
        <category term="团体程序设计天梯赛" />
        <category term="Sort" />
        <updated>2022-04-11T11:21:06.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/08/Algorithm015/</id>
        <title>C++的STL中字符串string自带方法find查找</title>
        <link rel="alternate" href="http://example.com/2022/04/08/Algorithm015/"/>
        <content type="html">&lt;h1 id=&#34;C-的STL中字符串string自带方法find查找&#34;&gt;&lt;a href=&#34;#C-的STL中字符串string自带方法find查找&#34; class=&#34;headerlink&#34; title=&#34;C++的STL中字符串string自带方法find查找&#34;&gt;&lt;/a&gt;C++的STL中字符串string自带方法find查找&lt;/h1&gt;&lt;h2 id=&#34;用法&#34;&gt;&lt;a href=&#34;#用法&#34; class=&#34;headerlink&#34; title=&#34;用法&#34;&gt;&lt;/a&gt;用法&lt;/h2&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;string str = &#34;abcd&#34;;
    cout &lt;&lt; str.find(&#39;a&#39;);
    //返回的是下标的值而不是指针或是迭代器
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;string str = &#34;abcd&#34;
string sub = &#34;cd&#34;
if(str.find(sub)!=string::npos)&amp;#123;
    cout&lt;&lt;&#34;找到了&#34;&lt;&lt;endl;
&amp;#125;else&amp;#123;
    cout&lt;&lt;&#34;没有找到&#34;&lt;&lt;endl;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要是没有找到，返回的是str::npos&lt;br&gt;注意，只有string的find方法是返回的下标，因为string是顺序索引，set,map,multiset,multimap都不是顺序索引的数据结构，所以返回的是迭代器。&lt;/p&gt;
&lt;h2 id=&#34;样例一-L1-070-吃火锅-15-分&#34;&gt;&lt;a href=&#34;#样例一-L1-070-吃火锅-15-分&#34; class=&#34;headerlink&#34; title=&#34;样例一:L1-070 吃火锅 (15 分)&#34;&gt;&lt;/a&gt;样例一:&lt;strong&gt;L1-070 吃火锅 (15 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053&#34;&gt;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2022/04/08/Algorithm015/68518b64-f2f7-4694-aaeb-d32afe657f7b.jpg&#34; alt=&#34;chg.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上图片来自微信朋友圈：这种天气你有什么破事打电话给我基本没用。但是如果你说“吃火锅”，那就厉害了，我们的故事就开始了。&lt;/p&gt;
&lt;p&gt;本题要求你实现一个程序，自动检查你朋友给你发来的信息里有没有 &lt;code&gt;chi1 huo3 guo1&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入每行给出一句不超过 80 个字符的、以回车结尾的朋友信息，信息为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。当读到某一行只有一个英文句点 &lt;code&gt;.&lt;/code&gt; 时，输入结束，此行不算在朋友信息里。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先在一行中输出朋友信息的总条数。然后对朋友的每一行信息，检查其中是否包含 &lt;code&gt;chi1 huo3 guo1&lt;/code&gt;，并且统计这样厉害的信息有多少条。在第二行中首先输出第一次出现 &lt;code&gt;chi1 huo3 guo1&lt;/code&gt; 的信息是第几条（从 1 开始计数），然后输出这类信息的总条数，其间以一个空格分隔。题目保证输出的所有数字不超过 100。&lt;/p&gt;
&lt;p&gt;如果朋友从头到尾都没提 &lt;code&gt;chi1 huo3 guo1&lt;/code&gt; 这个关键词，则在第二行输出一个表情 &lt;code&gt;-_-#&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例-1：&#34;&gt;&lt;a href=&#34;#输入样例-1：&#34; class=&#34;headerlink&#34; title=&#34;输入样例 1：&#34;&gt;&lt;/a&gt;输入样例 1：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;Hello!
are you there?
wantta chi1 huo3 guo1?
that&#39;s so li hai le
our story begins from chi1 huo3 guo1 le
.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例-1：&#34;&gt;&lt;a href=&#34;#输出样例-1：&#34; class=&#34;headerlink&#34; title=&#34;输出样例 1：&#34;&gt;&lt;/a&gt;输出样例 1：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;5
3 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输入样例-2：&#34;&gt;&lt;a href=&#34;#输入样例-2：&#34; class=&#34;headerlink&#34; title=&#34;输入样例 2：&#34;&gt;&lt;/a&gt;输入样例 2：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;Hello!
are you there?
wantta qi huo3 guo1 chi1huo3guo1?
that&#39;s so li hai le
our story begins from ci1 huo4 guo2 le
.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例-2：&#34;&gt;&lt;a href=&#34;#输出样例-2：&#34; class=&#34;headerlink&#34; title=&#34;输出样例 2：&#34;&gt;&lt;/a&gt;输出样例 2：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;5
-_-#
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
&amp;#123;
    int flag=0;					//用来判断是否是第一次找到吃火锅
    int cnt=0;					//用来记录总行数
    int count=0;				//用来记录有多少个吃火锅
    int firstp=0;				//用来记录第一次出现吃火锅的位置
    string cmp=&#34;chi1 huo3 guo1&#34;;
    while (true)
    &amp;#123;
        string s;
        s.clear();
        getline(cin,s);
        if(s.size()==1&amp;&amp;s==&#34;.&#34;)&amp;#123;
            break;
        &amp;#125;
        string tmp =s;
        if(tmp.find(cmp)!=string::npos)&amp;#123;
            if(flag==0) &amp;#123;
                flag =1;
                firstp = cnt+1;
            &amp;#125;
            count=count+1;
        &amp;#125;
        cnt=cnt+1;

    &amp;#125;
    if(count==0)&amp;#123;
        cout&lt;&lt;cnt&lt;&lt;endl;
        cout&lt;&lt;&#34;-_-#&#34;&lt;&lt;endl;
    &amp;#125; else&amp;#123;
        cout&lt;&lt;cnt&lt;&lt;endl;
        cout&lt;&lt;firstp&lt;&lt;&#34; &#34;&lt;&lt;count&lt;&lt;endl;
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_50675813/article/details/113313343&#34;&gt;(18条消息) c++STL中的find()函数 有两种使用方法_我们不生产代码，只是代码的搬运工的博客-CSDN博客_c++中find函数的使用方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053&#34;&gt;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="String" />
        <category term="Find" />
        <category term="STL" />
        <category term="C++" />
        <updated>2022-04-08T11:18:57.000Z</updated>
    </entry>
</feed>
