<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>Amicoyuan • Posts by &#34;vector&#34; tag</title>
    <link href="http://example.com" />
    <updated>2022-04-23T13:44:47.000Z</updated>
    <category term="AVX" />
    <category term="Data Structure" />
    <category term="String" />
    <category term="Find" />
    <category term="STL" />
    <category term="C++" />
    <category term="Set" />
    <category term="团体程序设计天梯赛" />
    <category term="Sort" />
    <category term="LinkList" />
    <category term="双向链表" />
    <category term="Graph" />
    <category term="邻接表" />
    <category term="Vector" />
    <category term="Binary tree" />
    <category term="BFS" />
    <category term="模拟" />
    <category term="邻接矩阵" />
    <category term="DFS" />
    <category term="结构体" />
    <category term="贪心" />
    <category term="Double类型相等比较" />
    <category term="Map" />
    <category term="并查集" />
    <category term="Pair" />
    <category term="线索二叉树" />
    <category term="KMP" />
    <category term="Tree" />
    <category term="森林" />
    <category term="Linux" />
    <category term="MPI" />
    <category term="Numactl" />
    <category term="Slurm" />
    <category term="Tensorflow" />
    <category term="性能分析工具" />
    <category term="gcov" />
    <entry>
        <id>http://example.com/2022/04/23/Algorithm031/</id>
        <title>L2-039 清点代码库 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/23/Algorithm031/"/>
        <content type="html">&lt;h2 id=&#34;L2-039-清点代码库-25-分&#34;&gt;&lt;a href=&#34;#L2-039-清点代码库-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-039 清点代码库 (25 分)&#34;&gt;&lt;/a&gt;L2-039 清点代码库 (25 分)&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg&#34; alt=&#34;code.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”&lt;/p&gt;
&lt;p&gt;这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 &lt;strong&gt;int&lt;/strong&gt; 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行中给出 2 个正整数，依次为 &lt;em&gt;N&lt;/em&gt;（≤104）和 &lt;em&gt;M&lt;/em&gt;（≤102），对应功能模块的个数和系列测试输入的个数。&lt;/p&gt;
&lt;p&gt;随后 &lt;em&gt;N&lt;/em&gt; 行，每行给出一个功能模块的 &lt;em&gt;M&lt;/em&gt; 个对应输出，数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先在第一行输出不同功能的个数 &lt;em&gt;K&lt;/em&gt;。随后 &lt;em&gt;K&lt;/em&gt; 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。&lt;/p&gt;
&lt;p&gt;注：所谓数列 { &lt;em&gt;A&lt;/em&gt;1, …, &lt;em&gt;A&lt;/em&gt;M } 比 { &lt;em&gt;B&lt;/em&gt;1, …, &lt;em&gt;B&lt;/em&gt;M } 大，是指存在 1≤i&amp;lt;*M*，使得 *A*1&amp;#x3D;*B*1，…，*Ai*&amp;#x3D;*Bi* 成立，且 *Ai*+1&amp;gt;&lt;em&gt;B&lt;/em&gt;+1。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;7 3
35 28 74
-1 -1 22
28 74 35
-1 -1 22
11 66 0
35 28 74
35 28 74
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;4
3 35 28 74
2 -1 -1 22
1 11 66 0
1 28 74 35
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;利用map的映射关系&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;vector&lt;int&gt;,int&gt; mp;   //key，value
vector&lt;int&gt; tmp;
int n,m;
bool cmp(pair&lt;vector&lt;int&gt;,int&gt; a,pair&lt;vector&lt;int&gt;,int&gt; b)
&amp;#123;
    if(a.second==b.second)
    &amp;#123;
        return a.first&lt;b.first;
    &amp;#125;
    return a.second&gt;b.second;

&amp;#125;
int main()
&amp;#123;
    cin&gt;&gt;n&gt;&gt;m;
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        for (int j = 0; j &lt; m; ++j) &amp;#123;
            int num;
            cin&gt;&gt;num;
            tmp.push_back(num);
        &amp;#125;
        mp[tmp]++;
        tmp.clear();
    &amp;#125;
    vector&lt;pair&lt;vector&lt;int&gt;,int&gt;&gt; v(mp.begin(),mp.end());		//把map类型转化成vector
    cout&lt;&lt;v.size()&lt;&lt;endl;
    sort(v.begin(),v.end(),cmp);								//sort排序，注意终点和起点
    for (int k = 0; k &lt;v.size() ; ++k) &amp;#123;
        cout&lt;&lt;v[k].second&lt;&lt;&#34; &#34;;
        for (int i = 0; i &lt;m ; ++i) &amp;#123;
            if(i!=m-1)&amp;#123;
                cout&lt;&lt;v[k].first[i]&lt;&lt;&#34; &#34;;
            &amp;#125; else&amp;#123;
                cout&lt;&lt;v[k].first[i]&lt;&lt;endl;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362&#34;&gt;题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Sort" />
        <category term="Vector" />
        <category term="Map" />
        <category term="Pair" />
        <updated>2022-04-23T13:44:47.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/13/Algorithm022/</id>
        <title>L2-031 深入虎穴 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/13/Algorithm022/"/>
        <content type="html">&lt;p&gt;著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。&lt;/p&gt;
&lt;p&gt;内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入首先在一行中给出正整数 &lt;em&gt;N&lt;/em&gt;（&amp;lt;105），是门的数量。最后 &lt;em&gt;N&lt;/em&gt; 行，第 &lt;em&gt;i&lt;/em&gt; 行（1≤&lt;em&gt;i&lt;/em&gt;≤&lt;em&gt;N&lt;/em&gt;）按以下格式描述编号为 &lt;em&gt;i&lt;/em&gt; 的那扇门背后能通向的门：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;K D[1] D[2] ... D[K]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;K&lt;/code&gt; 是通道的数量，其后是每扇门的编号。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;13
3 2 3 4
2 5 6
1 7
1 8
1 9
0
2 11 10
1 13
0
0
1 12
0
0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;12
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接表 + BFS&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;int&gt; v[100005];
int book[100005];
int start=0;
int bfs()&amp;#123;								//BFS
    queue&lt;int&gt; q;
    q.push(start);						//根节点入队
    int x;
    while(!q.empty())&amp;#123;
        x=q.front();
        q.pop();
        for (int i = 0; i &lt;v[x].size() ; ++i) &amp;#123;				
            q.push(v[x][i]);
        &amp;#125;
    &amp;#125;									//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。
    return x;							//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门
&amp;#125;
int main()
&amp;#123;
    int n;
    cin&gt;&gt;n;
    for (int i = 1; i &lt;=n ; ++i) &amp;#123;
        int time;
        cin&gt;&gt;time;
        for (int j = 1; j &lt;=time ; ++j) &amp;#123;
            int num;
            cin&gt;&gt;num;
            book[num]=1;
            v[i].push_back(num);

        &amp;#125;
    &amp;#125;
    for (int k = 1; k &lt;=n ; ++k) &amp;#123;			//找入口
        if(book[k]==0) start=k;				//没有门通向的门，即为入口
    &amp;#125;
    int ans=bfs();
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888&#34;&gt;题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="邻接表" />
        <category term="Vector" />
        <category term="Binary tree" />
        <category term="BFS" />
        <updated>2022-04-13T11:09:46.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/13/Algorithm021/</id>
        <title>L2-040 哲哲打游戏 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/13/Algorithm021/"/>
        <content type="html">&lt;h2 id=&#34;L2-040-哲哲打游戏-25-分&#34;&gt;&lt;a href=&#34;#L2-040-哲哲打游戏-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-040 哲哲打游戏 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-040 哲哲打游戏 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;哲哲是一位硬核游戏玩家。最近一款名叫《达诺达诺》的新游戏刚刚上市，哲哲自然要快速攻略游戏，守护硬核游戏玩家的一切！&lt;/p&gt;
&lt;p&gt;为简化模型，我们不妨假设游戏有 &lt;em&gt;N&lt;/em&gt; 个剧情点，通过游戏里不同的操作或选择可以从某个剧情点去往另外一个剧情点。此外，游戏还设置了一些&lt;strong&gt;存档&lt;/strong&gt;，在某个剧情点可以将玩家的游戏进度保存在一个档位上，读取存档后可以回到剧情点，重新进行操作或者选择，到达不同的剧情点。&lt;/p&gt;
&lt;p&gt;为了追踪硬核游戏玩家哲哲的攻略进度，你打算写一个程序来完成这个工作。假设你已经知道了游戏的全部剧情点和流程，以及哲哲的游戏操作，请你输出哲哲的游戏进度。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行是两个正整数 &lt;em&gt;N&lt;/em&gt; 和 &lt;em&gt;M&lt;/em&gt; (1≤&lt;em&gt;N&lt;/em&gt;,&lt;em&gt;M&lt;/em&gt;≤105)，表示总共有 &lt;em&gt;N&lt;/em&gt; 个剧情点，哲哲有 &lt;em&gt;M&lt;/em&gt; 个游戏操作。&lt;/p&gt;
&lt;p&gt;接下来的 &lt;em&gt;N&lt;/em&gt; 行，每行对应一个剧情点的发展设定。第 &lt;em&gt;i&lt;/em&gt; 行的第一个数字是 &lt;em&gt;K**i&lt;/em&gt;，表示剧情点 &lt;em&gt;i&lt;/em&gt; 通过一些操作或选择能去往下面 &lt;em&gt;K**i&lt;/em&gt; 个剧情点；接下来有 &lt;em&gt;K**i&lt;/em&gt; 个数字，第 &lt;em&gt;k&lt;/em&gt; 个数字表示做第 &lt;em&gt;k&lt;/em&gt; 个操作或选择可以去往的剧情点编号。&lt;/p&gt;
&lt;p&gt;最后有 &lt;em&gt;M&lt;/em&gt; 行，每行第一个数字是 0、1 或 2，分别表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 表示哲哲做出了某个操作或选择，后面紧接着一个数字 &lt;em&gt;j&lt;/em&gt;，表示哲哲在当前剧情点做出了第 &lt;em&gt;j&lt;/em&gt; 个选择。我们保证哲哲的选择永远是合法的。&lt;/li&gt;
&lt;li&gt;1 表示哲哲进行了一次存档，后面紧接着是一个数字 &lt;em&gt;j&lt;/em&gt;，表示存档放在了第 &lt;em&gt;j&lt;/em&gt; 个档位上。&lt;/li&gt;
&lt;li&gt;2 表示哲哲进行了一次读取存档的操作，后面紧接着是一个数字 &lt;em&gt;j&lt;/em&gt;，表示读取了放在第 &lt;em&gt;j&lt;/em&gt; 个位置的存档。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;约定：所有操作或选择以及剧情点编号都从 1 号开始。存档的档位不超过 100 个，编号也从 1 开始。游戏默认从 1 号剧情点开始。总的选项数（即 ∑&lt;em&gt;K**i&lt;/em&gt;）不超过 106。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对于每个 1（即存档）操作，在一行中输出存档的剧情点编号。&lt;/p&gt;
&lt;p&gt;最后一行输出哲哲最后到达的剧情点编号。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;10 11
3 2 3 4
1 6
3 4 7 5
1 3
1 9
2 3 5
3 1 8 5
1 9
2 8 10
0
1 1
0 3
0 1
1 2
0 2
0 2
2 2
0 3
0 1
1 1
0 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;1
3
9
10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;样例解释：&#34;&gt;&lt;a href=&#34;#样例解释：&#34; class=&#34;headerlink&#34; title=&#34;样例解释：&#34;&gt;&lt;/a&gt;样例解释：&lt;/h3&gt;&lt;p&gt;简单给出样例中经过的剧情点顺序：&lt;/p&gt;
&lt;p&gt;1 -&amp;gt; 4 -&amp;gt; 3 -&amp;gt; 7 -&amp;gt; 8 -&amp;gt; 3 -&amp;gt; 5 -&amp;gt; 9 -&amp;gt; 10。&lt;/p&gt;
&lt;p&gt;档位 1 开始存的是 1 号剧情点；档位 2 存的是 3 号剧情点；档位 1 后来又存了 9 号剧情点。&lt;/p&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接表 + 模拟，主要是理解题意&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
&amp;#123;
    int n,k;
    cin&gt;&gt;n&gt;&gt;k;
    vector&lt;int&gt; v[n+1];
    int save[105];							//存档点
    int now=1;								//当前剧情点
    for (int i = 1; i &lt;=n ; ++i) &amp;#123;
        int num;
        cin&gt;&gt;num;
        for (int j = 0; j &lt;num ; ++j) &amp;#123;
            int x;
            cin&gt;&gt;x;
            v[i].push_back(x);				//邻接表存操作数
        &amp;#125;
    &amp;#125;
    for (int l = 0; l &lt;k ; ++l) &amp;#123;			//模拟过程
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        if(a==1)&amp;#123;
            save[b]=now;
            cout&lt;&lt;now&lt;&lt;endl;
        &amp;#125;
        if(a==0)&amp;#123;
            now=v[now][b-1];
        &amp;#125;
        if(a==2)&amp;#123;
            now=save[b];
        &amp;#125;
    &amp;#125;
    cout&lt;&lt;now&lt;&lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652363&#34;&gt;题目详情 - L2-040 哲哲打游戏 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="邻接表" />
        <category term="Vector" />
        <category term="模拟" />
        <updated>2022-04-13T11:09:41.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/13/Algorithm019/</id>
        <title>L2-026 小字辈 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/13/Algorithm019/"/>
        <content type="html">&lt;h2 id=&#34;L2-026-小字辈-25-分&#34;&gt;&lt;a href=&#34;#L2-026-小字辈-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-026 小字辈 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-026 小字辈 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父&amp;#x2F;母。家谱中辈分最高的老祖宗对应的父&amp;#x2F;母编号为 -1。一行中的数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;9
2 6 5 5 -1 5 6 4 7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;4
1 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接表建树+BFS&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;int&gt; tree[100005];				//邻接表建树
int deeptree[100005];					//记录树的深度
int n;
int root;								//根节点
int bfs()&amp;#123;								//bfs
    queue&lt;int&gt; q;
    q.push(root);						//根节点入队
    int x;								
    while(!q.empty())&amp;#123;
        x=q.front();
        q.pop();
        for (int i = 0; i &lt;tree[x].size() ; ++i) &amp;#123;
            deeptree[tree[x][i]]=deeptree[x]+1;						//每一层的深度为上一层加1
            q.push(tree[x][i]);

        &amp;#125;
    &amp;#125;
    return deeptree[x];				//返回最后一个结点的深度，即深度的最大值
&amp;#125;
int main()
&amp;#123;
    n;
    cin&gt;&gt;n;
    int a[n];
    for (int i = 1; i &lt;=n ; ++i) &amp;#123;
        cin&gt;&gt;a[i];
        if(a[i]==-1)&amp;#123;
            root=i;				//找根节点
        &amp;#125;
    &amp;#125;
    for (int j = 1; j &lt;=n ; ++j) &amp;#123;					//建树
        tree[a[j]].push_back(j);					//j是a[j]的孩子节点
        if(a[j]==-1) deeptree[j]=1;					//初始化根节点深度为1
    &amp;#125;
    int ans=bfs();
    cout&lt;&lt;ans&lt;&lt;endl;
    int maxdeepcnt=0;								//记录最大深度的个数
    int tmp[n];										//找最大深度的id
    for (int k = 1; k &lt;=n ; ++k) &amp;#123;					
        if(ans==deeptree[k])&amp;#123;
            maxdeepcnt++;
            tmp[maxdeepcnt]=k;
        &amp;#125;
    &amp;#125;
    //输出格式控制
    for (int l = 1; l &lt;=maxdeepcnt ; ++l) &amp;#123;
        if(l!=maxdeepcnt) cout&lt;&lt;tmp[l]&lt;&lt;&#34; &#34;;
        else cout&lt;&lt;tmp[l]&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808&#34;&gt;题目详情 - L2-026 小字辈 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="邻接表" />
        <category term="Vector" />
        <category term="Binary tree" />
        <category term="BFS" />
        <updated>2022-04-13T01:45:49.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/12/Algorithm018/</id>
        <title>L2-023 图着色问题 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/12/Algorithm018/"/>
        <content type="html">&lt;h2 id=&#34;L2-023-图着色问题-25-分&#34;&gt;&lt;a href=&#34;#L2-023-图着色问题-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-023 图着色问题 (25 分)&#34;&gt;&lt;/a&gt;L2-023 图着色问题 (25 分)&lt;/h2&gt;&lt;p&gt;图着色问题是一个著名的NP完全问题。给定无向图&lt;em&gt;G&lt;/em&gt;&amp;#x3D;(&lt;em&gt;V&lt;/em&gt;,&lt;em&gt;E&lt;/em&gt;)，问可否用&lt;em&gt;K&lt;/em&gt;种颜色为&lt;em&gt;V&lt;/em&gt;中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？&lt;/p&gt;
&lt;p&gt;但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出3个整数&lt;em&gt;V&lt;/em&gt;（0&amp;lt;&lt;em&gt;V&lt;/em&gt;≤500）、&lt;em&gt;E&lt;/em&gt;（≥0）和&lt;em&gt;K&lt;/em&gt;（0&amp;lt;&lt;em&gt;K&lt;/em&gt;≤&lt;em&gt;V&lt;/em&gt;），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到&lt;em&gt;V&lt;/em&gt;编号。随后&lt;em&gt;E&lt;/em&gt;行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数&lt;em&gt;N&lt;/em&gt;（≤20），是待检查的颜色分配方案的个数。随后&lt;em&gt;N&lt;/em&gt;行，每行顺次给出&lt;em&gt;V&lt;/em&gt;个顶点的颜色（第&lt;em&gt;i&lt;/em&gt;个数字表示第&lt;em&gt;i&lt;/em&gt;个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;对每种颜色分配方案，如果是图着色问题的一个解则输出&lt;code&gt;Yes&lt;/code&gt;，否则输出&lt;code&gt;No&lt;/code&gt;，每句占一行。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;img src=&#34;/2022/04/12/Algorithm018/graph.png&#34; alt=&#34;graph&#34; style=&#34;zoom: 67%;&#34;&gt;

&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;6 8 3
2 1
1 3
4 6
2 5
2 4
5 4
5 6
3 6
4
1 2 3 3 1 2
4 5 6 6 4 5
1 2 3 4 5 6
2 3 4 2 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;Yes
Yes
No
No
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Set + 邻接表&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
&amp;#123;
    int v,e,k;
    cin&gt;&gt;v&gt;&gt;e&gt;&gt;k;
    vector&lt;int&gt; g[505];			//邻接表
    int color[505];				//记录颜色
    for (int i = 0; i &lt;e ; ++i) &amp;#123;       //建立邻接表
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        g[a].push_back(b);
        g[b].push_back(a);
    &amp;#125;
    int time;
    cin&gt;&gt;time;
    for (int j = 0; j &lt;time ; ++j) &amp;#123;
        int flag=1;
        set&lt;int&gt; s;					//用来统计颜色总数
        s.clear();
        for (int i = 1; i &lt;=v; ++i) &amp;#123;
            int num;
            cin&gt;&gt;num;
            color[i]=num;
            s.insert(num);
        &amp;#125;
        if(s.size()!=k)&amp;#123;			//如果颜色数不等于k即非法
            cout&lt;&lt;&#34;No&#34;&lt;&lt;endl;
            continue;
        &amp;#125;
        for (int l = 1; l &lt;=v ; ++l) &amp;#123;						//遍历邻接表
            for (int i = 0; i &lt;g[l].size(); ++i) &amp;#123;
                if(color[l]==color[g[l][i]])&amp;#123;				//如果相邻结点颜色一样则为假
                    flag=0;
                    break;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        if(flag==1)&amp;#123;
            cout&lt;&lt;&#34;Yes&#34;&lt;&lt;endl;
        &amp;#125;else&amp;#123;
            cout&lt;&lt;&#34;No&#34;&lt;&lt;endl;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805057298481152&#34;&gt;题目详情 - L2-023 图着色问题 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="Set" />
        <category term="团体程序设计天梯赛" />
        <category term="Graph" />
        <category term="邻接表" />
        <category term="Vector" />
        <updated>2022-04-12T10:59:52.000Z</updated>
    </entry>
</feed>
