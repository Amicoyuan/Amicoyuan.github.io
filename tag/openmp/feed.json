{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"openmp\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/01/06/openmp002/",
            "url": "http://example.com/2023/01/06/openmp002/",
            "title": "OpenMP寻找循环依赖",
            "date_published": "2023-01-06T09:15:48.000Z",
            "content_html": "<h3 id=\"1-OpenMP寻找循环依赖\"><a href=\"#1-OpenMP寻找循环依赖\" class=\"headerlink\" title=\"1.OpenMP寻找循环依赖\"></a>1.OpenMP寻找循环依赖</h3><p>​\t\t当我们试图使用一个parallel for指令时，首先应该注意的是：要小心发现循环依赖。我们不需要担心一般的数据依赖。例如，在下面循环中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>    x[i] = a + i*h;\t\t\t<span class=\"hljs-comment\">//2</span><br>    y[i] = <span class=\"hljs-built_in\">exp</span>(x[i]);\t\t<span class=\"hljs-comment\">//3</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在第二行和第三行之间有一个数据依赖。然而，如下的并行化没有问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel num_threads(thread_count)</span><br><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>    x[i] = a + i*h;\t\t\t<span class=\"hljs-comment\">//3</span><br>    y[i] = <span class=\"hljs-built_in\">exp</span>(x[i]);\t\t<span class=\"hljs-comment\">//4</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>因为x[ i ]的计算与它接下来的使用总是被分配给同一个进程。</p>\n<p>​\t\t我们也应该观察到，有依赖关系的语句，其中至少一条语句会有序地写或更新变量。因此为了检测循环依赖，我们只需要重点观察被循环体更新的变量，即我们应该寻找在一个迭代中被读或被写，而在另一个迭代中被写的变量。</p>\n<h3 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2.总结\"></a>2.总结</h3><ol>\n<li>数据依赖在优化过程中非常常见</li>\n<li>如何解决数据依赖对提升并行化的效果影响很大</li>\n</ol>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2023/01/03/openmp001/",
            "url": "http://example.com/2023/01/03/openmp001/",
            "title": "OpenMP梯度积分法",
            "date_published": "2023-01-03T09:19:45.000Z",
            "content_html": "<h2 id=\"OpenMP梯度积分法\"><a href=\"#OpenMP梯度积分法\" class=\"headerlink\" title=\"OpenMP梯度积分法\"></a>OpenMP梯度积分法</h2><h3 id=\"1-梯度积分法\"><a href=\"#1-梯度积分法\" class=\"headerlink\" title=\"1.梯度积分法\"></a>1.梯度积分法</h3><p><img src=\"/2023/01/03/openmp001/image-20230106165434252.png\" alt=\"001\"></p>\n<p><img src=\"/2023/01/03/openmp001/image-20230106165507737.png\" alt=\"image-20230106165507737\"></p>\n<h3 id=\"2-识别两类任务\"><a href=\"#2-识别两类任务\" class=\"headerlink\" title=\"2.识别两类任务\"></a>2.识别两类任务</h3><p><img src=\"/2023/01/03/openmp001/image-20230106164847677.png\" alt=\"image-20230106164847677\"></p>\n<ol>\n<li>单个梯形的面积计算</li>\n<li>梯形面积求和</li>\n</ol>\n<p>在1.1的任务中，没有任务间的通信，但这一组任务中的每一组任务都与1.2的任务通信</p>\n<h3 id=\"3-累加线程结果\"><a href=\"#3-累加线程结果\" class=\"headerlink\" title=\"3.累加线程结果\"></a>3.累加线程结果</h3><p>​\t使用一个共享变量作为所有线程的和 ，每个线程可以将它计算的部分结果累加到共享变量中，让每个线程执行类似下面的语句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp critical</span><br>global_result += myresult;                <span class=\"hljs-comment\">//需要互斥访问</span><br></code></pre></div></td></tr></table></figure>\n\n<p>竞争条件，使用临界区解决。保证每次只有一个线程执行这段结构性代码。</p>\n<h3 id=\"4-程序完整代码\"><a href=\"#4-程序完整代码\" class=\"headerlink\" title=\"4.程序完整代码\"></a>4.程序完整代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;omp.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Trap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> a,<span class=\"hljs-keyword\">double</span> b,<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">double</span> *global_result_p)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span> global_result = <span class=\"hljs-number\">0.0</span>;<br>\t<span class=\"hljs-keyword\">double</span> a,b;\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//为了区分local_a,local_b</span><br>\t<span class=\"hljs-keyword\">int</span> n;<br>\t<span class=\"hljs-keyword\">int</span> thread_count;<br>\t<br>\tthread_count = <span class=\"hljs-number\">8</span>;                                      \t<span class=\"hljs-comment\">//指定你的线程数</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter a,b, and n\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%lf %lf %d&quot;</span>,&amp;a,&amp;b,&amp;n);<br>    <br>    <span class=\"hljs-comment\">//并行区开始</span><br>\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel num_threads(thread_count)\t\t\t<span class=\"hljs-comment\">//指定Trap函数由thread_count个线程执行</span></span><br>\t<span class=\"hljs-built_in\">Trap</span>(a,b,n,&amp;global_result);<br>\t<span class=\"hljs-comment\">//并行区结束</span><br>    <br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;With n = %d trapezoids, our estimate\\n&quot;</span>,n);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;of the integral from %f to %f = %.4lf\\n&quot;</span>,a,b,global_result);<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Trap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> a,<span class=\"hljs-keyword\">double</span> b,<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">double</span> *global_result_p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span> h,x,my_result;<br>\t<span class=\"hljs-keyword\">double</span> local_a,local_b;<br>\t<span class=\"hljs-keyword\">int</span> i,local_n;\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//local_n代表本进程被分配了多少个任务</span><br>\t<span class=\"hljs-keyword\">int</span> my_rank = <span class=\"hljs-built_in\">omp_get_thread_num</span>();<br>\t<span class=\"hljs-keyword\">int</span> thread_count = <span class=\"hljs-built_in\">omp_get_num_threads</span>();<br>\t<br>\th = (b-a)/n;\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//梯形底的长度</span><br>\tlocal_n = n/thread_count;\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//每个线程分配的梯形数，保证能整除</span><br>\tlocal_a = a + my_rank*local_n*h;\t\t\t\t\t\t<span class=\"hljs-comment\">//区间的左端点</span><br>\tlocal_b = local_a + local_n*h;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//区间的右端点</span><br>\t<span class=\"hljs-comment\">//对global_result共享部分和</span><br>    my_result = (<span class=\"hljs-built_in\">f</span>(local_a) + <span class=\"hljs-built_in\">f</span>(local_b))/<span class=\"hljs-number\">2.0</span>;\t\t\t\t<span class=\"hljs-comment\">//f(x)是目标函数</span><br>\t<span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span> ; i&lt;=local_n<span class=\"hljs-number\">-1</span>; i++)&#123;<br>\t\tx = local_a + i*h;<br>\t\tmy_result += <span class=\"hljs-built_in\">f</span>(x);<br>\t&#125;<br>\tmy_result = my_result*h;<br>    <span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp critical\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//临界区，这里可以直接使用OpenMP提供的reduction</span></span><br>\t*global_result_p += my_result;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//线程将部分和结果累加到共享变量</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><ol>\n<li>核心是拆分任务区域，把子任务分配到个个线程</li>\n<li>共享变量的选取决定了可并行度</li>\n<li>通过共享变量实现了归约的操作(这里使用到了临界区)</li>\n</ol>\n",
            "tags": [
                "OpenMP"
            ]
        }
    ]
}