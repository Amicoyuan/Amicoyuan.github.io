<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan • Posts by &#34;openmp&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Mon, 09 Jan 2023 15:06:18 +0800</pubDate>
        <lastBuildDate>Mon, 09 Jan 2023 15:06:18 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>并查集</category>
        <category>Map</category>
        <category>Pair</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Mirror</category>
        <category>Numactl</category>
        <category>OpenMP</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2023/01/09/openmp003/</guid>
            <title>OpenMP π值估计</title>
            <link>http://example.com/2023/01/09/openmp003/</link>
            <category>OpenMP</category>
            <pubDate>Mon, 09 Jan 2023 15:06:18 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;π值估计&#34;&gt;&lt;a href=&#34;#π值估计&#34; class=&#34;headerlink&#34; title=&#34;π值估计&#34;&gt;&lt;/a&gt;π值估计&lt;/h2&gt;&lt;h3 id=&#34;1-数学背景&#34;&gt;&lt;a href=&#34;#1-数学背景&#34; class=&#34;headerlink&#34; title=&#34;1.数学背景&#34;&gt;&lt;/a&gt;1.数学背景&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/2023/01/09/openmp003/image-20230109150836877.png&#34; alt=&#34;image-20230109150836877&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们能够在串行代码下实行这个公式：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; factor = &lt;span class=&#34;hljs-number&#34;&gt;1.0&lt;/span&gt;;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; sum = &lt;span class=&#34;hljs-number&#34;&gt;0.0&lt;/span&gt;;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt;(k=&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; ; k &amp;lt; n; k++)&amp;#123;&lt;br&gt;    sum += factor /(&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;*k+&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;);&lt;br&gt;    factor = - factor;&lt;br&gt;&amp;#125;&lt;br&gt;pi_approx = &lt;span class=&#34;hljs-number&#34;&gt;4.0&lt;/span&gt;*sum;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;2-OpenMP并行化&#34;&gt;&lt;a href=&#34;#2-OpenMP并行化&#34; class=&#34;headerlink&#34; title=&#34;2.OpenMP并行化&#34;&gt;&lt;/a&gt;2.OpenMP并行化&lt;/h3&gt;&lt;p&gt;为了使用OpenMP来并行化，可以首先倾向于这样做：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; factor = &lt;span class=&#34;hljs-number&#34;&gt;1.0&lt;/span&gt;;&lt;br&gt;&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; sum = &lt;span class=&#34;hljs-number&#34;&gt;0.0&lt;/span&gt;;&lt;br&gt;&lt;span class=&#34;hljs-number&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; omp parallel for num_threads(thread_count) reduction(+:sum)  &lt;span class=&#34;hljs-comment&#34;&gt;//对sum进行求和归约&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-number&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt;(k=&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; ; k &amp;lt; n; k++)&amp;#123;&lt;br&gt;&lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;     sum += factor /(&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;*k+&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;);&lt;br&gt;&lt;span class=&#34;hljs-number&#34;&gt;6&lt;/span&gt;     factor = - factor;&lt;br&gt;&lt;span class=&#34;hljs-number&#34;&gt;7&lt;/span&gt; &amp;#125;&lt;br&gt;&lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt; pi_approx = &lt;span class=&#34;hljs-number&#34;&gt;4.0&lt;/span&gt;*sum;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然而，第k次迭代中对第6行的factor的更新和接下来的第k + 1次迭代中对第5行的sum的累加是一个循环依赖（数据依赖）。如果第k次迭代被分配·到一个线程，而第k + 1次迭代被分配给另一个线程，则我们不能保证第6行中factor的值是正确的。&lt;/p&gt;
&lt;p&gt;在这种情况下我们能通过检查系数来解决这个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2023/01/09/openmp003/image-20230109161031989.png&#34; alt=&#34;image-20230109161031989&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到：在第k次迭代，factor的值应该是&lt;img src=&#34;/2023/01/09/openmp003/image-20230109161206995.png&#34; alt=&#34;image-20230109161206995&#34;&gt;。如果k是偶数，那么值是+1；如果k是奇数，值是-1。&lt;/p&gt;
&lt;h3 id=&#34;3-消除循环依赖（数据依赖）&#34;&gt;&lt;a href=&#34;#3-消除循环依赖（数据依赖）&#34; class=&#34;headerlink&#34; title=&#34;3.消除循环依赖（数据依赖）&#34;&gt;&lt;/a&gt;3.消除循环依赖（数据依赖）&lt;/h3&gt;&lt;p&gt;因此，如果将下述代码：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;sum += factor /(&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;*k+&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;);&lt;br&gt;factor = - factor;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;替换为：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt;(k % &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; ==&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;)			&lt;span class=&#34;hljs-comment&#34;&gt;//通过奇偶性，来独立factor消除循环依赖（数据依赖）&lt;/span&gt;&lt;br&gt;    factor = &lt;span class=&#34;hljs-number&#34;&gt;1.0&lt;/span&gt;;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;&lt;br&gt;    factor = &lt;span class=&#34;hljs-number&#34;&gt;-1.0&lt;/span&gt;;&lt;br&gt;sum += factor/(&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;*k+&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;);&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样就消除了循环依赖（数据依赖）。&lt;/p&gt;
&lt;h3 id=&#34;4-作用域&#34;&gt;&lt;a href=&#34;#4-作用域&#34; class=&#34;headerlink&#34; title=&#34;4.作用域&#34;&gt;&lt;/a&gt;4.作用域&lt;/h3&gt;&lt;p&gt;​	然而，事情仍然不是完全正确的。如果在我们的系统上使用两个线程运行程序，并设n&amp;#x3D;1000，那么结果仍然是错误的。例如，&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2023/01/09/openmp003/image-20230109164120205.png&#34; alt=&#34;image-20230109164120205&#34;&gt;&lt;/p&gt;
&lt;p&gt;另一方面，如果只有一个线程运行程序，我们总是得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2023/01/09/openmp003/image-20230109164204808.png&#34; alt=&#34;image-20230109164204808&#34;&gt;&lt;/p&gt;
&lt;p&gt;为什么会有这种错误。在一个已经被parallel for指令并行化的块中，缺省情况下任何在循环前声明的变量（唯一的例外是循环变量）在线程间都是共享的。因此factor被共享（被所有线程所共享）。例如，线程0可能会给他赋值1，但在它能用这个值更新sum前，线程1可能又给他赋值为-1了。因此，除了消除计算factor时的循环依赖（数据依赖）外，我们还需要保证每个线程有它自己的factor副本，就是说，为了使代码正确，我们需要保证factor有私有作用域（简单来说就是保证当前线程的factor的值不能被其他线程修改，也只有当前线程能更新和使用factor）。通过添加一个private子句到parallel指令中来实现这一目标。&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; factor = &lt;span class=&#34;hljs-number&#34;&gt;1.0&lt;/span&gt;;&lt;br&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; sum = &lt;span class=&#34;hljs-number&#34;&gt;0.0&lt;/span&gt;;&lt;br&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; omp parallel for num_threads(thread_count) reduction(+:sum) private(factor)  &lt;span class=&#34;hljs-comment&#34;&gt;//对sum进行求和归约&lt;/span&gt;&lt;/span&gt;&lt;br&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt;(k=&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; ; k &amp;lt; n; k++)&amp;#123;&lt;br&gt;     &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt;(k % &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; ==&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;)			&lt;span class=&#34;hljs-comment&#34;&gt;//通过奇偶性，来独立factor消除循环依赖（数据依赖）&lt;/span&gt;&lt;br&gt;    	factor = &lt;span class=&#34;hljs-number&#34;&gt;1.0&lt;/span&gt;;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;&lt;br&gt;    	factor = &lt;span class=&#34;hljs-number&#34;&gt;-1.0&lt;/span&gt;;&lt;br&gt;     sum += factor /(&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;*k+&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;);&lt;br&gt; &amp;#125;&lt;br&gt; pi_approx = &lt;span class=&#34;hljs-number&#34;&gt;4.0&lt;/span&gt;*sum;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在private子句内列举的变量，在每个线程上都有一个私有副本被创建。因此，在我们的例子中，thread_count个线程中的每一个都有它自己的factor变量的副本，因此一个线程对factor的更新不会影响另一个线程的factor值。&lt;/p&gt;
&lt;p&gt;​		要记住的重要的一点是，一个有私有作用域的变量的值在parallel块或者parallel for块的开始处是未指定的。它的值在parallel或parallel for块完成之后也是未指定的。例如，下列代码中的第一个printf语句的输出是非确定的，因为在它被现实初始化之前就打印了私有变量x。类似地，最终的printf输出也是非确定的，因为他在parallel块完成之后打印x。&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; x = &lt;span class=&#34;hljs-number&#34;&gt;5&lt;/span&gt;;&lt;br&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; omp parallel num_threads(thread_count) private(x)&lt;/span&gt;&lt;br&gt;&amp;#123;&lt;br&gt;    &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; my_rank = &lt;span class=&#34;hljs-built_in&#34;&gt;omp_get_thread_num&lt;/span&gt;();&lt;br&gt;    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Thread %d &amp;gt; before initialization,x = %d\n&amp;quot;&lt;/span&gt;,myrank,x);&lt;br&gt;    x = &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;*my_rank + &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;;&lt;br&gt;    &lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Thread %d &amp;gt; after initialization,x = %d\n&amp;quot;&lt;/span&gt;,my_rank,x);&lt;br&gt;&amp;#125;&lt;br&gt;&lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;After parallel block, x = %d\n&amp;quot;&lt;/span&gt;,x);&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-关于作用域的更多问题&#34;&gt;&lt;a href=&#34;#5-关于作用域的更多问题&#34; class=&#34;headerlink&#34; title=&#34;5.关于作用域的更多问题&#34;&gt;&lt;/a&gt;5.关于作用域的更多问题&lt;/h3&gt;&lt;p&gt;​		关于变量factor的问题是常见问题中的一个。我们通常需要考虑在parallel块或parallel for块中的每个变量的作用域。因此，与其让OpenMP决定每个变量的作用域，还不如让程序员明确块中每个变量的作用域。事实上，OpenMP提供了一个子句default，该子句显示地要求我们这样做。如果我们添加子句：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-built_in&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;default&lt;/span&gt;&lt;/span&gt;(none)&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;到parallel或parallel for指令中，那么编译器将要求我们明确在这个块中使用的每个变量和已经在块之外声明的变量的作用域。（在一个块中声明的变量都是私有的，因为它们会被分配给线程的栈。）&lt;/p&gt;
&lt;p&gt;​	例如，使用一个default（none）子句，对π的计算将如下所示。&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; omp parallel for num_threads(thread_count) default(none) reduction(+:sum) private(k,factor)  &lt;span class=&#34;hljs-comment&#34;&gt;//对sum进行求和归约&lt;/span&gt;&lt;/span&gt;&lt;br&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt;(k=&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; ; k &amp;lt; n; k++)&amp;#123;&lt;br&gt;     &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt;(k % &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; ==&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;)			&lt;span class=&#34;hljs-comment&#34;&gt;//通过奇偶性，来独立factor消除循环依赖（数据依赖）&lt;/span&gt;&lt;br&gt;    	factor = &lt;span class=&#34;hljs-number&#34;&gt;1.0&lt;/span&gt;;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt;&lt;br&gt;    	factor = &lt;span class=&#34;hljs-number&#34;&gt;-1.0&lt;/span&gt;;&lt;br&gt;     sum += factor /(&lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;*k+&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;);&lt;br&gt; &amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在这个例子中，我们在for循环中使用4个变量。由于default子句，我们需要明确每个变量的作用域。正如我们已经注意到的，sum是一个归约变量（同时拥有私有和共享作用域的属性）。我们也已经注意到factor和循环变量中k应该有私有作用域。从未在parallel或parallel for块中更新的变量，如这个例子中的n，能够被安全的共享。与私有变量不同，共享变量在块内具有在parallel或parallel for块之前的值，在块之后的值与块内的最后一个值相同。因此，如果n在块之前被初始化为1000，则在parallel for语句中他将保持这个值。因为在for循环中值没有改变，所有在循环结束后它将保持这个值。&lt;/p&gt;
&lt;h3 id=&#34;6-总结&#34;&gt;&lt;a href=&#34;#6-总结&#34; class=&#34;headerlink&#34; title=&#34;6.总结&#34;&gt;&lt;/a&gt;6.总结&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;分析数学背景，解决循环依赖（数据依赖）&lt;/li&gt;
&lt;li&gt;判断变量的作用域&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-参考资料&#34;&gt;&lt;a href=&#34;#7-参考资料&#34; class=&#34;headerlink&#34; title=&#34;7.参考资料&#34;&gt;&lt;/a&gt;7.参考资料&lt;/h3&gt;&lt;p&gt;并行程序导论 （美）Peter S.Pacheco&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2023/01/06/openmp002/</guid>
            <title>OpenMP寻找循环依赖</title>
            <link>http://example.com/2023/01/06/openmp002/</link>
            <category>OpenMP</category>
            <pubDate>Fri, 06 Jan 2023 17:15:48 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;1-OpenMP寻找循环依赖&#34;&gt;&lt;a href=&#34;#1-OpenMP寻找循环依赖&#34; class=&#34;headerlink&#34; title=&#34;1.OpenMP寻找循环依赖&#34;&gt;&lt;/a&gt;1.OpenMP寻找循环依赖&lt;/h3&gt;&lt;p&gt;​		当我们试图使用一个parallel for指令时，首先应该注意的是：要小心发现循环依赖。我们不需要担心一般的数据依赖。例如，在下面循环中：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt;(i=&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;i&amp;lt;n;i++)&amp;#123;&lt;br&gt;    x[i] = a + i*h;			&lt;span class=&#34;hljs-comment&#34;&gt;//2&lt;/span&gt;&lt;br&gt;    y[i] = &lt;span class=&#34;hljs-built_in&#34;&gt;exp&lt;/span&gt;(x[i]);		&lt;span class=&#34;hljs-comment&#34;&gt;//3&lt;/span&gt;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在第二行和第三行之间有一个数据依赖。然而，如下的并行化没有问题。&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; omp parallel num_threads(thread_count)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt;(i=&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;i&amp;lt;n;i++)&amp;#123;&lt;br&gt;    x[i] = a + i*h;			&lt;span class=&#34;hljs-comment&#34;&gt;//3&lt;/span&gt;&lt;br&gt;    y[i] = &lt;span class=&#34;hljs-built_in&#34;&gt;exp&lt;/span&gt;(x[i]);		&lt;span class=&#34;hljs-comment&#34;&gt;//4&lt;/span&gt;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;因为x[ i ]的计算与它接下来的使用总是被分配给同一个进程。&lt;/p&gt;
&lt;p&gt;​		我们也应该观察到，有依赖关系的语句，其中至少一条语句会有序地写或更新变量。因此为了检测循环依赖，我们只需要重点观察被循环体更新的变量，即我们应该寻找在一个迭代中被读或被写，而在另一个迭代中被写的变量。&lt;/p&gt;
&lt;h3 id=&#34;2-总结&#34;&gt;&lt;a href=&#34;#2-总结&#34; class=&#34;headerlink&#34; title=&#34;2.总结&#34;&gt;&lt;/a&gt;2.总结&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据依赖在优化过程中非常常见&lt;/li&gt;
&lt;li&gt;如何解决数据依赖对提升并行化的效果影响很大&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-参考资料&#34;&gt;&lt;a href=&#34;#3-参考资料&#34; class=&#34;headerlink&#34; title=&#34;3.参考资料&#34;&gt;&lt;/a&gt;3.参考资料&lt;/h3&gt;&lt;p&gt;并行程序导论 （美）Peter S.Pacheco&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2023/01/03/openmp001/</guid>
            <title>OpenMP梯度积分法</title>
            <link>http://example.com/2023/01/03/openmp001/</link>
            <category>OpenMP</category>
            <pubDate>Tue, 03 Jan 2023 17:19:45 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;OpenMP梯度积分法&#34;&gt;&lt;a href=&#34;#OpenMP梯度积分法&#34; class=&#34;headerlink&#34; title=&#34;OpenMP梯度积分法&#34;&gt;&lt;/a&gt;OpenMP梯度积分法&lt;/h2&gt;&lt;h3 id=&#34;1-梯度积分法&#34;&gt;&lt;a href=&#34;#1-梯度积分法&#34; class=&#34;headerlink&#34; title=&#34;1.梯度积分法&#34;&gt;&lt;/a&gt;1.梯度积分法&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/2023/01/03/openmp001/image-20230106165434252.png&#34; alt=&#34;001&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2023/01/03/openmp001/image-20230106165507737.png&#34; alt=&#34;image-20230106165507737&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-识别两类任务&#34;&gt;&lt;a href=&#34;#2-识别两类任务&#34; class=&#34;headerlink&#34; title=&#34;2.识别两类任务&#34;&gt;&lt;/a&gt;2.识别两类任务&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/2023/01/03/openmp001/image-20230106164847677.png&#34; alt=&#34;image-20230106164847677&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单个梯形的面积计算&lt;/li&gt;
&lt;li&gt;梯形面积求和&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在2.1的任务中，没有任务间的通信，但这一组任务中的每一组任务都与2.2的任务通信&lt;/p&gt;
&lt;h3 id=&#34;3-累加线程结果&#34;&gt;&lt;a href=&#34;#3-累加线程结果&#34; class=&#34;headerlink&#34; title=&#34;3.累加线程结果&#34;&gt;&lt;/a&gt;3.累加线程结果&lt;/h3&gt;&lt;p&gt;​	使用一个共享变量作为所有线程的和 ，每个线程可以将它计算的部分结果累加到共享变量中，让每个线程执行类似下面的语句：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; omp critical&lt;/span&gt;&lt;br&gt;global_result += myresult;                &lt;span class=&#34;hljs-comment&#34;&gt;//需要互斥访问&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;竞争条件，使用临界区解决。保证每次只有一个线程执行这段结构性代码。&lt;/p&gt;
&lt;h3 id=&#34;4-程序完整代码&#34;&gt;&lt;a href=&#34;#4-程序完整代码&#34; class=&#34;headerlink&#34; title=&#34;4.程序完整代码&#34;&gt;&lt;/a&gt;4.程序完整代码&lt;/h3&gt;&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;hljs-meta-string&#34;&gt;&amp;lt;omp.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;Trap&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; a,&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; b,&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; n,&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; *global_result_p)&lt;/span&gt;&lt;/span&gt;;&lt;br&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; argc, &lt;span class=&#34;hljs-keyword&#34;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; global_result = &lt;span class=&#34;hljs-number&#34;&gt;0.0&lt;/span&gt;;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; a,b;												&lt;span class=&#34;hljs-comment&#34;&gt;//为了区分local_a,local_b&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; n;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; thread_count;&lt;br&gt;	&lt;br&gt;	thread_count = &lt;span class=&#34;hljs-number&#34;&gt;8&lt;/span&gt;;                                      	&lt;span class=&#34;hljs-comment&#34;&gt;//指定你的线程数&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;Enter a,b, and n\n&amp;quot;&lt;/span&gt;);&lt;br&gt;	&lt;span class=&#34;hljs-built_in&#34;&gt;scanf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;%lf %lf %d&amp;quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;b,&amp;amp;n);&lt;br&gt;    &lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;//并行区开始&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; omp parallel num_threads(thread_count)			&lt;span class=&#34;hljs-comment&#34;&gt;//指定Trap函数由thread_count个线程执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-built_in&#34;&gt;Trap&lt;/span&gt;(a,b,n,&amp;amp;global_result);&lt;br&gt;	&lt;span class=&#34;hljs-comment&#34;&gt;//并行区结束&lt;/span&gt;&lt;br&gt;    &lt;br&gt;	&lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;With n = %d trapezoids, our estimate\n&amp;quot;&lt;/span&gt;,n);&lt;br&gt;	&lt;span class=&#34;hljs-built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;of the integral from %f to %f = %.4lf\n&amp;quot;&lt;/span&gt;,a,b,global_result);&lt;br&gt;	&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;Trap&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; a,&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; b,&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; n,&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; *global_result_p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;/span&gt;&amp;#123;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; h,x,my_result;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;double&lt;/span&gt; local_a,local_b;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; i,local_n;											&lt;span class=&#34;hljs-comment&#34;&gt;//local_n代表本进程被分配了多少个任务&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; my_rank = &lt;span class=&#34;hljs-built_in&#34;&gt;omp_get_thread_num&lt;/span&gt;();&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; thread_count = &lt;span class=&#34;hljs-built_in&#34;&gt;omp_get_num_threads&lt;/span&gt;();&lt;br&gt;	&lt;br&gt;	h = (b-a)/n;											&lt;span class=&#34;hljs-comment&#34;&gt;//梯形底的长度&lt;/span&gt;&lt;br&gt;	local_n = n/thread_count;								&lt;span class=&#34;hljs-comment&#34;&gt;//每个线程分配的梯形数，保证能整除&lt;/span&gt;&lt;br&gt;	local_a = a + my_rank*local_n*h;						&lt;span class=&#34;hljs-comment&#34;&gt;//区间的左端点&lt;/span&gt;&lt;br&gt;	local_b = local_a + local_n*h;							&lt;span class=&#34;hljs-comment&#34;&gt;//区间的右端点&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-comment&#34;&gt;//对global_result共享部分和&lt;/span&gt;&lt;br&gt;    my_result = (&lt;span class=&#34;hljs-built_in&#34;&gt;f&lt;/span&gt;(local_a) + &lt;span class=&#34;hljs-built_in&#34;&gt;f&lt;/span&gt;(local_b))/&lt;span class=&#34;hljs-number&#34;&gt;2.0&lt;/span&gt;;				&lt;span class=&#34;hljs-comment&#34;&gt;//f(x)是目标函数&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt;(i = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; ; i&amp;lt;=local_n&lt;span class=&#34;hljs-number&#34;&gt;-1&lt;/span&gt;; i++)&amp;#123;&lt;br&gt;		x = local_a + i*h;&lt;br&gt;		my_result += &lt;span class=&#34;hljs-built_in&#34;&gt;f&lt;/span&gt;(x);&lt;br&gt;	&amp;#125;&lt;br&gt;	my_result = my_result*h;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;//&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-meta-keyword&#34;&gt;pragma&lt;/span&gt; omp critical									&lt;span class=&#34;hljs-comment&#34;&gt;//临界区，这里可以直接使用OpenMP提供的reduction&lt;/span&gt;&lt;/span&gt;&lt;br&gt;	*global_result_p += my_result;							&lt;span class=&#34;hljs-comment&#34;&gt;//线程将部分和结果累加到共享变量&lt;/span&gt;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-总结&#34;&gt;&lt;a href=&#34;#5-总结&#34; class=&#34;headerlink&#34; title=&#34;5.总结&#34;&gt;&lt;/a&gt;5.总结&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;核心是拆分任务区域，把子任务分配到个个线程&lt;/li&gt;
&lt;li&gt;共享变量的选取决定了可并行度&lt;/li&gt;
&lt;li&gt;通过共享变量实现了归约的操作(这里使用到了临界区)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-参考资料&#34;&gt;&lt;a href=&#34;#6-参考资料&#34; class=&#34;headerlink&#34; title=&#34;6.参考资料&#34;&gt;&lt;/a&gt;6.参考资料&lt;/h3&gt;&lt;p&gt;并行程序导论 （美）Peter S.Pacheco&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
