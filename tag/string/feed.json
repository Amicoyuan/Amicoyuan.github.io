{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"string\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/04/27/Algorithm034/",
            "url": "http://example.com/2022/04/27/Algorithm034/",
            "title": "串的模式匹配算法-KMP算法",
            "date_published": "2022-04-27T11:39:05.000Z",
            "content_html": "<h2 id=\"串的模式匹配算法-KMP算法\"><a href=\"#串的模式匹配算法-KMP算法\" class=\"headerlink\" title=\"串的模式匹配算法-KMP算法\"></a>串的模式匹配算法-KMP算法</h2><h3 id=\"求next数组\"><a href=\"#求next数组\" class=\"headerlink\" title=\"求next数组\"></a>求next数组</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void get_next(SSting t,int next[])\n&#123;\n    int i=1,j=0;\n    next[1]=0;\n    while(i<t.length)\n    &#123;\n        if(j==0||t.ch[i]==t.ch[j])\n        &#123;\n            i++;\n            j++;\n            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1\n        &#125;else&#123;\n            j=next[j];      //否则令j=next[j]，循环继续\n        &#125;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"KMP匹配算法\"><a href=\"#KMP匹配算法\" class=\"headerlink\" title=\"KMP匹配算法\"></a>KMP匹配算法</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int Index_KMP(SSting s,SSting t,int next[])&#123;\n    int i=1,j=1;\n    while (i<=s.length&&j<=t.length)&#123;\n        if(j==0||s.ch[i]==t.ch[j])\n        &#123;\n            j++;                    //继续比较后续字符\n            i++;\n        &#125;else&#123;\n            j=next[j];              //模式串向右移动\n        &#125;\n    &#125;\n    if(j>t.length)\n    &#123;\n        return i-t.length;          //匹配成功\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"完整代码：\"><a href=\"#完整代码：\" class=\"headerlink\" title=\"完整代码：\"></a>完整代码：</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\n#define MAXLEN 255\t\t\t\t\t//预定义最大串长\ntypedef struct&#123;\n    char ch[MAXLEN];\t\t\t\t//每个分量存储一个字符\n    int length;\t\t\t\t\t\t//串的实际长度\n&#125;SSting;\nvoid get_next(SSting t,int next[])\n&#123;\n    int i=1,j=0;\n    next[1]=0;\n    while(i<t.length)\n    &#123;\n        if(j==0||t.ch[i]==t.ch[j])\n        &#123;\n            i++;\n            j++;\n            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1\n        &#125;else&#123;\n            j=next[j];      //否则令j=next[j]，循环继续\n        &#125;\n    &#125;\n&#125;\nint Index_KMP(SSting s,SSting t,int next[])&#123;\n    int i=1,j=1;\n    while (i<=s.length&&j<=t.length)&#123;\n        if(j==0||s.ch[i]==t.ch[j])\n        &#123;\n            j++;                    //继续比较后续字符\n            i++;\n        &#125;else&#123;\n            j=next[j];              //模式串向右移动\n        &#125;\n    &#125;\n    if(j>t.length)\n    &#123;\n        return i-t.length;          //匹配成功\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\nint main()\n&#123;\n    SSting a,b;\n    string s1=\"ababcabcacbab\";\n    string s2=\"abcac\";\n    a.length=s1.size();\n    b.length=s2.size();\n    int next[s2.size()+1];\n    get_next(b,next);\n    for (int i = 0; i <s1.size(); ++i) &#123;\t//初始化\n        a.ch[i+1]=s1[i];\n    &#125;\n    for (int j = 0; j <s2.size() ; ++j) &#123;\t//初始化\n        b.ch[j+1]=s2[j];\n    &#125;\n    int x=Index_KMP(a,b,next);\n    if(x!=0)\n    &#123;\n        cout<<\"找到了位置是：\"<<x<<endl;\n    &#125;else&#123;\n        cout<<\"没有找到\"<<endl;\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"程序输出：\"><a href=\"#程序输出：\" class=\"headerlink\" title=\"程序输出：\"></a>程序输出：</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">找到了位置是：6\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure",
                "String",
                "KMP"
            ]
        },
        {
            "id": "http://example.com/2022/04/27/Algorithm033/",
            "url": "http://example.com/2022/04/27/Algorithm033/",
            "title": "串-简单的模式匹配算法",
            "date_published": "2022-04-27T09:11:18.000Z",
            "content_html": "<h2 id=\"串-简单的模式匹配算法\"><a href=\"#串-简单的模式匹配算法\" class=\"headerlink\" title=\"串-简单的模式匹配算法\"></a>串-简单的模式匹配算法</h2><h3 id=\"简单的模式匹配算法\"><a href=\"#简单的模式匹配算法\" class=\"headerlink\" title=\"简单的模式匹配算法\"></a>简单的模式匹配算法</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int Index(SSting s,SSting t)        //简单的模式匹配算法\n&#123;\n    int i=1,j=1;\n    while(i<=s.length && j<= t.length)\n    &#123;\n        if(s.ch[i]==t.ch[j])\n        &#123;\n            i++;                      //继续比较后继字符\n            j++;\n        &#125;else&#123;                        //指针后退重新开始匹配\n            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位\n            j=1;\n        &#125;\n    &#125;\n    if(j>t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号\n    else return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"完整程序源代码\"><a href=\"#完整程序源代码\" class=\"headerlink\" title=\"完整程序源代码\"></a>完整程序源代码</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\n#define MAXLEN 255\t\t\t\t\t//预定义最大串长\ntypedef struct&#123;\n    char ch[MAXLEN];\t\t\t\t//每个分量存储一个字符\n    int length;\t\t\t\t\t\t//串的实际长度\n&#125;SSting;\nint Index(SSting s,SSting t)        //简单的模式匹配算法\n&#123;\n    int i=1,j=1;\n    while(i<=s.length && j<= t.length)\n    &#123;\n        if(s.ch[i]==t.ch[j])\n        &#123;\n            i++;                      //继续比较后继字符\n            j++;\n        &#125;else&#123;                        //指针后退重新开始匹配\n            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位\n            j=1;\n        &#125;\n    &#125;\n    if(j>t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号\n    else return 0;\n&#125;\nint main()\n&#123;\n    SSting a,b;\n    string s1=\"ababcabcacbab\";\n    string s2=\"abcac\";\n    a.length=s1.size();\n    b.length=s2.size();\n    for (int i = 0; i <s1.size(); ++i) &#123;\t//初始化\n        a.ch[i+1]=s1[i];\n    &#125;\n    for (int j = 0; j <s2.size() ; ++j) &#123;\t//初始化\n        b.ch[j+1]=s2[j];\n    &#125;\n    int x=Index(a,b);\n    if(x!=0)\n    &#123;\n        cout<<\"找到了位置是：\"<<x<<endl;\n    &#125;else&#123;\n        cout<<\"没有找到\"<<endl;\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">找到了位置是：6\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure",
                "String"
            ]
        },
        {
            "id": "http://example.com/2022/04/08/Algorithm015/",
            "url": "http://example.com/2022/04/08/Algorithm015/",
            "title": "C++的STL中字符串string自带方法find查找",
            "date_published": "2022-04-08T11:18:57.000Z",
            "content_html": "<h1 id=\"C-的STL中字符串string自带方法find查找\"><a href=\"#C-的STL中字符串string自带方法find查找\" class=\"headerlink\" title=\"C++的STL中字符串string自带方法find查找\"></a>C++的STL中字符串string自带方法find查找</h1><h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string str = \"abcd\";\n    cout << str.find('a');\n    //返回的是下标的值而不是指针或是迭代器\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string str = \"abcd\"\nstring sub = \"cd\"\nif(str.find(sub)!=string::npos)&#123;\n    cout<<\"找到了\"<<endl;\n&#125;else&#123;\n    cout<<\"没有找到\"<<endl;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>要是没有找到，返回的是str::npos<br>注意，只有string的find方法是返回的下标，因为string是顺序索引，set,map,multiset,multimap都不是顺序索引的数据结构，所以返回的是迭代器。</p>\n<h2 id=\"样例一-L1-070-吃火锅-15-分\"><a href=\"#样例一-L1-070-吃火锅-15-分\" class=\"headerlink\" title=\"样例一:L1-070 吃火锅 (15 分)\"></a>样例一:<strong>L1-070 吃火锅 (15 分)</strong></h2><p><strong>题目链接：</strong></p>\n<p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053\">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053</a></p>\n<p><img src=\"/2022/04/08/Algorithm015/68518b64-f2f7-4694-aaeb-d32afe657f7b.jpg\" alt=\"chg.jpg\"></p>\n<p>以上图片来自微信朋友圈：这种天气你有什么破事打电话给我基本没用。但是如果你说“吃火锅”，那就厉害了，我们的故事就开始了。</p>\n<p>本题要求你实现一个程序，自动检查你朋友给你发来的信息里有没有 <code>chi1 huo3 guo1</code>。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入每行给出一句不超过 80 个字符的、以回车结尾的朋友信息，信息为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。当读到某一行只有一个英文句点 <code>.</code> 时，输入结束，此行不算在朋友信息里。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>首先在一行中输出朋友信息的总条数。然后对朋友的每一行信息，检查其中是否包含 <code>chi1 huo3 guo1</code>，并且统计这样厉害的信息有多少条。在第二行中首先输出第一次出现 <code>chi1 huo3 guo1</code> 的信息是第几条（从 1 开始计数），然后输出这类信息的总条数，其间以一个空格分隔。题目保证输出的所有数字不超过 100。</p>\n<p>如果朋友从头到尾都没提 <code>chi1 huo3 guo1</code> 这个关键词，则在第二行输出一个表情 <code>-_-#</code>。</p>\n<h3 id=\"输入样例-1：\"><a href=\"#输入样例-1：\" class=\"headerlink\" title=\"输入样例 1：\"></a>输入样例 1：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">Hello!\nare you there?\nwantta chi1 huo3 guo1?\nthat's so li hai le\nour story begins from chi1 huo3 guo1 le\n.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例-1：\"><a href=\"#输出样例-1：\" class=\"headerlink\" title=\"输出样例 1：\"></a>输出样例 1：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">5\n3 2\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"输入样例-2：\"><a href=\"#输入样例-2：\" class=\"headerlink\" title=\"输入样例 2：\"></a>输入样例 2：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">Hello!\nare you there?\nwantta qi huo3 guo1 chi1huo3guo1?\nthat's so li hai le\nour story begins from ci1 huo4 guo2 le\n.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例-2：\"><a href=\"#输出样例-2：\" class=\"headerlink\" title=\"输出样例 2：\"></a>输出样例 2：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">5\n-_-#\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nint main()\n&#123;\n    int flag=0;\t\t\t\t\t//用来判断是否是第一次找到吃火锅\n    int cnt=0;\t\t\t\t\t//用来记录总行数\n    int count=0;\t\t\t\t//用来记录有多少个吃火锅\n    int firstp=0;\t\t\t\t//用来记录第一次出现吃火锅的位置\n    string cmp=\"chi1 huo3 guo1\";\n    while (true)\n    &#123;\n        string s;\n        s.clear();\n        getline(cin,s);\n        if(s.size()==1&&s==\".\")&#123;\n            break;\n        &#125;\n        string tmp =s;\n        if(tmp.find(cmp)!=string::npos)&#123;\n            if(flag==0) &#123;\n                flag =1;\n                firstp = cnt+1;\n            &#125;\n            count=count+1;\n        &#125;\n        cnt=cnt+1;\n\n    &#125;\n    if(count==0)&#123;\n        cout<<cnt<<endl;\n        cout<<\"-_-#\"<<endl;\n    &#125; else&#123;\n        cout<<cnt<<endl;\n        cout<<firstp<<\" \"<<count<<endl;\n    &#125;\n\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/qq_50675813/article/details/113313343\">(18条消息) c++STL中的find()函数 有两种使用方法_我们不生产代码，只是代码的搬运工的博客-CSDN博客_c++中find函数的使用方法</a></p>\n<p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053\">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053</a></p>\n",
            "tags": [
                "String",
                "Find",
                "STL",
                "C++"
            ]
        }
    ]
}