<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan • Posts by &#34;string&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Wed, 27 Apr 2022 19:39:05 +0800</pubDate>
        <lastBuildDate>Wed, 27 Apr 2022 19:39:05 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>并查集</category>
        <category>Map</category>
        <category>Pair</category>
        <category>线索二叉树</category>
        <category>KMP</category>
        <category>Tree</category>
        <category>森林</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Numactl</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/27/Algorithm034/</guid>
            <title>串的模式匹配算法-KMP算法</title>
            <link>http://example.com/2022/04/27/Algorithm034/</link>
            <category>Data Structure</category>
            <category>String</category>
            <category>KMP</category>
            <pubDate>Wed, 27 Apr 2022 19:39:05 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;串的模式匹配算法-KMP算法&#34;&gt;&lt;a href=&#34;#串的模式匹配算法-KMP算法&#34; class=&#34;headerlink&#34; title=&#34;串的模式匹配算法-KMP算法&#34;&gt;&lt;/a&gt;串的模式匹配算法-KMP算法&lt;/h2&gt;&lt;h3 id=&#34;求next数组&#34;&gt;&lt;a href=&#34;#求next数组&#34; class=&#34;headerlink&#34; title=&#34;求next数组&#34;&gt;&lt;/a&gt;求next数组&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;void get_next(SSting t,int next[])
&amp;#123;
    int i=1,j=0;
    next[1]=0;
    while(i&lt;t.length)
    &amp;#123;
        if(j==0||t.ch[i]==t.ch[j])
        &amp;#123;
            i++;
            j++;
            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1
        &amp;#125;else&amp;#123;
            j=next[j];      //否则令j=next[j]，循环继续
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;KMP匹配算法&#34;&gt;&lt;a href=&#34;#KMP匹配算法&#34; class=&#34;headerlink&#34; title=&#34;KMP匹配算法&#34;&gt;&lt;/a&gt;KMP匹配算法&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;int Index_KMP(SSting s,SSting t,int next[])&amp;#123;
    int i=1,j=1;
    while (i&lt;=s.length&amp;&amp;j&lt;=t.length)&amp;#123;
        if(j==0||s.ch[i]==t.ch[j])
        &amp;#123;
            j++;                    //继续比较后续字符
            i++;
        &amp;#125;else&amp;#123;
            j=next[j];              //模式串向右移动
        &amp;#125;
    &amp;#125;
    if(j&gt;t.length)
    &amp;#123;
        return i-t.length;          //匹配成功
    &amp;#125;else&amp;#123;
        return 0;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;完整代码：&#34;&gt;&lt;a href=&#34;#完整代码：&#34; class=&#34;headerlink&#34; title=&#34;完整代码：&#34;&gt;&lt;/a&gt;完整代码：&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
#define MAXLEN 255					//预定义最大串长
typedef struct&amp;#123;
    char ch[MAXLEN];				//每个分量存储一个字符
    int length;						//串的实际长度
&amp;#125;SSting;
void get_next(SSting t,int next[])
&amp;#123;
    int i=1,j=0;
    next[1]=0;
    while(i&lt;t.length)
    &amp;#123;
        if(j==0||t.ch[i]==t.ch[j])
        &amp;#123;
            i++;
            j++;
            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1
        &amp;#125;else&amp;#123;
            j=next[j];      //否则令j=next[j]，循环继续
        &amp;#125;
    &amp;#125;
&amp;#125;
int Index_KMP(SSting s,SSting t,int next[])&amp;#123;
    int i=1,j=1;
    while (i&lt;=s.length&amp;&amp;j&lt;=t.length)&amp;#123;
        if(j==0||s.ch[i]==t.ch[j])
        &amp;#123;
            j++;                    //继续比较后续字符
            i++;
        &amp;#125;else&amp;#123;
            j=next[j];              //模式串向右移动
        &amp;#125;
    &amp;#125;
    if(j&gt;t.length)
    &amp;#123;
        return i-t.length;          //匹配成功
    &amp;#125;else&amp;#123;
        return 0;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    SSting a,b;
    string s1=&#34;ababcabcacbab&#34;;
    string s2=&#34;abcac&#34;;
    a.length=s1.size();
    b.length=s2.size();
    int next[s2.size()+1];
    get_next(b,next);
    for (int i = 0; i &lt;s1.size(); ++i) &amp;#123;	//初始化
        a.ch[i+1]=s1[i];
    &amp;#125;
    for (int j = 0; j &lt;s2.size() ; ++j) &amp;#123;	//初始化
        b.ch[j+1]=s2[j];
    &amp;#125;
    int x=Index_KMP(a,b,next);
    if(x!=0)
    &amp;#123;
        cout&lt;&lt;&#34;找到了位置是：&#34;&lt;&lt;x&lt;&lt;endl;
    &amp;#125;else&amp;#123;
        cout&lt;&lt;&#34;没有找到&#34;&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出：&#34;&gt;&lt;a href=&#34;#程序输出：&#34; class=&#34;headerlink&#34; title=&#34;程序输出：&#34;&gt;&lt;/a&gt;程序输出：&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;找到了位置是：6
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/27/Algorithm033/</guid>
            <title>串-简单的模式匹配算法</title>
            <link>http://example.com/2022/04/27/Algorithm033/</link>
            <category>Data Structure</category>
            <category>String</category>
            <pubDate>Wed, 27 Apr 2022 17:11:18 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;串-简单的模式匹配算法&#34;&gt;&lt;a href=&#34;#串-简单的模式匹配算法&#34; class=&#34;headerlink&#34; title=&#34;串-简单的模式匹配算法&#34;&gt;&lt;/a&gt;串-简单的模式匹配算法&lt;/h2&gt;&lt;h3 id=&#34;简单的模式匹配算法&#34;&gt;&lt;a href=&#34;#简单的模式匹配算法&#34; class=&#34;headerlink&#34; title=&#34;简单的模式匹配算法&#34;&gt;&lt;/a&gt;简单的模式匹配算法&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;int Index(SSting s,SSting t)        //简单的模式匹配算法
&amp;#123;
    int i=1,j=1;
    while(i&lt;=s.length &amp;&amp; j&lt;= t.length)
    &amp;#123;
        if(s.ch[i]==t.ch[j])
        &amp;#123;
            i++;                      //继续比较后继字符
            j++;
        &amp;#125;else&amp;#123;                        //指针后退重新开始匹配
            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位
            j=1;
        &amp;#125;
    &amp;#125;
    if(j&gt;t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号
    else return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;完整程序源代码&#34;&gt;&lt;a href=&#34;#完整程序源代码&#34; class=&#34;headerlink&#34; title=&#34;完整程序源代码&#34;&gt;&lt;/a&gt;完整程序源代码&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&lt;bits/stdc++.h&gt;
using namespace std;
#define MAXLEN 255					//预定义最大串长
typedef struct&amp;#123;
    char ch[MAXLEN];				//每个分量存储一个字符
    int length;						//串的实际长度
&amp;#125;SSting;
int Index(SSting s,SSting t)        //简单的模式匹配算法
&amp;#123;
    int i=1,j=1;
    while(i&lt;=s.length &amp;&amp; j&lt;= t.length)
    &amp;#123;
        if(s.ch[i]==t.ch[j])
        &amp;#123;
            i++;                      //继续比较后继字符
            j++;
        &amp;#125;else&amp;#123;                        //指针后退重新开始匹配
            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位
            j=1;
        &amp;#125;
    &amp;#125;
    if(j&gt;t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号
    else return 0;
&amp;#125;
int main()
&amp;#123;
    SSting a,b;
    string s1=&#34;ababcabcacbab&#34;;
    string s2=&#34;abcac&#34;;
    a.length=s1.size();
    b.length=s2.size();
    for (int i = 0; i &lt;s1.size(); ++i) &amp;#123;	//初始化
        a.ch[i+1]=s1[i];
    &amp;#125;
    for (int j = 0; j &lt;s2.size() ; ++j) &amp;#123;	//初始化
        b.ch[j+1]=s2[j];
    &amp;#125;
    int x=Index(a,b);
    if(x!=0)
    &amp;#123;
        cout&lt;&lt;&#34;找到了位置是：&#34;&lt;&lt;x&lt;&lt;endl;
    &amp;#125;else&amp;#123;
        cout&lt;&lt;&#34;没有找到&#34;&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序输出&#34;&gt;&lt;a href=&#34;#程序输出&#34; class=&#34;headerlink&#34; title=&#34;程序输出&#34;&gt;&lt;/a&gt;程序输出&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;找到了位置是：6
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/08/Algorithm015/</guid>
            <title>C++的STL中字符串string自带方法find查找</title>
            <link>http://example.com/2022/04/08/Algorithm015/</link>
            <category>String</category>
            <category>Find</category>
            <category>STL</category>
            <category>C++</category>
            <pubDate>Fri, 08 Apr 2022 19:18:57 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;C-的STL中字符串string自带方法find查找&#34;&gt;&lt;a href=&#34;#C-的STL中字符串string自带方法find查找&#34; class=&#34;headerlink&#34; title=&#34;C++的STL中字符串string自带方法find查找&#34;&gt;&lt;/a&gt;C++的STL中字符串string自带方法find查找&lt;/h1&gt;&lt;h2 id=&#34;用法&#34;&gt;&lt;a href=&#34;#用法&#34; class=&#34;headerlink&#34; title=&#34;用法&#34;&gt;&lt;/a&gt;用法&lt;/h2&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;string str = &#34;abcd&#34;;
    cout &lt;&lt; str.find(&#39;a&#39;);
    //返回的是下标的值而不是指针或是迭代器
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;string str = &#34;abcd&#34;
string sub = &#34;cd&#34;
if(str.find(sub)!=string::npos)&amp;#123;
    cout&lt;&lt;&#34;找到了&#34;&lt;&lt;endl;
&amp;#125;else&amp;#123;
    cout&lt;&lt;&#34;没有找到&#34;&lt;&lt;endl;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要是没有找到，返回的是str::npos&lt;br&gt;注意，只有string的find方法是返回的下标，因为string是顺序索引，set,map,multiset,multimap都不是顺序索引的数据结构，所以返回的是迭代器。&lt;/p&gt;
&lt;h2 id=&#34;样例一-L1-070-吃火锅-15-分&#34;&gt;&lt;a href=&#34;#样例一-L1-070-吃火锅-15-分&#34; class=&#34;headerlink&#34; title=&#34;样例一:L1-070 吃火锅 (15 分)&#34;&gt;&lt;/a&gt;样例一:&lt;strong&gt;L1-070 吃火锅 (15 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053&#34;&gt;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2022/04/08/Algorithm015/68518b64-f2f7-4694-aaeb-d32afe657f7b.jpg&#34; alt=&#34;chg.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上图片来自微信朋友圈：这种天气你有什么破事打电话给我基本没用。但是如果你说“吃火锅”，那就厉害了，我们的故事就开始了。&lt;/p&gt;
&lt;p&gt;本题要求你实现一个程序，自动检查你朋友给你发来的信息里有没有 &lt;code&gt;chi1 huo3 guo1&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入每行给出一句不超过 80 个字符的、以回车结尾的朋友信息，信息为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。当读到某一行只有一个英文句点 &lt;code&gt;.&lt;/code&gt; 时，输入结束，此行不算在朋友信息里。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先在一行中输出朋友信息的总条数。然后对朋友的每一行信息，检查其中是否包含 &lt;code&gt;chi1 huo3 guo1&lt;/code&gt;，并且统计这样厉害的信息有多少条。在第二行中首先输出第一次出现 &lt;code&gt;chi1 huo3 guo1&lt;/code&gt; 的信息是第几条（从 1 开始计数），然后输出这类信息的总条数，其间以一个空格分隔。题目保证输出的所有数字不超过 100。&lt;/p&gt;
&lt;p&gt;如果朋友从头到尾都没提 &lt;code&gt;chi1 huo3 guo1&lt;/code&gt; 这个关键词，则在第二行输出一个表情 &lt;code&gt;-_-#&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;输入样例-1：&#34;&gt;&lt;a href=&#34;#输入样例-1：&#34; class=&#34;headerlink&#34; title=&#34;输入样例 1：&#34;&gt;&lt;/a&gt;输入样例 1：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;Hello!
are you there?
wantta chi1 huo3 guo1?
that&#39;s so li hai le
our story begins from chi1 huo3 guo1 le
.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例-1：&#34;&gt;&lt;a href=&#34;#输出样例-1：&#34; class=&#34;headerlink&#34; title=&#34;输出样例 1：&#34;&gt;&lt;/a&gt;输出样例 1：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;5
3 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输入样例-2：&#34;&gt;&lt;a href=&#34;#输入样例-2：&#34; class=&#34;headerlink&#34; title=&#34;输入样例 2：&#34;&gt;&lt;/a&gt;输入样例 2：&lt;/h3&gt;&lt;pre class=&#34; language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;Hello!
are you there?
wantta qi huo3 guo1 chi1huo3guo1?
that&#39;s so li hai le
our story begins from ci1 huo4 guo2 le
.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例-2：&#34;&gt;&lt;a href=&#34;#输出样例-2：&#34; class=&#34;headerlink&#34; title=&#34;输出样例 2：&#34;&gt;&lt;/a&gt;输出样例 2：&lt;/h3&gt;&lt;pre class=&#34; language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;5
-_-#
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码&#34;&gt;&lt;a href=&#34;#程序源代码&#34; class=&#34;headerlink&#34; title=&#34;程序源代码&#34;&gt;&lt;/a&gt;程序源代码&lt;/h3&gt;&lt;pre class=&#34; language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
&amp;#123;
    int flag=0;					//用来判断是否是第一次找到吃火锅
    int cnt=0;					//用来记录总行数
    int count=0;				//用来记录有多少个吃火锅
    int firstp=0;				//用来记录第一次出现吃火锅的位置
    string cmp=&#34;chi1 huo3 guo1&#34;;
    while (true)
    &amp;#123;
        string s;
        s.clear();
        getline(cin,s);
        if(s.size()==1&amp;&amp;s==&#34;.&#34;)&amp;#123;
            break;
        &amp;#125;
        string tmp =s;
        if(tmp.find(cmp)!=string::npos)&amp;#123;
            if(flag==0) &amp;#123;
                flag =1;
                firstp = cnt+1;
            &amp;#125;
            count=count+1;
        &amp;#125;
        cnt=cnt+1;

    &amp;#125;
    if(count==0)&amp;#123;
        cout&lt;&lt;cnt&lt;&lt;endl;
        cout&lt;&lt;&#34;-_-#&#34;&lt;&lt;endl;
    &amp;#125; else&amp;#123;
        cout&lt;&lt;cnt&lt;&lt;endl;
        cout&lt;&lt;firstp&lt;&lt;&#34; &#34;&lt;&lt;count&lt;&lt;endl;
    &amp;#125;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_50675813/article/details/113313343&#34;&gt;(18条消息) c++STL中的find()函数 有两种使用方法_我们不生产代码，只是代码的搬运工的博客-CSDN博客_c++中find函数的使用方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053&#34;&gt;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482053&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
