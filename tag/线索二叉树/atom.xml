<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>Amicoyuan • Posts by &#34;线索二叉树&#34; tag</title>
    <link href="http://example.com" />
    <updated>2022-05-04T12:05:19.000Z</updated>
    <category term="AVX" />
    <category term="Data Structure" />
    <category term="String" />
    <category term="Find" />
    <category term="STL" />
    <category term="C++" />
    <category term="Set" />
    <category term="团体程序设计天梯赛" />
    <category term="Sort" />
    <category term="LinkList" />
    <category term="双向链表" />
    <category term="Graph" />
    <category term="邻接表" />
    <category term="Vector" />
    <category term="Binary tree" />
    <category term="BFS" />
    <category term="模拟" />
    <category term="邻接矩阵" />
    <category term="DFS" />
    <category term="结构体" />
    <category term="贪心" />
    <category term="Double类型相等比较" />
    <category term="并查集" />
    <category term="Map" />
    <category term="Pair" />
    <category term="KMP" />
    <category term="线索二叉树" />
    <category term="Tree" />
    <category term="森林" />
    <category term="Linux" />
    <category term="MPI" />
    <category term="Numactl" />
    <category term="Slurm" />
    <category term="Tensorflow" />
    <category term="性能分析工具" />
    <category term="gcov" />
    <entry>
        <id>http://example.com/2022/05/04/Algorithm035/</id>
        <title>线索二叉树</title>
        <link rel="alternate" href="http://example.com/2022/05/04/Algorithm035/"/>
        <content type="html">&lt;h2 id=&#34;线索二叉树&#34;&gt;&lt;a href=&#34;#线索二叉树&#34; class=&#34;headerlink&#34; title=&#34;线索二叉树&#34;&gt;&lt;/a&gt;线索二叉树&lt;/h2&gt;&lt;h3 id=&#34;线索二叉树的存储结构&#34;&gt;&lt;a href=&#34;#线索二叉树的存储结构&#34; class=&#34;headerlink&#34; title=&#34;线索二叉树的存储结构&#34;&gt;&lt;/a&gt;线索二叉树的存储结构&lt;/h3&gt;&lt;p&gt;线索二叉树的存储结构描述如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;ltag = 0 lchild域指示结点的左孩子
ltag = 1 lchild域指示结点的前驱
//
rtag = 0 rchild域指示结点的右孩子
rtag = 1 rchild域指示结点的后继
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;typedef struct ThreadNode&amp;#123;
    ElemType data;						//数据元素
    struct ThreadNode *lchild,*rchild;				//左右孩子指针
    int ltag,rtag;									//左右线索标志
&amp;#125;ThreadNode，*ThreadTree;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;中序线索二叉树的构造&#34;&gt;&lt;a href=&#34;#中序线索二叉树的构造&#34; class=&#34;headerlink&#34; title=&#34;中序线索二叉树的构造&#34;&gt;&lt;/a&gt;中序线索二叉树的构造&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void InThread(ThreadTree &amp;amp;p,ThreadNode &amp;amp;pre)&amp;#123;
    if(p!=NULL)&amp;#123;
        InThread(p-&amp;gt;lchild,pre);			//递归，线索化左子树
        &amp;#123;
            if(p-&amp;gt;lchild==NULL)&amp;#123;			//左子树为空，建立前驱线索
                p-&amp;gt;lchild=pre;
                p-&amp;gt;ltag=1;
            &amp;#125;
            if(pre!=NULL&amp;amp;&amp;amp;pre-&amp;gt;rchild==NULL)&amp;#123;
                pre-&amp;gt;rchild=p;				//建立前驱结点的后继线索
                pre-&amp;gt;rtag=1;
            &amp;#125;
            pre=p;							//标记当前结点成为刚刚访问过的结点
            InThread(p-&amp;gt;rchild,pre);		//递归，线索化右子树
        &amp;#125;//if(p!=NULL)
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void CreateInThread(ThreadTree T)&amp;#123;
    ThreadTree pre = NULL;
    if(T!=NULL)&amp;#123;						//非空二叉树。线索化
        InThread(T,pre);				//线索化二叉树
        pre-&amp;gt;rchild=NULL;				//处理遍历的最后一个结点
        pre-&amp;gt;rtag=1;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;中序线索二叉树的遍历&#34;&gt;&lt;a href=&#34;#中序线索二叉树的遍历&#34; class=&#34;headerlink&#34; title=&#34;中序线索二叉树的遍历&#34;&gt;&lt;/a&gt;中序线索二叉树的遍历&lt;/h3&gt;&lt;p&gt;1)求中序线索二叉树中中序序列下的第一个结点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;Thread *Firstnode(ThreadNode *p)&amp;#123;
    while(p-&amp;gt;ltag==0) p=p-&amp;gt;lchild;		//最左下结点（不一定是叶结点）
    return p;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2)求中序线索二叉树中结点p在中序序列下的后继&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;ThreadNode *Nextnode(ThreadNode *p)&amp;#123;
    if(p-&amp;gt;rtag==0) return Firstnode(p-&amp;gt;rchild);
    else return p-&amp;gt;rchild;			//rtag==1直接返回后继线索
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3)利用上面两个算法，可以写出不含头节点的中序线索二叉树的中序遍历算法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void Inorder(ThreadNode *T)&amp;#123;
    for(ThreadNode *p=Firstnode;p!=NULL;p=Nextnode(p))
        visit(p);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Data Structure" />
        <category term="Binary tree" />
        <category term="线索二叉树" />
        <updated>2022-05-04T12:05:19.000Z</updated>
    </entry>
</feed>
