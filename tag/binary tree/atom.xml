<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>Amicoyuan • Posts by &#34;binary tree&#34; tag</title>
    <link href="http://example.com" />
    <updated>2022-05-04T12:05:19.000Z</updated>
    <category term="AVX" />
    <category term="Data Structure" />
    <category term="String" />
    <category term="Find" />
    <category term="STL" />
    <category term="C++" />
    <category term="Set" />
    <category term="团体程序设计天梯赛" />
    <category term="Sort" />
    <category term="LinkList" />
    <category term="双向链表" />
    <category term="Graph" />
    <category term="邻接表" />
    <category term="Vector" />
    <category term="Binary tree" />
    <category term="BFS" />
    <category term="模拟" />
    <category term="邻接矩阵" />
    <category term="DFS" />
    <category term="结构体" />
    <category term="贪心" />
    <category term="Double类型相等比较" />
    <category term="并查集" />
    <category term="Map" />
    <category term="Pair" />
    <category term="KMP" />
    <category term="线索二叉树" />
    <category term="Tree" />
    <category term="森林" />
    <category term="Linux" />
    <category term="MPI" />
    <category term="Numactl" />
    <category term="Slurm" />
    <category term="Tensorflow" />
    <category term="性能分析工具" />
    <category term="gcov" />
    <entry>
        <id>http://example.com/2022/05/04/Algorithm035/</id>
        <title>线索二叉树</title>
        <link rel="alternate" href="http://example.com/2022/05/04/Algorithm035/"/>
        <content type="html">&lt;h2 id=&#34;线索二叉树&#34;&gt;&lt;a href=&#34;#线索二叉树&#34; class=&#34;headerlink&#34; title=&#34;线索二叉树&#34;&gt;&lt;/a&gt;线索二叉树&lt;/h2&gt;&lt;h3 id=&#34;线索二叉树的存储结构&#34;&gt;&lt;a href=&#34;#线索二叉树的存储结构&#34; class=&#34;headerlink&#34; title=&#34;线索二叉树的存储结构&#34;&gt;&lt;/a&gt;线索二叉树的存储结构&lt;/h3&gt;&lt;p&gt;线索二叉树的存储结构描述如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;ltag = 0 lchild域指示结点的左孩子
ltag = 1 lchild域指示结点的前驱
//
rtag = 0 rchild域指示结点的右孩子
rtag = 1 rchild域指示结点的后继
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;typedef struct ThreadNode&amp;#123;
    ElemType data;						//数据元素
    struct ThreadNode *lchild,*rchild;				//左右孩子指针
    int ltag,rtag;									//左右线索标志
&amp;#125;ThreadNode，*ThreadTree;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;中序线索二叉树的构造&#34;&gt;&lt;a href=&#34;#中序线索二叉树的构造&#34; class=&#34;headerlink&#34; title=&#34;中序线索二叉树的构造&#34;&gt;&lt;/a&gt;中序线索二叉树的构造&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void InThread(ThreadTree &amp;amp;p,ThreadNode &amp;amp;pre)&amp;#123;
    if(p!=NULL)&amp;#123;
        InThread(p-&amp;gt;lchild,pre);			//递归，线索化左子树
        &amp;#123;
            if(p-&amp;gt;lchild==NULL)&amp;#123;			//左子树为空，建立前驱线索
                p-&amp;gt;lchild=pre;
                p-&amp;gt;ltag=1;
            &amp;#125;
            if(pre!=NULL&amp;amp;&amp;amp;pre-&amp;gt;rchild==NULL)&amp;#123;
                pre-&amp;gt;rchild=p;				//建立前驱结点的后继线索
                pre-&amp;gt;rtag=1;
            &amp;#125;
            pre=p;							//标记当前结点成为刚刚访问过的结点
            InThread(p-&amp;gt;rchild,pre);		//递归，线索化右子树
        &amp;#125;//if(p!=NULL)
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void CreateInThread(ThreadTree T)&amp;#123;
    ThreadTree pre = NULL;
    if(T!=NULL)&amp;#123;						//非空二叉树。线索化
        InThread(T,pre);				//线索化二叉树
        pre-&amp;gt;rchild=NULL;				//处理遍历的最后一个结点
        pre-&amp;gt;rtag=1;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;中序线索二叉树的遍历&#34;&gt;&lt;a href=&#34;#中序线索二叉树的遍历&#34; class=&#34;headerlink&#34; title=&#34;中序线索二叉树的遍历&#34;&gt;&lt;/a&gt;中序线索二叉树的遍历&lt;/h3&gt;&lt;p&gt;1)求中序线索二叉树中中序序列下的第一个结点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;Thread *Firstnode(ThreadNode *p)&amp;#123;
    while(p-&amp;gt;ltag==0) p=p-&amp;gt;lchild;		//最左下结点（不一定是叶结点）
    return p;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2)求中序线索二叉树中结点p在中序序列下的后继&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;ThreadNode *Nextnode(ThreadNode *p)&amp;#123;
    if(p-&amp;gt;rtag==0) return Firstnode(p-&amp;gt;rchild);
    else return p-&amp;gt;rchild;			//rtag==1直接返回后继线索
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3)利用上面两个算法，可以写出不含头节点的中序线索二叉树的中序遍历算法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void Inorder(ThreadNode *T)&amp;#123;
    for(ThreadNode *p=Firstnode;p!=NULL;p=Nextnode(p))
        visit(p);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="Data Structure" />
        <category term="Binary tree" />
        <category term="线索二叉树" />
        <updated>2022-05-04T12:05:19.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/14/Algorithm024/</id>
        <title>L2-011 玩转二叉树 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/14/Algorithm024/"/>
        <content type="html">&lt;h2 id=&#34;L2-011-玩转二叉树-25-分&#34;&gt;&lt;a href=&#34;#L2-011-玩转二叉树-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-011 玩转二叉树 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-011 玩转二叉树 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出一个正整数&lt;code&gt;N&lt;/code&gt;（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;7
1 2 3 4 5 6 7
4 1 3 2 6 5 7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;4 6 1 7 5 3 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;镜面反转即为在层序遍历时交换左右子树的遍历顺序，左-&amp;gt;右变成右-&amp;gt;左&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前序 + 中序 建树 + BFS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建树详细过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/04/07/Algorithm014/&#34;&gt;由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef struct BiTNode&amp;#123;
    int data;
    struct BiTNode *lchild,*rchild;
&amp;#125;BiTNode,*BiTree;
int n;
int in[35];
int pre[35];
BiTree PostCreate(int prel,int prer,int inl,int inr)&amp;#123;					//前序加中序建树
    if(prel&amp;gt;prer)&amp;#123;
        return NULL;
    &amp;#125;
    BiTNode *root;
    root=(BiTNode*)malloc(sizeof(BiTNode));
    root-&amp;gt;data=pre[prel];
    int index=0;
    for (int i = inl; i &amp;lt;=inr; ++i) &amp;#123;
        if(pre[prel]==in[i])&amp;#123;
            index=i;
            break;
        &amp;#125;
    &amp;#125;
    int numleft=index-inl;
    root-&amp;gt;lchild=PostCreate(prel+1,prel+numleft,inl,index-1);
    root-&amp;gt;rchild=PostCreate(prel+numleft+1,prer,index+1,inr);
    return root;
&amp;#125;
void LevelOrder(BiTree T)
&amp;#123;
    queue&amp;lt;BiTree&amp;gt; q;
    q.push(T);
    int i=0;
    while (!q.empty())&amp;#123;
        BiTNode *tmp =q.front();
        q.pop();
        if(i!=n-1)&amp;#123;										//输出格式控制
            cout&amp;lt;&amp;lt;tmp-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        &amp;#125;else&amp;#123;
            cout&amp;lt;&amp;lt;tmp-&amp;gt;data;
        &amp;#125;
        i++;
        if(tmp-&amp;gt;rchild!=NULL)&amp;#123;							//镜面反转，左-&amp;gt;右变成右-&amp;gt;左
            q.push(tmp-&amp;gt;rchild);
        &amp;#125;
        if(tmp-&amp;gt;lchild!=NULL)&amp;#123;
            q.push(tmp-&amp;gt;lchild);
        &amp;#125;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    BiTree tree;
    tree=NULL;
    cin&amp;gt;&amp;gt;n;
    for (int i = 0; i &amp;lt;n ; ++i) &amp;#123;
        cin&amp;gt;&amp;gt;in[i];
    &amp;#125;
    for (int j = 0; j &amp;lt;n ; ++j) &amp;#123;
        cin&amp;gt;&amp;gt;pre[j];
    &amp;#125;
    tree=PostCreate(0,n-1,0,n-1);
    LevelOrder(tree);
    cout&amp;lt;&amp;lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784&#34;&gt;题目详情 - L2-011 玩转二叉树 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/04/07/Algorithm014/&#34;&gt;由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Binary tree" />
        <category term="BFS" />
        <updated>2022-04-14T06:01:10.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/14/Algorithm023/</id>
        <title>L2-035 完全二叉树的层序遍历 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/14/Algorithm023/"/>
        <content type="html">&lt;h2 id=&#34;L2-035-完全二叉树的层序遍历-25-分&#34;&gt;&lt;a href=&#34;#L2-035-完全二叉树的层序遍历-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-035 完全二叉树的层序遍历 (25 分)&#34;&gt;&lt;/a&gt;L2-035 完全二叉树的层序遍历 (25 分)&lt;/h2&gt;&lt;p&gt;一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是&lt;strong&gt;完美二叉树&lt;/strong&gt;。对于深度为 &lt;em&gt;D&lt;/em&gt; 的，有 &lt;em&gt;N&lt;/em&gt; 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 &lt;em&gt;N&lt;/em&gt; 个结点，这样的树就是&lt;strong&gt;完全二叉树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行中给出正整数 &lt;em&gt;N&lt;/em&gt;（≤30），即树中结点个数。第二行给出后序遍历序列，为 &lt;em&gt;N&lt;/em&gt; 个不超过 100 的正整数。同一行中所有数字都以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;8
91 71 2 34 10 15 55 18
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;18 34 55 71 2 10 15 91
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;后序遍历建树 + 完全二叉树性质&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int tree[10001];
int n;
void post(int i)&amp;#123;		//根据后序遍历建树
    if(2*i&amp;lt;=n)&amp;#123;			//当2*i&amp;lt;=n时，结点i的左孩子编号为2*i，否则无左孩子
        post(2*i);
    &amp;#125;
    if(2*i+1&amp;lt;=n)&amp;#123;		//当2*i+1&amp;lt;=n时，结点i的右孩子编号为2*i+1，否则无右孩子
        post(2*i+1);
    &amp;#125;
    cin&amp;gt;&amp;gt;tree[i];
&amp;#125;
int main()
&amp;#123;

    cin&amp;gt;&amp;gt;n;
    post(1);           //后序遍历建树
    for (int i = 1; i &amp;lt;=n ; ++i) &amp;#123;						//顺序输出即为层序遍历
        if(i!=n)&amp;#123;
            cout&amp;lt;&amp;lt;tree[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        &amp;#125;else&amp;#123;
            cout&amp;lt;&amp;lt;tree[i];
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058&#34;&gt;https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="Binary tree" />
        <updated>2022-04-14T06:01:05.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/13/Algorithm022/</id>
        <title>L2-031 深入虎穴 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/13/Algorithm022/"/>
        <content type="html">&lt;p&gt;著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。&lt;/p&gt;
&lt;p&gt;内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入首先在一行中给出正整数 &lt;em&gt;N&lt;/em&gt;（&amp;lt;105），是门的数量。最后 &lt;em&gt;N&lt;/em&gt; 行，第 &lt;em&gt;i&lt;/em&gt; 行（1≤&lt;em&gt;i&lt;/em&gt;≤&lt;em&gt;N&lt;/em&gt;）按以下格式描述编号为 &lt;em&gt;i&lt;/em&gt; 的那扇门背后能通向的门：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;K D[1] D[2] ... D[K]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;K&lt;/code&gt; 是通道的数量，其后是每扇门的编号。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;13
3 2 3 4
2 5 6
1 7
1 8
1 9
0
2 11 10
1 13
0
0
1 12
0
0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;12
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接表 + BFS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
vector&amp;lt;int&amp;gt; v[100005];
int book[100005];
int start=0;
int bfs()&amp;#123;								//BFS
    queue&amp;lt;int&amp;gt; q;
    q.push(start);						//根节点入队
    int x;
    while(!q.empty())&amp;#123;
        x=q.front();
        q.pop();
        for (int i = 0; i &amp;lt;v[x].size() ; ++i) &amp;#123;				
            q.push(v[x][i]);
        &amp;#125;
    &amp;#125;									//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。
    return x;							//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门
&amp;#125;
int main()
&amp;#123;
    int n;
    cin&amp;gt;&amp;gt;n;
    for (int i = 1; i &amp;lt;=n ; ++i) &amp;#123;
        int time;
        cin&amp;gt;&amp;gt;time;
        for (int j = 1; j &amp;lt;=time ; ++j) &amp;#123;
            int num;
            cin&amp;gt;&amp;gt;num;
            book[num]=1;
            v[i].push_back(num);

        &amp;#125;
    &amp;#125;
    for (int k = 1; k &amp;lt;=n ; ++k) &amp;#123;			//找入口
        if(book[k]==0) start=k;				//没有门通向的门，即为入口
    &amp;#125;
    int ans=bfs();
    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888&#34;&gt;题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="邻接表" />
        <category term="Vector" />
        <category term="Binary tree" />
        <category term="BFS" />
        <updated>2022-04-13T11:09:46.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2022/04/13/Algorithm019/</id>
        <title>L2-026 小字辈 (25 分)</title>
        <link rel="alternate" href="http://example.com/2022/04/13/Algorithm019/"/>
        <content type="html">&lt;h2 id=&#34;L2-026-小字辈-25-分&#34;&gt;&lt;a href=&#34;#L2-026-小字辈-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-026 小字辈 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-026 小字辈 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父&amp;#x2F;母。家谱中辈分最高的老祖宗对应的父&amp;#x2F;母编号为 -1。一行中的数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;in&#34;&gt;9
2 6 5 5 -1 5 6 4 7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;out&#34;&gt;4
1 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接表建树+BFS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
vector&amp;lt;int&amp;gt; tree[100005];				//邻接表建树
int deeptree[100005];					//记录树的深度
int n;
int root;								//根节点
int bfs()&amp;#123;								//bfs
    queue&amp;lt;int&amp;gt; q;
    q.push(root);						//根节点入队
    int x;								
    while(!q.empty())&amp;#123;
        x=q.front();
        q.pop();
        for (int i = 0; i &amp;lt;tree[x].size() ; ++i) &amp;#123;
            deeptree[tree[x][i]]=deeptree[x]+1;						//每一层的深度为上一层加1
            q.push(tree[x][i]);

        &amp;#125;
    &amp;#125;
    return deeptree[x];				//返回最后一个结点的深度，即深度的最大值
&amp;#125;
int main()
&amp;#123;
    n;
    cin&amp;gt;&amp;gt;n;
    int a[n];
    for (int i = 1; i &amp;lt;=n ; ++i) &amp;#123;
        cin&amp;gt;&amp;gt;a[i];
        if(a[i]==-1)&amp;#123;
            root=i;				//找根节点
        &amp;#125;
    &amp;#125;
    for (int j = 1; j &amp;lt;=n ; ++j) &amp;#123;					//建树
        tree[a[j]].push_back(j);					//j是a[j]的孩子节点
        if(a[j]==-1) deeptree[j]=1;					//初始化根节点深度为1
    &amp;#125;
    int ans=bfs();
    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
    int maxdeepcnt=0;								//记录最大深度的个数
    int tmp[n];										//找最大深度的id
    for (int k = 1; k &amp;lt;=n ; ++k) &amp;#123;					
        if(ans==deeptree[k])&amp;#123;
            maxdeepcnt++;
            tmp[maxdeepcnt]=k;
        &amp;#125;
    &amp;#125;
    //输出格式控制
    for (int l = 1; l &amp;lt;=maxdeepcnt ; ++l) &amp;#123;
        if(l!=maxdeepcnt) cout&amp;lt;&amp;lt;tmp[l]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        else cout&amp;lt;&amp;lt;tmp[l]&amp;lt;&amp;lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808&#34;&gt;题目详情 - L2-026 小字辈 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="Data Structure" />
        <category term="C++" />
        <category term="团体程序设计天梯赛" />
        <category term="邻接表" />
        <category term="Vector" />
        <category term="Binary tree" />
        <category term="BFS" />
        <updated>2022-04-13T01:45:49.000Z</updated>
    </entry>
</feed>
