{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"binary tree\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/05/04/Algorithm035/",
            "url": "http://example.com/2022/05/04/Algorithm035/",
            "title": "线索二叉树",
            "date_published": "2022-05-04T12:05:19.000Z",
            "content_html": "<h2 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h2><h3 id=\"线索二叉树的存储结构\"><a href=\"#线索二叉树的存储结构\" class=\"headerlink\" title=\"线索二叉树的存储结构\"></a>线索二叉树的存储结构</h3><p>线索二叉树的存储结构描述如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">ltag = <span class=\"hljs-number\">0</span> lchild域指示结点的左孩子<br>ltag = <span class=\"hljs-number\">1</span> lchild域指示结点的前驱<br><span class=\"hljs-comment\">//</span><br>rtag = <span class=\"hljs-number\">0</span> rchild域指示结点的右孩子<br>rtag = <span class=\"hljs-number\">1</span> rchild域指示结点的后继<br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ThreadNode</span>&#123;</span><br>    ElemType data;\t\t\t\t\t\t<span class=\"hljs-comment\">//数据元素</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ThreadNode</span> *<span class=\"hljs-title\">lchild</span>,*<span class=\"hljs-title\">rchild</span>;</span>\t\t\t\t<span class=\"hljs-comment\">//左右孩子指针</span><br>    <span class=\"hljs-keyword\">int</span> ltag,rtag;\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//左右线索标志</span><br>&#125;ThreadNode，*ThreadTree;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"中序线索二叉树的构造\"><a href=\"#中序线索二叉树的构造\" class=\"headerlink\" title=\"中序线索二叉树的构造\"></a>中序线索二叉树的构造</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">InThread</span><span class=\"hljs-params\">(ThreadTree &amp;p,ThreadNode &amp;pre)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(p!=<span class=\"hljs-literal\">NULL</span>)&#123;<br>        <span class=\"hljs-built_in\">InThread</span>(p-&gt;lchild,pre);\t\t\t<span class=\"hljs-comment\">//递归，线索化左子树</span><br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(p-&gt;lchild==<span class=\"hljs-literal\">NULL</span>)&#123;\t\t\t<span class=\"hljs-comment\">//左子树为空，建立前驱线索</span><br>                p-&gt;lchild=pre;<br>                p-&gt;ltag=<span class=\"hljs-number\">1</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span>(pre!=<span class=\"hljs-literal\">NULL</span>&amp;&amp;pre-&gt;rchild==<span class=\"hljs-literal\">NULL</span>)&#123;<br>                pre-&gt;rchild=p;\t\t\t\t<span class=\"hljs-comment\">//建立前驱结点的后继线索</span><br>                pre-&gt;rtag=<span class=\"hljs-number\">1</span>;<br>            &#125;<br>            pre=p;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//标记当前结点成为刚刚访问过的结点</span><br>            <span class=\"hljs-built_in\">InThread</span>(p-&gt;rchild,pre);\t\t<span class=\"hljs-comment\">//递归，线索化右子树</span><br>        &#125;<span class=\"hljs-comment\">//if(p!=NULL)</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CreateInThread</span><span class=\"hljs-params\">(ThreadTree T)</span></span>&#123;<br>    ThreadTree pre = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-keyword\">if</span>(T!=<span class=\"hljs-literal\">NULL</span>)&#123;\t\t\t\t\t\t<span class=\"hljs-comment\">//非空二叉树。线索化</span><br>        <span class=\"hljs-built_in\">InThread</span>(T,pre);\t\t\t\t<span class=\"hljs-comment\">//线索化二叉树</span><br>        pre-&gt;rchild=<span class=\"hljs-literal\">NULL</span>;\t\t\t\t<span class=\"hljs-comment\">//处理遍历的最后一个结点</span><br>        pre-&gt;rtag=<span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"中序线索二叉树的遍历\"><a href=\"#中序线索二叉树的遍历\" class=\"headerlink\" title=\"中序线索二叉树的遍历\"></a>中序线索二叉树的遍历</h3><p>1)求中序线索二叉树中中序序列下的第一个结点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Thread *<span class=\"hljs-title\">Firstnode</span><span class=\"hljs-params\">(ThreadNode *p)</span></span>&#123;<br>    <span class=\"hljs-keyword\">while</span>(p-&gt;ltag==<span class=\"hljs-number\">0</span>) p=p-&gt;lchild;\t\t<span class=\"hljs-comment\">//最左下结点（不一定是叶结点）</span><br>    <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>2)求中序线索二叉树中结点p在中序序列下的后继</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">ThreadNode *<span class=\"hljs-title\">Nextnode</span><span class=\"hljs-params\">(ThreadNode *p)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(p-&gt;rtag==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Firstnode</span>(p-&gt;rchild);<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> p-&gt;rchild;\t\t\t<span class=\"hljs-comment\">//rtag==1直接返回后继线索</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>3)利用上面两个算法，可以写出不含头节点的中序线索二叉树的中序遍历算法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Inorder</span><span class=\"hljs-params\">(ThreadNode *T)</span></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(ThreadNode *p=Firstnode;p!=<span class=\"hljs-literal\">NULL</span>;p=<span class=\"hljs-built_in\">Nextnode</span>(p))<br>        <span class=\"hljs-built_in\">visit</span>(p);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n",
            "tags": [
                "Data Structure",
                "Binary tree",
                "线索二叉树"
            ]
        },
        {
            "id": "http://example.com/2022/04/14/Algorithm024/",
            "url": "http://example.com/2022/04/14/Algorithm024/",
            "title": "L2-011 玩转二叉树 (25 分)",
            "date_published": "2022-04-14T06:01:10.000Z",
            "content_html": "<h2 id=\"L2-011-玩转二叉树-25-分\"><a href=\"#L2-011-玩转二叉树-25-分\" class=\"headerlink\" title=\"L2-011 玩转二叉树 (25 分)\"></a><strong>L2-011 玩转二叉树 (25 分)</strong></h2><p>给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs in\">7<br>1 2 3 4 5 6 7<br>4 1 3 2 6 5 7<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs out\">4 6 1 7 5 3 2<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>镜面反转即为在层序遍历时交换左右子树的遍历顺序，左-&gt;右变成右-&gt;左</strong></p>\n<p><strong>前序 + 中序 建树 + BFS</strong></p>\n<p><strong>建树详细过程：</strong></p>\n<p><a href=\"https://xingyuanjie.top/2022/04/07/Algorithm014/\">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">BiTNode</span>&#123;</span><br>    <span class=\"hljs-keyword\">int</span> data;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">BiTNode</span> *<span class=\"hljs-title\">lchild</span>,*<span class=\"hljs-title\">rchild</span>;</span><br>&#125;BiTNode,*BiTree;<br><span class=\"hljs-keyword\">int</span> n;<br><span class=\"hljs-keyword\">int</span> in[<span class=\"hljs-number\">35</span>];<br><span class=\"hljs-keyword\">int</span> pre[<span class=\"hljs-number\">35</span>];<br><span class=\"hljs-function\">BiTree <span class=\"hljs-title\">PostCreate</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> prel,<span class=\"hljs-keyword\">int</span> prer,<span class=\"hljs-keyword\">int</span> inl,<span class=\"hljs-keyword\">int</span> inr)</span></span>&#123;\t\t\t\t\t<span class=\"hljs-comment\">//前序加中序建树</span><br>    <span class=\"hljs-keyword\">if</span>(prel&gt;prer)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>    &#125;<br>    BiTNode *root;<br>    root=(BiTNode*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(BiTNode));<br>    root-&gt;data=pre[prel];<br>    <span class=\"hljs-keyword\">int</span> index=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = inl; i &lt;=inr; ++i) &#123;<br>        <span class=\"hljs-keyword\">if</span>(pre[prel]==in[i])&#123;<br>            index=i;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> numleft=index-inl;<br>    root-&gt;lchild=<span class=\"hljs-built_in\">PostCreate</span>(prel+<span class=\"hljs-number\">1</span>,prel+numleft,inl,index<span class=\"hljs-number\">-1</span>);<br>    root-&gt;rchild=<span class=\"hljs-built_in\">PostCreate</span>(prel+numleft+<span class=\"hljs-number\">1</span>,prer,index+<span class=\"hljs-number\">1</span>,inr);<br>    <span class=\"hljs-keyword\">return</span> root;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">LevelOrder</span><span class=\"hljs-params\">(BiTree T)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    queue&lt;BiTree&gt; q;<br>    q.<span class=\"hljs-built_in\">push</span>(T);<br>    <span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">empty</span>())&#123;<br>        BiTNode *tmp =q.<span class=\"hljs-built_in\">front</span>();<br>        q.<span class=\"hljs-built_in\">pop</span>();<br>        <span class=\"hljs-keyword\">if</span>(i!=n<span class=\"hljs-number\">-1</span>)&#123;\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//输出格式控制</span><br>            cout&lt;&lt;tmp-&gt;data&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            cout&lt;&lt;tmp-&gt;data;<br>        &#125;<br>        i++;<br>        <span class=\"hljs-keyword\">if</span>(tmp-&gt;rchild!=<span class=\"hljs-literal\">NULL</span>)&#123;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//镜面反转，左-&gt;右变成右-&gt;左</span><br>            q.<span class=\"hljs-built_in\">push</span>(tmp-&gt;rchild);<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(tmp-&gt;lchild!=<span class=\"hljs-literal\">NULL</span>)&#123;<br>            q.<span class=\"hljs-built_in\">push</span>(tmp-&gt;lchild);<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    BiTree tree;<br>    tree=<span class=\"hljs-literal\">NULL</span>;<br>    cin&gt;&gt;n;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;n ; ++i) &#123;<br>        cin&gt;&gt;in[i];<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt;n ; ++j) &#123;<br>        cin&gt;&gt;pre[j];<br>    &#125;<br>    tree=<span class=\"hljs-built_in\">PostCreate</span>(<span class=\"hljs-number\">0</span>,n<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">0</span>,n<span class=\"hljs-number\">-1</span>);<br>    <span class=\"hljs-built_in\">LevelOrder</span>(tree);<br>    cout&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784\">题目详情 - L2-011 玩转二叉树 (25 分) (pintia.cn)</a></p>\n<p><a href=\"https://xingyuanjie.top/2022/04/07/Algorithm014/\">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Binary tree",
                "BFS"
            ]
        },
        {
            "id": "http://example.com/2022/04/14/Algorithm023/",
            "url": "http://example.com/2022/04/14/Algorithm023/",
            "title": "L2-035 完全二叉树的层序遍历 (25 分)",
            "date_published": "2022-04-14T06:01:05.000Z",
            "content_html": "<h2 id=\"L2-035-完全二叉树的层序遍历-25-分\"><a href=\"#L2-035-完全二叉树的层序遍历-25-分\" class=\"headerlink\" title=\"L2-035 完全二叉树的层序遍历 (25 分)\"></a>L2-035 完全二叉树的层序遍历 (25 分)</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是<strong>完美二叉树</strong>。对于深度为 <em>D</em> 的，有 <em>N</em> 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 <em>N</em> 个结点，这样的树就是<strong>完全二叉树</strong>。</p>\n<p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>N</em>（≤30），即树中结点个数。第二行给出后序遍历序列，为 <em>N</em> 个不超过 100 的正整数。同一行中所有数字都以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs in\">8<br>91 71 2 34 10 15 55 18<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs out\">18 34 55 71 2 10 15 91<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>后序遍历建树 + 完全二叉树性质</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">int</span> tree[<span class=\"hljs-number\">10001</span>];<br><span class=\"hljs-keyword\">int</span> n;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">post</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span></span>&#123;\t\t<span class=\"hljs-comment\">//根据后序遍历建树</span><br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">2</span>*i&lt;=n)&#123;\t\t\t<span class=\"hljs-comment\">//当2*i&lt;=n时，结点i的左孩子编号为2*i，否则无左孩子</span><br>        <span class=\"hljs-built_in\">post</span>(<span class=\"hljs-number\">2</span>*i);<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">2</span>*i+<span class=\"hljs-number\">1</span>&lt;=n)&#123;\t\t<span class=\"hljs-comment\">//当2*i+1&lt;=n时，结点i的右孩子编号为2*i+1，否则无右孩子</span><br>        <span class=\"hljs-built_in\">post</span>(<span class=\"hljs-number\">2</span>*i+<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    cin&gt;&gt;tree[i];<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br><br>    cin&gt;&gt;n;<br>    <span class=\"hljs-built_in\">post</span>(<span class=\"hljs-number\">1</span>);           <span class=\"hljs-comment\">//后序遍历建树</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;=n ; ++i) &#123;\t\t\t\t\t\t<span class=\"hljs-comment\">//顺序输出即为层序遍历</span><br>        <span class=\"hljs-keyword\">if</span>(i!=n)&#123;<br>            cout&lt;&lt;tree[i]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            cout&lt;&lt;tree[i];<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058\">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Binary tree"
            ]
        },
        {
            "id": "http://example.com/2022/04/13/Algorithm022/",
            "url": "http://example.com/2022/04/13/Algorithm022/",
            "title": "L2-031 深入虎穴 (25 分)",
            "date_published": "2022-04-13T11:09:46.000Z",
            "content_html": "<p>著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。</p>\n<p>内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入首先在一行中给出正整数 <em>N</em>（&lt;105），是门的数量。最后 <em>N</em> 行，第 <em>i</em> 行（1≤<em>i</em>≤<em>N</em>）按以下格式描述编号为 <em>i</em> 的那扇门背后能通向的门：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs mathematica\"><span class=\"hljs-built_in\">K</span> <span class=\"hljs-built_in\">D</span><span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-built_in\">D</span><span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">2</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-operator\">...</span> <span class=\"hljs-built_in\">D</span><span class=\"hljs-punctuation\">[</span><span class=\"hljs-built_in\">K</span><span class=\"hljs-punctuation\">]</span><br></code></pre></div></td></tr></table></figure>\n\n<p>其中 <code>K</code> 是通道的数量，其后是每扇门的编号。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs in\">13<br>3 2 3 4<br>2 5 6<br>1 7<br>1 8<br>1 9<br>0<br>2 11 10<br>1 13<br>0<br>0<br>1 12<br>0<br>0<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs out\">12<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接表 + BFS</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br>vector&lt;<span class=\"hljs-keyword\">int</span>&gt; v[<span class=\"hljs-number\">100005</span>];<br><span class=\"hljs-keyword\">int</span> book[<span class=\"hljs-number\">100005</span>];<br><span class=\"hljs-keyword\">int</span> start=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">()</span></span>&#123;\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//BFS</span><br>    queue&lt;<span class=\"hljs-keyword\">int</span>&gt; q;<br>    q.<span class=\"hljs-built_in\">push</span>(start);\t\t\t\t\t\t<span class=\"hljs-comment\">//根节点入队</span><br>    <span class=\"hljs-keyword\">int</span> x;<br>    <span class=\"hljs-keyword\">while</span>(!q.<span class=\"hljs-built_in\">empty</span>())&#123;<br>        x=q.<span class=\"hljs-built_in\">front</span>();<br>        q.<span class=\"hljs-built_in\">pop</span>();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;v[x].<span class=\"hljs-built_in\">size</span>() ; ++i) &#123;\t\t\t\t<br>            q.<span class=\"hljs-built_in\">push</span>(v[x][i]);<br>        &#125;<br>    &#125;\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</span><br>    <span class=\"hljs-keyword\">return</span> x;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;=n ; ++i) &#123;<br>        <span class=\"hljs-keyword\">int</span> time;<br>        cin&gt;&gt;time;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;=time ; ++j) &#123;<br>            <span class=\"hljs-keyword\">int</span> num;<br>            cin&gt;&gt;num;<br>            book[num]=<span class=\"hljs-number\">1</span>;<br>            v[i].<span class=\"hljs-built_in\">push_back</span>(num);<br><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">1</span>; k &lt;=n ; ++k) &#123;\t\t\t<span class=\"hljs-comment\">//找入口</span><br>        <span class=\"hljs-keyword\">if</span>(book[k]==<span class=\"hljs-number\">0</span>) start=k;\t\t\t\t<span class=\"hljs-comment\">//没有门通向的门，即为入口</span><br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> ans=<span class=\"hljs-built_in\">bfs</span>();<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888\">题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "邻接表",
                "Vector",
                "Binary tree",
                "BFS"
            ]
        },
        {
            "id": "http://example.com/2022/04/13/Algorithm019/",
            "url": "http://example.com/2022/04/13/Algorithm019/",
            "title": "L2-026 小字辈 (25 分)",
            "date_published": "2022-04-13T01:45:49.000Z",
            "content_html": "<h2 id=\"L2-026-小字辈-25-分\"><a href=\"#L2-026-小字辈-25-分\" class=\"headerlink\" title=\"L2-026 小字辈 (25 分)\"></a><strong>L2-026 小字辈 (25 分)</strong></h2><p>本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父&#x2F;母。家谱中辈分最高的老祖宗对应的父&#x2F;母编号为 -1。一行中的数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs in\">9<br>2 6 5 5 -1 5 6 4 7<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs out\">4<br>1 9<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接表建树+BFS</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br>vector&lt;<span class=\"hljs-keyword\">int</span>&gt; tree[<span class=\"hljs-number\">100005</span>];\t\t\t\t<span class=\"hljs-comment\">//邻接表建树</span><br><span class=\"hljs-keyword\">int</span> deeptree[<span class=\"hljs-number\">100005</span>];\t\t\t\t\t<span class=\"hljs-comment\">//记录树的深度</span><br><span class=\"hljs-keyword\">int</span> n;<br><span class=\"hljs-keyword\">int</span> root;\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//根节点</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">()</span></span>&#123;\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bfs</span><br>    queue&lt;<span class=\"hljs-keyword\">int</span>&gt; q;<br>    q.<span class=\"hljs-built_in\">push</span>(root);\t\t\t\t\t\t<span class=\"hljs-comment\">//根节点入队</span><br>    <span class=\"hljs-keyword\">int</span> x;\t\t\t\t\t\t\t\t<br>    <span class=\"hljs-keyword\">while</span>(!q.<span class=\"hljs-built_in\">empty</span>())&#123;<br>        x=q.<span class=\"hljs-built_in\">front</span>();<br>        q.<span class=\"hljs-built_in\">pop</span>();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;tree[x].<span class=\"hljs-built_in\">size</span>() ; ++i) &#123;<br>            deeptree[tree[x][i]]=deeptree[x]+<span class=\"hljs-number\">1</span>;\t\t\t\t\t\t<span class=\"hljs-comment\">//每一层的深度为上一层加1</span><br>            q.<span class=\"hljs-built_in\">push</span>(tree[x][i]);<br><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> deeptree[x];\t\t\t\t<span class=\"hljs-comment\">//返回最后一个结点的深度，即深度的最大值</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    n;<br>    cin&gt;&gt;n;<br>    <span class=\"hljs-keyword\">int</span> a[n];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;=n ; ++i) &#123;<br>        cin&gt;&gt;a[i];<br>        <span class=\"hljs-keyword\">if</span>(a[i]==<span class=\"hljs-number\">-1</span>)&#123;<br>            root=i;\t\t\t\t<span class=\"hljs-comment\">//找根节点</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;=n ; ++j) &#123;\t\t\t\t\t<span class=\"hljs-comment\">//建树</span><br>        tree[a[j]].<span class=\"hljs-built_in\">push_back</span>(j);\t\t\t\t\t<span class=\"hljs-comment\">//j是a[j]的孩子节点</span><br>        <span class=\"hljs-keyword\">if</span>(a[j]==<span class=\"hljs-number\">-1</span>) deeptree[j]=<span class=\"hljs-number\">1</span>;\t\t\t\t\t<span class=\"hljs-comment\">//初始化根节点深度为1</span><br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> ans=<span class=\"hljs-built_in\">bfs</span>();<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">int</span> maxdeepcnt=<span class=\"hljs-number\">0</span>;\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//记录最大深度的个数</span><br>    <span class=\"hljs-keyword\">int</span> tmp[n];\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//找最大深度的id</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">1</span>; k &lt;=n ; ++k) &#123;\t\t\t\t\t<br>        <span class=\"hljs-keyword\">if</span>(ans==deeptree[k])&#123;<br>            maxdeepcnt++;<br>            tmp[maxdeepcnt]=k;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//输出格式控制</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> l = <span class=\"hljs-number\">1</span>; l &lt;=maxdeepcnt ; ++l) &#123;<br>        <span class=\"hljs-keyword\">if</span>(l!=maxdeepcnt) cout&lt;&lt;tmp[l]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>        <span class=\"hljs-keyword\">else</span> cout&lt;&lt;tmp[l]&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808\">题目详情 - L2-026 小字辈 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "邻接表",
                "Vector",
                "Binary tree",
                "BFS"
            ]
        }
    ]
}