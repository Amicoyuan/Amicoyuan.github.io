{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"bfs\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/04/14/Algorithm024/",
            "url": "http://example.com/2022/04/14/Algorithm024/",
            "title": "L2-011 玩转二叉树 (25 分)",
            "date_published": "2022-04-14T06:01:10.000Z",
            "content_html": "<h2 id=\"L2-011-玩转二叉树-25-分\"><a href=\"#L2-011-玩转二叉树-25-分\" class=\"headerlink\" title=\"L2-011 玩转二叉树 (25 分)\"></a><strong>L2-011 玩转二叉树 (25 分)</strong></h2><p>给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">7\n1 2 3 4 5 6 7\n4 1 3 2 6 5 7\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">4 6 1 7 5 3 2\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>镜面反转即为在层序遍历时交换左右子树的遍历顺序，左-&gt;右变成右-&gt;左</strong></p>\n<p><strong>前序 + 中序 建树 + BFS</strong></p>\n<p><strong>建树详细过程：</strong></p>\n<p><a href=\"https://xingyuanjie.top/2022/04/07/Algorithm014/\">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct BiTNode&#123;\n    int data;\n    struct BiTNode *lchild,*rchild;\n&#125;BiTNode,*BiTree;\nint n;\nint in[35];\nint pre[35];\nBiTree PostCreate(int prel,int prer,int inl,int inr)&#123;\t\t\t\t\t//前序加中序建树\n    if(prel>prer)&#123;\n        return NULL;\n    &#125;\n    BiTNode *root;\n    root=(BiTNode*)malloc(sizeof(BiTNode));\n    root->data=pre[prel];\n    int index=0;\n    for (int i = inl; i <=inr; ++i) &#123;\n        if(pre[prel]==in[i])&#123;\n            index=i;\n            break;\n        &#125;\n    &#125;\n    int numleft=index-inl;\n    root->lchild=PostCreate(prel+1,prel+numleft,inl,index-1);\n    root->rchild=PostCreate(prel+numleft+1,prer,index+1,inr);\n    return root;\n&#125;\nvoid LevelOrder(BiTree T)\n&#123;\n    queue<BiTree> q;\n    q.push(T);\n    int i=0;\n    while (!q.empty())&#123;\n        BiTNode *tmp =q.front();\n        q.pop();\n        if(i!=n-1)&#123;\t\t\t\t\t\t\t\t\t\t//输出格式控制\n            cout<<tmp->data<<\" \";\n        &#125;else&#123;\n            cout<<tmp->data;\n        &#125;\n        i++;\n        if(tmp->rchild!=NULL)&#123;\t\t\t\t\t\t\t//镜面反转，左->右变成右->左\n            q.push(tmp->rchild);\n        &#125;\n        if(tmp->lchild!=NULL)&#123;\n            q.push(tmp->lchild);\n        &#125;\n    &#125;\n&#125;\nint main()\n&#123;\n    BiTree tree;\n    tree=NULL;\n    cin>>n;\n    for (int i = 0; i <n ; ++i) &#123;\n        cin>>in[i];\n    &#125;\n    for (int j = 0; j <n ; ++j) &#123;\n        cin>>pre[j];\n    &#125;\n    tree=PostCreate(0,n-1,0,n-1);\n    LevelOrder(tree);\n    cout<<endl;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784\">题目详情 - L2-011 玩转二叉树 (25 分) (pintia.cn)</a></p>\n<p><a href=\"https://xingyuanjie.top/2022/04/07/Algorithm014/\">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Binary tree",
                "BFS"
            ]
        },
        {
            "id": "http://example.com/2022/04/13/Algorithm022/",
            "url": "http://example.com/2022/04/13/Algorithm022/",
            "title": "L2-031 深入虎穴 (25 分)",
            "date_published": "2022-04-13T11:09:46.000Z",
            "content_html": "<p>著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。</p>\n<p>内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入首先在一行中给出正整数 <em>N</em>（&lt;105），是门的数量。最后 <em>N</em> 行，第 <em>i</em> 行（1≤<em>i</em>≤<em>N</em>）按以下格式描述编号为 <em>i</em> 的那扇门背后能通向的门：</p>\n<pre><code>K D[1] D[2] ... D[K]\n</code></pre>\n<p>其中 <code>K</code> 是通道的数量，其后是每扇门的编号。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">13\n3 2 3 4\n2 5 6\n1 7\n1 8\n1 9\n0\n2 11 10\n1 13\n0\n0\n1 12\n0\n0\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">12\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接表 + BFS</strong></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[100005];\nint book[100005];\nint start=0;\nint bfs()&#123;\t\t\t\t\t\t\t\t//BFS\n    queue<int> q;\n    q.push(start);\t\t\t\t\t\t//根节点入队\n    int x;\n    while(!q.empty())&#123;\n        x=q.front();\n        q.pop();\n        for (int i = 0; i <v[x].size() ; ++i) &#123;\t\t\t\t\n            q.push(v[x][i]);\n        &#125;\n    &#125;\t\t\t\t\t\t\t\t\t//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。\n    return x;\t\t\t\t\t\t\t//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门\n&#125;\nint main()\n&#123;\n    int n;\n    cin>>n;\n    for (int i = 1; i <=n ; ++i) &#123;\n        int time;\n        cin>>time;\n        for (int j = 1; j <=time ; ++j) &#123;\n            int num;\n            cin>>num;\n            book[num]=1;\n            v[i].push_back(num);\n\n        &#125;\n    &#125;\n    for (int k = 1; k <=n ; ++k) &#123;\t\t\t//找入口\n        if(book[k]==0) start=k;\t\t\t\t//没有门通向的门，即为入口\n    &#125;\n    int ans=bfs();\n    cout<<ans<<endl;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888\">题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "邻接表",
                "Vector",
                "Binary tree",
                "BFS"
            ]
        },
        {
            "id": "http://example.com/2022/04/13/Algorithm019/",
            "url": "http://example.com/2022/04/13/Algorithm019/",
            "title": "L2-026 小字辈 (25 分)",
            "date_published": "2022-04-13T01:45:49.000Z",
            "content_html": "<h2 id=\"L2-026-小字辈-25-分\"><a href=\"#L2-026-小字辈-25-分\" class=\"headerlink\" title=\"L2-026 小字辈 (25 分)\"></a><strong>L2-026 小字辈 (25 分)</strong></h2><p>本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父&#x2F;母。家谱中辈分最高的老祖宗对应的父&#x2F;母编号为 -1。一行中的数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\" language-in\"><code class=\"language-in\">9\n2 6 5 5 -1 5 6 4 7\n</code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\" language-out\"><code class=\"language-out\">4\n1 9\n</code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接表建树+BFS</strong></p>\n<pre class=\" language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nvector<int> tree[100005];\t\t\t\t//邻接表建树\nint deeptree[100005];\t\t\t\t\t//记录树的深度\nint n;\nint root;\t\t\t\t\t\t\t\t//根节点\nint bfs()&#123;\t\t\t\t\t\t\t\t//bfs\n    queue<int> q;\n    q.push(root);\t\t\t\t\t\t//根节点入队\n    int x;\t\t\t\t\t\t\t\t\n    while(!q.empty())&#123;\n        x=q.front();\n        q.pop();\n        for (int i = 0; i <tree[x].size() ; ++i) &#123;\n            deeptree[tree[x][i]]=deeptree[x]+1;\t\t\t\t\t\t//每一层的深度为上一层加1\n            q.push(tree[x][i]);\n\n        &#125;\n    &#125;\n    return deeptree[x];\t\t\t\t//返回最后一个结点的深度，即深度的最大值\n&#125;\nint main()\n&#123;\n    n;\n    cin>>n;\n    int a[n];\n    for (int i = 1; i <=n ; ++i) &#123;\n        cin>>a[i];\n        if(a[i]==-1)&#123;\n            root=i;\t\t\t\t//找根节点\n        &#125;\n    &#125;\n    for (int j = 1; j <=n ; ++j) &#123;\t\t\t\t\t//建树\n        tree[a[j]].push_back(j);\t\t\t\t\t//j是a[j]的孩子节点\n        if(a[j]==-1) deeptree[j]=1;\t\t\t\t\t//初始化根节点深度为1\n    &#125;\n    int ans=bfs();\n    cout<<ans<<endl;\n    int maxdeepcnt=0;\t\t\t\t\t\t\t\t//记录最大深度的个数\n    int tmp[n];\t\t\t\t\t\t\t\t\t\t//找最大深度的id\n    for (int k = 1; k <=n ; ++k) &#123;\t\t\t\t\t\n        if(ans==deeptree[k])&#123;\n            maxdeepcnt++;\n            tmp[maxdeepcnt]=k;\n        &#125;\n    &#125;\n    //输出格式控制\n    for (int l = 1; l <=maxdeepcnt ; ++l) &#123;\n        if(l!=maxdeepcnt) cout<<tmp[l]<<\" \";\n        else cout<<tmp[l]<<endl;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808\">题目详情 - L2-026 小字辈 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "邻接表",
                "Vector",
                "Binary tree",
                "BFS"
            ]
        }
    ]
}