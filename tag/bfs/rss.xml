<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Amicoyuan • Posts by &#34;bfs&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Thu, 14 Apr 2022 14:01:10 +0800</pubDate>
        <lastBuildDate>Thu, 14 Apr 2022 14:01:10 +0800</lastBuildDate>
        <category>AVX</category>
        <category>Data Structure</category>
        <category>String</category>
        <category>Find</category>
        <category>STL</category>
        <category>C++</category>
        <category>Set</category>
        <category>团体程序设计天梯赛</category>
        <category>Sort</category>
        <category>LinkList</category>
        <category>双向链表</category>
        <category>Graph</category>
        <category>邻接表</category>
        <category>Vector</category>
        <category>Binary tree</category>
        <category>BFS</category>
        <category>模拟</category>
        <category>邻接矩阵</category>
        <category>DFS</category>
        <category>结构体</category>
        <category>贪心</category>
        <category>Double类型相等比较</category>
        <category>并查集</category>
        <category>Map</category>
        <category>Pair</category>
        <category>KMP</category>
        <category>线索二叉树</category>
        <category>Tree</category>
        <category>森林</category>
        <category>Linux</category>
        <category>MPI</category>
        <category>Numactl</category>
        <category>Slurm</category>
        <category>Tensorflow</category>
        <category>性能分析工具</category>
        <category>gcov</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/14/Algorithm024/</guid>
            <title>L2-011 玩转二叉树 (25 分)</title>
            <link>http://example.com/2022/04/14/Algorithm024/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>Binary tree</category>
            <category>BFS</category>
            <pubDate>Thu, 14 Apr 2022 14:01:10 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-011-玩转二叉树-25-分&#34;&gt;&lt;a href=&#34;#L2-011-玩转二叉树-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-011 玩转二叉树 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-011 玩转二叉树 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入第一行给出一个正整数&lt;code&gt;N&lt;/code&gt;（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34;line-numbers language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;7
1 2 3 4 5 6 7
4 1 3 2 6 5 7
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34;line-numbers language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;4 6 1 7 5 3 2
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;镜面反转即为在层序遍历时交换左右子树的遍历顺序，左-&amp;gt;右变成右-&amp;gt;左&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前序 + 中序 建树 + BFS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建树详细过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/04/07/Algorithm014/&#34;&gt;由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef struct BiTNode&amp;#123;
    int data;
    struct BiTNode *lchild,*rchild;
&amp;#125;BiTNode,*BiTree;
int n;
int in[35];
int pre[35];
BiTree PostCreate(int prel,int prer,int inl,int inr)&amp;#123;					//前序加中序建树
    if(prel&gt;prer)&amp;#123;
        return NULL;
    &amp;#125;
    BiTNode *root;
    root=(BiTNode*)malloc(sizeof(BiTNode));
    root-&gt;data=pre[prel];
    int index=0;
    for (int i = inl; i &lt;=inr; ++i) &amp;#123;
        if(pre[prel]==in[i])&amp;#123;
            index=i;
            break;
        &amp;#125;
    &amp;#125;
    int numleft=index-inl;
    root-&gt;lchild=PostCreate(prel+1,prel+numleft,inl,index-1);
    root-&gt;rchild=PostCreate(prel+numleft+1,prer,index+1,inr);
    return root;
&amp;#125;
void LevelOrder(BiTree T)
&amp;#123;
    queue&lt;BiTree&gt; q;
    q.push(T);
    int i=0;
    while (!q.empty())&amp;#123;
        BiTNode *tmp =q.front();
        q.pop();
        if(i!=n-1)&amp;#123;										//输出格式控制
            cout&lt;&lt;tmp-&gt;data&lt;&lt;&#34; &#34;;
        &amp;#125;else&amp;#123;
            cout&lt;&lt;tmp-&gt;data;
        &amp;#125;
        i++;
        if(tmp-&gt;rchild!=NULL)&amp;#123;							//镜面反转，左-&gt;右变成右-&gt;左
            q.push(tmp-&gt;rchild);
        &amp;#125;
        if(tmp-&gt;lchild!=NULL)&amp;#123;
            q.push(tmp-&gt;lchild);
        &amp;#125;
    &amp;#125;
&amp;#125;
int main()
&amp;#123;
    BiTree tree;
    tree=NULL;
    cin&gt;&gt;n;
    for (int i = 0; i &lt;n ; ++i) &amp;#123;
        cin&gt;&gt;in[i];
    &amp;#125;
    for (int j = 0; j &lt;n ; ++j) &amp;#123;
        cin&gt;&gt;pre[j];
    &amp;#125;
    tree=PostCreate(0,n-1,0,n-1);
    LevelOrder(tree);
    cout&lt;&lt;endl;
    return 0;
&amp;#125;
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784&#34;&gt;题目详情 - L2-011 玩转二叉树 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xingyuanjie.top/2022/04/07/Algorithm014/&#34;&gt;由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/13/Algorithm022/</guid>
            <title>L2-031 深入虎穴 (25 分)</title>
            <link>http://example.com/2022/04/13/Algorithm022/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>邻接表</category>
            <category>Vector</category>
            <category>Binary tree</category>
            <category>BFS</category>
            <pubDate>Wed, 13 Apr 2022 19:09:46 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。&lt;/p&gt;
&lt;p&gt;内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入首先在一行中给出正整数 &lt;em&gt;N&lt;/em&gt;（&amp;lt;105），是门的数量。最后 &lt;em&gt;N&lt;/em&gt; 行，第 &lt;em&gt;i&lt;/em&gt; 行（1≤&lt;em&gt;i&lt;/em&gt;≤&lt;em&gt;N&lt;/em&gt;）按以下格式描述编号为 &lt;em&gt;i&lt;/em&gt; 的那扇门背后能通向的门：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;K D[1] D[2] ... D[K]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;K&lt;/code&gt; 是通道的数量，其后是每扇门的编号。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34;line-numbers language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;13
3 2 3 4
2 5 6
1 7
1 8
1 9
0
2 11 10
1 13
0
0
1 12
0
0
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34;line-numbers language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;12
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接表 + BFS&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;int&gt; v[100005];
int book[100005];
int start=0;
int bfs()&amp;#123;								//BFS
    queue&lt;int&gt; q;
    q.push(start);						//根节点入队
    int x;
    while(!q.empty())&amp;#123;
        x=q.front();
        q.pop();
        for (int i = 0; i &lt;v[x].size() ; ++i) &amp;#123;				
            q.push(v[x][i]);
        &amp;#125;
    &amp;#125;									//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。
    return x;							//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门
&amp;#125;
int main()
&amp;#123;
    int n;
    cin&gt;&gt;n;
    for (int i = 1; i &lt;=n ; ++i) &amp;#123;
        int time;
        cin&gt;&gt;time;
        for (int j = 1; j &lt;=time ; ++j) &amp;#123;
            int num;
            cin&gt;&gt;num;
            book[num]=1;
            v[i].push_back(num);

        &amp;#125;
    &amp;#125;
    for (int k = 1; k &lt;=n ; ++k) &amp;#123;			//找入口
        if(book[k]==0) start=k;				//没有门通向的门，即为入口
    &amp;#125;
    int ans=bfs();
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
&amp;#125;
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料：&#34;&gt;&lt;a href=&#34;#参考资料：&#34; class=&#34;headerlink&#34; title=&#34;参考资料：&#34;&gt;&lt;/a&gt;参考资料：&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888&#34;&gt;题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/13/Algorithm019/</guid>
            <title>L2-026 小字辈 (25 分)</title>
            <link>http://example.com/2022/04/13/Algorithm019/</link>
            <category>Data Structure</category>
            <category>C++</category>
            <category>团体程序设计天梯赛</category>
            <category>邻接表</category>
            <category>Vector</category>
            <category>Binary tree</category>
            <category>BFS</category>
            <pubDate>Wed, 13 Apr 2022 09:45:49 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;L2-026-小字辈-25-分&#34;&gt;&lt;a href=&#34;#L2-026-小字辈-25-分&#34; class=&#34;headerlink&#34; title=&#34;L2-026 小字辈 (25 分)&#34;&gt;&lt;/a&gt;&lt;strong&gt;L2-026 小字辈 (25 分)&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。&lt;/p&gt;
&lt;h3 id=&#34;输入格式：&#34;&gt;&lt;a href=&#34;#输入格式：&#34; class=&#34;headerlink&#34; title=&#34;输入格式：&#34;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父&amp;#x2F;母。家谱中辈分最高的老祖宗对应的父&amp;#x2F;母编号为 -1。一行中的数字间以空格分隔。&lt;/p&gt;
&lt;h3 id=&#34;输出格式：&#34;&gt;&lt;a href=&#34;#输出格式：&#34; class=&#34;headerlink&#34; title=&#34;输出格式：&#34;&gt;&lt;/a&gt;输出格式：&lt;/h3&gt;&lt;p&gt;首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。&lt;/p&gt;
&lt;h3 id=&#34;输入样例：&#34;&gt;&lt;a href=&#34;#输入样例：&#34; class=&#34;headerlink&#34; title=&#34;输入样例：&#34;&gt;&lt;/a&gt;输入样例：&lt;/h3&gt;&lt;pre class=&#34;line-numbers language-in&#34;&gt;&lt;code class=&#34;language-in&#34;&gt;9
2 6 5 5 -1 5 6 4 7
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输出样例：&#34;&gt;&lt;a href=&#34;#输出样例：&#34; class=&#34;headerlink&#34; title=&#34;输出样例：&#34;&gt;&lt;/a&gt;输出样例：&lt;/h3&gt;&lt;pre class=&#34;line-numbers language-out&#34;&gt;&lt;code class=&#34;language-out&#34;&gt;4
1 9
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;程序源代码：&#34;&gt;&lt;a href=&#34;#程序源代码：&#34; class=&#34;headerlink&#34; title=&#34;程序源代码：&#34;&gt;&lt;/a&gt;程序源代码：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;邻接表建树+BFS&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c++&#34;&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;int&gt; tree[100005];				//邻接表建树
int deeptree[100005];					//记录树的深度
int n;
int root;								//根节点
int bfs()&amp;#123;								//bfs
    queue&lt;int&gt; q;
    q.push(root);						//根节点入队
    int x;								
    while(!q.empty())&amp;#123;
        x=q.front();
        q.pop();
        for (int i = 0; i &lt;tree[x].size() ; ++i) &amp;#123;
            deeptree[tree[x][i]]=deeptree[x]+1;						//每一层的深度为上一层加1
            q.push(tree[x][i]);

        &amp;#125;
    &amp;#125;
    return deeptree[x];				//返回最后一个结点的深度，即深度的最大值
&amp;#125;
int main()
&amp;#123;
    n;
    cin&gt;&gt;n;
    int a[n];
    for (int i = 1; i &lt;=n ; ++i) &amp;#123;
        cin&gt;&gt;a[i];
        if(a[i]==-1)&amp;#123;
            root=i;				//找根节点
        &amp;#125;
    &amp;#125;
    for (int j = 1; j &lt;=n ; ++j) &amp;#123;					//建树
        tree[a[j]].push_back(j);					//j是a[j]的孩子节点
        if(a[j]==-1) deeptree[j]=1;					//初始化根节点深度为1
    &amp;#125;
    int ans=bfs();
    cout&lt;&lt;ans&lt;&lt;endl;
    int maxdeepcnt=0;								//记录最大深度的个数
    int tmp[n];										//找最大深度的id
    for (int k = 1; k &lt;=n ; ++k) &amp;#123;					
        if(ans==deeptree[k])&amp;#123;
            maxdeepcnt++;
            tmp[maxdeepcnt]=k;
        &amp;#125;
    &amp;#125;
    //输出格式控制
    for (int l = 1; l &lt;=maxdeepcnt ; ++l) &amp;#123;
        if(l!=maxdeepcnt) cout&lt;&lt;tmp[l]&lt;&lt;&#34; &#34;;
        else cout&lt;&lt;tmp[l]&lt;&lt;endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#参考资料&#34; class=&#34;headerlink&#34; title=&#34;参考资料&#34;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808&#34;&gt;题目详情 - L2-026 小字辈 (25 分) (pintia.cn)&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
