{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"linux\" tag",
    "description": "",
    "home_page_url": "https://xingyuanjie.top",
    "items": [
        {
            "id": "https://xingyuanjie.top/2023/02/28/Linux004/",
            "url": "https://xingyuanjie.top/2023/02/28/Linux004/",
            "title": "C/C++关键字之restrict",
            "date_published": "2023-02-28T11:45:09.000Z",
            "content_html": "<h1 id=\"C-x2F-C-关键字之restrict\"><a href=\"#C-x2F-C-关键字之restrict\" class=\"headerlink\" title=\"C&#x2F;C++关键字之restrict\"></a>C&#x2F;C++关键字之restrict</h1><p>在C语言中，restrict关键字用于修饰指针（C99标准）。通过加上restrict关键字，程序员可提示编译器：在该指针的生命周期内，其指向的对象不会被别的指针所引用。</p>\n<p>需要注意的是，在C++中，并无明确统一的标准支持restrict关键字。但是很多编译器实现了功能相同的关键字，例如gcc和clang中的__restrict关键字。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>*a, <span class=\"hljs-keyword\">int</span>* b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    *a = <span class=\"hljs-number\">10</span>;<br>    *b = <span class=\"hljs-number\">12</span>;<br>    <span class=\"hljs-keyword\">return</span> *a + *b;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>add1函数的返回值会永远是10 + 12 &#x3D; 22吗？</p>\n<p>答案是不一定。在指针a和b的地址不同时，返回22没有问题。但是当指针a与b指向的是同一个int对象时，该对象先被赋值为10，后被赋值为12，因此a和b都返回12，因此add1函数最终返回24。</p>\n<p>下面是一个简单的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>* a, <span class=\"hljs-keyword\">int</span>* b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    *a = <span class=\"hljs-number\">10</span>;<br>    *b = <span class=\"hljs-number\">12</span>;<br>    <span class=\"hljs-keyword\">return</span> *a + *b;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span>* c;<br>    <span class=\"hljs-keyword\">int</span>* d;<br>    d=(<span class=\"hljs-keyword\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">int</span>)*<span class=\"hljs-number\">1</span>);<br>    c=(<span class=\"hljs-keyword\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">int</span>)*<span class=\"hljs-number\">1</span>);<br>    *c=<span class=\"hljs-number\">10</span>;<br>    *d=<span class=\"hljs-number\">12</span>;<br>    *d=<span class=\"hljs-number\">12</span>;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;c:&quot;</span>&lt;&lt;*c&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;d:&quot;</span>&lt;&lt;*d&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;When Pointers a and b have different addresses&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-built_in\">add1</span>(c,d)&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;When Pointers a and b have the same address&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-built_in\">add1</span>(c,c)&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>程序输出：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">c:<span class=\"hljs-number\">10</span><br>d:<span class=\"hljs-number\">12</span><br>When Pointers a <span class=\"hljs-keyword\">and</span> b have different addresses<br><span class=\"hljs-number\">22</span><br>When Pointers a <span class=\"hljs-keyword\">and</span> b have the same address<br><span class=\"hljs-number\">24</span><br></code></pre></div></td></tr></table></figure>\n\n<p>开启-O3优化，add1对应的汇编代码如下:</p>\n<p>为了得到<code>*a</code>的值访问了1次内存，而不管在何种条件下(<code>a == b</code> or <code>a != b</code>)，<code>*b</code>的值都是12。因此编译器将<code>*a</code>的值载入<code>eax</code>寄存器后，直接加上立即数12，而无需再访问内存获取<code>*b</code>的值。在无法确定指针a和b是否相同的情况下，编译器只能帮你优化到这里了。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\"><span class=\"hljs-number\">0000000000400</span>a10 &lt;_Z4add1PiS_&gt;:<br>  <span class=\"hljs-number\">400</span>a10:   c7 <span class=\"hljs-number\">07</span> <span class=\"hljs-number\">0</span>a <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0</span>xa,(%rdi) ; *a = <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-number\">400</span>a16:   c7 <span class=\"hljs-number\">06</span> <span class=\"hljs-number\">0</span>c <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0</span>xc,(%rsi) ; *b = <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-number\">400</span>a1c:   <span class=\"hljs-number\">8</span>b <span class=\"hljs-number\">07</span>                   mov    (%rdi),%eax ; 结果 = *a<br>  <span class=\"hljs-number\">400</span>a1e:   <span class=\"hljs-number\">83</span> c0 <span class=\"hljs-number\">0</span>c                add    $<span class=\"hljs-number\">0</span>xc,%eax   ; 结果 += <span class=\"hljs-number\">12</span> <br>  <span class=\"hljs-number\">400</span>a21:   c3                      retq<br></code></pre></div></td></tr></table></figure>\n\n<p>加上了restrict关键字过后，同样开启-O3优化，add1对应的汇编代码如下：</p>\n<p>加上关键字restrict后，编译器能够确认指针a和b不可能指向同一个内存地址，因此在求*a + *b时，无虚访问内存，因为*a必然等于立即数10，*b必然等于立即数12。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>* __restrict  a, <span class=\"hljs-keyword\">int</span>* __restrict b)</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>    *a = <span class=\"hljs-number\">10</span>;<br>    *b = <span class=\"hljs-number\">12</span>;<br>    <span class=\"hljs-keyword\">return</span> *a + *b ;<br>&#125;<br><span class=\"hljs-number\">0000000000400</span>a30 &lt;_Z4add2PiS_&gt;:<br>  <span class=\"hljs-number\">400</span>a30:   c7 <span class=\"hljs-number\">07</span> <span class=\"hljs-number\">0</span>a <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0xa</span>,(%rdi) ; *a = <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-number\">400</span>a36:   b8 <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>          mov    $<span class=\"hljs-number\">0x16</span>,%eax  ; 结果 = <span class=\"hljs-number\">22</span><br>  <span class=\"hljs-number\">400</span>a3b:   c7 <span class=\"hljs-number\">06</span> <span class=\"hljs-number\">0</span>c <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span> <span class=\"hljs-number\">00</span>       movl   $<span class=\"hljs-number\">0xc</span>,(%rsi) ; *b = <span class=\"hljs-number\">12</span><br>  <span class=\"hljs-number\">400</span>a41:   c3  <br></code></pre></div></td></tr></table></figure>\n\n<p>有无restrict关键字的两种情况下的汇编指令可看到，后者比前者少访问一次内存，且少执行一条指令。就是因为没加restruct关键字时，编译器不能确定别的地方是不是会修改此值，所以会去相应的地址查看。</p>\n<p><strong>这样当我们明确知道两个指针不可能指向同一个地址时，我们就可以通过使用restrict关键字来进行性能优化。</strong></p>\n<p>注意使用restrict的时候，程序员必须确保不会出现<strong>pointer aliasing</strong>，即同一块内存无法通过两个或以上的指针变量名访问。不满足这个条件强行指定restrict，将会出现<strong>underfined behavior</strong>。</p>\n<p>通常编写代码时会忽略pointer aliasing的问题。更常见是在性能分析时，通过反汇编看到很多冗余的读取指令，才会想到加入restrict关键字来提升性能。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://zhuanlan.zhihu.com/p/349726808\">C&#x2F;C++关键字之restrict - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://github.com/ClickHouse/ClickHouse/pull/19946\">Improve performance of aggregate functions by alexey-milovidov · Pull Request #19946 · ClickHouse&#x2F;ClickHouse (github.com)</a></p>\n<p><a href=\"https://en.cppreference.com/w/c/language/restrict\">restrict type qualifier - cppreference.com</a></p>\n<p><a href=\"https://www.zhihu.com/question/41653775/answer/2535730128\">如何理解C语言关键字restrict？ - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://blog.csdn.net/qq_41822235/article/details/83479562\">(65条消息) 关键字_restrict___restrict_楚楚可薇的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qq_41950508/article/details/126619881?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-126619881-blog-102577325.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-126619881-blog-102577325.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1\">(65条消息) 【C++】关键字restrict的作用_restrict关键字的作用_不知所措的渣渣辉的博客-CSDN博客</a></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/24/Linux003/",
            "url": "https://xingyuanjie.top/2023/02/24/Linux003/",
            "title": "基于GDB的程序调试",
            "date_published": "2023-02-24T08:50:20.000Z",
            "content_html": "<h2 id=\"基于GDB的程序调试\"><a href=\"#基于GDB的程序调试\" class=\"headerlink\" title=\"基于GDB的程序调试\"></a>基于GDB的程序调试</h2><h3 id=\"程序调试工具GDB\"><a href=\"#程序调试工具GDB\" class=\"headerlink\" title=\"程序调试工具GDB\"></a>程序调试工具GDB</h3><p>编译器GCC，项目构建工具Make（又称gmake），以及GDB。</p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224165344672.png\" alt=\"image-20230224165344672\"></p>\n<p><strong>GDB是什么？</strong></p>\n<p>GDB：GNU symbolic debugger是Linux下常用的程序调试器</p>\n<p><strong>GDB可以做什么？</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224165606636.png\" alt=\"image-20230224165606636\"></p>\n<p><strong>GDB官网：</strong><a href=\"https://www.sourceware.org/gdb/\">GDB: The GNU Project Debugger (sourceware.org)</a></p>\n<h3 id=\"调试案例一\"><a href=\"#调试案例一\" class=\"headerlink\" title=\"调试案例一\"></a>调试案例一</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">int</span> n,sum;<br>    n = <span class=\"hljs-number\">1</span>;<br>    sum = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>( n &lt;= <span class=\"hljs-number\">100</span>)<br>    &#123;<br>        sum = sum + n;<br>        n = n + <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在编译程序的时候，需要加调试选项： -g</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">gcc gdb001.c -g -o ex1<br></code></pre></div></td></tr></table></figure>\n\n<p>使用gdb启动程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">gdb ./ex1<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>进入gdb调试环境</strong>：</p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224170419171.png\" alt=\"image-20230224170419171\"></p>\n<p><strong>在调试环境中：使用l选项会显示带行号的源代码</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224170620617.png\" alt=\"image-20230224170620617\"></p>\n<p><strong>但是默认情况下，l选项只显示10行源代码，如果查看后续代码，在调试界面Enter回车即可</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224170804048.png\" alt=\"image-20230224170804048\"></p>\n<p><strong>在第7行源代码处打断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224171858691.png\" alt=\"image-20230224171858691\"></p>\n<p><strong>运行程序，遇到断点停止：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172105514.png\" alt=\"image-20230224172105514\"></p>\n<p><strong>查看代码中变量n的值</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172200662.png\" alt=\"image-20230224172200662\"></p>\n<p>当前n的值为1，$1表示该变量所在存储区的名称</p>\n<p><strong>在程序第12行处打断点</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172321002.png\" alt=\"image-20230224172321002\"></p>\n<p><strong>继续执行程序</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172356622.png\" alt=\"image-20230224172356622\"></p>\n<p><strong>查看当前n变量的值</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172422998.png\" alt=\"image-20230224172422998\"></p>\n<p>当前n的值为101</p>\n<p><strong>退出调试</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172456626.png\" alt=\"image-20230224172456626\"></p>\n<p><strong>查看调试环境所有断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172650422.png\" alt=\"image-20230224172650422\"></p>\n<p><strong>删除第7行的断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172745323.png\" alt=\"image-20230224172745323\"></p>\n<p><strong>禁用编号为2的断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224172832507.png\" alt=\"image-20230224172832507\"></p>\n<p>注意断点状态Enb(enable)由y变成n，代表禁用</p>\n<p><strong>恢复编号为2的断点：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224173006975.png\" alt=\"image-20230224173006975\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>GDB有三种调试模式：</p>\n<p><strong>调试执行程序：</strong>（前面的案例），注意编译加调试信息(-g)</p>\n<p><strong>调试core文件   ：</strong>需要对系统设置的core文件大小作调整（ulimit - c unlimlited），否则可能无法\t\t\t\t\t\t\t  产生core文件</p>\n<p><strong>调试正在执行的程序（gdb attach） ：</strong>Top找到进程编号pid，Gdb attach pid</p>\n<p><strong>GDB结构组成：</strong></p>\n<p><img src=\"/2023/02/24/Linux003/image-20230224173613247.png\" alt=\"image-20230224173613247\"></p>\n<h3 id=\"常用调试指令：\"><a href=\"#常用调试指令：\" class=\"headerlink\" title=\"常用调试指令：\"></a>常用调试指令：</h3><h4 id=\"启动指令\"><a href=\"#启动指令\" class=\"headerlink\" title=\"启动指令\"></a>启动指令</h4><p>调试程序：gdb program</p>\n<p>根据core文件调试程序：gdb program corefile</p>\n<p>跟踪调试进程：gdb attach pid</p>\n<h4 id=\"程序运行\"><a href=\"#程序运行\" class=\"headerlink\" title=\"程序运行\"></a>程序运行</h4><p>run，该命令会运行至程序结束，除非遇到断点或报错</p>\n<h4 id=\"单步执行\"><a href=\"#单步执行\" class=\"headerlink\" title=\"单步执行\"></a>单步执行</h4><p>步进执行不进栈？next</p>\n<p>步进执行，进栈step</p>\n<h4 id=\"代码查看\"><a href=\"#代码查看\" class=\"headerlink\" title=\"代码查看\"></a>代码查看</h4><p>列出断点附近或程序所有代码list</p>\n<p>设置现实代码的行数 set listsize &lt;n&gt;</p>\n<h4 id=\"退出调试\"><a href=\"#退出调试\" class=\"headerlink\" title=\"退出调试\"></a>退出调试</h4><p>quit</p>\n<h4 id=\"查看栈信息\"><a href=\"#查看栈信息\" class=\"headerlink\" title=\"查看栈信息\"></a>查看栈信息</h4><p>bt\t打印当前的函数调用栈的所有信息</p>\n<p>bt &lt;n&gt;\tn是一个正整数，表示只打印栈顶上n层的栈信息</p>\n<p>bt &lt;-n&gt;\t表示只打印栈底下n层的栈信息</p>\n<h4 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h4><p><strong>代码断点：</strong></p>\n<ul>\n<li>break lineNumber | functionName</li>\n<li>break lineNumber | functionName if condition</li>\n<li>tbreak lineNumber | functionName  临时断点，仅能使用一次</li>\n</ul>\n<p><strong>内存断点（观察点）：</strong></p>\n<ul>\n<li>监控内存值改变 watch expr [if condition]</li>\n<li>监控内存值被读取 rwatch expr [if condition]</li>\n<li>监控内存值被读取和写入 awatch wxpr [if condition]</li>\n</ul>\n<p><strong>事件断点：</strong></p>\n<ul>\n<li>C++ exception，使用catch exception [name]</li>\n<li>Ada exception，使用catch handlers [name]</li>\n<li>exec事件，使用catch exec</li>\n<li>fork事件，使用catch fork 或者 catch vfork</li>\n<li>加载和卸载动态so事件，使用catch load|unload [regexp]</li>\n<li>监听系统信号，使用catch signal [signal]</li>\n<li>监听系统调用，使用catch syscall[name|number|group:groupname|g:groupname]…</li>\n</ul>\n<p><strong>打印变量：</strong></p>\n<ul>\n<li>Print [file | func]::variable 查看局部变量或全局变量</li>\n<li>Print *array@len  数组首地址@查看长度</li>\n<li>x&#x2F;[n | u] &lt;addr&gt;\tx命令查看内存地址钟的值，n：表示显示内存的长度，u：表示从当前地址往后请求的字节数</li>\n</ul>\n<p><strong>打印寄存器：</strong></p>\n<p>info register\t查看寄存器（除了浮点寄存器）</p>\n<p>all-registers\t查看所有寄存器</p>\n<p>info registers &lt;reg_name …&gt;查看所指定寄存器</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><strong>来源培训PPT 作者：Relax  邮箱：<a href=\"mailto:&#x77;&#x61;&#x6e;&#103;&#x77;&#x31;&#x31;&#49;&#x40;&#x69;&#x63;&#108;&#x6f;&#x75;&#x64;&#x2e;&#x63;&#x6f;&#x6d;\">&#x77;&#x61;&#x6e;&#103;&#x77;&#x31;&#x31;&#49;&#x40;&#x69;&#x63;&#108;&#x6f;&#x75;&#x64;&#x2e;&#x63;&#x6f;&#x6d;</a></strong></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/15/blislab003/",
            "url": "https://xingyuanjie.top/2023/02/15/blislab003/",
            "title": "BLISlab中C矩阵初始化速度测试",
            "date_published": "2023-02-15T03:48:16.000Z",
            "content_html": "<h2 id=\"BLISlab中C矩阵初始化速度测试\"><a href=\"#BLISlab中C矩阵初始化速度测试\" class=\"headerlink\" title=\"BLISlab中C矩阵初始化速度测试\"></a>BLISlab中C矩阵初始化速度测试</h2><p><strong>假设我们想把C中的所有元素都设为0。</strong></p>\n<p><strong>统一编译命令：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">g++  xxx.cpp -O0 -std=c++11 -o xxx<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本一：\"><a href=\"#版本一：\" class=\"headerlink\" title=\"版本一：\"></a>版本一：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\t\t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>    \t\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123; <br>        \t\t<span class=\"hljs-built_in\">C</span>(i,j) = <span class=\"hljs-number\">0.0</span>;<br>   \t\t \t&#125;<br>\t\t&#125;<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：\"><a href=\"#实测结果：\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">10776901341</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">10776901</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">10776</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">10</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本二：\"><a href=\"#版本二：\" class=\"headerlink\" title=\"版本二：\"></a>版本二：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\t<span class=\"hljs-keyword\">double</span> *cp;<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    \tcp = &amp;C[ j*ldc ];\t\t\t<span class=\"hljs-comment\">//point cp to top of ith column</span><br>    \t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>        \t*cp++ = <span class=\"hljs-number\">0.0</span>;\t\t<span class=\"hljs-comment\">//set element that cp points to to zero and</span><br>    \t&#125;\t\t<span class=\"hljs-comment\">//advance the pointer</span><br>\t&#125;<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：-1\"><a href=\"#实测结果：-1\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">3455968000</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">3455968</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">3455</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">3</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本三：\"><a href=\"#版本三：\" class=\"headerlink\" title=\"版本三：\"></a>版本三：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\t<span class=\"hljs-keyword\">double</span> *cp;<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    \tcp = &amp;C[ j * ldc ];<br>    \t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>       \t\t*(cp+<span class=\"hljs-number\">0</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \t*(cp+<span class=\"hljs-number\">1</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \t*(cp+<span class=\"hljs-number\">2</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \t*(cp+<span class=\"hljs-number\">3</span>) = <span class=\"hljs-number\">0.0</span>;<br>        \tcp+=<span class=\"hljs-number\">4</span>;<br>   \t\t&#125;<br>\t&#125;\t<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：-2\"><a href=\"#实测结果：-2\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">2581347801</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">2581347</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">2581</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">2</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"版本四：\"><a href=\"#版本四：\" class=\"headerlink\" title=\"版本四：\"></a>版本四：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> C( i, j )     C[ (j)*ldc + (i) ]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;\t<br>\t<span class=\"hljs-keyword\">int</span> i,j,m,n;<br>\tm=<span class=\"hljs-number\">20000</span>;<br>\tn=<span class=\"hljs-number\">20000</span>;<br>\t<span class=\"hljs-keyword\">int</span> ldc=m;<br>\t<span class=\"hljs-keyword\">double</span>*\tC =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(m*n*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br>\t<span class=\"hljs-keyword\">double</span> *cp;<br>\tstd::chrono::high_resolution_clock::time_point tp1 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>    <span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> c0 =<span class=\"hljs-number\">0.0</span>,c1=<span class=\"hljs-number\">0.0</span>,c2=<span class=\"hljs-number\">0.0</span>,c3=<span class=\"hljs-number\">0.0</span>;<br>\t<span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    \tcp = &amp;C[ j * ldc ];<br>    \t<span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>        \t*(cp+<span class=\"hljs-number\">0</span>) = c0;<br>        \t*(cp+<span class=\"hljs-number\">1</span>) = c1;<br>        \t*(cp+<span class=\"hljs-number\">2</span>) = c2;<br>        \t*(cp+<span class=\"hljs-number\">3</span>) = c3;<br>        \tcp+=<span class=\"hljs-number\">4</span>;<br>   \t\t &#125;<br>\t&#125;<br>\tstd::chrono::high_resolution_clock::time_point tp2 = std::chrono::high_resolution_clock::<span class=\"hljs-built_in\">now</span>();<br>\tstd::chrono::duration&lt;<span class=\"hljs-keyword\">size_t</span>, std::nano&gt; dur = tp2 - tp1;<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;1 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 纳秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 微妙&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 毫秒&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4 被计时代码耗时：&quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(dur).<span class=\"hljs-built_in\">count</span>() &lt;&lt; <span class=\"hljs-string\">&quot; 秒钟&quot;</span> &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"实测结果：-3\"><a href=\"#实测结果：-3\" class=\"headerlink\" title=\"实测结果：\"></a>实测结果：</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span>被计时代码耗时：<span class=\"hljs-number\">2269606428</span> 纳秒<br><span class=\"hljs-symbol\">2 </span>被计时代码耗时：<span class=\"hljs-number\">2269606</span> 微妙<br><span class=\"hljs-symbol\">3 </span>被计时代码耗时：<span class=\"hljs-number\">2269</span> 毫秒<br><span class=\"hljs-symbol\">4 </span>被计时代码耗时：<span class=\"hljs-number\">2</span> 秒钟<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://gukaifeng.cn/posts/c-11-chrono-gao-jing-du-ji-shi-fang-fa/\">C++11 chrono 高精度计时方法 | GuKaifeng’s Blog</a></p>\n",
            "tags": [
                "Linux",
                "dgemm"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/12/blislib002/",
            "url": "https://xingyuanjie.top/2023/02/12/blislib002/",
            "title": "BLISlab tutoril阅读",
            "date_published": "2023-02-12T13:11:56.000Z",
            "content_html": "<h1 id=\"BLISlab-tutoril阅读\"><a href=\"#BLISlab-tutoril阅读\" class=\"headerlink\" title=\"BLISlab tutoril阅读\"></a>BLISlab tutoril阅读</h1><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><p><strong>Git地址：</strong><a href=\"https://github.com/flame/blislab\">https://github.com/flame/blislab</a> 【代码包包含tutoril.pdf】</p>\n<h2 id=\"BLISlab-A-Sandbox-for-Optimizing-GEMM\"><a href=\"#BLISlab-A-Sandbox-for-Optimizing-GEMM\" class=\"headerlink\" title=\"BLISlab: A Sandbox for Optimizing GEMM\"></a>BLISlab: A Sandbox for Optimizing GEMM</h2><h2 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h2><p>矩阵-矩阵乘法是科学计算中非常重要的基本运算，机器学习也越来越重要。这是一个非常简单的概念，可以在典型的高中代数课程中引入，但在实践中又非常重要，它在计算机上的实现仍然是一个活跃的研究主题。本笔记描述了一组使用该操作的练习，如何在具有分层内存(多个缓存)的现代cpu上获得高性能。它是基于blas类库实例化软件(BLIS)框架下的见解，通过公开一个模仿BLIS实现的简化“沙盒”来实现的。因此，它也成为BLIS优化的“众包”工具。</p>\n<h2 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1.Introduction\"></a>1.Introduction</h2><p>矩阵-矩阵乘法(Gemm)经常被用作一个简单的例子，以提高如何在现代处理器上优化代码的意识。原因是该操作描述简单，很难完全优化，而且具有实际意义。在本文档中，我们将带领读者了解目前CPU架构中最快实现的技术。</p>\n<h3 id=\"1-1-Basic-Linear-Algebra-Subprograms-BLAS\"><a href=\"#1-1-Basic-Linear-Algebra-Subprograms-BLAS\" class=\"headerlink\" title=\"1.1 Basic Linear Algebra Subprograms (BLAS)\"></a>1.1 Basic Linear Algebra Subprograms (BLAS)</h3><p>基本线性代数子程序(BLAS)[10,5,4,14]为一组线性代数操作形成了一个接口，在此基础上构建了更高级别的线性代数库，如LAPACK[2]和libflame[19]。其思想是，如果有人针对给定的体系结构优化BLAS，那么所有以调用BLAS的方式编写的应用程序和库都将受益于这种优化。</p>\n<p>BLAS被分为三组:一级BLAS(矢量-矢量操作)、二级BLAS(矩阵-矢量操作)和三级BLAS(矩阵-矩阵操作)。最后一组得益于这样一个事实:如果所有矩阵操作数的大小都是n × n，则O(n3)浮点运算对O(n)个数据执行，因此在内存层(主存、缓存和寄存器)之间移动数据的成本可以在很多次计算中平摊。因此，如果仔细执行这些操作，原则上可以实现高性能。</p>\n<h3 id=\"1-2-Matrix-matrix-multiplication\"><a href=\"#1-2-Matrix-matrix-multiplication\" class=\"headerlink\" title=\"1.2 Matrix-matrix multiplication\"></a>1.2 Matrix-matrix multiplication</h3><p>特别地，BLAS通过(Fortran)调用支持具有双精度浮点数的Gemm:</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs fortran\">dgemm( transa, transb, m, n, k alpha, A,lda, B, ldb, beta, C, ldc)<br></code></pre></div></td></tr></table></figure>\n\n<p>通过适当地选择转置a和转置b来计算:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230212215656711.png\" alt=\"image-20230212215656711\"></p>\n<p>这里C是m × n, k是“第三维”。参数dla, dlb和dlc将在本文档后面进行解释。</p>\n<p>在我们的练习中，我们考虑Gemm的简化版本:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230212215836596.png\" alt=\"image-20230212215836596\"></p>\n<p>其中C是m × n, A是m × k, B是k × n。如果了解如何优化dgemm的这种特殊情况，那么可以很容易地将此知识扩展到所有3级BLAS功能。</p>\n<h3 id=\"1-3-High-performance-implementation\"><a href=\"#1-3-High-performance-implementation\" class=\"headerlink\" title=\"1.3 High-performance implementation\"></a>1.3 High-performance implementation</h3><p>高性能实现的复杂性使得BLAS(尤其是Gemm)的实现通常都是由默默无闻的专家来完成的，这些专家为硬件供应商开发数字库，例如IBM的ESSL、Intel的MKL、Cray的LibSci和AMD的ACML库。这些库通常是用汇编代码编写的(至少是部分)，并且针对特定的处理器高度专门化。</p>\n<p>一篇关键论文[1]展示了“算法和体系结构”方法如何携手设计ar体系结构、编译器和算法，使BLAS能够用高级语言(Fortan)为IBM Power体系结构编写，并解释了在这些处理器上实现高性能的复杂性。便携式高性能ANSI C (PHiPAC)[3]项目随后提供了用C编写高性能代码的指南，并建议如何自动生成和优化以这种方式编写的Gemm。Au tomatatically tuning Linear Algebra Software (ATLAS)[17,18]建立在这些见解的基础上，使BLAS库的自动调优和自动生成成为主流。</p>\n<p>在本文档的一部分中，我们讨论了有关该主题的最新论文，包括引入了实施Gemm[6]的Goto方法和该方法[16]的BLIS重构的论文，以及其他更直接相关的论文。</p>\n<h3 id=\"1-4-Other-similar-exercises\"><a href=\"#1-4-Other-similar-exercises\" class=\"headerlink\" title=\"1.4 Other similar exercises\"></a>1.4 Other similar exercises</h3><p>还有一些人基于Gemm组合了练习。与本文相关的最新成果有:乌尔姆大学Michael Lehn所作的“优化微内核:从纯C到SSE”，以及我们自己整理的关于“优化微内核”的维基。</p>\n<h3 id=\"1-5-We-need-you\"><a href=\"#1-5-We-need-you\" class=\"headerlink\" title=\"1.5 We need you!\"></a>1.5 We need you!</h3><p>本文的目的是指导您实现Gemm的高性能实现。我们的别有用心是，用于实现BLAS的BLIS框架需要针对各种cpu高度优化的所谓微内核。在教你基本技巧的过程中，我们希望找到“那个人”将贡献最好的微内核。就把它当做我们版的高性能计算机达人秀吧。虽然我们在描述中关注的是Intel Haswell架构的优化，但是设置可以很容易地修改，从而帮助您(和我们)优化其他cpu。事实上，BLIS本身支持的体系结构包括AMD和Intel的x86处理器，IBM的Power处理器，ARM处理器和德州仪器的DSP处理器[15,12,8]。</p>\n<h2 id=\"2-Step-1-The-Basics\"><a href=\"#2-Step-1-The-Basics\" class=\"headerlink\" title=\"2 Step 1: The Basics\"></a>2 Step 1: The Basics</h2><h3 id=\"2-1-Simple-matrix-matrix-multiplication\"><a href=\"#2-1-Simple-matrix-matrix-multiplication\" class=\"headerlink\" title=\"2.1 Simple matrix-matrix multiplication\"></a>2.1 Simple matrix-matrix multiplication</h3><p>在我们的讨论中，我们将考虑计算：</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213165803939.png\" alt=\"image-20230213165803939\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213165826084.png\" alt=\"image-20230213165826084\"></p>\n<p>其中，A、B、C分别为m × k、k × n、m × n矩阵。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213165920897.png\" alt=\"image-20230213165920897\"></p>\n<p>如果A、B和C存储在二维数组A、B和C中，下面的伪代码计算C:&#x3D;<br>AB + C:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230213170125083.png\" alt=\"image-20230213170125083\"></p>\n<p>分别计算乘法和加法，计算需要2mnk个浮点运算(flop)。</p>\n<h3 id=\"2-2-Setup\"><a href=\"#2-2-Setup\" class=\"headerlink\" title=\"2.2 Setup\"></a>2.2 Setup</h3><p>为了让您高效地学习如何高效地进行计算，您可以在启动项目时准备好大部分基础设施。我们已经构造了子目录step1，有点像实现真正库might的项目。对于我们的目的来说，这可能是多余的，但是如何构建软件项目是一项值得学习的有用技能。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214173819349.png\" alt=\"image-20230214173819349\"></p>\n<p>考虑图4，它演示了子目录step1的目录结构:</p>\n<p><strong>README</strong>是一个描述目录内容以及如何编译和执行代码的文件。</p>\n<p><strong>source .sh</strong>配置环境变量的文件。在那个文件中</p>\n<p><strong>BLISLAB USE INTEL</strong>设置是否使用INTEL编译器(true)或GNU编译器(false)。</p>\n<p><strong>BLISLAB USE BLAS</strong>指示您的参考dgemm是否使用外部BLAS库实现(如果您的机器上安装了这样的BLAS库，则为true)，还是简单的三重循环实现(false)。</p>\n<p><strong>COMPILER OPT LEVEL</strong>设置GNU或Intel编译器的优化级别(O0, O1, O2, O3)。<br>(请注意，例如，O3由大写字母“O”和数字“3”组成。)</p>\n<p><strong>OMP NUM THREADS</strong> and <strong>BLISLAB IC NT</strong>设置用于并行版本的线程数<br>代码。对于第1步，将它们都设置为1。</p>\n<p><strong>dgemm</strong>是实现dgemm的例程存在的子目录。在其中</p>\n<p><strong>bl_dgemm_ref.c</strong>包含例程<strong>dgemm ref</strong>，它是dgemm的一个简单实现，如果<strong>BLISLAB_use_BLAS &#x3D; false</strong>，您将使用它来检查实现的正确性。</p>\n<p><strong>my_dgemm.c</strong>包含例程<strong>dgemm</strong>，它最初是dgemm的一个简单实现，您将优化它作为掌握如何优化gemm的第一步的一部分。</p>\n<p><strong>Bl_dgemm_util.c</strong>包含稍后会派上用场的实用程序例程</p>\n<p><strong>include</strong>这个目录包含包含各种宏定义和其他头信息的文件。</p>\n<p><strong>lib</strong>此目录将保存由您实现的源文件(libblislab. lib)生成的库。libblislab.a)您还可以在此目录中安装参考库(例如OpenBLAS)以比较性能。</p>\n<p><strong>test</strong> 这个目录包含“测试驱动程序”和各种实现的正确性&#x2F;性能检查脚本。</p>\n<p><strong>test_bl_demm .c</strong>包含测试例程bl_demm的“测试驱动程序”。</p>\n<p><strong>test_bl_dgemm.x</strong>是<strong>test_bl_dgemm.c</strong>的可执行文件。</p>\n<p><strong>Run_bl_dgemm.sh</strong>包含一个bash脚本，用于收集性能结果。</p>\n<p><strong>tacc_run_bl_dgemm.sh</strong> contains a <strong>SLURM</strong> script for you to (optionally) submit the job to the Texas Advanced Computing Center (TACC) machines if you have an account there.</p>\n<h3 id=\"2-3-Getting-started\"><a href=\"#2-3-Getting-started\" class=\"headerlink\" title=\"2.3 Getting started\"></a>2.3 Getting started</h3><p>我们希望您从my_dgemm.c中的实现开始，并通过应用各种标准优化技术对其进行优化。该文件中的初始实现是具有图2中给出的三个循环的简单实现。首先要注意的是二维数组如何以所谓的列-主序映射到内存。这种选择的原因是最初的BLAS假定数组的列主存储，因为该接口首先是为Fortran用户提供的。检查</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214185803699.png\" alt=\"image-20230214185803699\"></p>\n<p>我们注意到，每个操作数都是一个宏。考虑文件的早期</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214185849594.png\" alt=\"image-20230214185849594\"></p>\n<p>地址C处的线性数组用于存储元素Ci,j，因此i,j元素被映射到位置j * ldc + i。查看它的方法是C的每一列都是连续存储的。但是，可以把矩阵C看作是嵌入在一个更大的数组中，该数组有ldc行，因此访问一行就意味着跨ldc遍历数组C。二维数组C的前维数通常是指这个较大数组的行维数，因此变量ldc (C的前维数)。下图说明了这三个矩阵:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214190409172.png\" alt=\"image-20230214190409172\"></p>\n<p>其中箭头表示列是连续存储的。</p>\n<h4 id=\"2-3-1-Configure-the-default-implementation\"><a href=\"#2-3-1-Configure-the-default-implementation\" class=\"headerlink\" title=\"2.3.1 Configure the default implementation\"></a>2.3.1 Configure the default implementation</h4><p>默认情况下，练习编译并链接到Intel的icc编译器，该编译器将对代码应用编译器优化(O3级)。您需要通过以下命令设置环境变量:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">source sourceme.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在终端中，您将看到输出:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL = TRUE<br>COMPILER_OPT_LEVEL = O3<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-3-2-Compile-execute-and-collect-results\"><a href=\"#2-3-2-Compile-execute-and-collect-results\" class=\"headerlink\" title=\"2.3.2 Compile, execute and collect results\"></a>2.3.2 Compile, execute and collect results</h4><p>如果您无法访问Intel的编译器(icc)，请阅读第2.3.2小节和2.3.3小节，并继续阅读第2.3.5小节。</p>\n<p>您可以编译、执行代码并通过执行收集性能结果</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">make clean<br>make<br>cd test<br>./run_bl_dgemm.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在子目录step1中。您将看到性能结果输出:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214231134260.png\" alt=\"image-20230214231134260\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214231142311.png\" alt=\"image-20230214231142311\"></p>\n<p>您可以在run_bl_dgemm.sh中更改采样块大小。请注意，如果代码中有错误，这些错误将被报告为，例如，</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230214231406465.png\" alt=\"image-20230214231406465\"></p>\n<h4 id=\"2-3-3-Draw-the-performance-graph\"><a href=\"#2-3-3-Draw-the-performance-graph\" class=\"headerlink\" title=\"2.3.3 Draw the performance graph\"></a>2.3.3 Draw the performance graph</h4><p>最后，您可以使用<strong>MATLAB</strong>用我们的脚本绘制性能图。在<strong>test</strong>子目录下，执行后</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">./collect_result_step1<br></code></pre></div></td></tr></table></figure>\n\n<p>你会得到一个MATLAB文件“step1_result.m”，具有性能结果。然后你可以执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">bl_dgemm_plot.m<br></code></pre></div></td></tr></table></figure>\n\n<p>在MATLAB中，然后生成性能图。</p>\n<h4 id=\"2-3-4-Change-to-the-GNU-compiler\"><a href=\"#2-3-4-Change-to-the-GNU-compiler\" class=\"headerlink\" title=\"2.3.4 Change to the GNU compiler\"></a>2.3.4 Change to the GNU compiler</h4><p>由于我们希望您明确地了解什么样的技巧可以带来高性能，并且由于有些人可能无法访问Intel编译器，因此接下来应该改为使用GNU C编译器。为此，你必须编辑<strong>sourceme.sh</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL=false<br></code></pre></div></td></tr></table></figure>\n\n<p>然后，类似于默认设置，您需要通过执行以下命令来设置环境变量:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">source sourceme.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在终端，你会观察到:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL = false<br>COMILER_OPT_LEVEL = O3<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-3-5-Turn-off-optimization\"><a href=\"#2-3-5-Turn-off-optimization\" class=\"headerlink\" title=\"2.3.5 Turn off optimization\"></a>2.3.5 Turn off optimization</h4><p>接下来，我们希望您关闭编译器执行的优化。这有三个目的:首先，这意味着您将必须显式地执行优化，这将允许您了解架构和算法如何交互。其次，优化编译器很可能会试图“撤销”您显式试图完成的任务。第三，在代码中构建的技巧越多，编译器就越难找出优化的方法。</p>\n<p>你需要先编辑<strong>sourceme.sh:</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">COMILER_OPT_LEVEL = O0<br></code></pre></div></td></tr></table></figure>\n\n<p>然后，类似于默认设置，您需要通过执行以下命令来设置环境变量:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">source sourceme.sh<br></code></pre></div></td></tr></table></figure>\n\n<p>在终端中，您将看到输出:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_INTEL = false<br>COMILER_OPT_LEVEL =O0<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-3-6-Optional-Use-optimized-BLAS-library-as-reference-implementation\"><a href=\"#2-3-6-Optional-Use-optimized-BLAS-library-as-reference-implementation\" class=\"headerlink\" title=\"2.3.6 (Optional) Use optimized BLAS library as reference implementation\"></a>2.3.6 (Optional) Use optimized BLAS library as reference implementation</h4><p>默认情况下，您的参考Gemm实现是一个非常缓慢的三循环实现。如果你在测试机器上安装了BLAS库，你可以通过设置该库中的dgemm作为你的参考实现:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_BLAS=true<br></code></pre></div></td></tr></table></figure>\n\n<p>在sourceme.sh。如果使用Intel编译器，则不需要显式指定MKL的路径。但是，如果使用GNU编译器，则需要指定BLAS库的路径。例如，您可能希望从<a href=\"https://github.com/flame/blis%E5%AE%89%E8%A3%85%E6%88%91%E4%BB%AC%E7%9A%84BLIS%E5%BA%93%E5%88%B0/home/lib/blis%E7%9B%AE%E5%BD%95%E5%90%8C%E6%97%B6%E5%9C%A8sourceme\">https://github.com/flame/blis安装我们的BLIS库到/home/lib/blis目录同时在sourceme</a> .sh中设置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLAS_DIR=/home/lib/blis<br></code></pre></div></td></tr></table></figure>\n\n<p>执行**$ source sourceme .sh**后，你会看到:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">BLISLAB_USE_BLAS = true<br>BLAS_DIR = /home/lib/blis<br></code></pre></div></td></tr></table></figure>\n\n<p>现在，您的实现的性能和准确性将与这个优化的库例程进行比较。</p>\n<h3 id=\"2-4-Basic-techniques\"><a href=\"#2-4-Basic-techniques\" class=\"headerlink\" title=\"2.4 Basic techniques\"></a>2.4 Basic techniques</h3><p>在本小节中，我们将介绍一些基本的交易技巧。</p>\n<h4 id=\"2-4-1-Using-pointers\"><a href=\"#2-4-1-Using-pointers\" class=\"headerlink\" title=\"2.4.1 Using pointers\"></a>2.4.1 Using pointers</h4><p>既然优化被关闭了，那么矩阵元素所在地址的计算将显式地公开。(优化编译器可以消除这种开销。)您要做的是更改my_gemm.c中的实现，以便它使用指针。在这样做之前，您可能需要备份原始的my_gemm.c，以防需要从头开始重新启动。实际上，在每个步骤中，您可能都希望在单独的文件中备份前面的实现</p>\n<p>这是基本的想法。假设我们想把C中的所有元素都设为0。一个基本的循环，按照在my_gemm.c中找到的内容来设计</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>        <span class=\"hljs-built_in\">C</span>(i,j) =<span class=\"hljs-number\">0.0</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>Using pointers, we might implement this as</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> *cp;<br><span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j*ldc ];\t\t\t<span class=\"hljs-comment\">//point cp to top of ith column</span><br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>        *cp++ = <span class=\"hljs-number\">0.0</span>;\t\t<span class=\"hljs-comment\">//set element that cp points to to zero and</span><br>    &#125;\t\t<span class=\"hljs-comment\">//advance the pointer</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>注意，我们有意地交换了循环的顺序，以便向前移动指针将我们带到C的列中。</p>\n<h4 id=\"2-4-2-Loop-unrolling\"><a href=\"#2-4-2-Loop-unrolling\" class=\"headerlink\" title=\"2.4.2 Loop unrolling\"></a>2.4.2 Loop unrolling</h4><p>每次通过内部循环更新循环索引i和指针cp都会产生相当大的开销。</p>\n<p>因此，编译器将执行循环展开。使用展开因子4，我们将C设置为0的简单循环变成</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> *cp;<br><br><span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j * ldc ];<br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>        *(cp+<span class=\"hljs-number\">0</span>) = <span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">1</span>) = <span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">2</span>) = <span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">3</span>) = <span class=\"hljs-number\">0.0</span>;<br>        cp+=<span class=\"hljs-number\">4</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>重要的</p>\n<ul>\n<li>i和cp现在每四次迭代才更新一次。</li>\n<li><em>(cp+0)使用称为间接寻址的机器指令，这比使用</em>(cp+k)计算更有效，其中k是变量。</li>\n<li>当它从内存中输入数据到缓存中时，每次输入一条64字节的缓存线。这意味着以64字节的块访问连续数据可以减少内存层之间的内存移动成本。</li>\n</ul>\n<p>请注意，在展开时，如果m不是4的倍数，则可能必须处理“边缘”。</p>\n<p>为了这个练习，你不需要担心这个边缘，只要你明智地选择你的采样块大小，就像第2.5节重申的那样。</p>\n<h4 id=\"2-4-3-Register-variables\"><a href=\"#2-4-3-Register-variables\" class=\"headerlink\" title=\"2.4.3 Register variables\"></a>2.4.3 Register variables</h4><p>注意，只有当数据存储在寄存器中时，计算才会发生。编译器将自动转换代码，以便插入将某些数据放入寄存器的中间步骤。可以给编译器一个提示，将某些数据保存在寄存器中是很好的，如下面的例子所示:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> *cp;<br><br><span class=\"hljs-keyword\">for</span>( j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)&#123;<br>    cp = &amp;C[ j * ldc ];<br>    <span class=\"hljs-keyword\">for</span>( i = <span class=\"hljs-number\">0</span>; i &lt; m; i+=<span class=\"hljs-number\">4</span>)&#123;<br>        <span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> c0 =<span class=\"hljs-number\">0.0</span>,c1=<span class=\"hljs-number\">0.0</span>,c2=<span class=\"hljs-number\">0.0</span>,c3=<span class=\"hljs-number\">0.0</span>;<br>        *(cp+<span class=\"hljs-number\">0</span>) = c0;<br>        *(cp+<span class=\"hljs-number\">1</span>) = c1;<br>        *(cp+<span class=\"hljs-number\">2</span>) = c2;<br>        *(cp+<span class=\"hljs-number\">3</span>) = c3;<br>        cp+=<span class=\"hljs-number\">4</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"2-5-A-modest-first-goal\"><a href=\"#2-5-A-modest-first-goal\" class=\"headerlink\" title=\"2.5 A modest first goal\"></a>2.5 A modest first goal</h4><p>现在我们要求您使用上面讨论的技术来优化my_dgemm.c。现在，只需要考虑如何为较小的矩阵获得更好的性能。具体来说，请看下面这张图:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230215110352304.png\" alt=\"image-20230215110352304\"></p>\n<p>我们想让你做的是编写你的代码，使C的mR × nR块保存在寄存器中。你可以选择mR和nR，但是你需要用这些选项更新文件<strong>include&#x2F;bl_config.h</strong>。这确保了测试驱动程序只尝试这些块大小的倍数的问题大小，所以您不必担心“边缘”。</p>\n<p>您将注意到，即使对于可以放入某个缓存内存中的较小的矩阵，您的实现(比您可能已安装的MKL或其他优化的BLAS库的实现差得多)。原因是编译器没有为浮点运算使用最快的指令。可以通过使用向量intrinsic funtions函数(允许您从C显式地利用它们)或通过在汇编代码中编码来访问这些函数。现在，我们还没到那一步。我们将<br>在步骤3中讨论更多。</p>\n<h2 id=\"3-Step-2-Blocking\"><a href=\"#3-Step-2-Blocking\" class=\"headerlink\" title=\"3 Step 2: Blocking\"></a>3 Step 2: Blocking</h2><h3 id=\"3-1-Poorman’s-BLAS\"><a href=\"#3-1-Poorman’s-BLAS\" class=\"headerlink\" title=\"3.1 Poorman’s BLAS\"></a>3.1 Poorman’s BLAS</h3><p>本练习的第1步使您认识到，随着基于缓存的体系结构的出现，Gemm的高性能实现需要仔细注意数据在内存层之间移动的成本和对该数据的计算的摊薄。为了保持这种可管理性，认识到只有使用相对较小的矩阵执行矩阵-矩阵乘法的“内核”需要高度优化，这是有帮助的，因为使用较大的矩阵的计算可以被分块，然后使用这样的内核而不会对整体性能产生不利影响。这一见解在[9]中得到了明确的提倡。</p>\n<p>这有时被称为“穷人的BLAS”，因为如果一个人只能负担得起优化矩阵-矩阵乘法(使用子矩阵)，那么就可以构建Gemm，以及其他重要的矩阵-矩阵运算，即三级BLAS。我们稍后将看到的是，从模块化和性能的角度来看，这实际上是一个好主意。</p>\n<p>在上一节中，您已经看到了分块的示例。</p>\n<h3 id=\"3-2-Blocked-matrix-matrix-multiplication\"><a href=\"#3-2-Blocked-matrix-matrix-multiplication\" class=\"headerlink\" title=\"3.2 Blocked matrix-matrix multiplication\"></a>3.2 Blocked matrix-matrix multiplication</h3><p>分块Gemm以利用处理器的分层内存的关键是理解当这些矩阵被分块时如何计算C:&#x3D; AB + C。分块</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216130352894.png\" alt=\"image-20230216130352894\"></p>\n<h3 id=\"3-3-Your-mission-if-you-choose-to-accept-it\"><a href=\"#3-3-Your-mission-if-you-choose-to-accept-it\" class=\"headerlink\" title=\"3.3 Your mission, if you choose to accept it\"></a>3.3 Your mission, if you choose to accept it</h3><p>我们现在要求您在my_dgemm中实现分块矩阵-矩阵乘法。具体来说，对于小矩阵，您可以获得比大矩阵更好的性能，因为小矩阵适合缓存。将矩阵划分为能够获得更高性能的子矩阵，您将看到，即使对于更大的矩阵，所得到的实现也能保持更好的性能</p>\n<h2 id=\"4-Step-3-Blocking-for-Multiple-Levels-of-Cache\"><a href=\"#4-Step-3-Blocking-for-Multiple-Levels-of-Cache\" class=\"headerlink\" title=\"4 Step 3: Blocking for Multiple Levels of Cache\"></a>4 Step 3: Blocking for Multiple Levels of Cache</h2><h3 id=\"4-1-The-Goto-Approach-to-Implementing-gemm\"><a href=\"#4-1-The-Goto-Approach-to-Implementing-gemm\" class=\"headerlink\" title=\"4.1 The Goto Approach to Implementing gemm\"></a>4.1 The Goto Approach to Implementing gemm</h3><p>2000年左右，Kazushige Goto用他的技术彻底改变了Gemm在当前cpu上的实现方式，该技术首次发表在论文[6]上。</p>\n<p>最近在[16]中描述了这种方法的进一步“重构”。</p>\n<p>BLIS框架的优点是它将必须高度优化的内核(可能使用向量intrinsic或在汇编代码中)减少为微内核。在本节中，我们将简要描述该方法的重点。然而，我们强烈建议读者熟悉以上两篇论文本身。</p>\n<p>图3(左)说明了Goto方法为三层缓存(L1、L2和L3)构建分块的方式。在BLIS框架中，实现就是这样结构的，因此只有底层的微内核需要针对给定的体系结构进行高度优化和定制。在最初的GotoBLAS实现(现在维护为OpenBLAS[11])中，从围绕微内核的第二个循环开始的操作是定制的。为了获得最佳性能，所有数据都是连续访问的，这就是为什么在到达微内核之前的某个时刻，数据是按照箭头所示的顺序打包的:</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216131649371.png\" alt=\"image-20230216131649371\"></p>\n<p>现在，注意上图中A块的每一列都乘以B块对应行中的每个元素(我们称这些A块和B块为微面板)。这意味着L2缓存的延迟(从缓存中引入A微面板元素所需的时间)可以平摊到2nR flop上。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216131916807.png\" alt=\"image-20230216131916807\"></p>\n<p>出于这个原因，我们可以组织计算，使A的微面板通常驻留在L2缓存中。实际上，我们可以做得更好:当A和B的微面板的一列发生排名1的更新时，A的微面板的下一列可以被带入寄存器，这样计算就可以掩盖数据移动的成本。事实上，我们希望将B的微面板保留在L1缓存中(因为它将被A的许多微面板重用)，这限制了分块参数kC。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216132839380.png\" alt=\"image-20230216132839380\"></p>\n<p>有人可能会问，上述方案是否是最优方案。在[7]中给出了一个理论，表明在一个理想化的模型下，上述是局部最优的(在某种意义上，假设数据在层次结构中的某个内存层中，在该级别上提出的阻塞最优地与下一个内存层平摊数据移动的成本)。[13]给出了指导各种分块参数选择的理论。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216133142749.png\" alt=\"image-20230216133142749\"></p>\n<h3 id=\"4-2-Setup\"><a href=\"#4-2-Setup\" class=\"headerlink\" title=\"4.2 Setup\"></a>4.2 Setup</h3><p>图4说明了子目录step3的目录结构。与步骤1相比，我们对以下目录&#x2F;文件进行了修改&#x2F;添加:</p>\n<p><strong>kernels</strong> 这个目录包含各种架构的微内核实现</p>\n<p><strong>bd_gemm_ukr.c</strong>给出了一个原生的C实现</p>\n<p><strong>bl_dgemm_int_kernel.c</strong> gives an <strong>AVX&#x2F;AVX2</strong> intrinsics micro-kernel implementation for Haswell architecture.</p>\n<p><strong>bl_dgemm_asm_kernel.c</strong> gives an <strong>AVX&#x2F;AVX2</strong> assembly micro-kernel implementation for Haswell architecture.</p>\n<h3 id=\"4-3-Advanced-techniques\"><a href=\"#4-3-Advanced-techniques\" class=\"headerlink\" title=\"4.3 Advanced techniques\"></a>4.3 Advanced techniques</h3><p>You can find the vector instructions online:</p>\n<p><strong>Intel Intrinsics Guide</strong></p>\n<p><strong>Intel ISA Extensions</strong></p>\n<h4 id=\"4-3-1-An-introduction-example-for-“axpy”\"><a href=\"#4-3-1-An-introduction-example-for-“axpy”\" class=\"headerlink\" title=\"4.3.1 An introduction example for “axpy”\"></a>4.3.1 An introduction example for “axpy”</h4><p>我们提供了一个实现“axpy”的示例，以演示如何使用Intel AVX intrinsic和Assembly(在misc&#x2F;examples子目录中)。</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216134020439.png\" alt=\"image-20230216134020439\"></p>\n<p>这个例子可以作为学习基本broacast&#x2F;fma&#x2F;load&#x2F;store指令的一个很好的起点。此外，这个示例实际上是4×4 rank-1更新的“broadcast”实现的原语。</p>\n<h4 id=\"4-3-2-4×4-rank-1-update\"><a href=\"#4-3-2-4×4-rank-1-update\" class=\"headerlink\" title=\"4.3.2 4×4 rank-1 update\"></a>4.3.2 4×4 rank-1 update</h4><p>微内核实现可以归结为4×4级别1的更新。有两种可能的实现:一种基于广播(图5)，另一种是蝴蝶排列(图6)。您还可以尝试其他可能的实现。</p>\n<h3 id=\"4-4-Your-mission-if-you-choose-to-accept-it\"><a href=\"#4-4-Your-mission-if-you-choose-to-accept-it\" class=\"headerlink\" title=\"4.4 Your mission, if you choose to accept it\"></a>4.4 Your mission, if you choose to accept it</h3><p>我们在my_dgemm中为您提供了简化BLIS框架的参考实现。代码的组织方式与图3所示相同。但是，每个循环中的步长并没有很好地选择，并且微内核实现是一个简单的C版本。因此。您不会期望代码具有高性能。我们要你做的就是:</p>\n<ul>\n<li>在include&#x2F;bl_config.h文件中指定分块参数mC, nC, kC和微内核大小参数mR, nR;</li>\n<li>使用矢量intrinsic或汇编代码实现高效的微内核。将代码放在kernels&#x2F;bl_dgemm_int_kernel.c(用于向量intrinsic)或kernels&#x2F;bl_dgemm_asm_kernel.c(用于as汇编)中。需要在“include&#x2F; BL_config.h”中修改“BL_MICRO_KERNEL”，指定微内核的函数名。</li>\n</ul>\n<p><img src=\"/2023/02/12/blislib002/image-20230216140558800.png\" alt=\"image-20230216140558800\"></p>\n<h2 id=\"5-Step-4-Parallelizing-with-OpenMP\"><a href=\"#5-Step-4-Parallelizing-with-OpenMP\" class=\"headerlink\" title=\"5 Step 4: Parallelizing with OpenMP\"></a>5 Step 4: Parallelizing with OpenMP</h2><p>BLIS构造GotoBLAS方法实现Gemm的好处是，它在tt C中公开了5个循环，这些循环可以很容易地与OpenMP指令并行。</p>\n<h3 id=\"5-1-To-parallelize-or-not-to-parallelize-that’s-the-question\"><a href=\"#5-1-To-parallelize-or-not-to-parallelize-that’s-the-question\" class=\"headerlink\" title=\"5.1 To parallelize or not to parallelize, that’s the question\"></a>5.1 To parallelize or not to parallelize, that’s the question</h3><p>最基本的问题是要并行化哪个循环。在[12]中详细讨论了每个循环的并行化的优点和缺点。对于多核体系结构(具有相对较少核的多线程体系结构)，可以在早期的论文[15]中找到结果。</p>\n<h2 id=\"6-Conclusion\"><a href=\"#6-Conclusion\" class=\"headerlink\" title=\"6 Conclusion\"></a>6 Conclusion</h2><p>我们使用GEMM作为案例研究来展示如何为性能进行编程</p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216141029854.png\" alt=\"image-20230216141029854\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216141041389.png\" alt=\"image-20230216141041389\"></p>\n<p><img src=\"/2023/02/12/blislib002/image-20230216141057850.png\" alt=\"image-20230216141057850\"></p>\n",
            "tags": [
                "Linux",
                "dgemm"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/02/blislab/",
            "url": "https://xingyuanjie.top/2023/02/02/blislab/",
            "title": "BLISlab dgemm优化",
            "date_published": "2023-02-02T06:38:00.000Z",
            "content_html": "<h1 id=\"BLISlab-dgemm优化\"><a href=\"#BLISlab-dgemm优化\" class=\"headerlink\" title=\"BLISlab dgemm优化\"></a>BLISlab dgemm优化</h1><h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><p><strong>Git地址：</strong><a href=\"https://github.com/flame/blislab\">https://github.com/flame/blislab</a></p>\n<p><strong>视频教程：</strong><a href=\"https://www.bilibili.com/video/BV1c94y117Uw?vd_source=3ae32e36058f58c5b85935fca9b77797%E3%80%90%E6%BE%8E%E5%B3%B0%E7%A7%91%E6%8A%80-%E5%BC%A0%E5%85%88%E8%BD%B6%E8%80%81%E5%B8%88%E3%80%91\">https://www.bilibili.com/video/BV1c94y117Uw?vd_source=3ae32e36058f58c5b85935fca9b77797【澎峰科技-张先轶老师】</a></p>\n<p><strong>阅读</strong>：tutorial.pdf【位于代码包中】</p>\n<h2 id=\"Step0\"><a href=\"#Step0\" class=\"headerlink\" title=\"Step0\"></a>Step0</h2><h3 id=\"1-克隆项目到本地\"><a href=\"#1-克隆项目到本地\" class=\"headerlink\" title=\"1.克隆项目到本地\"></a>1.克隆项目到本地</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">git clone https://github.com/flame/blislab.git<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-代码结构\"><a href=\"#2-代码结构\" class=\"headerlink\" title=\"2.代码结构\"></a>2.代码结构</h3><p><img src=\"/2023/02/02/blislab/image-20230202155728203.png\" alt=\"image-20230202155728203\"></p>\n<h3 id=\"3-编译环境\"><a href=\"#3-编译环境\" class=\"headerlink\" title=\"3.编译环境\"></a>3.编译环境</h3><p><img src=\"/2023/02/02/blislab/image-20230202155820411.png\" alt=\"image-20230202155820411\"></p>\n<h3 id=\"4-运行环境配置脚本\"><a href=\"#4-运行环境配置脚本\" class=\"headerlink\" title=\"4.运行环境配置脚本\"></a>4.运行环境配置脚本</h3><p><img src=\"/2023/02/02/blislab/image-20230202160027957.png\" alt=\"image-20230202160027957\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 step0]# source ./sourceme.sh <br>BLISLAB_DIR = .<br>BLISLAB_USE_INTEL = false<br>BLISLAB_USE_BLAS = false<br>COMPILER_OPT_LEVEL = O3<br>BLAS_DIR = /u/jianyu/lib/openblas<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"5-Makefile\"><a href=\"#5-Makefile\" class=\"headerlink\" title=\"5.Makefile\"></a>5.Makefile</h3><p><img src=\"/2023/02/02/blislab/image-20230202160244490.png\" alt=\"image-20230202160244490\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 step0]# make<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/my_dgemm.c -o dgemm/my_dgemm.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/bl_dgemm_ref.c -o dgemm/bl_dgemm_ref.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>gcc -O3 -march=core-avx2 -fPIC -c dgemm/bl_dgemm_util.c -o dgemm/bl_dgemm_util.o -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>ar cr lib/libblislab.a dgemm/my_dgemm.o dgemm/bl_dgemm_ref.o dgemm/bl_dgemm_util.o    <br>ranlib lib/libblislab.a<br>gcc -O3 -march=core-avx2 -fPIC -shared -o lib/libblislab.so dgemm/my_dgemm.o dgemm/bl_dgemm_ref.o dgemm/bl_dgemm_util.o     ./lib/libblislab.a -lpthread -lm -lrt<br>cd ./test &amp;&amp; make &amp;&amp; cd . -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br>make[1]: 进入目录“/root/blislab/step0/test”<br>gcc -O3 -march=core-avx2 -fPIC test_bl_dgemm.c -o test_bl_dgemm.x -I../include -I../kernels -I/u/jianyu/lib/openblas/include ../lib/libblislab.a -lpthread -lm -lrt<br>make[1]: 离开目录“/root/blislab/step0/test”<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"6-make-gnu-inc\"><a href=\"#6-make-gnu-inc\" class=\"headerlink\" title=\"6.make.gnu.inc\"></a>6.make.gnu.inc</h3><p><img src=\"/2023/02/02/blislab/image-20230202160608401.png\" alt=\"image-20230202160608401\"></p>\n<h3 id=\"7-ref参考实现是否调用BLAS\"><a href=\"#7-ref参考实现是否调用BLAS\" class=\"headerlink\" title=\"7.ref参考实现是否调用BLAS\"></a>7.ref参考实现是否调用BLAS</h3><p><img src=\"/2023/02/02/blislab/image-20230202160904158.png\" alt=\"image-20230202160904158\"></p>\n<h3 id=\"8-my-dgemm-c\"><a href=\"#8-my-dgemm-c\" class=\"headerlink\" title=\"8.my_dgemm.c\"></a>8.my_dgemm.c</h3><p><img src=\"/2023/02/02/blislab/image-20230202160939940.png\" alt=\"image-20230202160939940\"></p>\n<h3 id=\"9-相关数据变量含义\"><a href=\"#9-相关数据变量含义\" class=\"headerlink\" title=\"9.相关数据变量含义\"></a>9.相关数据变量含义</h3><p><img src=\"/2023/02/02/blislab/image-20230202161055971.png\" alt=\"image-20230202161055971\"></p>\n<h3 id=\"10-代码采用列主元\"><a href=\"#10-代码采用列主元\" class=\"headerlink\" title=\"10.代码采用列主元\"></a>10.代码采用列主元</h3><p><img src=\"/2023/02/02/blislab/image-20230202161219553.png\" alt=\"image-20230202161219553\"></p>\n<h3 id=\"11-dgemm使用脚本测试\"><a href=\"#11-dgemm使用脚本测试\" class=\"headerlink\" title=\"11.dgemm使用脚本测试\"></a>11.dgemm使用脚本测试</h3><p>Test目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 test]# ./run_bl_dgemm.sh <br>result=[<br><span class=\"hljs-meta\">%</span><span class=\"bash\">m\t%n\t%k\t%MY_GFLOPS\t%REF_GFLOPS</span><br>   16\t    16\t    16\t  7.35\t  1.93<br>   32\t    32\t    32\t  7.88\t  1.29<br>   48\t    48\t    48\t  9.81\t  1.17<br>   64\t    64\t    64\t  8.98\t  1.20<br>   80\t    80\t    80\t  9.59\t  1.11<br>   96\t    96\t    96\t  7.74\t  1.08<br>  112\t   112\t   112\t  8.32\t  0.95<br>  128\t   128\t   128\t  7.74\t  1.04<br>  144\t   144\t   144\t  7.39\t  0.99<br>  160\t   160\t   160\t  7.13\t  1.06<br>  176\t   176\t   176\t  7.58\t  1.06<br>  192\t   192\t   192\t  7.73\t  0.98<br>  208\t   208\t   208\t  7.29\t  1.01<br>  224\t   224\t   224\t  7.90\t  0.97<br>  240\t   240\t   240\t  7.61\t  1.00<br>  256\t   256\t   256\t  6.72\t  0.96<br>  272\t   272\t   272\t  7.51\t  0.99<br>  288\t   288\t   288\t  7.39\t  0.99<br>  304\t   304\t   304\t  7.84\t  0.99<br>  320\t   320\t   320\t  7.61\t  0.97<br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//run_bl_dgemm.sh</span><br>#!/bin/bash<br><br>#For Mac OS only<br><span class=\"hljs-keyword\">export</span> DYLD_LIBRARY_PATH=/opt/intel/lib:/opt/intel/mkl/lib<br><br>#Single Thread<br><span class=\"hljs-keyword\">export</span> KMP_AFFINITY=compact  #Rule to bind core to thread <span class=\"hljs-keyword\">for</span> OMP thread with Intel compiler <span class=\"hljs-keyword\">for</span> parallel version<br><span class=\"hljs-keyword\">export</span> OMP_NUM_THREADS=<span class=\"hljs-number\">1</span>     #Set OMP number of threads <span class=\"hljs-keyword\">for</span> parallel version<br><span class=\"hljs-keyword\">export</span> BLISLAB_IC_NT=<span class=\"hljs-number\">1</span>       #Set BLISLAB number of threads <span class=\"hljs-keyword\">for</span> parallel version<br>k_start=<span class=\"hljs-number\">16</span>\t\t\t\t\t\t<span class=\"hljs-comment\">//起始大小\t\t</span><br>k_end=<span class=\"hljs-number\">1024</span>\t\t\t\t\t\t<span class=\"hljs-comment\">//结束大小</span><br>k_blocksize=<span class=\"hljs-number\">16</span>\t\t\t\t\t<span class=\"hljs-comment\">//步长</span><br>echo <span class=\"hljs-string\">&quot;result=[&quot;</span><br>echo -e <span class=\"hljs-string\">&quot;%m\\t%n\\t%k\\t%MY_GFLOPS\\t%REF_GFLOPS&quot;</span><br><span class=\"hljs-keyword\">for</span> (( k=k_start; k&lt;=k_end; k+=k_blocksize ))<br><span class=\"hljs-keyword\">do</span><br>    ./test_bl_dgemm.x     $k $k $k <br>done<br>echo <span class=\"hljs-string\">&quot;];&quot;</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"12-dgemm手动指定参数测试\"><a href=\"#12-dgemm手动指定参数测试\" class=\"headerlink\" title=\"12.dgemm手动指定参数测试\"></a>12.dgemm手动指定参数测试</h3><p>Test目录下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">[root@hadoop1 test]# ./test_bl_dgemm.x <span class=\"hljs-number\">256</span> <span class=\"hljs-number\">256</span> <span class=\"hljs-number\">256</span> <br>  <span class=\"hljs-number\">256</span>\t   <span class=\"hljs-number\">256</span>\t   <span class=\"hljs-number\">256</span>\t  <span class=\"hljs-number\">5.00</span>\t  <span class=\"hljs-number\">0.84</span><br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">[root@hadoop1 test]# ./test_bl_dgemm.x <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">32</span> <span class=\"hljs-number\">128</span><br>   <span class=\"hljs-number\">16</span>\t    <span class=\"hljs-number\">32</span>\t   <span class=\"hljs-number\">128</span>\t  <span class=\"hljs-number\">8.77</span>\t  <span class=\"hljs-number\">1.02</span><br></code></pre></div></td></tr></table></figure>\n\n<p><strong>这里要注意哪个代表m,n,k?</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">( <span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[] )</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span>    m, n, k; <br><br>    <span class=\"hljs-keyword\">if</span> ( argc != <span class=\"hljs-number\">4</span> ) &#123;<br>        <span class=\"hljs-built_in\">printf</span>( <span class=\"hljs-string\">&quot;Error: require 3 arguments, but only %d provided.\\n&quot;</span>, argc - <span class=\"hljs-number\">1</span> );<br>        <span class=\"hljs-built_in\">exit</span>( <span class=\"hljs-number\">0</span> );<br>    &#125;<br><br>    <span class=\"hljs-built_in\">sscanf</span>( argv[ <span class=\"hljs-number\">1</span> ], <span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;m );<br>    <span class=\"hljs-built_in\">sscanf</span>( argv[ <span class=\"hljs-number\">2</span> ], <span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;n );<br>    <span class=\"hljs-built_in\">sscanf</span>( argv[ <span class=\"hljs-number\">3</span> ], <span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;k );<br><br>    <span class=\"hljs-built_in\">test_bl_dgemm</span>( m, n, k );<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"13-计时区域\"><a href=\"#13-计时区域\" class=\"headerlink\" title=\"13.计时区域\"></a><strong>13.计时区域</strong></h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span> ( i = <span class=\"hljs-number\">0</span>; i &lt; nrepeats; i ++ ) &#123;<br>        ref_beg = <span class=\"hljs-built_in\">bl_clock</span>();\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//blislib提供的封装</span><br>        &#123;<br>            <span class=\"hljs-built_in\">bl_dgemm_ref</span>(<br>                    m,<br>                    n,<br>                    k,<br>                    A,<br>                    lda,<br>                    B,<br>                    ldb,<br>                    C_ref,<br>                    ldc_ref<br>                    );<br>        &#125;<br>        ref_time = <span class=\"hljs-built_in\">bl_clock</span>() - ref_beg;<br><br>        <span class=\"hljs-keyword\">if</span> ( i == <span class=\"hljs-number\">0</span> ) &#123;<br>            ref_rectime = ref_time;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            ref_rectime = ref_time &lt; ref_rectime ? ref_time : ref_rectime;\t\t\t\t\t<span class=\"hljs-comment\">//多次计时取最优</span><br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"14-正确性检验\"><a href=\"#14-正确性检验\" class=\"headerlink\" title=\"14.正确性检验\"></a>14.正确性检验</h3><p>Test目录下Test_bl_gemm.c</p>\n<p>结果比较：通过比较你的优化计算结果和参考计算结果对比</p>\n<p>Gflops的计算</p>\n<ul>\n<li>有效浮点次数 &#x3D; 2*m*n*k</li>\n<li>Gflops &#x3D; 有效浮点次数 &#x2F; 时间</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">computeError</span>(<br>        ldc,<br>        ldc_ref,<br>        m,<br>        n,<br>        C,<br>        C_ref<br>        );<br><br><span class=\"hljs-comment\">// Compute overall floating point operations.</span><br>flops = ( m * n / ( <span class=\"hljs-number\">1000.0</span> * <span class=\"hljs-number\">1000.0</span> * <span class=\"hljs-number\">1000.0</span> ) ) * ( <span class=\"hljs-number\">2</span> * k );<br><br><span class=\"hljs-built_in\">printf</span>( <span class=\"hljs-string\">&quot;%5d\\t %5d\\t %5d\\t %5.2lf\\t %5.2lf\\n&quot;</span>, <br>        m, n, k, flops / bl_dgemm_rectime, flops / ref_rectime );<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"15-课后作业\"><a href=\"#15-课后作业\" class=\"headerlink\" title=\"15.课后作业\"></a>15.课后作业</h3><p><strong>perf工具的用法</strong>：</p>\n<p><a href=\"https://xingyuanjie.top/2022/01/19/tool003/\">perf-系统级性能分析工具 - Amicoyuan (xingyuanjie.top)</a></p>\n<p><strong>分析不同的j,p,i循环顺序的性能：</strong></p>\n<p>原因cache miss造成的差异</p>\n<h2 id=\"Step1\"><a href=\"#Step1\" class=\"headerlink\" title=\"Step1\"></a>Step1</h2><h3 id=\"1-与Step0比较\"><a href=\"#1-与Step0比较\" class=\"headerlink\" title=\"1.与Step0比较\"></a>1.与Step0比较</h3><p><strong>左边是Step1右边是Step0</strong></p>\n<p><img src=\"/2023/02/02/blislab/image-20230202165659964.png\" alt=\"image-20230202165659964\"></p>\n<h3 id=\"2-基本分块\"><a href=\"#2-基本分块\" class=\"headerlink\" title=\"2.基本分块\"></a>2.基本分块</h3><p><img src=\"/2023/02/02/blislab/image-20230202170723811.png\" alt=\"image-20230202170723811\"></p>\n<h3 id=\"3-反汇编\"><a href=\"#3-反汇编\" class=\"headerlink\" title=\"3.反汇编\"></a>3.反汇编</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 dgemm]# objdump -d ./my_dgemm.o &gt; my_dgemm.S<br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs assembly\">./my_dgemm.o：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;AddDot&gt;:<br>   0:\t85 ff                \ttest   %edi,%edi<br>   2:\t7e 2e                \tjle    32 &lt;AddDot+0x32&gt;<br>   4:\t48 63 d2             \tmovslq %edx,%rdx<br>   7:\tc4 c1 7b 10 01       \tvmovsd (%r9),%xmm0<br>   c:\t31 c0                \txor    %eax,%eax<br>   e:\t48 c1 e2 03          \tshl    $0x3,%rdx<br>  12:\t66 0f 1f 44 00 00    \tnopw   0x0(%rax,%rax,1)<br>  18:\tc5 fb 10 0e          \tvmovsd (%rsi),%xmm1<br>  1c:\t48 01 d6             \tadd    %rdx,%rsi<br>  1f:\tc4 e2 f1 b9 04 c1    \tvfmadd231sd (%rcx,%rax,8),%xmm1,%xmm0<br>  25:\t48 83 c0 01          \tadd    $0x1,%rax<br>  29:\tc4 c1 7b 11 01       \tvmovsd %xmm0,(%r9)<br>  2e:\t39 c7                \tcmp    %eax,%edi<br>  30:\t7f e6                \tjg     18 &lt;AddDot+0x18&gt;<br>  32:\tf3 c3                \trepz retq <br>  34:\t66 90                \txchg   %ax,%ax<br>  36:\t66 2e 0f 1f 84 00 00 \tnopw   %cs:0x0(%rax,%rax,1)<br>  3d:\t00 00 00 <br><br>0000000000000040 &lt;AddDot_MRxNR&gt;:<br>  40:\te9 00 00 00 00       \tjmpq   45 &lt;AddDot_MRxNR+0x5&gt;<br>  45:\t90                   \tnop<br>  46:\t66 2e 0f 1f 84 00 00 \tnopw   %cs:0x0(%rax,%rax,1)<br>  4d:\t00 00 00 <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"4-反汇编（-fPIC引入的差异）\"><a href=\"#4-反汇编（-fPIC引入的差异）\" class=\"headerlink\" title=\"4.反汇编（-fPIC引入的差异）\"></a>4.反汇编（-fPIC引入的差异）</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 test]# objdump -d ./test_bl_dgemm.x  &gt; test.S<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202171234007.png\" alt=\"image-20230202171234007\"></p>\n<h3 id=\"5-Gcc生成汇编\"><a href=\"#5-Gcc生成汇编\" class=\"headerlink\" title=\"5.Gcc生成汇编\"></a>5.Gcc生成汇编</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">[root@hadoop1 step1]# gcc -O3 -march=core-avx2 -fPIC -S dgemm/my_dgemm.c -o dgemm/my_dgemm1.S -I./include -I./kernels -I/u/jianyu/lib/openblas/include<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202171758087.png\" alt=\"image-20230202171758087\"></p>\n<h3 id=\"6-Step0与Step1比较\"><a href=\"#6-Step0与Step1比较\" class=\"headerlink\" title=\"6.Step0与Step1比较\"></a>6.Step0与Step1比较</h3><p><img src=\"/2023/02/02/blislab/image-20230202172816584.png\" alt=\"image-20230202172816584\"></p>\n<h3 id=\"7-分块，修改MR，-NR为4×4\"><a href=\"#7-分块，修改MR，-NR为4×4\" class=\"headerlink\" title=\"7.分块，修改MR， NR为4×4\"></a>7.分块，修改MR， NR为4×4</h3><p><img src=\"/2023/02/02/blislab/image-20230202173132817.png\" alt=\"image-20230202173132817\"></p>\n<h3 id=\"8-分块（2×2）\"><a href=\"#8-分块（2×2）\" class=\"headerlink\" title=\"8.分块（2×2）\"></a>8.分块（2×2）</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">void</span> AddDot_2×<span class=\"hljs-number\">2</span>( <span class=\"hljs-keyword\">int</span> k, <span class=\"hljs-keyword\">double</span> *A, <span class=\"hljs-keyword\">int</span> lda, <span class=\"hljs-keyword\">double</span> *B, <span class=\"hljs-keyword\">int</span> ldb, <span class=\"hljs-keyword\">double</span> *C,<span class=\"hljs-keyword\">int</span> ldc ) &#123;<br>\t<span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> C00, C01, C10, C11;<br>    <span class=\"hljs-keyword\">int</span> p;<br>    C00=<span class=\"hljs-number\">0.0</span>;<br>    C01=<span class=\"hljs-number\">0.0</span>;<br>    C10=<span class=\"hljs-number\">0.0</span>;<br>    C11=<span class=\"hljs-number\">0.0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span>( p=<span class=\"hljs-number\">0</span> ;p &lt; k; p++)<br>    &#123;<br>        C00 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>);<br>        C01 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>);<br>        C10 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>);<br>        C11 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>) +=C00;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>) +=C01;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) +=C10;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>) +=C11;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202173645399.png\" alt=\"image-20230202173645399\"></p>\n<h3 id=\"9-AddDot-2x2汇编代码\"><a href=\"#9-AddDot-2x2汇编代码\" class=\"headerlink\" title=\"9.AddDot_2x2汇编代码\"></a>9.AddDot_2x2汇编代码</h3><p><img src=\"/2023/02/02/blislab/image-20230202191728644.png\" alt=\"image-20230202191728644\"></p>\n<h3 id=\"10-AddDot-2x2最内层循环展开\"><a href=\"#10-AddDot-2x2最内层循环展开\" class=\"headerlink\" title=\"10.AddDot_2x2最内层循环展开\"></a>10.AddDot_2x2最内层循环展开</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">void</span> AddDot_2×<span class=\"hljs-number\">2</span>( <span class=\"hljs-keyword\">int</span> k, <span class=\"hljs-keyword\">double</span> *A, <span class=\"hljs-keyword\">int</span> lda, <span class=\"hljs-keyword\">double</span> *B, <span class=\"hljs-keyword\">int</span> ldb, <span class=\"hljs-keyword\">double</span> *C,<span class=\"hljs-keyword\">int</span> ldc ) &#123;<br>\t<span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">double</span> C00, C01, C10, C11;<br>    <span class=\"hljs-keyword\">int</span> p;<br>    C00=<span class=\"hljs-number\">0.0</span>;<br>    C01=<span class=\"hljs-number\">0.0</span>;<br>    C10=<span class=\"hljs-number\">0.0</span>;<br>    C11=<span class=\"hljs-number\">0.0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span>( p=<span class=\"hljs-number\">0</span> ;p &lt; k; p+=<span class=\"hljs-number\">2</span>)<br>    &#123;<br>        C00 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>        C01 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">0</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);<br>        C10 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">0</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>        C11 += <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p) * <span class=\"hljs-built_in\">B</span>( p, <span class=\"hljs-number\">1</span>) + <span class=\"hljs-built_in\">A</span>( <span class=\"hljs-number\">1</span>, p+<span class=\"hljs-number\">1</span>) * <span class=\"hljs-built_in\">B</span>( p+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>) +=C00;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>) +=C01;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) +=C10;<br>    <span class=\"hljs-built_in\">C</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>) +=C11;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/02/02/blislab/image-20230202192033816.png\" alt=\"image-20230202192033816\"></p>\n<h3 id=\"11-AddDot-2x2汇编代码【最内层循环展开】\"><a href=\"#11-AddDot-2x2汇编代码【最内层循环展开】\" class=\"headerlink\" title=\"11.AddDot_2x2汇编代码【最内层循环展开】\"></a>11.AddDot_2x2汇编代码【最内层循环展开】</h3><p><img src=\"/2023/02/02/blislab/image-20230202192319993.png\" alt=\"image-20230202192319993\"></p>\n<h2 id=\"Step2\"><a href=\"#Step2\" class=\"headerlink\" title=\"Step2\"></a>Step2</h2><h3 id=\"1-与Step1的性能比较\"><a href=\"#1-与Step1的性能比较\" class=\"headerlink\" title=\"1.与Step1的性能比较\"></a>1.与Step1的性能比较</h3><p><img src=\"/2023/02/02/blislab/image-20230206163219051.png\" alt=\"image-20230206163219051\"></p>\n<h3 id=\"2-优化kernel-x2F-bl-dgemm-ukr-c\"><a href=\"#2-优化kernel-x2F-bl-dgemm-ukr-c\" class=\"headerlink\" title=\"2.优化kernel&#x2F;bl_dgemm_ukr.c\"></a>2.优化kernel&#x2F;bl_dgemm_ukr.c</h3><p><img src=\"/2023/02/02/blislab/image-20230206163713966.png\" alt=\"image-20230206163713966\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206163803615.png\" alt=\"image-20230206163803615\"></p>\n<h3 id=\"3-优化后性能对比\"><a href=\"#3-优化后性能对比\" class=\"headerlink\" title=\"3.优化后性能对比\"></a>3.优化后性能对比</h3><p><img src=\"/2023/02/02/blislab/image-20230206163833950.png\" alt=\"image-20230206163833950\"></p>\n<h3 id=\"4-下降原因分析\"><a href=\"#4-下降原因分析\" class=\"headerlink\" title=\"4.下降原因分析\"></a>4.下降原因分析</h3><p><img src=\"/2023/02/02/blislab/image-20230206164335213.png\" alt=\"image-20230206164335213\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206164734050.png\" alt=\"image-20230206164734050\"></p>\n<h3 id=\"5-如何进行分块\"><a href=\"#5-如何进行分块\" class=\"headerlink\" title=\"5.如何进行分块\"></a>5.如何进行分块</h3><p><img src=\"/2023/02/02/blislab/image-20230206165017812.png\" alt=\"image-20230206165017812\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206165103417.png\" alt=\"image-20230206165103417\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170050450.png\" alt=\"image-20230206170050450\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170105998.png\" alt=\"image-20230206170105998\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170126588.png\" alt=\"image-20230206170126588\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170153251.png\" alt=\"image-20230206170153251\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170226248.png\" alt=\"image-20230206170226248\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170242872.png\" alt=\"image-20230206170242872\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170320842.png\" alt=\"image-20230206170320842\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206170334857.png\" alt=\"image-20230206170334857\"></p>\n<h3 id=\"6-Dgemm代码\"><a href=\"#6-Dgemm代码\" class=\"headerlink\" title=\"6.Dgemm代码\"></a>6.Dgemm代码</h3><p><img src=\"/2023/02/02/blislab/image-20230206171538013.png\" alt=\"image-20230206171538013\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206171556767.png\" alt=\"image-20230206171556767\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206171622104.png\" alt=\"image-20230206171622104\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206171639209.png\" alt=\"image-20230206171639209\"></p>\n<h3 id=\"7-Dgemm-macro-kenrel代码\"><a href=\"#7-Dgemm-macro-kenrel代码\" class=\"headerlink\" title=\"7.Dgemm macro kenrel代码\"></a>7.Dgemm macro kenrel代码</h3><p><img src=\"/2023/02/02/blislab/image-20230206171903844.png\" alt=\"image-20230206171903844\"></p>\n<p><img src=\"/2023/02/02/blislab/image-20230206171940282.png\" alt=\"image-20230206171940282\"></p>\n<h3 id=\"8-Gemm汇总\"><a href=\"#8-Gemm汇总\" class=\"headerlink\" title=\"8.Gemm汇总\"></a>8.Gemm汇总</h3><p><img src=\"/2023/02/02/blislab/image-20230206172351890.png\" alt=\"image-20230206172351890\"></p>\n<h3 id=\"9-拓展\"><a href=\"#9-拓展\" class=\"headerlink\" title=\"9.拓展\"></a>9.拓展</h3><p><img src=\"/2023/02/02/blislab/image-20230206172425329.png\" alt=\"image-20230206172425329\"></p>\n<h3 id=\"10-双缓冲优化\"><a href=\"#10-双缓冲优化\" class=\"headerlink\" title=\"10.双缓冲优化\"></a>10.双缓冲优化</h3><p><img src=\"/2023/02/02/blislab/image-20230206172846408.png\" alt=\"image-20230206172846408\"></p>\n",
            "tags": [
                "Linux",
                "dgemm"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2022/05/20/slurm001/",
            "url": "https://xingyuanjie.top/2022/05/20/slurm001/",
            "title": "Slurm",
            "date_published": "2022-05-20T09:43:02.000Z",
            "content_html": "<h2 id=\"Slurm\"><a href=\"#Slurm\" class=\"headerlink\" title=\"Slurm\"></a>Slurm</h2><h4 id=\"1-sstat-查看RUNNING作业\"><a href=\"#1-sstat-查看RUNNING作业\" class=\"headerlink\" title=\"1.sstat 查看RUNNING作业\"></a>1.sstat 查看RUNNING作业</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">sstat -e<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/slurm001/image-20220520174453969.png\" alt=\"image-20220520174453969\"></p>\n<p><strong>使用举例：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">sstat -a --format=&quot;JobId,Pids,AveCPU,AveRSS,MaxRSS&quot;  1755818<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/slurm001/image-20220520175001331.png\" alt=\"image-20220520175001331\"></p>\n<h4 id=\"2-sacct-查看FINISHED作业\"><a href=\"#2-sacct-查看FINISHED作业\" class=\"headerlink\" title=\"2.sacct 查看FINISHED作业\"></a>2.sacct 查看FINISHED作业</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">sacct -e<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/slurm001/image-20220520174622868.png\" alt=\"image-20220520174622868\"></p>\n<p><strong>使用举例：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">sacct --format=&quot;JobId,Elapsed,CPUTime,CPUTimeRAW,AveCPU,TotalCPU,UserCPU,SystemCPU,AveRSS,MaxRSS&quot; -j 1754217<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/slurm001/image-20220520174807162.png\" alt=\"image-20220520174807162\"></p>\n<h4 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h4><p><a href=\"https://blog.csdn.net/kongxx/article/details/52556943\">(28条消息) Slurm查看作业CPU和MEM_kongxx的博客-CSDN博客_slurm 查看节点</a></p>\n",
            "tags": [
                "Linux",
                "Slurm"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2022/05/20/numactl001/",
            "url": "https://xingyuanjie.top/2022/05/20/numactl001/",
            "title": "numactl",
            "date_published": "2022-05-20T09:35:59.000Z",
            "content_html": "<ol>\n<li></li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">numactl --hardware<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/numactl001/image-20220520173911653.png\" alt=\"image-20220520173911653\"></p>\n<ol start=\"2\">\n<li></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shelll\">numastat<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/numactl001/image-20220520174030171.png\" alt=\"image-20220520174030171\"></p>\n<ol start=\"3\">\n<li></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">numactl --show<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/numactl001/image-20220520174148487.png\" alt=\"image-20220520174148487\"></p>\n<h5 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h5><p><a href=\"https://blog.csdn.net/qccz123456/article/details/81979819\">(28条消息) Linux工具之numactl_qccz123456的博客-CSDN博客_numactl</a></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1699088343604813491&wfr=spider&for=pc&searchword=numactl\">宋宝华：为什么numactl内存绑定对代码段不起作用 (baidu.com)</a></p>\n",
            "tags": [
                "Linux",
                "Numactl"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2022/05/20/Linux002/",
            "url": "https://xingyuanjie.top/2022/05/20/Linux002/",
            "title": "linux的jobs,fg,bg命令",
            "date_published": "2022-05-20T09:13:08.000Z",
            "content_html": "<h3 id=\"linux让前台程序脱离终端运行\"><a href=\"#linux让前台程序脱离终端运行\" class=\"headerlink\" title=\"linux让前台程序脱离终端运行\"></a>linux让前台程序脱离终端运行</h3><p>1.首先运行你的程序</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520171436032.png\" alt=\"image-20220520171436032\"></p>\n<p>2.随后使用Ctrl + z，挂起你的进程</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520171510946.png\" alt=\"image-20220520171510946\"></p>\n<p>3.然后使用jobs查看所有的进程</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520171913979.png\" alt=\"image-20220520171913979\"></p>\n<p>4.随后使用bg+id，表示该任务为后台1号任务</p>\n<p>bg命令用于将作业放到后台运行，使前台可以执行其他任务</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520172110992.png\" alt=\"image-20220520172110992\"></p>\n<h3 id=\"linux让后台程序移动到前台终端\"><a href=\"#linux让后台程序移动到前台终端\" class=\"headerlink\" title=\"linux让后台程序移动到前台终端\"></a>linux让后台程序移动到前台终端</h3><p>Linux常用命令fg主要用于将后台作业移动到前台终端运行</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520172358345.png\" alt=\"image-20220520172358345\"></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2022/05/20/Linux001/",
            "url": "https://xingyuanjie.top/2022/05/20/Linux001/",
            "title": "Linux常用指令",
            "date_published": "2022-05-20T09:08:45.000Z",
            "content_html": "<h2 id=\"Linux常用指令\"><a href=\"#Linux常用指令\" class=\"headerlink\" title=\"Linux常用指令\"></a>Linux常用指令</h2><h4 id=\"杀死进程\"><a href=\"#杀死进程\" class=\"headerlink\" title=\"杀死进程\"></a>杀死进程</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">kill <span class=\"hljs-number\">-9</span> id<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/Linux001/image-20220520171246860.png\" alt=\"image-20220520171246860\"></p>\n",
            "tags": [
                "Linux"
            ]
        }
    ]
}