{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"data structure\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/05/06/Algorithm037/",
            "url": "http://example.com/2022/05/06/Algorithm037/",
            "title": "图的存储",
            "date_published": "2022-05-06T08:38:38.000Z",
            "content_html": "<h2 id=\"图的存储\"><a href=\"#图的存储\" class=\"headerlink\" title=\"图的存储\"></a>图的存储</h2><h3 id=\"邻接矩阵法\"><a href=\"#邻接矩阵法\" class=\"headerlink\" title=\"邻接矩阵法\"></a>邻接矩阵法</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#define MaxVertexNum 100\t\t\t\t\t\t\t\t\t//顶点数目的最大值\ntypedef char VertexType;\t\t\t\t\t\t\t\t\t//顶点的数据类型\ntypedef int EdgeType;\t\t\t\t\t\t\t\t\t\t//带权图中边上权值的数据类型\ntypedef struct&#123;\n    VertexType Vex[MaxVertexNum];\t\t\t\t\t\t\t//顶点表\n    EdgeType Edge[MaxVertexNum][MaxVertexNum];\t\t\t\t//邻接矩阵，边表\n    int vexnum,arcnum;\t\t\t\t\t\t\t\t\t\t//图中当前顶点数和弧数\n&#125;MGraph;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"邻接表法\"><a href=\"#邻接表法\" class=\"headerlink\" title=\"邻接表法\"></a>邻接表法</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#define MaxVertexNum 100\t\t\t\t\t\t\t\t\t//图中顶点数目的最大值\ntypedef struct ArcNode&#123;\t\t\t\t\t\t\t\t\t\t//边表结点\n    int adjvex;\t\t\t\t\t\t\t\t\t\t\t\t//该弧所指向的顶点的位置\n    struct ArcNode *next;\t\t\t\t\t\t\t\t\t//指向下一条弧的指针\n    //InfoType infp;\t\t\t\t\t\t\t\t\t\t//网的边权值\n&#125;ArcNode;\ntypedef struct VNode&#123;\t\t\t\t\t\t\t\t\t\t//顶点表结点\n    VertexType data;\t\t\t\t\t\t\t\t\t\t//顶点信息\n    ArcNode *first;\t\t\t\t\t\t\t\t\t\t\t//指向第一条依附该顶点的弧的指针\n&#125;VNode,AdjList[MaxVertexNum];\ntypedef struct&#123;\n    AdjList vertices;\t\t\t\t\t\t\t\t\t\t//邻接表\n    int vexnum,arcnum;\t\t\t\t\t\t\t\t\t\t//图的顶点数和弧数\n&#125;ALGraph;\t\t\t\t\t\t\t\t\t\t\t\t\t//ALGraph是以邻接表存储的图的类型\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure",
                "Graph"
            ]
        },
        {
            "id": "http://example.com/2022/05/05/Algorithm036/",
            "url": "http://example.com/2022/05/05/Algorithm036/",
            "title": "树、森林",
            "date_published": "2022-05-05T08:58:34.000Z",
            "content_html": "<h2 id=\"树、森林\"><a href=\"#树、森林\" class=\"headerlink\" title=\"树、森林\"></a>树、森林</h2><h3 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h3><h4 id=\"双亲表示法\"><a href=\"#双亲表示法\" class=\"headerlink\" title=\"双亲表示法\"></a>双亲表示法</h4><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#define MAX_TREE_SIZE 100\t\t\t\t\t//树中最多节点数\t\ntypedef struct&#123;\t\t\t\t\t\t\t\t//树的结点定义\n    ElemType data;\t\t\t\t\t\t\t//数据元素\t\n    int parent;\t\t\t\t\t\t\t\t//双亲位置域\n&#125;PTNode;\ntypedef struct&#123;\t\t\t\t\t\t\t\t//树的类型定义\n    PTNode nodes[MAX_TREE_SIZE];\t\t\t//双亲表示\n    int n;\t\t\t\t\t\t\t\t\t//节点数\n&#125;PTree;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"孩子兄弟法\"><a href=\"#孩子兄弟法\" class=\"headerlink\" title=\"孩子兄弟法\"></a>孩子兄弟法</h4><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">typedef struct CSNode&#123;\n    ElemType data;\t\t\t\t\t\t\t\t\t\t\t//数据域\n    struct CSNode *firstchild,*nextsibling;\t\t\t\t\t//第一个孩子和右兄弟指针\n&#125;CSNode,*CSTree;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure",
                "Tree",
                "森林"
            ]
        },
        {
            "id": "http://example.com/2022/05/04/Algorithm035/",
            "url": "http://example.com/2022/05/04/Algorithm035/",
            "title": "线索二叉树",
            "date_published": "2022-05-04T12:05:19.000Z",
            "content_html": "<h2 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h2><h3 id=\"线索二叉树的存储结构\"><a href=\"#线索二叉树的存储结构\" class=\"headerlink\" title=\"线索二叉树的存储结构\"></a>线索二叉树的存储结构</h3><p>线索二叉树的存储结构描述如下</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">ltag = 0 lchild域指示结点的左孩子\nltag = 1 lchild域指示结点的前驱\n//\nrtag = 0 rchild域指示结点的右孩子\nrtag = 1 rchild域指示结点的后继\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">typedef struct ThreadNode&#123;\n    ElemType data;\t\t\t\t\t\t//数据元素\n    struct ThreadNode *lchild,*rchild;\t\t\t\t//左右孩子指针\n    int ltag,rtag;\t\t\t\t\t\t\t\t\t//左右线索标志\n&#125;ThreadNode，*ThreadTree;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"中序线索二叉树的构造\"><a href=\"#中序线索二叉树的构造\" class=\"headerlink\" title=\"中序线索二叉树的构造\"></a>中序线索二叉树的构造</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void InThread(ThreadTree &p,ThreadNode &pre)&#123;\n    if(p!=NULL)&#123;\n        InThread(p->lchild,pre);\t\t\t//递归，线索化左子树\n        &#123;\n            if(p->lchild==NULL)&#123;\t\t\t//左子树为空，建立前驱线索\n                p->lchild=pre;\n                p->ltag=1;\n            &#125;\n            if(pre!=NULL&&pre->rchild==NULL)&#123;\n                pre->rchild=p;\t\t\t\t//建立前驱结点的后继线索\n                pre->rtag=1;\n            &#125;\n            pre=p;\t\t\t\t\t\t\t//标记当前结点成为刚刚访问过的结点\n            InThread(p->rchild,pre);\t\t//递归，线索化右子树\n        &#125;//if(p!=NULL)\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void CreateInThread(ThreadTree T)&#123;\n    ThreadTree pre = NULL;\n    if(T!=NULL)&#123;\t\t\t\t\t\t//非空二叉树。线索化\n        InThread(T,pre);\t\t\t\t//线索化二叉树\n        pre->rchild=NULL;\t\t\t\t//处理遍历的最后一个结点\n        pre->rtag=1;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"中序线索二叉树的遍历\"><a href=\"#中序线索二叉树的遍历\" class=\"headerlink\" title=\"中序线索二叉树的遍历\"></a>中序线索二叉树的遍历</h3><p>1)求中序线索二叉树中中序序列下的第一个结点</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Thread *Firstnode(ThreadNode *p)&#123;\n    while(p->ltag==0) p=p->lchild;\t\t//最左下结点（不一定是叶结点）\n    return p;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>2)求中序线索二叉树中结点p在中序序列下的后继</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">ThreadNode *Nextnode(ThreadNode *p)&#123;\n    if(p->rtag==0) return Firstnode(p->rchild);\n    else return p->rchild;\t\t\t//rtag==1直接返回后继线索\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>3)利用上面两个算法，可以写出不含头节点的中序线索二叉树的中序遍历算法</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void Inorder(ThreadNode *T)&#123;\n    for(ThreadNode *p=Firstnode;p!=NULL;p=Nextnode(p))\n        visit(p);\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure",
                "Binary tree",
                "线索二叉树"
            ]
        },
        {
            "id": "http://example.com/2022/04/27/Algorithm034/",
            "url": "http://example.com/2022/04/27/Algorithm034/",
            "title": "串的模式匹配算法-KMP算法",
            "date_published": "2022-04-27T11:39:05.000Z",
            "content_html": "<h2 id=\"串的模式匹配算法-KMP算法\"><a href=\"#串的模式匹配算法-KMP算法\" class=\"headerlink\" title=\"串的模式匹配算法-KMP算法\"></a>串的模式匹配算法-KMP算法</h2><h3 id=\"求next数组\"><a href=\"#求next数组\" class=\"headerlink\" title=\"求next数组\"></a>求next数组</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void get_next(SSting t,int next[])\n&#123;\n    int i=1,j=0;\n    next[1]=0;\n    while(i<t.length)\n    &#123;\n        if(j==0||t.ch[i]==t.ch[j])\n        &#123;\n            i++;\n            j++;\n            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1\n        &#125;else&#123;\n            j=next[j];      //否则令j=next[j]，循环继续\n        &#125;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"KMP匹配算法\"><a href=\"#KMP匹配算法\" class=\"headerlink\" title=\"KMP匹配算法\"></a>KMP匹配算法</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int Index_KMP(SSting s,SSting t,int next[])&#123;\n    int i=1,j=1;\n    while (i<=s.length&&j<=t.length)&#123;\n        if(j==0||s.ch[i]==t.ch[j])\n        &#123;\n            j++;                    //继续比较后续字符\n            i++;\n        &#125;else&#123;\n            j=next[j];              //模式串向右移动\n        &#125;\n    &#125;\n    if(j>t.length)\n    &#123;\n        return i-t.length;          //匹配成功\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"完整代码：\"><a href=\"#完整代码：\" class=\"headerlink\" title=\"完整代码：\"></a>完整代码：</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\n#define MAXLEN 255\t\t\t\t\t//预定义最大串长\ntypedef struct&#123;\n    char ch[MAXLEN];\t\t\t\t//每个分量存储一个字符\n    int length;\t\t\t\t\t\t//串的实际长度\n&#125;SSting;\nvoid get_next(SSting t,int next[])\n&#123;\n    int i=1,j=0;\n    next[1]=0;\n    while(i<t.length)\n    &#123;\n        if(j==0||t.ch[i]==t.ch[j])\n        &#123;\n            i++;\n            j++;\n            next[i]=j;      //若pi=pj,则next[j+i]=next[j]+1\n        &#125;else&#123;\n            j=next[j];      //否则令j=next[j]，循环继续\n        &#125;\n    &#125;\n&#125;\nint Index_KMP(SSting s,SSting t,int next[])&#123;\n    int i=1,j=1;\n    while (i<=s.length&&j<=t.length)&#123;\n        if(j==0||s.ch[i]==t.ch[j])\n        &#123;\n            j++;                    //继续比较后续字符\n            i++;\n        &#125;else&#123;\n            j=next[j];              //模式串向右移动\n        &#125;\n    &#125;\n    if(j>t.length)\n    &#123;\n        return i-t.length;          //匹配成功\n    &#125;else&#123;\n        return 0;\n    &#125;\n&#125;\nint main()\n&#123;\n    SSting a,b;\n    string s1=\"ababcabcacbab\";\n    string s2=\"abcac\";\n    a.length=s1.size();\n    b.length=s2.size();\n    int next[s2.size()+1];\n    get_next(b,next);\n    for (int i = 0; i <s1.size(); ++i) &#123;\t//初始化\n        a.ch[i+1]=s1[i];\n    &#125;\n    for (int j = 0; j <s2.size() ; ++j) &#123;\t//初始化\n        b.ch[j+1]=s2[j];\n    &#125;\n    int x=Index_KMP(a,b,next);\n    if(x!=0)\n    &#123;\n        cout<<\"找到了位置是：\"<<x<<endl;\n    &#125;else&#123;\n        cout<<\"没有找到\"<<endl;\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"程序输出：\"><a href=\"#程序输出：\" class=\"headerlink\" title=\"程序输出：\"></a>程序输出：</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">找到了位置是：6\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure",
                "String",
                "KMP"
            ]
        },
        {
            "id": "http://example.com/2022/04/27/Algorithm033/",
            "url": "http://example.com/2022/04/27/Algorithm033/",
            "title": "串-简单的模式匹配算法",
            "date_published": "2022-04-27T09:11:18.000Z",
            "content_html": "<h2 id=\"串-简单的模式匹配算法\"><a href=\"#串-简单的模式匹配算法\" class=\"headerlink\" title=\"串-简单的模式匹配算法\"></a>串-简单的模式匹配算法</h2><h3 id=\"简单的模式匹配算法\"><a href=\"#简单的模式匹配算法\" class=\"headerlink\" title=\"简单的模式匹配算法\"></a>简单的模式匹配算法</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int Index(SSting s,SSting t)        //简单的模式匹配算法\n&#123;\n    int i=1,j=1;\n    while(i<=s.length && j<= t.length)\n    &#123;\n        if(s.ch[i]==t.ch[j])\n        &#123;\n            i++;                      //继续比较后继字符\n            j++;\n        &#125;else&#123;                        //指针后退重新开始匹配\n            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位\n            j=1;\n        &#125;\n    &#125;\n    if(j>t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号\n    else return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"完整程序源代码\"><a href=\"#完整程序源代码\" class=\"headerlink\" title=\"完整程序源代码\"></a>完整程序源代码</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\n#define MAXLEN 255\t\t\t\t\t//预定义最大串长\ntypedef struct&#123;\n    char ch[MAXLEN];\t\t\t\t//每个分量存储一个字符\n    int length;\t\t\t\t\t\t//串的实际长度\n&#125;SSting;\nint Index(SSting s,SSting t)        //简单的模式匹配算法\n&#123;\n    int i=1,j=1;\n    while(i<=s.length && j<= t.length)\n    &#123;\n        if(s.ch[i]==t.ch[j])\n        &#123;\n            i++;                      //继续比较后继字符\n            j++;\n        &#125;else&#123;                        //指针后退重新开始匹配\n            i=i-j+2;                  //每次匹配失败后，都把模式t后移一位\n            j=1;\n        &#125;\n    &#125;\n    if(j>t.length) return i-t.length;           //返回与模式t中第一个字符相等的字符在主串s中的序号\n    else return 0;\n&#125;\nint main()\n&#123;\n    SSting a,b;\n    string s1=\"ababcabcacbab\";\n    string s2=\"abcac\";\n    a.length=s1.size();\n    b.length=s2.size();\n    for (int i = 0; i <s1.size(); ++i) &#123;\t//初始化\n        a.ch[i+1]=s1[i];\n    &#125;\n    for (int j = 0; j <s2.size() ; ++j) &#123;\t//初始化\n        b.ch[j+1]=s2[j];\n    &#125;\n    int x=Index(a,b);\n    if(x!=0)\n    &#123;\n        cout<<\"找到了位置是：\"<<x<<endl;\n    &#125;else&#123;\n        cout<<\"没有找到\"<<endl;\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">找到了位置是：6\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure",
                "String"
            ]
        },
        {
            "id": "http://example.com/2022/04/23/Algorithm032/",
            "url": "http://example.com/2022/04/23/Algorithm032/",
            "title": "L2-036 网红点打卡攻略 (25 分)",
            "date_published": "2022-04-23T13:50:27.000Z",
            "content_html": "<h2 id=\"L2-036-网红点打卡攻略-25-分\"><a href=\"#L2-036-网红点打卡攻略-25-分\" class=\"headerlink\" title=\"L2-036 网红点打卡攻略 (25 分)\"></a>L2-036 网红点打卡攻略 (25 分)</h2><p>一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>首先第一行给出两个正整数：网红点的个数 <em>N</em>（1&lt;<em>N</em>≤200）和网红点之间通路的条数 <em>M</em>。随后 <em>M</em> 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 <em>N</em> 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 <code>0</code>。</p>\n<p>再下一行给出一个正整数 <em>K</em>，是待检验的攻略的数量。随后 <em>K</em> 行，每行给出一条待检攻略，格式为：</p>\n<p><em>n</em> <em>V</em>1 <em>V</em>2 ⋯ Vn</p>\n<p>其中 <em>n</em>(≤200) 是攻略中的网红点数，<em>Vi</em> 是路径上的网红点编号。这里假设你从家里出发，从 <em>V</em>1 开始打卡，最后从 <em>Vn</em> 回家。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在第一行输出满足要求的攻略的个数。</p>\n<p>在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。</p>\n<p>题目保证至少存在一个有效攻略，并且总路费不超过 109。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">6 13\n0 5 2\n6 2 2\n6 0 1\n3 4 2\n1 5 2\n2 5 1\n3 1 1\n4 1 2\n1 6 1\n6 3 2\n1 2 1\n4 5 3\n2 0 2\n7\n6 5 1 4 3 6 2\n6 5 2 1 6 3 4\n8 6 2 1 6 3 4 5 2\n3 2 1 5\n6 6 1 3 4 5 2\n7 6 2 1 3 4 5 2\n6 5 2 1 4 3 6\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">3\n5 11\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"样例说明：\"><a href=\"#样例说明：\" class=\"headerlink\" title=\"样例说明：\"></a>样例说明：</h3><p>第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。</p>\n<p>第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 &#x3D; 14；</p>\n<p>第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &#x3D; 11，是一条更省钱的攻略；</p>\n<p>第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。</p>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint g[205][205];\nint minsize=INT_MAX;\t\t\t//初始化为INT_MAX\nint minid=0;\nint main()\n&#123;\n    cin>>n>>m;\n    int cnt=0;\n    memset(g,0,sizeof(g));\n    for (int i = 0; i <m ; ++i) &#123;\n        int a,b,c;\n        cin>>a>>b>>c;\n        g[a][b]=c;\n        g[b][a]=c;\n    &#125;\n    int time;\n    cin>>time;\n    for (int j = 0; j <time ; ++j) &#123;\n        int k;\n        cin>>k;\n        int roll[k+5];\n        int has[k+5];\n        memset(has,0,sizeof(has));\n        roll[0]=roll[k+1]=0;\t\t\t\t\t//起点和终点必定是家\n        for (int i = 1; i <=k ; ++i) &#123;\n            cin>>roll[i];\n            if(has[roll[i]]) has[0]=1;\t\t\t//每个打卡点仅能打卡一次\n            else has[roll[i]]=1;\n        &#125;\n        int flag=1;\n        int tmpsize=0;\n        if(k!=n||has[0]) continue;\n        for (int l = 1; l <=k+1 ; ++l) &#123;\n            if(g[roll[l-1]][roll[l]]==0)\n            &#123;\n                flag=0;\n                break;\n            &#125;\n            tmpsize+=g[roll[l-1]][roll[l]];\n        &#125;\n        if(flag==1)\n        &#123;\n            if(tmpsize<minsize)&#123;\n                minsize=tmpsize;\n                minid=j+1;\n\n            &#125;\n            cnt++;\n        &#125;\n    &#125;\n    cout<<cnt<<endl;\n    cout<<minid<<\" \"<<minsize<<endl;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482059\">题目详情 - L2-036 网红点打卡攻略 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Graph",
                "邻接矩阵"
            ]
        },
        {
            "id": "http://example.com/2022/04/23/Algorithm031/",
            "url": "http://example.com/2022/04/23/Algorithm031/",
            "title": "L2-039 清点代码库 (25 分)",
            "date_published": "2022-04-23T13:44:47.000Z",
            "content_html": "<h2 id=\"L2-039-清点代码库-25-分\"><a href=\"#L2-039-清点代码库-25-分\" class=\"headerlink\" title=\"L2-039 清点代码库 (25 分)\"></a>L2-039 清点代码库 (25 分)</h2><p><img src=\"/2022/04/23/Algorithm031/58e6a034-993d-4049-8deb-23d769c8597e.jpg\" alt=\"code.jpg\"></p>\n<p>上图转自新浪微博：“阿里代码库有几亿行代码，但其中有很多功能重复的代码，比如单单快排就被重写了几百遍。请设计一个程序，能够将代码库中所有功能重复的代码找出。各位大佬有啥想法，我当时就懵了，然后就挂了。。。”</p>\n<p>这里我们把问题简化一下：首先假设两个功能模块如果接受同样的输入，总是给出同样的输出，则它们就是功能重复的；其次我们把每个模块的输出都简化为一个整数（在 <strong>int</strong> 范围内）。于是我们可以设计一系列输入，检查所有功能模块的对应输出，从而查出功能重复的代码。你的任务就是设计并实现这个简化问题的解决方案。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行中给出 2 个正整数，依次为 <em>N</em>（≤104）和 <em>M</em>（≤102），对应功能模块的个数和系列测试输入的个数。</p>\n<p>随后 <em>N</em> 行，每行给出一个功能模块的 <em>M</em> 个对应输出，数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>首先在第一行输出不同功能的个数 <em>K</em>。随后 <em>K</em> 行，每行给出具有这个功能的模块的个数，以及这个功能的对应输出。数字间以 1 个空格分隔，行首尾不得有多余空格。输出首先按模块个数非递增顺序，如果有并列，则按输出序列的递增序给出。</p>\n<p>注：所谓数列 { <em>A</em>1, …, <em>A</em>M } 比 { <em>B</em>1, …, <em>B</em>M } 大，是指存在 1≤i&lt;*M*，使得 *A*1&#x3D;*B*1，…，*Ai*&#x3D;*Bi* 成立，且 *Ai*+1&gt;<em>B</em>+1。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">7 3\n35 28 74\n-1 -1 22\n28 74 35\n-1 -1 22\n11 66 0\n35 28 74\n35 28 74\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">4\n3 35 28 74\n2 -1 -1 22\n1 11 66 0\n1 28 74 35\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>利用map的映射关系</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nmap<vector<int>,int> mp;   //key，value\nvector<int> tmp;\nint n,m;\nbool cmp(pair<vector<int>,int> a,pair<vector<int>,int> b)\n&#123;\n    if(a.second==b.second)\n    &#123;\n        return a.first<b.first;\n    &#125;\n    return a.second>b.second;\n\n&#125;\nint main()\n&#123;\n    cin>>n>>m;\n    for (int i = 0; i <n ; ++i) &#123;\n        for (int j = 0; j < m; ++j) &#123;\n            int num;\n            cin>>num;\n            tmp.push_back(num);\n        &#125;\n        mp[tmp]++;\n        tmp.clear();\n    &#125;\n    vector<pair<vector<int>,int>> v(mp.begin(),mp.end());\t\t//把map类型转化成vector\n    cout<<v.size()<<endl;\n    sort(v.begin(),v.end(),cmp);\t\t\t\t\t\t\t\t//sort排序，注意终点和起点\n    for (int k = 0; k <v.size() ; ++k) &#123;\n        cout<<v[k].second<<\" \";\n        for (int i = 0; i <m ; ++i) &#123;\n            if(i!=m-1)&#123;\n                cout<<v[k].first[i]<<\" \";\n            &#125; else&#123;\n                cout<<v[k].first[i]<<endl;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652362\">题目详情 - L2-039 清点代码库 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Sort",
                "Vector",
                "Map",
                "Pair"
            ]
        },
        {
            "id": "http://example.com/2022/04/16/Algorithm028/",
            "url": "http://example.com/2022/04/16/Algorithm028/",
            "title": "L2-010 排座位 (25 分)",
            "date_published": "2022-04-16T06:57:46.000Z",
            "content_html": "<h2 id=\"L2-010-排座位-25-分\"><a href=\"#L2-010-排座位-25-分\" class=\"headerlink\" title=\"L2-010 排座位 (25 分)\"></a><strong>L2-010 排座位 (25 分)</strong></h2><p>布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入第一行给出3个正整数：<code>N</code>（≤100），即前来参宴的宾客总人数，则这些人从1到<code>N</code>编号；<code>M</code>为已知两两宾客之间的关系数；<code>K</code>为查询的条数。随后<code>M</code>行，每行给出一对宾客之间的关系，格式为：<code>宾客1 宾客2 关系</code>，其中<code>关系</code>为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后<code>K</code>行，每行给出一对需要查询的宾客编号。</p>\n<p>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出<code>No problem</code>；如果他们之间并不是朋友，但也不敌对，则输出<code>OK</code>；如果他们之间有敌对，然而也有共同的朋友，则输出<code>OK but...</code>；如果他们之间只有敌对关系，则输出<code>No way</code>。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">7 8 4\n5 6 1\n2 7 -1\n1 3 1\n3 4 1\n6 7 -1\n1 2 1\n1 4 1\n2 3 -1\n3 4\n5 7\n2 3\n7 2\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">No problem\nOK\nOK but...\nNo way\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接矩阵 + 并查集</strong></p>\n<p><strong>并查集具体链接：</strong></p>\n<p><a href=\"https://xingyuanjie.top/2022/01/04/Algorithm004/\">并查集 - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nint pre[100];\t\t\t\t//父节点\nint deep[100];\t\t\t\t//深度\nint g[101][101];\t\t\t//邻接矩阵建图\nvoid init(int n)&#123;\n    for (int i = 0; i <n ; ++i) &#123;\n        pre[i]=i;\n        deep[i]=0;\n    &#125;\n&#125;\nint find(int x)&#123;\n    if(pre[x]==x)&#123;\n        return x;\n    &#125; else&#123;\n        return pre[x]=find(pre[x]);\n    &#125;\n&#125;\nvoid unit(int x,int y)&#123;\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n    if(deep[x]<deep[y])&#123;\n        pre[x]=y;\n    &#125;else&#123;\n        pre[y]=x;\n        if(deep[x]==deep[y])&#123;\n            deep[x]++;\n        &#125;\n    &#125;\n&#125;\nint main()\n&#123;\n    int n,m,k;\n    init(105);\n    memset(g,0,sizeof(g));\n    cin>>n>>m>>k;\n    for (int i = 0; i <m ; ++i) &#123;\n        int a,b,c;\n        cin>>a>>b>>c;\n        g[a][b]=g[b][a]=c;\n        if(c==1) unit(a,b);\t\t\t\t\t//如果是朋友则合并\n    &#125;\n    for (int j = 0; j <k ; ++j) &#123;\n        int a,b;\n        cin>>a>>b;\n        if(g[a][b]==1&&g[b][a]==1) cout<<\"No problem\"<<endl;\n        else if(g[a][b]==0&&g[b][a]==0) cout<<\"OK\"<<endl;\t\t\t//两人毫无关系\n        else if(g[a][b]==-1&&g[b][a]==-1&&find(a)==find(b)) cout<<\"OK but...\"<<endl;\t//敌对且有共同朋友\n        else if(g[a][b]==-1&&g[b][a]==-1) cout<<\"No way\"<<endl;\t\t//仅敌对\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://blog.csdn.net/weixin_45260385/article/details/109752008\">(20条消息) 【PTA】 L2-010 排座位 (25分) 【简单并查集】_黑桃️的博客-CSDN博客</a></p>\n<p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805066135879680\">题目详情 - L2-010 排座位 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Graph",
                "邻接矩阵",
                "并查集"
            ]
        },
        {
            "id": "http://example.com/2022/04/15/Algorithm025/",
            "url": "http://example.com/2022/04/15/Algorithm025/",
            "title": "L2-013 红色警报 (25 分)",
            "date_published": "2022-04-15T13:09:30.000Z",
            "content_html": "<h2 id=\"L2-013-红色警报-25-分\"><a href=\"#L2-013-红色警报-25-分\" class=\"headerlink\" title=\"L2-013 红色警报 (25 分)\"></a>L2-013 红色警报 (25 分)</h2><p>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出两个整数<code>N</code>（0 &lt; <code>N</code> ≤ 500）和<code>M</code>（≤ 5000），分别为城市个数（于是默认城市从0到<code>N</code>-1编号）和连接两城市的通路条数。随后<code>M</code>行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数<code>K</code>和随后的<code>K</code>个被攻占的城市的编号。</p>\n<p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出<code>Red Alert: City k is lost!</code>，其中<code>k</code>是该城市的编号；否则只输出<code>City k is lost.</code>即可。如果该国失去了最后一个城市，则增加一行输出<code>Game Over.</code>。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">5 4\n0 1\n1 3\n3 0\n0 4\n5\n1 2 0 4 3\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">City 1 is lost.\nCity 2 is lost.\nRed Alert: City 0 is lost!\nCity 4 is lost.\nCity 3 is lost.\nGame Over.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接矩阵建图 + DFS统计连通分量数</strong></p>\n<p><strong>对于无向图来说，dfstrave()中dfs()或bfstrave()中bfs()的调用次数等于该图的连通分量数</strong></p>\n<p><strong>无向图中的极大连通子图称为连通分量</strong></p>\n<p><strong>极大连通子图必须连通，且包含尽可能多的顶点和边</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint g[505][505];\t\t\t\t\t\t//邻接矩阵存图\nint visit[505];\t\t\t\t\t\t\t//标记访问数组\nint lost[505];\t\t\t\t\t\t\t//记录被攻占的城市\nvoid dfs(int node)&#123;\t\t\t\t\t\t//正常的DFS\n    visit[node]=1;\n    for(int i=0;i<n;i++)\n    &#123;\n        if(visit[i]==0&&g[node][i]==1)\n        &#123;\n            dfs(i);\n        &#125;\n    &#125;\n&#125;\nint dfstrave()&#123;\n    int cnt=0;\n    memset(visit,0,sizeof(visit));\t\t\t//初始化访问数组\n    for(int i=0;i<n;i++)&#123;\n        if(lost[i]==1) visit[i]=1;\t\t\t//如果该城市被攻占，则标记他为以访问\n    &#125;\n    for(int i=0;i<n;i++)&#123;\n        if(visit[i]==0)&#123;\n            dfs(i);\n            cnt++;      \t\t\t\t\t//统计连通分量数\n        &#125;\n    &#125;\n    return cnt;\n&#125;\nint main()\n&#123;\n    cin>>n>>m;\n    memset(lost,0,sizeof(lost));\t\t\t//初始化\n    memset(g,0,sizeof(g));\t\t\t\t\t//初始化\n    for(int i=0;i<m;i++)&#123;\n        int a,b;\n        cin>>a>>b;\n        g[a][b]=g[b][a]=1;\t\t\t\t\t//存储无向图\n    &#125;\n    int cnt=dfstrave();\t\t\t\t\t\t//获得初始的连通分量数\n    int k;\n    cin>>k;\n    for(int w=0;w<k;w++)&#123;\n        int city;\n        cin>>city;\n        lost[city]=1;\t\t\t\t\t\t//记录该城市被攻占\n        for(int i=0;i<n;i++)&#123;\n            if(g[city][i]==1)&#123;\t\t\t\t\n                g[city][i]=g[i][city]=0;\t//标记和他相连的城市不再相连\n            &#125;\n        &#125;\n        int tempcnt=dfstrave();\t\t\t\t//当前的连通分量\n        if(tempcnt<=cnt)&#123;\t\t\t\t\t//如果当前的连通分量小于等于原来的连通分量，说明图的连通性没有被改变\n            printf(\"City %d is lost.\\n\", city);\n        &#125;else&#123;\t\t\t\t\t\t\t\t//否则，连通性被改变了\n            printf(\"Red Alert: City %d is lost!\\n\", city);\n        &#125;\n        cnt=tempcnt;\t\t\t\t\t\t//更新连通分量\n        if(w==n-1)&#123;\t\t\t\t\t\t\t//城市已经被攻占完毕\n            printf(\"Game Over.\\n\");\n        &#125;\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805063963230208\">题目详情 - L2-013 红色警报 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Graph",
                "邻接矩阵",
                "DFS"
            ]
        },
        {
            "id": "http://example.com/2022/04/14/Algorithm024/",
            "url": "http://example.com/2022/04/14/Algorithm024/",
            "title": "L2-011 玩转二叉树 (25 分)",
            "date_published": "2022-04-14T06:01:10.000Z",
            "content_html": "<h2 id=\"L2-011-玩转二叉树-25-分\"><a href=\"#L2-011-玩转二叉树-25-分\" class=\"headerlink\" title=\"L2-011 玩转二叉树 (25 分)\"></a><strong>L2-011 玩转二叉树 (25 分)</strong></h2><p>给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">7\n1 2 3 4 5 6 7\n4 1 3 2 6 5 7\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">4 6 1 7 5 3 2\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>镜面反转即为在层序遍历时交换左右子树的遍历顺序，左-&gt;右变成右-&gt;左</strong></p>\n<p><strong>前序 + 中序 建树 + BFS</strong></p>\n<p><strong>建树详细过程：</strong></p>\n<p><a href=\"https://xingyuanjie.top/2022/04/07/Algorithm014/\">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct BiTNode&#123;\n    int data;\n    struct BiTNode *lchild,*rchild;\n&#125;BiTNode,*BiTree;\nint n;\nint in[35];\nint pre[35];\nBiTree PostCreate(int prel,int prer,int inl,int inr)&#123;\t\t\t\t\t//前序加中序建树\n    if(prel>prer)&#123;\n        return NULL;\n    &#125;\n    BiTNode *root;\n    root=(BiTNode*)malloc(sizeof(BiTNode));\n    root->data=pre[prel];\n    int index=0;\n    for (int i = inl; i <=inr; ++i) &#123;\n        if(pre[prel]==in[i])&#123;\n            index=i;\n            break;\n        &#125;\n    &#125;\n    int numleft=index-inl;\n    root->lchild=PostCreate(prel+1,prel+numleft,inl,index-1);\n    root->rchild=PostCreate(prel+numleft+1,prer,index+1,inr);\n    return root;\n&#125;\nvoid LevelOrder(BiTree T)\n&#123;\n    queue<BiTree> q;\n    q.push(T);\n    int i=0;\n    while (!q.empty())&#123;\n        BiTNode *tmp =q.front();\n        q.pop();\n        if(i!=n-1)&#123;\t\t\t\t\t\t\t\t\t\t//输出格式控制\n            cout<<tmp->data<<\" \";\n        &#125;else&#123;\n            cout<<tmp->data;\n        &#125;\n        i++;\n        if(tmp->rchild!=NULL)&#123;\t\t\t\t\t\t\t//镜面反转，左->右变成右->左\n            q.push(tmp->rchild);\n        &#125;\n        if(tmp->lchild!=NULL)&#123;\n            q.push(tmp->lchild);\n        &#125;\n    &#125;\n&#125;\nint main()\n&#123;\n    BiTree tree;\n    tree=NULL;\n    cin>>n;\n    for (int i = 0; i <n ; ++i) &#123;\n        cin>>in[i];\n    &#125;\n    for (int j = 0; j <n ; ++j) &#123;\n        cin>>pre[j];\n    &#125;\n    tree=PostCreate(0,n-1,0,n-1);\n    LevelOrder(tree);\n    cout<<endl;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805065406070784\">题目详情 - L2-011 玩转二叉树 (25 分) (pintia.cn)</a></p>\n<p><a href=\"https://xingyuanjie.top/2022/04/07/Algorithm014/\">由遍历顺序构建二叉树(前序+中序;后序+中序) - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Binary tree",
                "BFS"
            ]
        },
        {
            "id": "http://example.com/2022/04/14/Algorithm023/",
            "url": "http://example.com/2022/04/14/Algorithm023/",
            "title": "L2-035 完全二叉树的层序遍历 (25 分)",
            "date_published": "2022-04-14T06:01:05.000Z",
            "content_html": "<h2 id=\"L2-035-完全二叉树的层序遍历-25-分\"><a href=\"#L2-035-完全二叉树的层序遍历-25-分\" class=\"headerlink\" title=\"L2-035 完全二叉树的层序遍历 (25 分)\"></a>L2-035 完全二叉树的层序遍历 (25 分)</h2><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是<strong>完美二叉树</strong>。对于深度为 <em>D</em> 的，有 <em>N</em> 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 <em>N</em> 个结点，这样的树就是<strong>完全二叉树</strong>。</p>\n<p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>N</em>（≤30），即树中结点个数。第二行给出后序遍历序列，为 <em>N</em> 个不超过 100 的正整数。同一行中所有数字都以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">8\n91 71 2 34 10 15 55 18\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">18 34 55 71 2 10 15 91\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>后序遍历建树 + 完全二叉树性质</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nint tree[10001];\nint n;\nvoid post(int i)&#123;\t\t//根据后序遍历建树\n    if(2*i<=n)&#123;\t\t\t//当2*i<=n时，结点i的左孩子编号为2*i，否则无左孩子\n        post(2*i);\n    &#125;\n    if(2*i+1<=n)&#123;\t\t//当2*i+1<=n时，结点i的右孩子编号为2*i+1，否则无右孩子\n        post(2*i+1);\n    &#125;\n    cin>>tree[i];\n&#125;\nint main()\n&#123;\n\n    cin>>n;\n    post(1);           //后序遍历建树\n    for (int i = 1; i <=n ; ++i) &#123;\t\t\t\t\t\t//顺序输出即为层序遍历\n        if(i!=n)&#123;\n            cout<<tree[i]<<\" \";\n        &#125;else&#123;\n            cout<<tree[i];\n        &#125;\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058\">https://pintia.cn/problem-sets/994805046380707840/problems/1336215880692482058</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Binary tree"
            ]
        },
        {
            "id": "http://example.com/2022/04/13/Algorithm022/",
            "url": "http://example.com/2022/04/13/Algorithm022/",
            "title": "L2-031 深入虎穴 (25 分)",
            "date_published": "2022-04-13T11:09:46.000Z",
            "content_html": "<p>著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。</p>\n<p>内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入首先在一行中给出正整数 <em>N</em>（&lt;105），是门的数量。最后 <em>N</em> 行，第 <em>i</em> 行（1≤<em>i</em>≤<em>N</em>）按以下格式描述编号为 <em>i</em> 的那扇门背后能通向的门：</p>\n<pre><code>K D[1] D[2] ... D[K]\n</code></pre>\n<p>其中 <code>K</code> 是通道的数量，其后是每扇门的编号。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">13\n3 2 3 4\n2 5 6\n1 7\n1 8\n1 9\n0\n2 11 10\n1 13\n0\n0\n1 12\n0\n0\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">12\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接表 + BFS</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[100005];\nint book[100005];\nint start=0;\nint bfs()&#123;\t\t\t\t\t\t\t\t//BFS\n    queue<int> q;\n    q.push(start);\t\t\t\t\t\t//根节点入队\n    int x;\n    while(!q.empty())&#123;\n        x=q.front();\n        q.pop();\n        for (int i = 0; i <v[x].size() ; ++i) &#123;\t\t\t\t\n            q.push(v[x][i]);\n        &#125;\n    &#125;\t\t\t\t\t\t\t\t\t//在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。\n    return x;\t\t\t\t\t\t\t//所以最后一层只有一个结点，所以BFS最后一个元素，即为最远的门\n&#125;\nint main()\n&#123;\n    int n;\n    cin>>n;\n    for (int i = 1; i <=n ; ++i) &#123;\n        int time;\n        cin>>time;\n        for (int j = 1; j <=time ; ++j) &#123;\n            int num;\n            cin>>num;\n            book[num]=1;\n            v[i].push_back(num);\n\n        &#125;\n    &#125;\n    for (int k = 1; k <=n ; ++k) &#123;\t\t\t//找入口\n        if(book[k]==0) start=k;\t\t\t\t//没有门通向的门，即为入口\n    &#125;\n    int ans=bfs();\n    cout<<ans<<endl;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1111914599412858888\">题目详情 - L2-031 深入虎穴 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "邻接表",
                "Vector",
                "Binary tree",
                "BFS"
            ]
        },
        {
            "id": "http://example.com/2022/04/13/Algorithm021/",
            "url": "http://example.com/2022/04/13/Algorithm021/",
            "title": "L2-040 哲哲打游戏 (25 分)",
            "date_published": "2022-04-13T11:09:41.000Z",
            "content_html": "<h2 id=\"L2-040-哲哲打游戏-25-分\"><a href=\"#L2-040-哲哲打游戏-25-分\" class=\"headerlink\" title=\"L2-040 哲哲打游戏 (25 分)\"></a><strong>L2-040 哲哲打游戏 (25 分)</strong></h2><p>哲哲是一位硬核游戏玩家。最近一款名叫《达诺达诺》的新游戏刚刚上市，哲哲自然要快速攻略游戏，守护硬核游戏玩家的一切！</p>\n<p>为简化模型，我们不妨假设游戏有 <em>N</em> 个剧情点，通过游戏里不同的操作或选择可以从某个剧情点去往另外一个剧情点。此外，游戏还设置了一些<strong>存档</strong>，在某个剧情点可以将玩家的游戏进度保存在一个档位上，读取存档后可以回到剧情点，重新进行操作或者选择，到达不同的剧情点。</p>\n<p>为了追踪硬核游戏玩家哲哲的攻略进度，你打算写一个程序来完成这个工作。假设你已经知道了游戏的全部剧情点和流程，以及哲哲的游戏操作，请你输出哲哲的游戏进度。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入第一行是两个正整数 <em>N</em> 和 <em>M</em> (1≤<em>N</em>,<em>M</em>≤105)，表示总共有 <em>N</em> 个剧情点，哲哲有 <em>M</em> 个游戏操作。</p>\n<p>接下来的 <em>N</em> 行，每行对应一个剧情点的发展设定。第 <em>i</em> 行的第一个数字是 <em>K**i</em>，表示剧情点 <em>i</em> 通过一些操作或选择能去往下面 <em>K**i</em> 个剧情点；接下来有 <em>K**i</em> 个数字，第 <em>k</em> 个数字表示做第 <em>k</em> 个操作或选择可以去往的剧情点编号。</p>\n<p>最后有 <em>M</em> 行，每行第一个数字是 0、1 或 2，分别表示：</p>\n<ul>\n<li>0 表示哲哲做出了某个操作或选择，后面紧接着一个数字 <em>j</em>，表示哲哲在当前剧情点做出了第 <em>j</em> 个选择。我们保证哲哲的选择永远是合法的。</li>\n<li>1 表示哲哲进行了一次存档，后面紧接着是一个数字 <em>j</em>，表示存档放在了第 <em>j</em> 个档位上。</li>\n<li>2 表示哲哲进行了一次读取存档的操作，后面紧接着是一个数字 <em>j</em>，表示读取了放在第 <em>j</em> 个位置的存档。</li>\n</ul>\n<p>约定：所有操作或选择以及剧情点编号都从 1 号开始。存档的档位不超过 100 个，编号也从 1 开始。游戏默认从 1 号剧情点开始。总的选项数（即 ∑<em>K**i</em>）不超过 106。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对于每个 1（即存档）操作，在一行中输出存档的剧情点编号。</p>\n<p>最后一行输出哲哲最后到达的剧情点编号。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">10 11\n3 2 3 4\n1 6\n3 4 7 5\n1 3\n1 9\n2 3 5\n3 1 8 5\n1 9\n2 8 10\n0\n1 1\n0 3\n0 1\n1 2\n0 2\n0 2\n2 2\n0 3\n0 1\n1 1\n0 2\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">1\n3\n9\n10\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"样例解释：\"><a href=\"#样例解释：\" class=\"headerlink\" title=\"样例解释：\"></a>样例解释：</h3><p>简单给出样例中经过的剧情点顺序：</p>\n<p>1 -&gt; 4 -&gt; 3 -&gt; 7 -&gt; 8 -&gt; 3 -&gt; 5 -&gt; 9 -&gt; 10。</p>\n<p>档位 1 开始存的是 1 号剧情点；档位 2 存的是 3 号剧情点；档位 1 后来又存了 9 号剧情点。</p>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接表 + 模拟，主要是理解题意</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nint main()\n&#123;\n    int n,k;\n    cin>>n>>k;\n    vector<int> v[n+1];\n    int save[105];\t\t\t\t\t\t\t//存档点\n    int now=1;\t\t\t\t\t\t\t\t//当前剧情点\n    for (int i = 1; i <=n ; ++i) &#123;\n        int num;\n        cin>>num;\n        for (int j = 0; j <num ; ++j) &#123;\n            int x;\n            cin>>x;\n            v[i].push_back(x);\t\t\t\t//邻接表存操作数\n        &#125;\n    &#125;\n    for (int l = 0; l <k ; ++l) &#123;\t\t\t//模拟过程\n        int a,b;\n        cin>>a>>b;\n        if(a==1)&#123;\n            save[b]=now;\n            cout<<now<<endl;\n        &#125;\n        if(a==0)&#123;\n            now=v[now][b-1];\n        &#125;\n        if(a==2)&#123;\n            now=save[b];\n        &#125;\n    &#125;\n    cout<<now<<endl;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/1386335159927652363\">题目详情 - L2-040 哲哲打游戏 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "邻接表",
                "Vector",
                "模拟"
            ]
        },
        {
            "id": "http://example.com/2022/04/13/Algorithm020/",
            "url": "http://example.com/2022/04/13/Algorithm020/",
            "title": "L2-027 名人堂与代金券 (25 分)",
            "date_published": "2022-04-13T01:45:55.000Z",
            "content_html": "<h2 id=\"L2-027-名人堂与代金券-25-分\"><a href=\"#L2-027-名人堂与代金券-25-分\" class=\"headerlink\" title=\"L2-027 名人堂与代金券 (25 分)\"></a>L2-027 名人堂与代金券 (25 分)</h2><p>对于在中国大学MOOC（<a href=\"http://www.icourse163.org/\">http://www.icourse163.org/</a> ）学习“数据结构”课程的学生，想要获得一张合格证书，总评成绩必须达到 60 分及以上，并且有另加福利：总评分在 [G, 100] 区间内者，可以得到 50 元 PAT 代金券；在 [60, G) 区间内者，可以得到 20 元PAT代金券。全国考点通用，一年有效。同时任课老师还会把总评成绩前 K 名的学生列入课程“名人堂”。本题就请你编写程序，帮助老师列出名人堂的学生，并统计一共发出了面值多少元的 PAT 代金券。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出 3 个整数，分别是 N（不超过 10 000 的正整数，为学生总数）、G（在 (60,100) 区间内的整数，为题面中描述的代金券等级分界线）、K（不超过 100 且不超过 N 的正整数，为进入名人堂的最低名次）。接下来 N 行，每行给出一位学生的账号（长度不超过15位、不带空格的字符串）和总评成绩（区间 [0, 100] 内的整数），其间以空格分隔。题目保证没有重复的账号。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>首先在一行中输出发出的 PAT 代金券的总面值。然后按总评成绩非升序输出进入名人堂的学生的名次、账号和成绩，其间以 1 个空格分隔。需要注意的是：成绩相同的学生享有并列的排名，排名并列时，按账号的字母序升序输出。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">10 80 5\ncy@zju.edu.cn 78\ncy@pat-edu.com 87\n1001@qq.com 65\nuh-oh@163.com 96\ntest@126.com 39\nanyone@qq.com 87\nzoe@mit.edu 80\njack@ucla.edu 88\nbob@cmu.edu 80\nken@163.com 70\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">360\n1 uh-oh@163.com 96\n2 jack@ucla.edu 88\n3 anyone@qq.com 87\n3 cy@pat-edu.com 87\n5 bob@cmu.edu 80\n5 zoe@mit.edu 80\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>结构体数组+sort排序，需要注意输出格式控制</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nstruct student&#123;\n    int score=0;\n    string email;\n&#125;;\nbool cmp(student a,student b)&#123;\n    if(a.score==b.score) return a.email<b.email;\t\t//如果分数相同返回字典序小的\n    return a.score>b.score;\t\t\t\t//返回分数最大的\n&#125;\nint main()\n&#123;\n    int n,g,k;\n    cin>>n>>g>>k;\n    student st[n];\n    int money=0;\n    for (int i = 0; i <n ; ++i) &#123;\t\t\t\t\t//输入加存钱\n        cin>>st[i].email>>st[i].score;\n        if(g<=st[i].score&&st[i].score<=100)&#123;\n            money+=50;\n        &#125;\n        if(60<=st[i].score&&st[i].score<g)&#123;\n            money+=20;\n        &#125;\n    &#125;\n    sort(st,st+n,cmp);\t\t\t\t\t\t\t\t//排序\n    cout<<money<<endl;\n    int cnt =1;\t\t\t\t\t\t\t\t\t\t//用来判断用否超过名人堂个数\n    int i=0;\t\t\t\t\t\t\t\t\t\t//遍历st结构体数组\n    int same=1;\t\t\t\t\t\t\t\t\t\t//分数相同的个数\n    int fscore=st[0].score;\t\t\t\t\t\t\t//用来判断分数是否相同\n    //这道题就格式输出需要注意下！\n    while(true) &#123;\n\n        if(fscore==st[i].score)&#123;\n            cout<<cnt<<\" \"<<st[i].email<<\" \"<<st[i].score<<endl;\t//相同即输出\n            if(i!=0) same++;\t\t//不为0号，则same++。\n        &#125;\n        if(fscore>st[i].score)&#123;\n            cnt=cnt+same;\t\t\t//不等，更新cnt值\n            same=1;\t\t\t\t\t//更新same值\n            if(cnt>k)&#123; break;&#125;\t\t//大于名人堂个数结束\n            cout<<cnt<<\" \"<<st[i].email<<\" \"<<st[i].score<<endl;\n            fscore=st[i].score;\t\t//更新用来判断分数是否相同的fscore\n\n        &#125;\n        i++;\n\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805055176163328\">题目详情 - L2-027 名人堂与代金券 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "Sort"
            ]
        },
        {
            "id": "http://example.com/2022/04/13/Algorithm019/",
            "url": "http://example.com/2022/04/13/Algorithm019/",
            "title": "L2-026 小字辈 (25 分)",
            "date_published": "2022-04-13T01:45:49.000Z",
            "content_html": "<h2 id=\"L2-026-小字辈-25-分\"><a href=\"#L2-026-小字辈-25-分\" class=\"headerlink\" title=\"L2-026 小字辈 (25 分)\"></a><strong>L2-026 小字辈 (25 分)</strong></h2><p>本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父&#x2F;母。家谱中辈分最高的老祖宗对应的父&#x2F;母编号为 -1。一行中的数字间以空格分隔。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><pre class=\"line-numbers language-in\"><code class=\"language-in\">9\n2 6 5 5 -1 5 6 4 7\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">4\n1 9\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"程序源代码：\"><a href=\"#程序源代码：\" class=\"headerlink\" title=\"程序源代码：\"></a>程序源代码：</h3><p><strong>邻接表建树+BFS</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nvector<int> tree[100005];\t\t\t\t//邻接表建树\nint deeptree[100005];\t\t\t\t\t//记录树的深度\nint n;\nint root;\t\t\t\t\t\t\t\t//根节点\nint bfs()&#123;\t\t\t\t\t\t\t\t//bfs\n    queue<int> q;\n    q.push(root);\t\t\t\t\t\t//根节点入队\n    int x;\t\t\t\t\t\t\t\t\n    while(!q.empty())&#123;\n        x=q.front();\n        q.pop();\n        for (int i = 0; i <tree[x].size() ; ++i) &#123;\n            deeptree[tree[x][i]]=deeptree[x]+1;\t\t\t\t\t\t//每一层的深度为上一层加1\n            q.push(tree[x][i]);\n\n        &#125;\n    &#125;\n    return deeptree[x];\t\t\t\t//返回最后一个结点的深度，即深度的最大值\n&#125;\nint main()\n&#123;\n    n;\n    cin>>n;\n    int a[n];\n    for (int i = 1; i <=n ; ++i) &#123;\n        cin>>a[i];\n        if(a[i]==-1)&#123;\n            root=i;\t\t\t\t//找根节点\n        &#125;\n    &#125;\n    for (int j = 1; j <=n ; ++j) &#123;\t\t\t\t\t//建树\n        tree[a[j]].push_back(j);\t\t\t\t\t//j是a[j]的孩子节点\n        if(a[j]==-1) deeptree[j]=1;\t\t\t\t\t//初始化根节点深度为1\n    &#125;\n    int ans=bfs();\n    cout<<ans<<endl;\n    int maxdeepcnt=0;\t\t\t\t\t\t\t\t//记录最大深度的个数\n    int tmp[n];\t\t\t\t\t\t\t\t\t\t//找最大深度的id\n    for (int k = 1; k <=n ; ++k) &#123;\t\t\t\t\t\n        if(ans==deeptree[k])&#123;\n            maxdeepcnt++;\n            tmp[maxdeepcnt]=k;\n        &#125;\n    &#125;\n    //输出格式控制\n    for (int l = 1; l <=maxdeepcnt ; ++l) &#123;\n        if(l!=maxdeepcnt) cout<<tmp[l]<<\" \";\n        else cout<<tmp[l]<<endl;\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805055679479808\">题目详情 - L2-026 小字辈 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "团体程序设计天梯赛",
                "邻接表",
                "Vector",
                "Binary tree",
                "BFS"
            ]
        },
        {
            "id": "http://example.com/2022/04/12/Algorithm018/",
            "url": "http://example.com/2022/04/12/Algorithm018/",
            "title": "L2-023 图着色问题 (25 分)",
            "date_published": "2022-04-12T10:59:52.000Z",
            "content_html": "<h2 id=\"L2-023-图着色问题-25-分\"><a href=\"#L2-023-图着色问题-25-分\" class=\"headerlink\" title=\"L2-023 图着色问题 (25 分)\"></a>L2-023 图着色问题 (25 分)</h2><p>图着色问题是一个著名的NP完全问题。给定无向图<em>G</em>&#x3D;(<em>V</em>,<em>E</em>)，问可否用<em>K</em>种颜色为<em>V</em>中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？</p>\n<p>但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。</p>\n<h3 id=\"输入格式：\"><a href=\"#输入格式：\" class=\"headerlink\" title=\"输入格式：\"></a>输入格式：</h3><p>输入在第一行给出3个整数<em>V</em>（0&lt;<em>V</em>≤500）、<em>E</em>（≥0）和<em>K</em>（0&lt;<em>K</em>≤<em>V</em>），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到<em>V</em>编号。随后<em>E</em>行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数<em>N</em>（≤20），是待检查的颜色分配方案的个数。随后<em>N</em>行，每行顺次给出<em>V</em>个顶点的颜色（第<em>i</em>个数字表示第<em>i</em>个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。</p>\n<h3 id=\"输出格式：\"><a href=\"#输出格式：\" class=\"headerlink\" title=\"输出格式：\"></a>输出格式：</h3><p>对每种颜色分配方案，如果是图着色问题的一个解则输出<code>Yes</code>，否则输出<code>No</code>，每句占一行。</p>\n<h3 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h3><img src=\"/2022/04/12/Algorithm018/graph.png\" alt=\"graph\" style=\"zoom: 67%;\">\n\n<pre class=\"line-numbers language-in\"><code class=\"language-in\">6 8 3\n2 1\n1 3\n4 6\n2 5\n2 4\n5 4\n5 6\n3 6\n4\n1 2 3 3 1 2\n4 5 6 6 4 5\n1 2 3 4 5 6\n2 3 4 2 3 4\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h3><pre class=\"line-numbers language-out\"><code class=\"language-out\">Yes\nYes\nNo\nNo\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><p><strong>Set + 邻接表</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\nint main()\n&#123;\n    int v,e,k;\n    cin>>v>>e>>k;\n    vector<int> g[505];\t\t\t//邻接表\n    int color[505];\t\t\t\t//记录颜色\n    for (int i = 0; i <e ; ++i) &#123;       //建立邻接表\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    &#125;\n    int time;\n    cin>>time;\n    for (int j = 0; j <time ; ++j) &#123;\n        int flag=1;\n        set<int> s;\t\t\t\t\t//用来统计颜色总数\n        s.clear();\n        for (int i = 1; i <=v; ++i) &#123;\n            int num;\n            cin>>num;\n            color[i]=num;\n            s.insert(num);\n        &#125;\n        if(s.size()!=k)&#123;\t\t\t//如果颜色数不等于k即非法\n            cout<<\"No\"<<endl;\n            continue;\n        &#125;\n        for (int l = 1; l <=v ; ++l) &#123;\t\t\t\t\t\t//遍历邻接表\n            for (int i = 0; i <g[l].size(); ++i) &#123;\n                if(color[l]==color[g[l][i]])&#123;\t\t\t\t//如果相邻结点颜色一样则为假\n                    flag=0;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        if(flag==1)&#123;\n            cout<<\"Yes\"<<endl;\n        &#125;else&#123;\n            cout<<\"No\"<<endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://pintia.cn/problem-sets/994805046380707840/problems/994805057298481152\">题目详情 - L2-023 图着色问题 (25 分) (pintia.cn)</a></p>\n",
            "tags": [
                "Data Structure",
                "C++",
                "Set",
                "团体程序设计天梯赛",
                "Graph",
                "邻接表",
                "Vector"
            ]
        },
        {
            "id": "http://example.com/2022/04/07/Algorithm014/",
            "url": "http://example.com/2022/04/07/Algorithm014/",
            "title": "由遍历顺序构建二叉树(前序+中序;后序+中序)",
            "date_published": "2022-04-07T12:55:58.000Z",
            "content_html": "<h1 id=\"由遍历顺序构建二叉树-前序-中序-后序-中序\"><a href=\"#由遍历顺序构建二叉树-前序-中序-后序-中序\" class=\"headerlink\" title=\"由遍历顺序构建二叉树(前序+中序;后序+中序)\"></a>由遍历顺序构建二叉树(前序+中序;后序+中序)</h1><h2 id=\"前序-中序\"><a href=\"#前序-中序\" class=\"headerlink\" title=\"前序+中序\"></a>前序+中序</h2><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">BiTree PreAndInCreateTree(int prel,int prer, int inl,int inr)&#123;\n    if(prel>prer)&#123;\n        return NULL;\n    &#125;\n    BiTNode *root;\n    int index=0;\n    root=(BiTNode*)malloc(sizeof(BiTNode));\t\t\t\t//记住分配空间\n    root->data=preF[prel];\t\t\t//前序遍历的第一个结点是根结点\n    int i;\n    for(i=inl;i<=inr;i++)\n    &#123;\n        if(preF[prel]==inF[i])&#123;\n            index=i;\n            break;\n            //找到了根结点，目的是在中序遍历中划分左右子树\n        &#125;\n    &#125;\n    //则其左子树节点个数为index-inl\n    //前序遍历的第一个结点是根结点,所以新的递归区间是prel+1,到prel+index-inl,\n    //中序遍历是左根右，所以新的递归区间是inl,index-1\n    root->lchild=PreAndInCreateTree(prel+1,prel+index-inl,inl,index-1);\n    //前序遍历是根左右，所以新的递归区间是prel+index-inl+1,prep\n    //中序遍历是左根右，所以新的递归区间是index+1,inr\n    root->rchild=PreAndInCreateTree(prel+index-inl+1,prer,index+1,inr);\n    return root;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"后序-中序\"><a href=\"#后序-中序\" class=\"headerlink\" title=\"后序+中序\"></a>后序+中序</h2><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">BiTree PostAndInCreateTree(int postl,int postr, int inl,int inr)&#123;\n    if(postl>postr)&#123;\n        return NULL;\n    &#125;\n    BiTNode *root;\n    int index=0;\n    root=(BiTNode*)malloc(sizeof(BiTNode));\n    root->data=posts[postr];\t//后序遍历的最后一个结点是根结点\n    for (int i = inl; i <=inr ; ++i) &#123;\n        if(posts[postr]==ins[i])\n        &#123;\n            index =i;\n            break;\n            //找到了根结点，目的是在中序遍历中划分左右子树\n        &#125;\n    &#125;//则其左子树节点个数为index-inl\n    //后续遍历的最后一个结点是根节点，所以新的递归区间是，postl,postl+index-inl-1\n    //中序遍历是左根右，所以新的递归区间是inl,index-1\n    root->lchild=PostAndInCreateTree(postl,postl+index-inl-1,inl,index-1);\n    //后序遍历是左右根，所以新的递归区间是postl+index-inl,postr-1\n    //中序遍历是左根右，所以新的递归区间是index+1,inr\n    root->rchild=PostAndInCreateTree(postl+index-inl,postr-1,index+1,inr);\n    return root;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"完整代码示例\"><a href=\"#完整代码示例\" class=\"headerlink\" title=\"完整代码示例\"></a>完整代码示例</h2><p><strong>前序+中序；后序+中序。递归调用可视化查看：(有助于理解递归调用过程)</strong></p>\n<p><a href=\"https://pythontutor.com/\">Python Tutor - Visualize Python, Java, C, C++, JavaScript, TypeScript, and Ruby code execution</a></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct BiTNode&#123;\n    int data;\t\t\t\t\t\t\t//数据域\n    struct BiTNode *lchild,*rchild;\t\t\t//左右孩子指针\n&#125;BiTNode,*BiTree;\n//tree\nint preF[6]=&#123;4,2,1,3,5,6&#125;;\t\t//前序遍历\nint inF[6]=&#123;1,2,3,4,6,5&#125;;\t\t//中序遍历\n//trees\nint posts[7]=&#123;2,3,1,5,7,6,4&#125;;\t//后序遍历\nint ins[7]=&#123;1,2,3,4,5,6,7&#125;;\t\t//中序遍历\nBiTree PreAndInCreateTree(int prel,int prer, int inl,int inr)&#123;\n    if(prel>prer)&#123;\n        return NULL;\n    &#125;\n    BiTNode *root;\n    int index=0;\n    root=(BiTNode*)malloc(sizeof(BiTNode));\t\t\t\t//记住分配空间\n    root->data=preF[prel];\t\t\t//前序遍历的第一个结点是根结点\n    int i;\n    for(i=inl;i<=inr;i++)\n    &#123;\n        if(preF[prel]==inF[i])&#123;\n            index=i;\n            break;\n            //找到了根结点，目的是在中序遍历中划分左右子树\n        &#125;\n    &#125;\n    //则其左子树节点个数为index-inl\n    //前序遍历的第一个结点是根结点,所以新的递归区间是prel+1,到prel+index-inl,\n    //中序遍历是左根右，所以新的递归区间是inl,index-1\n    root->lchild=PreAndInCreateTree(prel+1,prel+index-inl,inl,index-1);\n    //前序遍历是根左右，所以新的递归区间是prel+index-inl+1,prep\n    //中序遍历是左根右，所以新的递归区间是index+1,inr\n    root->rchild=PreAndInCreateTree(prel+index-inl+1,prer,index+1,inr);\n    return root;\n&#125;\nBiTree PostAndInCreateTree(int postl,int postr, int inl,int inr)&#123;\n    if(postl>postr)&#123;\n        return NULL;\n    &#125;\n    BiTNode *root;\n    int index=0;\n    root=(BiTNode*)malloc(sizeof(BiTNode));\n    root->data=posts[postr];\t//后序遍历的最后一个结点是根结点\n    for (int i = inl; i <=inr ; ++i) &#123;\n        if(posts[postr]==ins[i])\n        &#123;\n            index =i;\n            break;\n            //找到了根结点，目的是在中序遍历中划分左右子树\n        &#125;\n    &#125;//则其左子树节点个数为index-inl\n    //后续遍历的最后一个结点是根节点，所以新的递归区间是，postl,postl+index-inl-1\n    //中序遍历是左根右，所以新的递归区间是inl,index-1\n    root->lchild=PostAndInCreateTree(postl,postl+index-inl-1,inl,index-1);\n    //后序遍历是左右根，所以新的递归区间是postl+index-inl,postr-1\n    //中序遍历是左根右，所以新的递归区间是index+1,inr\n    root->rchild=PostAndInCreateTree(postl+index-inl,postr-1,index+1,inr);\n    return root;\n&#125;\nvoid LevelOrder(BiTree T)\n&#123;\n    queue<BiTree> q;\n    q.push(T);\n    while (!q.empty())&#123;\n        BiTNode *tmp =q.front();\n        q.pop();\n        cout<<tmp->data;\n        if(tmp->lchild!=NULL)&#123;\n            q.push(tmp->lchild);\n        &#125;\n        if(tmp->rchild!=NULL)&#123;\n            q.push(tmp->rchild);\n        &#125;\n    &#125;\n&#125;\nint main()\n&#123;\n\n    BiTree tree;\n    tree=NULL;\n    tree=PreAndInCreateTree(0,5,0,5);\n    cout<<\"输入为前序加中序遍历，输出他的层序遍历：\"<<endl;\n    LevelOrder(tree);\n    cout<<endl;\n    BiTree trees;\n    trees=NULL;\n    cout<<\"输入为后序加中序遍历，输出他的层序遍历：\"<<endl;\n    trees=PostAndInCreateTree(0,6,0,6);\n    LevelOrder(trees);\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h2><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">输入为前序加中序遍历，输出他的层序遍历：\n425136\n输入为后序加中序遍历，输出他的层序遍历：\n4163572\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure"
            ]
        },
        {
            "id": "http://example.com/2022/04/07/Algorithm013/",
            "url": "http://example.com/2022/04/07/Algorithm013/",
            "title": "二叉树的前、中、后、层序遍历",
            "date_published": "2022-04-07T10:08:34.000Z",
            "content_html": "<h1 id=\"二叉树的前、中、后、层序遍历\"><a href=\"#二叉树的前、中、后、层序遍历\" class=\"headerlink\" title=\"二叉树的前、中、后、层序遍历\"></a>二叉树的前、中、后、层序遍历</h1><h2 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h2><h3 id=\"前序遍历建树\"><a href=\"#前序遍历建树\" class=\"headerlink\" title=\"前序遍历建树\"></a>前序遍历建树</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">BiTree PreCreateTree(BiTree tree)&#123;\n    char ch;\n    cin>>ch;\n    if(ch=='#') return NULL;\n    else&#123;\n        tree=(BiTree)malloc(sizeof(BiTNode));\n        tree->data=ch;\n        tree->lchild=PreCreateTree(tree->lchild);\n        tree->rchild=PreCreateTree(tree->rchild);\n        return tree;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void PreOrder(BiTree root)//先序遍历\n &#123;\n     if (root != NULL)\n     &#123;\n         printf(\"%c\", root->data);\n         PreOrder(root->lchild);\n         PreOrder(root->rchild);\n     &#125;\n &#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void InOrder(BiTree root)//中序遍历\n&#123;\n    if (root != NULL)\n    &#123;\n        InOrder(root->lchild);\n        printf(\"%c\", root->data);\n        InOrder(root->rchild);\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void PostOrder(BiTree root)//后序遍历\n&#123;\n    if (root != NULL)\n    &#123;\n        PostOrder(root->lchild);\n        PostOrder(root->rchild);\n        printf(\"%c\", root->data);\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"层序遍历-借助STL-queue-实现\"><a href=\"#层序遍历-借助STL-queue-实现\" class=\"headerlink\" title=\"层序遍历(借助STL:queue)实现\"></a>层序遍历(借助STL:queue)实现</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void LevelOrder(BiTree T)\n&#123;\n    queue<BiTree> q;\n    q.push(T);\n    while (!q.empty())&#123;\n        BiTNode *tmp =q.front();\n        q.pop();\n        cout<<tmp->data;\n        if(tmp->lchild!=NULL)&#123;\n            q.push(tmp->lchild);\n        &#125;\n        if(tmp->rchild!=NULL)&#123;\n            q.push(tmp->rchild);\n        &#125;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <bits/stdc++.h>\nusing namespace std;\ntypedef char ElemType;\ntypedef struct BiTNode&#123;\n    ElemType data;\t\t\t\t\t\t\t//数据域\n    struct BiTNode *lchild,*rchild;\t\t\t//左右孩子指针\n&#125;BiTNode,*BiTree;\nBiTree PreCreateTree(BiTree tree)&#123;\n    char ch;\n    cin>>ch;\n    if(ch=='#') return NULL;\n    else&#123;\n        tree=(BiTree)malloc(sizeof(BiTNode));\n        tree->data=ch;\n        tree->lchild=PreCreateTree(tree->lchild);\n        tree->rchild=PreCreateTree(tree->rchild);\n        return tree;\n    &#125;\n&#125;\nvoid PreOrder(BiTree root)//先序遍历\n &#123;\n     if (root != NULL)\n     &#123;\n         printf(\"%c\", root->data);\n         PreOrder(root->lchild);\n         PreOrder(root->rchild);\n     &#125;\n &#125;\nvoid InOrder(BiTree root)//中序遍历\n&#123;\n    if (root != NULL)\n    &#123;\n        InOrder(root->lchild);\n        printf(\"%c\", root->data);\n        InOrder(root->rchild);\n    &#125;\n&#125;\nvoid PostOrder(BiTree root)//后序遍历\n&#123;\n    if (root != NULL)\n    &#123;\n        PostOrder(root->lchild);\n        PostOrder(root->rchild);\n        printf(\"%c\", root->data);\n    &#125;\n&#125;\nvoid LevelOrder(BiTree T)\n&#123;\n    queue<BiTree> q;\n    q.push(T);\n    while (!q.empty())&#123;\n        BiTNode *tmp =q.front();\n        q.pop();\n        cout<<tmp->data;\n        if(tmp->lchild!=NULL)&#123;\n            q.push(tmp->lchild);\n        &#125;\n        if(tmp->rchild!=NULL)&#123;\n            q.push(tmp->rchild);\n        &#125;\n    &#125;\n&#125;\nint main()\n&#123;\n    BiTree tree;\n    tree=NULL;\n    //按先序的方式输入二叉树的结点元素（注：输入#表示节点为空）\n    //例如这棵树为:ABC##DE#G##F###\n    tree=PreCreateTree(tree);\n    cout<<\"前序遍历\"<<endl;\n    PreOrder(tree);\n    cout<<endl;\n    cout<<\"中序遍历\"<<endl;\n    InOrder(tree);\n    cout<<endl;\n    cout<<\"后序遍历\"<<endl;\n    PostOrder(tree);\n    cout<<endl;\n    cout<<\"层序遍历\"<<endl;\n    LevelOrder(tree);\n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h2><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">前序遍历\nABCDEGF\n中序遍历\nCBEGDFA\n后序遍历\nCGEFDBA\n层序遍历\nABCDEFG\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure"
            ]
        },
        {
            "id": "http://example.com/2022/04/06/Algorithm012/",
            "url": "http://example.com/2022/04/06/Algorithm012/",
            "title": "二叉树的存储结构",
            "date_published": "2022-04-06T11:41:45.000Z",
            "content_html": "<h1 id=\"二叉树的存储结构\"><a href=\"#二叉树的存储结构\" class=\"headerlink\" title=\"二叉树的存储结构\"></a>二叉树的存储结构</h1><h2 id=\"1-顺序存储方式\"><a href=\"#1-顺序存储方式\" class=\"headerlink\" title=\"1.顺序存储方式\"></a>1.顺序存储方式</h2><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#define MaxSize 100\nstruct TreeNode&#123;\n    ElemType value;\t\t\t//结点中的数据元素\n    bool isEmpty;\t\t\t//结点是否为空\n&#125;;\n\nTreeNode t[MaxSize];\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"2-链式存储结构\"><a href=\"#2-链式存储结构\" class=\"headerlink\" title=\"2.链式存储结构\"></a>2.链式存储结构</h2><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">typedef struct BiTNode&#123;\n    ElemType data;\t\t\t\t\t\t\t//数据域\n    struct BiTNode *lchild,*rchild;\t\t\t//左右孩子指针\n&#125;BiTNode,*BiTree;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"3-三叉链表\"><a href=\"#3-三叉链表\" class=\"headerlink\" title=\"3.三叉链表\"></a>3.三叉链表</h2><p>三叉链表—方便找父节点</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">typedef struct BiTNode&#123;\n    ElemType data;\t\t\t\t\t\t\t//数据域\n    struct BiTNode *lchild,*rchild;\t\t\t//左右孩子指针\n    struct BiTNode *parent;\t\t\t\t\t//父结点指针\n&#125;BiTNode,*BiTree;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure"
            ]
        },
        {
            "id": "http://example.com/2022/04/06/Algorithm011/",
            "url": "http://example.com/2022/04/06/Algorithm011/",
            "title": "串的存储结构",
            "date_published": "2022-04-06T11:35:13.000Z",
            "content_html": "<h1 id=\"串的存储结构\"><a href=\"#串的存储结构\" class=\"headerlink\" title=\"串的存储结构\"></a>串的存储结构</h1><h2 id=\"1-定长顺序存储表示\"><a href=\"#1-定长顺序存储表示\" class=\"headerlink\" title=\"1.定长顺序存储表示\"></a>1.定长顺序存储表示</h2><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#define MAXLEN 255\t\t\t\t\t//预定义最大串长\ntypedef struct&#123;\n    char ch[MAXLEN];\t\t\t\t//每个分量存储一个字符\n    int length;\t\t\t\t\t\t//串的实际长度\n&#125;SSting;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"2-堆分配存储表示\"><a href=\"#2-堆分配存储表示\" class=\"headerlink\" title=\"2.堆分配存储表示\"></a>2.堆分配存储表示</h2><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">typedef struct&#123;\n    char *ch;\t\t\t\t\t\t//按串长分配存储区，ch指向串的基地址\n    int length;\t\t\t\t\t\t//串的长度\n&#125;HString;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n",
            "tags": [
                "Data Structure"
            ]
        }
    ]
}