{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"c/c++\" tag",
    "description": "",
    "home_page_url": "https://xingyuanjie.top",
    "items": [
        {
            "id": "https://xingyuanjie.top/2023/04/30/enum/",
            "url": "https://xingyuanjie.top/2023/04/30/enum/",
            "title": "C/C++枚举类型 enum",
            "date_published": "2023-04-30T07:44:23.000Z",
            "content_html": "<h2 id=\"C-x2F-C-枚举类型-enum\"><a href=\"#C-x2F-C-枚举类型-enum\" class=\"headerlink\" title=\"C&#x2F;C++枚举类型 enum\"></a>C&#x2F;C++枚举类型 enum</h2><p><strong>枚举类型的定义：</strong>枚举类型(enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>\n<p>定义格式：枚举类型的定义格式为：</p>\n<figure class=\"highlight bnf\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs bnf\">enum <span class=\"hljs-attribute\">&lt;类型名&gt;</span> &#123;<span class=\"hljs-attribute\">&lt;枚举常量表&gt;</span>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>格式说明：</strong></p>\n<ul>\n<li>关键字enum——指明其后的标识符是一个枚举类型的名字。</li>\n<li>枚举常量表——由枚举常量构成。”枚举常量”或称”枚举成员”，是以标识符形式表示的整型量，表示枚举类型的取值。枚举常量表列出枚举类型的所有取值，各枚举常量之间以”，”间隔，且必须各不相同。取值类型与条件表达式相同。</li>\n</ul>\n<p><strong>应用举例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">color_set1</span> &#123;</span>RED, BLUE, WHITE, BLACK&#125;; <span class=\"hljs-comment\">// 定义枚举类型color_set1</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">week</span> &#123;</span>Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; <span class=\"hljs-comment\">// 定义枚举类型week</span><br></code></pre></div></td></tr></table></figure>\n\n<p><strong>重要提示：</strong></p>\n<p>枚举常量代表该枚举类型的变量可能取的值，编译系统为每个枚举常量指定一个整数值，默认状态下，这个整数就是所列举元素的序号，序号从0开始。 可以在定义枚举类型时为部分或全部枚举常量指定整数值，在指定值之前的枚举常量仍按默认方式取值，而指定值之后的枚举常量按依次加1的原则取值。 各枚举常量的值可以重复。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">fruit_set</span> &#123;</span>apple, orange, banana=<span class=\"hljs-number\">1</span>, peach, grape&#125;<br><span class=\"hljs-comment\">//枚举常量apple=0,orange=1, banana=1,peach=2,grape=3。</span><br><span class=\"hljs-keyword\">enum</span> week &#123;Sun=<span class=\"hljs-number\">7</span>, Mon=<span class=\"hljs-number\">1</span>, Tue, Wed, Thu, Fri, Sat&#125;;<br><span class=\"hljs-comment\">//枚举常量Sun,Mon,Tue,Wed,Thu,Fri,Sat的值分别为7、1、2、3、4、5、6。</span><br></code></pre></div></td></tr></table></figure>\n\n<p>枚举常量只能以标识符形式表示，而不能是整型、字符型等文字常量。例如，以下定义非法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">letter_set</span> &#123;</span><span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;d&#x27;</span>,<span class=\"hljs-string\">&#x27;F&#x27;</span>,<span class=\"hljs-string\">&#x27;s&#x27;</span>,<span class=\"hljs-string\">&#x27;T&#x27;</span>&#125;; <span class=\"hljs-comment\">//枚举常量不能是字符常量</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">year_set</span>&#123;</span><span class=\"hljs-number\">2000</span>,<span class=\"hljs-number\">2001</span>,<span class=\"hljs-number\">2002</span>,<span class=\"hljs-number\">2003</span>,<span class=\"hljs-number\">2004</span>,<span class=\"hljs-number\">2005</span>&#125;; <span class=\"hljs-comment\">//枚举常量不能是整型常量</span><br></code></pre></div></td></tr></table></figure>\n\n<p>可改为以下形式则定义合法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">letter_set</span> &#123;</span>a, d, F, s, T&#125;;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">year_set</span>&#123;</span>y2000, y2001, y2002, y2003, y2004, y2005&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<hr>\n<h2 id=\"枚举变量的使用\"><a href=\"#枚举变量的使用\" class=\"headerlink\" title=\"枚举变量的使用\"></a>枚举变量的使用</h2><p>定义枚举类型的主要目的是：增加程序的可读性。枚举类型最常见也最有意义的用处之一就是用来描述状态量，这点将在第9章 输入输出流类看到。</p>\n<p>定义格式：定义枚举类型之后，就可以定义该枚举类型的变量，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">color_set1 color1, color2;<br></code></pre></div></td></tr></table></figure>\n\n<p>亦可类型与变量同时定义（甚至类型名可省），格式如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> &#123;</span>Sun,Mon,Tue,Wed,Thu,Fri,Sat&#125; weekday1, weekday2;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"相关操作\"><a href=\"#相关操作\" class=\"headerlink\" title=\"相关操作\"></a>相关操作</h3><p>枚举变量的值只能取枚举常量表中所列的值，就是整型数的一个子集。</p>\n<p>枚举变量占用内存的大小与整型数相同。</p>\n<p>枚举变量只能参与赋值和关系运算以及输出操作，参与运算时用其本身的整数值。例如，设有定义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">color_set1</span> &#123;</span>RED, BLUE, WHITE, BLACK&#125; color1, color2;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">color_set2</span> &#123;</span> GREEN, RED, YELLOW, WHITE&#125; color3, color4;<br></code></pre></div></td></tr></table></figure>\n\n<p>则允许的赋值操作如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">color3=RED;           <span class=\"hljs-comment\">//将枚举常量值赋给枚举变量</span><br>color4=color3;        <span class=\"hljs-comment\">//相同类型的枚举变量赋值，color4的值为RED</span><br><span class=\"hljs-keyword\">int</span>  i=color3;        <span class=\"hljs-comment\">//将枚举变量赋给整型变量，i的值为1</span><br><span class=\"hljs-keyword\">int</span>  j=GREEN;         <span class=\"hljs-comment\">//将枚举常量赋给整型变量，j的值为0</span><br></code></pre></div></td></tr></table></figure>\n\n<p>允许的关系运算有：&#x3D;&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;等，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//比较同类型枚举变量color3，color4是否相等</span><br><span class=\"hljs-keyword\">if</span> (color3==color4) cout&lt;&lt;<span class=\"hljs-string\">&quot;相等&quot;</span>；<br><span class=\"hljs-comment\">//输出的是变量color3与WHITE的比较结果，结果为1</span><br>cout&lt;&lt; color3&lt;WHITE;<br></code></pre></div></td></tr></table></figure>\n\n<p>枚举变量可以直接输出，输出的是变量的整数值。例如：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">cout</span>&lt;&lt; color<span class=\"hljs-number\">3</span>;         //输出的是color<span class=\"hljs-number\">3</span>的整数值，即RED的整数值<span class=\"hljs-number\">1</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"重要提示\"><a href=\"#重要提示\" class=\"headerlink\" title=\"重要提示\"></a>重要提示</h3><ul>\n<li>枚举变量可以直接输出，但不能直接输入。如：cout &gt;&gt; color3;  &#x2F;&#x2F;非法</li>\n<li>不能直接将常量赋给枚举变量。如： color1&#x3D;1; &#x2F;&#x2F;非法</li>\n<li>不同类型的枚举变量之间不能相互赋值。如： color1&#x3D;color3; &#x2F;&#x2F;非法</li>\n<li>枚举变量的输入输出一般都采用switch语句将其转换为字符或字符串；枚举类型数据的其他处理也往往应用switch语句，以保证程序的合法性和可读性。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.runoob.com/w3cnote/cpp-enum-intro.html\">C++ 枚举类型详解 | 菜鸟教程 (runoob.com)</a></p>\n",
            "tags": [
                "C/C++"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/04/30/violate/",
            "url": "https://xingyuanjie.top/2023/04/30/violate/",
            "title": "C/C++ volatile关键字",
            "date_published": "2023-04-30T07:30:24.000Z",
            "content_html": "<h2 id=\"C-x2F-C-volatile关键字\"><a href=\"#C-x2F-C-volatile关键字\" class=\"headerlink\" title=\"C&#x2F;C++ volatile关键字\"></a>C&#x2F;C++ volatile关键字</h2><p><strong>volatile后面的变量，是常变量，会直接访问地址，如果没有这个关键字，就可能会暂时使用寄存器的值，而不是读取地址。</strong></p>\n<p>C&#x2F;C++ 中的 volatile 关键字和 const 对应，用来修饰变量。volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">10</span>;<br></code></pre></div></td></tr></table></figure>\n\n<p>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p>\n<p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。</p>\n<p><strong>volatile关键字的实现：如在并行环境下，进行同步操作，用volatile修饰回答字地址，即可实现并行环境下的同步。这种方法一般使用在非阻塞通信中。</strong></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/ijn842/article/details/81273232\">浅谈C语言的volatile关键字_琼琼的博客的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/GreatTang/article/details/90454011\">C++ volatile_c++ violate_来日梦多长的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/jerry_wuhao/article/details/113247800\">C&#x2F;C++ 中 volatile 关键字_c++ violate关键字_王俊洁、�的博客-CSDN博客</a></p>\n",
            "tags": [
                "C/C++"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/28/vectorbool/",
            "url": "https://xingyuanjie.top/2023/02/28/vectorbool/",
            "title": "vector<bool>与vector<T>",
            "date_published": "2023-02-28T12:59:01.000Z",
            "content_html": "<h1 id=\"vector-lt-bool-gt-与vector-lt-T-gt\"><a href=\"#vector-lt-bool-gt-与vector-lt-T-gt\" class=\"headerlink\" title=\"vector&lt;bool&gt;与vector&lt;T&gt;\"></a>vector&lt;bool&gt;与vector&lt;T&gt;</h1><p>vector&lt;bool&gt; 不像其他容器一样按Byte存储的，它是按bit存储的，也就是说一个正常的bool类型的空间可以存放vector&lt;bool&gt;中的8个，空间上确实优化了很多，然而，c++是不能直接取对bit操作的（因为C++的最小可寻址值通常以byte为单位），对其使用operator[]其实返回的不是bool的引用而是一个”proxy reference”是”std::vector&lt; bool&gt;:reference”类型的对象。</p>\n<p>正因为如此，vector&lt;bool&gt;通过代理对象进行存取访问时需要执行逐位处理，访问通常比int之类的普通类型操作要慢很多。</p>\n<p>因此，对vecotr&lt;bool&gt;的使用需慎重考虑以下几点：<br>(1)是否需要牺牲速度来获取空间上的优化<br>(2)算法中会否有对vecotr地址进行解引用操作的可能。</p>\n<p>如果不满足以上条件，建议使用deque&lt;bool&gt;来取代vector&lt;bool&gt;，功能基本相同，但deque&lt;bool&gt;未对其进行特殊处理。</p>\n<p>下面是vector&lt;bool&gt;与vector&lt;T&gt;简单的对比例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\tvector&lt;<span class=\"hljs-keyword\">char</span>&gt; ch;<br>\tvector&lt;<span class=\"hljs-keyword\">int</span>&gt; in;<br>\tvector&lt;<span class=\"hljs-keyword\">bool</span>&gt; bo;<br> <br>\t<span class=\"hljs-keyword\">int</span> m = <span class=\"hljs-number\">1e6</span>;<br>\t<span class=\"hljs-keyword\">clock_t</span> t1, t2, t3;<br> <br>\tt1 = <span class=\"hljs-built_in\">clock</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>\t\tch.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>\t&#125;<br>\tt1 = <span class=\"hljs-built_in\">clock</span>() - t1;<br> <br>\tt2 = <span class=\"hljs-built_in\">clock</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>\t\tin.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">0</span>);<br>\t&#125;<br>\tt2 = <span class=\"hljs-built_in\">clock</span>() - t2;<br> <br>\tt3 = <span class=\"hljs-built_in\">clock</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; i++)&#123;<br>\t\tbo.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br>\tt3 = <span class=\"hljs-built_in\">clock</span>() - t3;<br> <br>\tcout &lt;&lt;<span class=\"hljs-string\">&quot;vector&lt;char&gt; &quot;</span>&lt;&lt; t1 &lt;&lt; <span class=\"hljs-string\">&quot;\\n vector&lt;int&gt; &quot;</span> &lt;&lt; t2 &lt;&lt; <span class=\"hljs-string\">&quot;\\nvector&lt;bool&gt; &quot;</span> &lt;&lt; t3 &lt;&lt; endl;<br>\tcout &lt;&lt; endl;<br> <br>\t<span class=\"hljs-built_in\">system</span>(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs cpp\">vector&lt;<span class=\"hljs-keyword\">char</span>&gt; <span class=\"hljs-number\">216</span><br>vextor&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-number\">229</span><br>vector&lt;<span class=\"hljs-keyword\">bool</span>&gt; <span class=\"hljs-number\">16535</span><br></code></pre></div></td></tr></table></figure>\n\n<p>这里发现vector&lt;bool&gt;相较于其他vector&lt;T&gt;速度要慢的多！</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/qq_52134928/article/details/121066304?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121066304-blog-86603050.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121066304-blog-86603050.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1\">(65条消息) 【C++】vector＜bool＞的特别之处_小陶同学_的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/u013249689/article/details/25297657\">(65条消息) 不使用vector的原因和替代方法_jackycmu的博客-CSDN博客</a></p>\n",
            "tags": [
                "STL",
                "Vector",
                "C/C++",
                "bool"
            ]
        },
        {
            "id": "https://xingyuanjie.top/2023/02/02/register/",
            "url": "https://xingyuanjie.top/2023/02/02/register/",
            "title": "register关键字",
            "date_published": "2023-02-02T11:57:01.000Z",
            "content_html": "<h2 id=\"register关键字\"><a href=\"#register关键字\" class=\"headerlink\" title=\"register关键字\"></a>register关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">register</span> <span class=\"hljs-keyword\">int</span> val = <span class=\"hljs-number\">100</span>;<br>\t<span class=\"hljs-comment\">//寄存器变量没有地址，不能取地址</span><br>\tval = <span class=\"hljs-number\">200</span>; <span class=\"hljs-comment\">//可以被写入</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, val);<br>\t<span class=\"hljs-comment\">// 在gcc编译器下 也不允许取地址</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">//由于使用register关键字，直接将val存在寄存器内，因此val没有内存地址，因此不能进行取地址操作。</span><br></code></pre></div></td></tr></table></figure>\n\n<ol>\n<li>我们通常采用局部变量采用 register 的，全局变量会导致 CPU 当中的寄存器被长时间占用。</li>\n<li>一个变量被存放到寄存器当中，那么这个变量的效率就会大大的提高,因为不用访存读取</li>\n<li>register关键字可以与指针变量一起使用。</li>\n<li>寄存器是一个存储类，并且C不允许变量使用多个存储类说明符。因此，register不能与static一起使用。</li>\n<li>寄存器只能在一个块内使用（局部），而不能在全局范围内（在主外部）使用</li>\n<li>寄存器数量有限</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://xie.infoq.cn/article/f6093f4eebd3664c0a1514e26\">【C语言】register 关键字_11月月更_謓泽_InfoQ写作社区</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/263575137\">一步带您了解C语言中的“register”关键字 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.ab62.cn/article/5406.html\">C语言关键字之auto register详解_C 语言_AB教程网 (ab62.cn)</a></p>\n",
            "tags": [
                "C/C++",
                "register"
            ]
        }
    ]
}