<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/site.jpg"><link rel="icon" href="/img/site.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><meta name="description" content="最短路径-Floyed和DijkstraFloyed样题一：P1364 医院设置题目描述：设有一棵二叉树，如图：  其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 11。如上图中，若医院建在1 处，则距离和 &#x3D;4+12+2\times20+2\times40&#x3D;136&amp;"><meta property="og:type" content="article"><meta property="og:title" content="最短路径-Floyed和Dijkstra"><meta property="og:url" content="http://example.com/2022/01/03/Algorithm003/index.html"><meta property="og:site_name" content="Amicoyuan"><meta property="og:description" content="最短路径-Floyed和DijkstraFloyed样题一：P1364 医院设置题目描述：设有一棵二叉树，如图：  其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 11。如上图中，若医院建在1 处，则距离和 &#x3D;4+12+2\times20+2\times40&#x3D;136&amp;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/2022/01/03/Algorithm003/166.png"><meta property="og:image" content="http://example.com/2022/01/03/Algorithm003/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x5bm5fbWc=,size_16,color_FFFFFF,t_70.png"><meta property="og:image" content="http://example.com/2022/01/03/Algorithm003/134d3eff026ab567e3a337c45dda5d61.png"><meta property="article:published_time" content="2022-01-03T13:42:00.000Z"><meta property="article:modified_time" content="2022-01-04T07:26:10.353Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="Data Structure"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/2022/01/03/Algorithm003/166.png"><title>最短路径-Floyed和Dijkstra - Amicoyuan</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.12",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"g10sppACiB0iwBrOiERhucmg-MdYXbMMI",app_key:"f7eskymhpDIBDrODMFqlWwQU",server_url:null,path:"window.location.pathname"}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Amicoyuan</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/tools/"><i class="iconfont icon-playstation-fill"></i> 工具</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="最短路径-Floyed和Dijkstra"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-01-03 21:42" pubdate>2022年1月3日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 17 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">最短路径-Floyed和Dijkstra</h1><div class="markdown-body"><h1 id="最短路径-Floyed和Dijkstra"><a href="#最短路径-Floyed和Dijkstra" class="headerlink" title="最短路径-Floyed和Dijkstra"></a>最短路径-Floyed和Dijkstra</h1><h2 id="Floyed"><a href="#Floyed" class="headerlink" title="Floyed"></a>Floyed</h2><h3 id="样题一：P1364-医院设置"><a href="#样题一：P1364-医院设置" class="headerlink" title="样题一：P1364 医院设置"></a>样题一：P1364 医院设置</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>设有一棵二叉树，如图：</p><p><img src="/2022/01/03/Algorithm003/166.png" srcset="/img/loading.gif" lazyload></p><p>其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 11。如上图中，若医院建在1 处，则距离和 &#x3D;4+12+2\times20+2\times40&#x3D;136&#x3D;4+12+2×20+2×40&#x3D;136；若医院建在 33 处，则距离和 &#x3D;4\times2+13+20+40&#x3D;81&#x3D;4×2+13+20+40&#x3D;81。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>第一行一个整数 n<em>n</em>，表示树的结点数。</p><p>接下来的 n<em>n</em> 行每行描述了一个结点的状况，包含三个整数 w, u, v<em>w</em>,<em>u</em>,<em>v</em>，其中 w<em>w</em> 为居民人口数，u<em>u</em> 为左链接（为 00 表示无链接），v<em>v</em> 为右链接（为 00 表示无链接）。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>一个整数，表示最小距离和。</p><h4 id="输入输出样例："><a href="#输入输出样例：" class="headerlink" title="输入输出样例："></a>输入输出样例：</h4><pre><code>5						
13 2 3
4 0 0
12 4 5
20 0 0
40 0 0
</code></pre><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><pre><code>81
</code></pre><h4 id="程序源代码："><a href="#程序源代码：" class="headerlink" title="程序源代码："></a>程序源代码：</h4><pre><code class="c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
int tree[1000][1000];   //tree的作用邻接矩阵建树
int w[1000],l,r;  //w每个结点的居民人口数
int mindis;       //最小记录和
int main() &#123;
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    &#123;
        for(int j=1;j&lt;=n;j++)
        &#123;
            tree[i][j]=0X3FFFFFFF;    //初始化邻接矩阵
        &#125;
    &#125;
    for (int i = 1; i &lt;=n ; ++i) &#123;
        tree[i][i]=0;    //初始化
        cin&gt;&gt;w[i]&gt;&gt;l&gt;&gt;r;  //读入数据
        if(l&gt;0) tree[i][l]=tree[l][i]=1;
        if(r&gt;0) tree[i][r]=tree[r][i]=1;
    &#125;
    for (int k = 1; k &lt;=n ; ++k) //用Floyed求任意两结点之间的最短路径
    &#123;
        for (int i = 1; i &lt;=n ; ++i) &#123;
            if(i!=k)
            &#123;
                for (int j = 1; j &lt;=n ; ++j) &#123;
                    if(i!=j&amp;&amp;j!=k&amp;&amp;tree[i][k]+tree[k][j]&lt;tree[i][j])
                    &#123;
                        tree[i][j]=tree[i][k]+tree[k][j];
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    mindis=INT_MAX;
    for(int i=1;i&lt;=n;i++) //穷举医院建在N个结点，找出最短距离
    &#123;
        int sum =0;
        for(int j=1;j&lt;=n;j++)
        &#123;
            sum+=tree[i][j]*w[j];
        &#125;
        if(sum&lt;mindis) mindis=sum;
    &#125;
    cout&lt;&lt;mindis&lt;&lt;endl;
    return 0;
&#125;
</code></pre><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="样题二："><a href="#样题二：" class="headerlink" title="样题二："></a>样题二：</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p><img src="/2022/01/03/Algorithm003/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x5bm5fbWc=,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload></p><p>输入n和m，代表n个节点，m条边，然后是m行输入，每行有x,y,z，代表x到y的路距离为z。<br>问题：从1出发到各点的最短路径</p><h4 id="测试样例："><a href="#测试样例：" class="headerlink" title="测试样例："></a>测试样例：</h4><pre><code class="c++">7 12
1 2 20
1 3 50
1 4 30
2 3 25
2 6 70
3 4 40
3 6 50
3 5 25
4 5 55
5 6 10
5 7 70
6 7 50
5
</code></pre><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><pre><code>1-&gt;2-&gt;3-&gt;5
70
</code></pre><h4 id="程序源代码：-1"><a href="#程序源代码：-1" class="headerlink" title="程序源代码："></a>程序源代码：</h4><pre><code class="c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 100;
int mapdis[maxn][maxn];  //表示x-&gt;y的距离(有向)
int dis[maxn];  //代表最短路径长
int path[maxn];  //记录前驱节点
int vis[maxn]; //用来记录该点是否已经是最短路径的点
int n,m;
void Dijkstra(int s)
&#123;
    //初始化
    memset(dis,0x3f,sizeof(dis));
    memset(path,-1,sizeof(path));
    memset(vis,0,sizeof(vis));
    
    dis[s]=0;   //自身到自身的距离是0
    while(1)
    &#123;
        int k=0; //用来记录当轮的起始点
        for (int i = 1; i &lt;=n; ++i) &#123;
            if(!vis[i]&amp;&amp;dis[i]&lt;dis[k])     //如果这个点还不为最短路径的点，并且这个点的路径是现在所有点中最小的
            &#123;
                k=i;      //那么就记录这个点为当轮的起始点
                          //特殊的这里第一次找到的是起点，及s=1。
            &#125;
        &#125;
        if(!k) return;  //所有点已经为最短路径的点，则返回
        vis[k]=1;       //标记该点为最短路径的点
        //松弛操作
        for (int j = 1; j &lt;=n ; ++j) &#123;   
            //第一次循环只有起点的邻接点的距离被更新
            //每次都更新找到，新找到的点的邻接点(新找到的点也就是当轮的起始点)
            if(dis[j]&gt;dis[k]+mapdis[k][j])  //最短路是由最短路+某一条固定路组成
            &#123;
                dis[j]=dis[k]+mapdis[k][j];//路径被改变
                path[j]=k;//重新记录前驱，最短路是由最短路+某一条固定路组成，所以前驱是有效的
            &#125;
        &#125;

    &#125;

&#125;
void print(int x) //递归打印
&#123;
    if(x == -1) return;
    print(path[x]);
    cout&lt;&lt;x&lt;&lt;&quot;-&gt;&quot;;
&#125;
int main() &#123;
    n,m;
    cin&gt;&gt;n&gt;&gt;m;
    //初始化
    memset(mapdis,0x3f,sizeof(mapdis));
    for (int i = 0; i &lt;m ; ++i) &#123;
        int x,y,z;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
        //记录x-&gt;y的距离
        mapdis[x][y]=z;
    &#125;
    Dijkstra(1);  //求1出发到各点的最短路径
    int order;    //读入终点
    cin&gt;&gt;order;
    print(path[order]);  //打印最短路径
    cout&lt;&lt;order&lt;&lt;endl;
    cout&lt;&lt;dis[order];    //最短路径长
    return 0;
&#125;
</code></pre><h3 id="样题三：L2-001-紧急救援-25-分"><a href="#样题三：L2-001-紧急救援-25-分" class="headerlink" title="样题三：L2-001 紧急救援 (25 分)"></a>样题三：<strong>L2-001 紧急救援 (25 分)</strong></h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h4><p>输入第一行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0 ~ (<em>N</em>−1)；<em>M</em>是快速道路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。</p><p>第二行给出<em>N</em>个正整数，其中第<em>i</em>个数是第<em>i</em>个城市的救援队的数目，数字间以空格分隔。随后的<em>M</em>行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h4><p>第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从<em>S</em>到<em>D</em>的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h4><pre><code class="c++">4 5 0 3
20 30 40 10
0 1 1
1 3 2
0 3 3
0 2 2
2 3 2结尾无空行
</code></pre><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h4><pre><code class="c++">2 60
0 1 3结尾无空行
</code></pre><h4 id="最短路径条数："><a href="#最短路径条数：" class="headerlink" title="最短路径条数："></a>最短路径条数：</h4><p>如果通过 <strong>index</strong> 点能把最短路径更新，那么最短路径条数就是从起点到<strong>index</strong>的最短路径条数。</p><p><img src="/2022/01/03/Algorithm003/134d3eff026ab567e3a337c45dda5d61.png" srcset="/img/loading.gif" lazyload></p><p>例如这张图，如果<strong>index</strong>可以更新当前的最短路径，并且s通过1和2到达index点的距离都相等，那么从s到d的最短路径条数其实就是从s到index的最短路径条数，由此可以得到第一个式子</p><pre><code class="c++">num[i]=num[index];
</code></pre><p>如果通过index点的周转，距离不变（依然是最小值），这说明通过index周转使得最短路径条数又多出了一部分，只需要用之前得到的最短路径条数加上num[index]即可，由此得出第二个式子</p><pre><code class="c++">num[i]+=num[index];
</code></pre><h4 id="程序源代码：-2"><a href="#程序源代码：-2" class="headerlink" title="程序源代码："></a>程序源代码：</h4><pre><code class="c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
int n,m,s,d;
const int maxn=505;
int arr[maxn];   //记录每个城市的援兵数
int dismap[maxn][maxn];    //储存X-Y的长度
int path[maxn];    //前驱节点
int dis[maxn];     //最短路径
int cost[maxn];    //最大救援队数量
int vis[maxn];     //用来记录该点是否已经是最短路径的点
int num[maxn];     //最短路径的条数
void dijk(int s)
&#123;
    memset(path,-1,sizeof(path));
    memset(dis,0x3f,sizeof(dis));
    memset(cost,0,sizeof(cost));
    memset(vis,0,sizeof(vis));
    memset(num,0,sizeof(num));
    dis[s]=0;
    cost[s]=arr[s];   //此时救援队数量等于出发点的救援队数量
    num[s]=1;         //一条最短路径
    while(true)
    &#123;
        int k=-1;
        int maxt =0x3f;
        for (int i = 0; i &lt; n; ++i) &#123;
            if(!vis[i]&amp;&amp;dis[i]&lt;maxt)
            &#123;
                k=i;
                maxt=dis[i];
            &#125;
        &#125;
        vis[k]=1;
        if(k==-1) return;

        for (int j = 0; j &lt; n; ++j) &#123;

            if(!vis[j]&amp;&amp;dis[j]&gt;dis[k]+dismap[k][j])&#123;
                dis[j]=dis[k]+dismap[k][j];
                path[j]=k;
                num[j]=num[k];   //如果能更新，说明产生了新的最短路径，num[i]变为从s到k的路径条数
                cost[j] = cost[k]+arr[j];  //产生了新的最短路径,人数为cost[k]+arr[j]
            &#125;
            else if (!vis[j]&amp;&amp;dis[j]==dis[k]+dismap[k][j])&#123; //存在新的最短路径
                num[j]+=num[k];   //最短路径条数更新
                //无论援兵量是否能更新，既然已经有了另一条路与当前最短路长度相同
                //就说明多了一些最短路条数
                if(cost[j]&lt;cost[k]+arr[j])   //援兵量能更新
                &#123;
                    cost[j]=cost[k]+arr[j];
                    path[j]=k;

                &#125;
            &#125;

        &#125;
    &#125;

&#125;
void print(int x)
&#123;
    if(x==-1) return;
    print(path[x]);
    cout&lt;&lt;x&lt;&lt;&quot; &quot;;
&#125;
int main()
&#123;

    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d;
    memset(arr,0,sizeof(arr));
    memset(dismap,0x3f,sizeof(dismap));
    for (int j = 0; j &lt;n ; ++j) &#123;
        cin&gt;&gt;arr[j];
    &#125;
    for (int i = 0; i &lt;m ; ++i) &#123;
        int x,y,z;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
        //此题是无向图
        dismap[x][y]=z;
        dismap[y][x]=z;
    &#125;
    dijk(s);
    cout&lt;&lt;num[d]&lt;&lt;&quot; &quot;&lt;&lt;cost[d]&lt;&lt;endl;//打印最短路径条数和最大援兵数
    print(path[d]);
    cout&lt;&lt;d&lt;&lt;endl;
    return 0;
&#125;
</code></pre><h2 id="相关题目链接："><a href="#相关题目链接：" class="headerlink" title="相关题目链接："></a>相关题目链接：</h2><p>[<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2404"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1364">P1364 医院设置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></a>]: “ 样题一：P1364 医院设置”</p><p><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805046380707840/problems/994805073643683840">题目详情 - L2-001 紧急救援 (25 分) (pintia.cn)</a> ：样题三：L2-001 紧急救援 (25 分)</p><p><a target="_blank" rel="noopener" href="https://www.freesion.com/article/8556971489/">L2-001 紧急救援 (25 分)&amp;&amp;dijkstra - 灰信网（软件开发博客聚合） (freesion.com)</a>：样题三参考资料</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Algorithm/">Algorithm</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Data-Structure/">Data Structure</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2022/01/04/Algorithm004/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">并查集</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/01/01/mpi005/"><span class="hidden-mobile">MPI学习(五)-环形拓扑上利用MPI进行通信</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",(function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/@waline/client@1/dist/Waline.min.js",(function(){var a=Object.assign({serverURL:"https://amicoyuan-waline-1odo0o0t6-amicoyuan.vercel.app/",path:"window.location.pathname",placeholder:"欢迎留言~(填写邮箱可在被回复时收到邮件提醒哦)",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],dark:'html[data-user-color-scheme="dark"]',avatar:"retro",avatarCDN:"https://seccdn.libravatar.org/avatar/",avatarForce:!1,wordLimit:0,pageSize:10,highlight:!0},{el:"#waline",path:window.location.pathname});new Waline(a),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{Fluid.plugins.initFancyBox("#waline .vcontent img:not(.vemoji)")})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/boot.js"></script></body></html>