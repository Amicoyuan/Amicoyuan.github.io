{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"computer organization\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/",
            "url": "http://example.com/2022/06/12/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/",
            "title": "内存对齐",
            "date_published": "2022-06-12T07:11:29.730Z",
            "content_html": "<h1 id=\"内存对齐\"><a href=\"#内存对齐\" class=\"headerlink\" title=\"内存对齐\"></a>内存对齐</h1><h2 id=\"CPU读取内存的方式\"><a href=\"#CPU读取内存的方式\" class=\"headerlink\" title=\"CPU读取内存的方式\"></a>CPU读取内存的方式</h2><p>CPU读取内存的方式其实非常复杂，为了更进一步的了解相关的原理，需要对计算机组成原理进行深度学习。</p>\n<h3 id=\"Memory-access-granularity-内存读取粒度\"><a href=\"#Memory-access-granularity-内存读取粒度\" class=\"headerlink\" title=\"Memory access granularity(内存读取粒度)\"></a>Memory access granularity(内存读取粒度)</h3><p>However, your computer’s processor does not read from and write to memory in byte-sized chunks. Instead, it accesses memory in two-, four-, eight- 16- or even 32-byte chunks. We’ll call the size in which a processor accesses memory its memory access granularity.</p>\n<p>CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为<em>memory access granularity（粒度）</em> 本人把它翻译为“内存读取粒度” 。</p>\n<p><a href=\"https://www.cnblogs.com/feng9exe/p/10059543.html\">https://www.cnblogs.com/feng9exe/p/10059543.html</a> ”内存对齐“</p>\n<h2 id=\"内存对齐举例\"><a href=\"#内存对齐举例\" class=\"headerlink\" title=\"内存对齐举例\"></a>内存对齐举例</h2><p>假设此计算机的内存读取粒度是4。</p>\n<h3 id=\"如果内存对齐时\"><a href=\"#如果内存对齐时\" class=\"headerlink\" title=\"如果内存对齐时\"></a>如果内存对齐时</h3><p>前提知识：</p>\n<p>1 Byte &#x3D; 8bit </p>\n<p>1 int8 占用 1 Byte</p>\n<p>1 int16 占用 2 Byte</p>\n<p>1 int32 占用 4 Byte</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//一个结构体的定义如下</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">S</span></span><br><span class=\"hljs-class\">&#123;</span><br>    int8 a;<br>    int32 b;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n\n\n<table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th align=\"center\">4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n<th>12</th>\n<th>13</th>\n<th>14</th>\n<th>15</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int8 a</td>\n<td></td>\n<td></td>\n<td></td>\n<td align=\"center\">int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>我们可以发现int8 a储存在0号内存上，占用1个Byte，1-3号内存空下了3个Byte。int32 b储存在了4-7号内存，一共4个Byte。</p>\n<p>由于此计算机的内存读取粒度时是4</p>\n<p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p>\n<p>当需要读取b(4-7号内存时)，计算机会读取4-7号内存，访问次数1次。</p>\n<h3 id=\"如果内存没有对齐时\"><a href=\"#如果内存没有对齐时\" class=\"headerlink\" title=\"如果内存没有对齐时\"></a>如果内存没有对齐时</h3><table>\n<thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n<th>11</th>\n<th>12</th>\n<th>13</th>\n<th>14</th>\n<th>15</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int8 a</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td>int32 b</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>我们可以发现int8 a储存在0号内存上，占用了1个Byte。int32 b储存在1-4号内存上，一共4个Byte。</p>\n<p>由于此计算机的内存读取粒度时是4</p>\n<p>当需要读取a(0号内存)时，计算机会读取0-3号一组内存，然后去掉1-3号内存。访问次数1次。</p>\n<p>当需要读取b(1-4号内存)时，计算机会先读取0-3号一组内存，去掉0号内存，再读取4-7号一组内存，去掉5-7号内存，随后再拼接1-3号内存和4号内存组成完整的b。访问次数2次。</p>\n<h2 id=\"内存对齐的目的\"><a href=\"#内存对齐的目的\" class=\"headerlink\" title=\"内存对齐的目的\"></a>内存对齐的目的</h2><p>合理的内存对齐可以高效的利用硬件性能，减少处理器内存访问次数。</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0\">https://www.bilibili.com/video/BV1Vt4y1m7DP?from=search&amp;amp;seid=13964421962700904405&amp;amp;spm_id_from=333.337.0.0</a> “内存对齐”</p>\n<p><a href=\"https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0\">https://www.bilibili.com/video/BV1v64y1X7YP?spm_id_from=333.999.0.0</a> “内存对齐对程序性能的影响”</p>\n",
            "tags": []
        }
    ]
}