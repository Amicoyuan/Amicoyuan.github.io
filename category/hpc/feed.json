{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"hpc\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/01/14/openmp005/",
            "url": "http://example.com/2023/01/14/openmp005/",
            "title": "OpenMP循环调度",
            "date_published": "2023-01-14T05:04:25.000Z",
            "content_html": "<h2 id=\"OpenMP循环调度\"><a href=\"#OpenMP循环调度\" class=\"headerlink\" title=\"OpenMP循环调度\"></a>OpenMP循环调度</h2><h3 id=\"1-循环调度\"><a href=\"#1-循环调度\" class=\"headerlink\" title=\"1.循环调度\"></a>1.循环调度</h3><p>当第一次遇到parallel for指令时，我们看到将各次循环分配给线程的操作是由系统完成的。然而，大部分OpenMP实现只是粗略地使用块分割：如果在串行循环中有n次迭代，那么在并行循环中，前n&#x2F;thread_count个迭代分配给线程0，接下来的n&#x2F;thread_count个迭代分配给线程1，依此类推。不难想到，这种分配方式肯定不是最优的。例如，假如我们想要并行化循环：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">sum = <span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;=n;i++)<br>    sum+=<span class=\"hljs-built_in\">f</span>(i);<br></code></pre></div></td></tr></table></figure>\n\n<p>同时，假设对f函数调用所需要的时间与参数i的大小成正比，那么与分配给线程0的工作相比，分配给线程thread_count-1的工作量相对较大。一个更好的分配方案是轮流分配线程的工作（循环划分）。在循环划分中，各次迭代被“轮流”地一次一个地分配给线程。假如 t&#x3D;thread_count。那么一个循环划分将如下分配各次迭代：</p>\n<p><img src=\"/2023/01/14/openmp005/image-20230114132246596.png\" alt=\"image-20230114132246596\"></p>\n<p>为了了解这样分配是如何影响性能的，我们编写了如下程序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> j,start=i*(i+<span class=\"hljs-number\">1</span>)/<span class=\"hljs-number\">2</span>,finish=start+i;<br>    <span class=\"hljs-keyword\">double</span> return_val = <span class=\"hljs-number\">0.0</span>;<br>    <br>    <span class=\"hljs-keyword\">for</span>(j = start; j&lt;=finish; j++)&#123;<br>        return_val += <span class=\"hljs-built_in\">sin</span>(j);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> return_val;<br>    <span class=\"hljs-comment\">/* f */</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>每当函数f（i）调用i次sin函数。例如，执行f（2i）的时间几乎是执行f（i）的时间的两倍。</p>\n<p>当n&#x3D;10000并且只用一个线程运行程序时，运行时间是3.67秒。当用两个线程和缺省分配方式（第0-5000次迭代分配给线程0，第5001-10000次迭代分配给线程1），运行程序时，运行时间为2.76秒。加速比仅为1.33.然而，当运行两个线程并采用循环划分时，运行时间减少到1.84秒。与单线程运行相比，加速比为1.99；与双线程，块分割相比，加速比为1.5！</p>\n<p>我们看到一个好的迭代分配能够对性能有很大的影响。再OpenMP中，将循环分配给线程称为调度，schedule子句用于在parallel for或者for指令中进行迭代分配。</p>\n<h3 id=\"2-schedule子句\"><a href=\"#2-schedule子句\" class=\"headerlink\" title=\"2.schedule子句\"></a>2.schedule子句</h3><p>在例子中，我们已经知道如何乎获取缺省调度：只需要添加parallel for指令和reduction子句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">sum=<span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)</span><br><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;=n;i++)&#123;<br>    sum+=<span class=\"hljs-built_in\">f</span>(i);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>为了对线程进行调度，可以添加一个schedule子句到parallel for指令中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">sum=<span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)\tschedule(static,1)</span><br><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;=n;i++)&#123;<br>    sum+=<span class=\"hljs-built_in\">f</span>(i);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>一般而言，schedule子句有如下形式：</p>\n<p>schedule（<type>[.<chunksize>]）</chunksize></type></p>\n<p>type可以是下列任意一个：</p>\n<ol>\n<li>static：迭代能够在循环执行前分配给线程</li>\n<li>dynamic或guided：迭代在循环执行时被分配给线程，因此在一个线程完成了它的当前迭代集合后，它能从运行时系统中请求更多</li>\n<li>auto：编译器和运行时系统决定调度方式</li>\n<li>runtime：调度在运行时决定</li>\n</ol>\n<p>chunksize是一个正整数。在OpenMP中，迭代块是在顺序循环中连续执行的一块迭代语句，块中的迭代次数是chunksize。只有static，dynamic和guided调度有chunksize。这虽然决定了调度的细节，但准确的解释还是依赖于type。</p>\n<h3 id=\"3-stastic调度类型\"><a href=\"#3-stastic调度类型\" class=\"headerlink\" title=\"3.stastic调度类型\"></a>3.stastic调度类型</h3><p>对于static调度，系统以轮转的方式分配chunksize块个迭代给每个线程。例如，假如有12个迭代，0，1，—，11和3个线程，如果在parallel for或for指令中使用schedule（static，1）迭代将如下分配：</p>\n<p><img src=\"/2023/01/14/openmp005/image-20230114141741424.png\" alt=\"image-20230114141741424\"></p>\n<p>如果使用schedule（static，2），迭代将如下进行分配：</p>\n<p><img src=\"/2023/01/14/openmp005/image-20230114141830866.png\" alt=\"image-20230114141830866\"></p>\n<p>如果使用schedule（static，4），迭代将如下分配：</p>\n<p><img src=\"/2023/01/14/openmp005/image-20230114141909092.png\" alt=\"image-20230114141909092\"></p>\n<p>因此，子句schedule（static,total_iterations&#x2F;thread_count）就相当于被大部分OpenMP实现所使用的缺省调度。</p>\n<p>这里，chunksize可以被忽略。如果他被忽略了，chunksize就近似等于total_iterations&#x2F;thread_count。</p>\n<h3 id=\"4-dynamic和guided调度类型\"><a href=\"#4-dynamic和guided调度类型\" class=\"headerlink\" title=\"4.dynamic和guided调度类型\"></a>4.dynamic和guided调度类型</h3><p>在dynamic调度中，迭代也被分成chunksize个连续迭代的块。每个线程执行一块，并且当一个线程完成一块时，它将从运行时系统请求另一块，直到所有的迭代完成。chunksize可以被忽略。当它被忽略时，chunksize为1。</p>\n<p>在guided调度中，每个线程也执行一块，并且当一个线程完成一块时，将请求另一块。然而，在guided调度中，当块完成后，新块的大小会变小。例如，在我们的系统中，如果用parallel for指令和schedule（guided）子句来运行梯形积分法程序，那么当n&#x3D;10000并且thread_count&#x3D;2时。迭代将如表5-3那样分配。块的大小近似等于剩下的迭代数除以线程数。第一个块的大小9999&#x2F;2≈5000，因为有9999个迭代未被分配的迭代。第二个块的大小为4999&#x2F;2≈2500，一次类推。</p>\n<p><img src=\"/2023/01/14/openmp005/image-20230114143233692.png\" alt=\"image-20230114143233692\"></p>\n<p>在guided调度中，如果没有指定chunksize，那么块的大小为1；如果指定了chunksize，那么块的大小就是chunksize，除了最后一块的大小可以比chunksize小。</p>\n<h3 id=\"5-runtime调度类型\"><a href=\"#5-runtime调度类型\" class=\"headerlink\" title=\"5.runtime调度类型\"></a>5.runtime调度类型</h3><p>为了理解schedule（runtime），我们需要离题一会儿，讨论一下环境变量。正如名字所暗示的，环境变量是能够被运行时系统所访问的命名值，即它们在程序的环境中是可得的。一些经常被使用的环境变量是PATH,HOME和SHELL。PATH变量明确了当寻找一个可执行文件时shell应该搜索哪些目录。它通常在UNIX和Windows系统中定义。HOME变量指定用户主目录的位置，而SHELL变量指定用户shell的可执行位置。这样通常在UNIX系统中。在类UNIX系统（例如Linux和Mac OS X）和Windows，环境变量能够在命令行中检查和指定。在类UNIX系统中，能使用shell命令行；在windows中，能使用集成开发环境的命令行。</p>\n<p>例如，如果我们正使用bash shell，要检查一个环境变量的值只需要输入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$PATH</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p>我们能够使用export命令来设置一个环境变量的值</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"><span class=\"hljs-built_in\">export</span> TEST_VAR = <span class=\"hljs-string\">&quot;hello&quot;</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p>如何检查和设置特定系统的环境变量，请咨询本地系统的专家。</p>\n<p>当schedule（runtime）指定时，系统使用环境变量OMP_SCHEDULE在运行时来决定如何调度循环。OMP_SCHEDULE环境变量会呈现任何能够被static，dynamic或guided调度所使用的值。例如，假设在程序中有一条parallel for指令，并且它已经被schedule（runtime）修改了。那么如果使用bash shell，就能通过执行以下命令将一个循环分配所得到的迭代分配给线程：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"><span class=\"hljs-built_in\">export</span> OMP_SCHEDULE=<span class=\"hljs-string\">&quot;static,1&quot;</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p>现在，当开始执行程序时，系统将调度for循环的迭代，就如同使用子句schedule（static，1）修改了parallel for指令那样。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><ol>\n<li>调度方式对加速效果的重要性</li>\n<li>合理分析任务特性，选择最适合的调度方式</li>\n</ol>\n<h3 id=\"7-参考资料\"><a href=\"#7-参考资料\" class=\"headerlink\" title=\"7.参考资料\"></a>7.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2023/01/13/openmp004/",
            "url": "http://example.com/2023/01/13/openmp004/",
            "title": "OpenMP排序",
            "date_published": "2023-01-13T08:26:51.000Z",
            "content_html": "<h2 id=\"OpenMP排序\"><a href=\"#OpenMP排序\" class=\"headerlink\" title=\"OpenMP排序\"></a>OpenMP排序</h2><h3 id=\"1-冒泡排序\"><a href=\"#1-冒泡排序\" class=\"headerlink\" title=\"1.冒泡排序\"></a>1.冒泡排序</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(list_length = n; list.length &gt;= <span class=\"hljs-number\">2</span>; list_length--)\t\t\t\t<span class=\"hljs-comment\">//升序排列</span><br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">0</span>;i &lt; list_length<span class=\"hljs-number\">-1</span>; i++)<br>        <span class=\"hljs-keyword\">if</span>(a[i] &gt; a[i+<span class=\"hljs-number\">1</span>])&#123;<br>            tmp = a[i];<br>            a[i] = a[i+<span class=\"hljs-number\">1</span>];<br>            a[i+<span class=\"hljs-number\">1</span>] = tmp;<br>        &#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>​\t\t显然，在外部循环中有一个循环依赖，在外部循环的任何一次迭代中，当前列表的内容依赖于外部循环的前一次迭代。例如，如果在算法开始时，a&#x3D;3,4,1,2，那么外部循环的第二次迭代将对列表3，1，2进行操作，因为4在第一次迭代中应该已经被移动到列表的最后了。但如果前两次迭代同时执行，则可能第二次迭代的有效列表包含4。\t</p>\n<p>​\t\t内部循环的循环依赖也很容易发现。在第i次迭代中，被比较的元素依赖于第i-1次迭代。如果在第i-1次迭代中a[i-1]和a[i]没有交换，那么第i次迭代将比较a[i]和a[i+1]。另一方面，如果第i-1次迭代交换了a[i-1]和a[i]，那么第i次迭代将比较原始的a[i-1] (现在是a[i]和a[i+1])。例如，假如当前列表是{3，1，2}。那么当i&#x3D;1时，我们将比较3和2，但如果i&#x3D;0和i&#x3D;1次迭代同时发生，则完全有可能i&#x3D;1次迭代回比较1和2。</p>\n<p>​\t\t我们完全不清楚怎样在不完全重写算法的情况下一处任何一个循环依赖。记住。即使我们总能找到循环依赖，但可能很难甚至不可能移除它。对于并行化for循环而言，parallel for指令不是一个通用的解决方法。</p>\n<h3 id=\"2-奇偶交换排序\"><a href=\"#2-奇偶交换排序\" class=\"headerlink\" title=\"2.奇偶交换排序\"></a>2.奇偶交换排序</h3><p>​\t\t奇偶交换排序是一个与冒泡排序相似的算法，但它相对来说更容易并行化。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(phase = <span class=\"hljs-number\">0</span>;phase &lt; n ; phase++)<br>    <span class=\"hljs-keyword\">if</span>(phase % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span>; i &lt; n ;i += <span class=\"hljs-number\">2</span>)<br>            <span class=\"hljs-keyword\">if</span>(a[i<span class=\"hljs-number\">-1</span>] &gt; a[i]) <span class=\"hljs-built_in\">swap</span>(a[i<span class=\"hljs-number\">-1</span>],a[i]);<br>\t<span class=\"hljs-keyword\">else</span><br>        <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span>;i &lt; n<span class=\"hljs-number\">-1</span> ;i += <span class=\"hljs-number\">2</span>)<br>            <span class=\"hljs-keyword\">if</span>(a[i] &gt; a[i+<span class=\"hljs-number\">1</span>]) <span class=\"hljs-built_in\">swap</span>(a[i],a[i+<span class=\"hljs-number\">1</span>]);<br></code></pre></div></td></tr></table></figure>\n\n<p>列表a存储n个整数，算法对他们进行升序排列。在一个“偶阶段”（phase %2 &#x3D;&#x3D;0 ）里，每个偶下标元素a[i]与它左边的元素a[i-1]相比较。如果他们是没有排好序的，就交换它们。在一个“奇阶段”里，每个奇下标元素与它右边的元素相比较。如果他们是没有排好序的，则交换他们。有定理证明：在n个阶段后，列表可以完成排序。</p>\n<p>​\t\t作为一个简单的例子，假设a&#x3D;{9,7,8,6}。表5-1显示了各个阶段的情况。在这个例子中，最后的阶段不是必要的，但算法并不在执行每个阶段前检查列表是否已经有序。</p>\n<p><img src=\"/2023/01/13/openmp004/image-20230113174202896.png\" alt=\"image-20230113174202896\"></p>\n<p>​\t\t不难看到外部循环有一个循环依赖。例如在a &#x3D; {9，7，8，6}之前。在阶段0中，内部循环将比较（9，7）和（8，6）这两对中的元素，这两对都会被交换。因此对于阶段1，列表将是{7，9，6，8}，并在阶段1中（9，6）中的元素被比较并交换。然而，如果阶段0和阶段1同时执行，则在阶段1中被检查可能是（7，8），是有序的。此外，我们尚不清楚如何消除这个循环依赖，因此并行化外部for循环不是一个好的选择。</p>\n<p>​\t\t但是，内部for循环并没有任何循环依赖。例如，在偶阶段循环中，变量i是奇数，所以对于两个不同的i值，例如，i&#x3D;j和i&#x3D;k，{j-1,j}和{k-1,k}将是不同的。（a[j-1],a[j]）和（a[k-1],a[k]）所产生的比较和可能的交换能够同时进行。</p>\n<p>​\t\t所以，我们试图使用程序5-4的代码并行化奇偶变化排序，但还是会有一些潜在的问题，首先，尽管任何一个偶阶段迭代并不依赖任何这个阶段的其他迭代，但是还需要注意，对p阶段和p+1阶段却并不是这样的。我们需要确定在任何一个线程开始p+1阶段之前，所有的线程必须先完成p阶段。然而，像parallel指令那样，parallel for指令在循环结束处有一个隐式的路障，因此，在所有的线程完成当前阶段（即阶段P之前），没有线程能够进入下一阶段，即p+1阶段。【这里需要注意在MPI中并没有隐式的路障来实现这个功能，需要程序员手动设置路障点】</p>\n<p>​\t\t其次，是创建和合并线程的开销。OpenMP实现可能会在每一遍外部循环都创建和合并thread__count个线程。表5-2的第一行显示了当输入列表包含20000个元素时，在我们系统上运行1，2，3，4个线程的运行时间。</p>\n<h3 id=\"3-程序5-4奇偶排序的第一个OpenMP实现\"><a href=\"#3-程序5-4奇偶排序的第一个OpenMP实现\" class=\"headerlink\" title=\"3.程序5-4\t奇偶排序的第一个OpenMP实现\"></a>3.程序5-4\t奇偶排序的第一个OpenMP实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(phase = <span class=\"hljs-number\">0</span>;phase &lt; n; phase++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(phase %<span class=\"hljs-number\">2</span> ==<span class=\"hljs-number\">0</span>)<br>    \t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp)</span><br>        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">1</span>;i&lt;n;i+=<span class=\"hljs-number\">2</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[i<span class=\"hljs-number\">-1</span>]&gt;a[i])&#123;<br>                tmp = a[i<span class=\"hljs-number\">-1</span>];<br>                a[i<span class=\"hljs-number\">-1</span>] = a[i];<br>                a[i] =tmp;<br>            &#125;<br>        &#125;<br>    <span class=\"hljs-keyword\">else</span><br>        <span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp)</span><br>        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">1</span>;i&lt;n<span class=\"hljs-number\">-1</span>;i+=<span class=\"hljs-number\">2</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[i] &gt; a[i+<span class=\"hljs-number\">1</span>])&#123;<br>                tmp = a[i+<span class=\"hljs-number\">1</span>];<br>                a[i+<span class=\"hljs-number\">1</span>] = a[i];<br>                a[i] = tmp;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2023/01/13/openmp004/image-20230113225724364.png\" alt=\"image-20230113225724364\"></p>\n<p>​\t\t这些时间耗费并不非常糟糕，但是我们想看看是否能做得更好。每次执行内部循环时，使用同样数量的线程。因此只创建一次线程，并在每次内部循环的执行中重用它们，这样做可能更好。幸运的是，OpenMP提供了允许这样做的指令。用parallel指令在外部循环前创建thread__count个线程的集合。然后，我们不在每次内部循环执行时创建一组新的线程，而是使用一个for指令，告诉OpenMP用已有的线程组来并行化for循环，对原有OpenMP实现的改动显示在程序5-5中。</p>\n<h3 id=\"4-程序5-5奇偶排序的第二个OpenMP实现\"><a href=\"#4-程序5-5奇偶排序的第二个OpenMP实现\" class=\"headerlink\" title=\"4.程序5-5\t奇偶排序的第二个OpenMP实现\"></a>4.程序5-5\t奇偶排序的第二个OpenMP实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) default(none) shared(a,n) private(i,tmp,phase)</span><br><span class=\"hljs-keyword\">for</span>(phase = <span class=\"hljs-number\">0</span>;phase &lt; n; phase++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(phase %<span class=\"hljs-number\">2</span> ==<span class=\"hljs-number\">0</span>)<br>\t\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp for</span><br>        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">1</span>;i&lt;n;i+=<span class=\"hljs-number\">2</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[i<span class=\"hljs-number\">-1</span>]&gt;a[i])&#123;<br>                tmp = a[i<span class=\"hljs-number\">-1</span>];<br>                a[i<span class=\"hljs-number\">-1</span>] = a[i];<br>                a[i] =tmp;<br>            &#125;<br>        &#125;<br>    <span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp for</span><br>        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">1</span>;i&lt;n<span class=\"hljs-number\">-1</span>;i+=<span class=\"hljs-number\">2</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(a[i] &gt; a[i+<span class=\"hljs-number\">1</span>])&#123;<br>                tmp = a[i+<span class=\"hljs-number\">1</span>];<br>                a[i+<span class=\"hljs-number\">1</span>] = a[i];<br>                a[i] = tmp;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>与parallel for指令不同的是，for指令并不创建任何线程。它使用已经在parallel块中创建的线程。在循环的末尾有一个隐式的路障。代码的结果（最终列表）将因此与原有的并行化代码所取得到的结果一样。</p>\n<p>​\t\t奇偶排序的第二个版本的运行时间显示在表5-2的第二行。当使用两个或更多线程时，使用两条for指令的版本要比使用两条parallel for指令的版本快17%。因此对于这个系统而言，为这点改变所做的小小努力是值得的。</p>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><ol>\n<li>循环依赖总会出现，我们可能会很难去解决它甚至根本无法解决。</li>\n<li>在构造并行区时要尽量减少创建和合并线程的开销</li>\n</ol>\n<h3 id=\"6-参考文献\"><a href=\"#6-参考文献\" class=\"headerlink\" title=\"6.参考文献\"></a>6.参考文献</h3><p>并行程序导论 （美）Peter S.Pacheco</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2023/01/09/openmp003/",
            "url": "http://example.com/2023/01/09/openmp003/",
            "title": "OpenMP π值估计",
            "date_published": "2023-01-09T07:06:18.000Z",
            "content_html": "<h2 id=\"π值估计\"><a href=\"#π值估计\" class=\"headerlink\" title=\"π值估计\"></a>π值估计</h2><h3 id=\"1-数学背景\"><a href=\"#1-数学背景\" class=\"headerlink\" title=\"1.数学背景\"></a>1.数学背景</h3><p><img src=\"/2023/01/09/openmp003/image-20230109150836877.png\" alt=\"image-20230109150836877\"></p>\n<p>我们能够在串行代码下实行这个公式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span> factor = <span class=\"hljs-number\">1.0</span>;<br><span class=\"hljs-keyword\">double</span> sum = <span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">0</span> ; k &lt; n; k++)&#123;<br>    sum += factor /(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br>    factor = - factor;<br>&#125;<br>pi_approx = <span class=\"hljs-number\">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-OpenMP并行化\"><a href=\"#2-OpenMP并行化\" class=\"headerlink\" title=\"2.OpenMP并行化\"></a>2.OpenMP并行化</h3><p>为了使用OpenMP来并行化，可以首先倾向于这样做：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">double</span> factor = <span class=\"hljs-number\">1.0</span>;<br><span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">double</span> sum = <span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-number\">3</span> <span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum)  <span class=\"hljs-comment\">//对sum进行求和归约</span></span><br><span class=\"hljs-number\">4</span> <span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">0</span> ; k &lt; n; k++)&#123;<br><span class=\"hljs-number\">5</span>     sum += factor /(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br><span class=\"hljs-number\">6</span>     factor = - factor;<br><span class=\"hljs-number\">7</span> &#125;<br><span class=\"hljs-number\">8</span> pi_approx = <span class=\"hljs-number\">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure>\n\n<p>然而，第k次迭代中对第6行的factor的更新和接下来的第k + 1次迭代中对第5行的sum的累加是一个循环依赖（数据依赖）。如果第k次迭代被分配·到一个线程，而第k + 1次迭代被分配给另一个线程，则我们不能保证第6行中factor的值是正确的。</p>\n<p>在这种情况下我们能通过检查系数来解决这个问题：</p>\n<p><img src=\"/2023/01/09/openmp003/image-20230109161031989.png\" alt=\"image-20230109161031989\"></p>\n<p>可以看到：在第k次迭代，factor的值应该是<img src=\"/2023/01/09/openmp003/image-20230109161206995.png\" alt=\"image-20230109161206995\">。如果k是偶数，那么值是+1；如果k是奇数，值是-1。</p>\n<h3 id=\"3-消除循环依赖（数据依赖）\"><a href=\"#3-消除循环依赖（数据依赖）\" class=\"headerlink\" title=\"3.消除循环依赖（数据依赖）\"></a>3.消除循环依赖（数据依赖）</h3><p>因此，如果将下述代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">sum += factor /(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br>factor = - factor;<br></code></pre></div></td></tr></table></figure>\n\n<p>替换为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">if</span>(k % <span class=\"hljs-number\">2</span> ==<span class=\"hljs-number\">0</span>)\t\t\t<span class=\"hljs-comment\">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    factor = <span class=\"hljs-number\">1.0</span>;<br><span class=\"hljs-keyword\">else</span><br>    factor = <span class=\"hljs-number\">-1.0</span>;<br>sum += factor/(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br></code></pre></div></td></tr></table></figure>\n\n<p>这样就消除了循环依赖（数据依赖）。</p>\n<h3 id=\"4-作用域\"><a href=\"#4-作用域\" class=\"headerlink\" title=\"4.作用域\"></a>4.作用域</h3><p>​\t然而，事情仍然不是完全正确的。如果在我们的系统上使用两个线程运行程序，并设n&#x3D;1000，那么结果仍然是错误的。例如，</p>\n<p><img src=\"/2023/01/09/openmp003/image-20230109164120205.png\" alt=\"image-20230109164120205\"></p>\n<p>另一方面，如果只有一个线程运行程序，我们总是得到：</p>\n<p><img src=\"/2023/01/09/openmp003/image-20230109164204808.png\" alt=\"image-20230109164204808\"></p>\n<p>为什么会有这种错误。在一个已经被parallel for指令并行化的块中，缺省情况下任何在循环前声明的变量（唯一的例外是循环变量）在线程间都是共享的。因此factor被共享（被所有线程所共享）。例如，线程0可能会给他赋值1，但在它能用这个值更新sum前，线程1可能又给他赋值为-1了。因此，除了消除计算factor时的循环依赖（数据依赖）外，我们还需要保证每个线程有它自己的factor副本，就是说，为了使代码正确，我们需要保证factor有私有作用域（简单来说就是保证当前线程的factor的值不能被其他线程修改，也只有当前线程能更新和使用factor）。通过添加一个private子句到parallel指令中来实现这一目标。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"> <span class=\"hljs-keyword\">double</span> factor = <span class=\"hljs-number\">1.0</span>;<br> <span class=\"hljs-keyword\">double</span> sum = <span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) reduction(+:sum) private(factor)  <span class=\"hljs-comment\">//对sum进行求和归约</span></span><br> <span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">0</span> ; k &lt; n; k++)&#123;<br>     <span class=\"hljs-keyword\">if</span>(k % <span class=\"hljs-number\">2</span> ==<span class=\"hljs-number\">0</span>)\t\t\t<span class=\"hljs-comment\">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    \tfactor = <span class=\"hljs-number\">1.0</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>    \tfactor = <span class=\"hljs-number\">-1.0</span>;<br>     sum += factor /(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br> &#125;<br> pi_approx = <span class=\"hljs-number\">4.0</span>*sum;<br></code></pre></div></td></tr></table></figure>\n\n<p>在private子句内列举的变量，在每个线程上都有一个私有副本被创建。因此，在我们的例子中，thread_count个线程中的每一个都有它自己的factor变量的副本，因此一个线程对factor的更新不会影响另一个线程的factor值。</p>\n<p>​\t\t要记住的重要的一点是，一个有私有作用域的变量的值在parallel块或者parallel for块的开始处是未指定的。它的值在parallel或parallel for块完成之后也是未指定的。例如，下列代码中的第一个printf语句的输出是非确定的，因为在它被现实初始化之前就打印了私有变量x。类似地，最终的printf输出也是非确定的，因为他在parallel块完成之后打印x。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> x = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel num_threads(thread_count) private(x)</span><br>&#123;<br>    <span class=\"hljs-keyword\">int</span> my_rank = <span class=\"hljs-built_in\">omp_get_thread_num</span>();<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Thread %d &gt; before initialization,x = %d\\n&quot;</span>,myrank,x);<br>    x = <span class=\"hljs-number\">2</span>*my_rank + <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Thread %d &gt; after initialization,x = %d\\n&quot;</span>,my_rank,x);<br>&#125;<br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;After parallel block, x = %d\\n&quot;</span>,x);<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"5-关于作用域的更多问题\"><a href=\"#5-关于作用域的更多问题\" class=\"headerlink\" title=\"5.关于作用域的更多问题\"></a>5.关于作用域的更多问题</h3><p>​\t\t关于变量factor的问题是常见问题中的一个。我们通常需要考虑在parallel块或parallel for块中的每个变量的作用域。因此，与其让OpenMP决定每个变量的作用域，还不如让程序员明确块中每个变量的作用域。事实上，OpenMP提供了一个子句default，该子句显示地要求我们这样做。如果我们添加子句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\"><span class=\"hljs-keyword\">default</span></span>(none)<br></code></pre></div></td></tr></table></figure>\n\n<p>到parallel或parallel for指令中，那么编译器将要求我们明确在这个块中使用的每个变量和已经在块之外声明的变量的作用域。（在一个块中声明的变量都是私有的，因为它们会被分配给线程的栈。）</p>\n<p>​\t例如，使用一个default（none）子句，对π的计算将如下所示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel for num_threads(thread_count) default(none) reduction(+:sum) private(k,factor)  <span class=\"hljs-comment\">//对sum进行求和归约</span></span><br> <span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">0</span> ; k &lt; n; k++)&#123;<br>     <span class=\"hljs-keyword\">if</span>(k % <span class=\"hljs-number\">2</span> ==<span class=\"hljs-number\">0</span>)\t\t\t<span class=\"hljs-comment\">//通过奇偶性，来独立factor消除循环依赖（数据依赖）</span><br>    \tfactor = <span class=\"hljs-number\">1.0</span>;<br>\t<span class=\"hljs-keyword\">else</span><br>    \tfactor = <span class=\"hljs-number\">-1.0</span>;<br>     sum += factor /(<span class=\"hljs-number\">2</span>*k+<span class=\"hljs-number\">1</span>);<br> &#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在这个例子中，我们在for循环中使用4个变量。由于default子句，我们需要明确每个变量的作用域。正如我们已经注意到的，sum是一个归约变量（同时拥有私有和共享作用域的属性）。我们也已经注意到factor和循环变量中k应该有私有作用域。从未在parallel或parallel for块中更新的变量，如这个例子中的n，能够被安全的共享。与私有变量不同，共享变量在块内具有在parallel或parallel for块之前的值，在块之后的值与块内的最后一个值相同。因此，如果n在块之前被初始化为1000，则在parallel for语句中他将保持这个值。因为在for循环中值没有改变，所有在循环结束后它将保持这个值。</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><ol>\n<li>分析数学背景，解决循环依赖（数据依赖）</li>\n<li>判断变量的作用域</li>\n</ol>\n<h3 id=\"7-参考资料\"><a href=\"#7-参考资料\" class=\"headerlink\" title=\"7.参考资料\"></a>7.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2023/01/06/openmp002/",
            "url": "http://example.com/2023/01/06/openmp002/",
            "title": "OpenMP寻找循环依赖",
            "date_published": "2023-01-06T09:15:48.000Z",
            "content_html": "<h3 id=\"1-OpenMP寻找循环依赖\"><a href=\"#1-OpenMP寻找循环依赖\" class=\"headerlink\" title=\"1.OpenMP寻找循环依赖\"></a>1.OpenMP寻找循环依赖</h3><p>​\t\t当我们试图使用一个parallel for指令时，首先应该注意的是：要小心发现循环依赖。我们不需要担心一般的数据依赖。例如，在下面循环中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>    x[i] = a + i*h;\t\t\t<span class=\"hljs-comment\">//2</span><br>    y[i] = <span class=\"hljs-built_in\">exp</span>(x[i]);\t\t<span class=\"hljs-comment\">//3</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>在第二行和第三行之间有一个数据依赖。然而，如下的并行化没有问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel num_threads(thread_count)</span><br><span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>    x[i] = a + i*h;\t\t\t<span class=\"hljs-comment\">//3</span><br>    y[i] = <span class=\"hljs-built_in\">exp</span>(x[i]);\t\t<span class=\"hljs-comment\">//4</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>因为x[ i ]的计算与它接下来的使用总是被分配给同一个进程。</p>\n<p>​\t\t我们也应该观察到，有依赖关系的语句，其中至少一条语句会有序地写或更新变量。因此为了检测循环依赖，我们只需要重点观察被循环体更新的变量，即我们应该寻找在一个迭代中被读或被写，而在另一个迭代中被写的变量。</p>\n<h3 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2.总结\"></a>2.总结</h3><ol>\n<li>数据依赖在优化过程中非常常见</li>\n<li>如何解决数据依赖对提升并行化的效果影响很大</li>\n</ol>\n<h3 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3.参考资料\"></a>3.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2023/01/03/openmp001/",
            "url": "http://example.com/2023/01/03/openmp001/",
            "title": "OpenMP梯度积分法",
            "date_published": "2023-01-03T09:19:45.000Z",
            "content_html": "<h2 id=\"OpenMP梯度积分法\"><a href=\"#OpenMP梯度积分法\" class=\"headerlink\" title=\"OpenMP梯度积分法\"></a>OpenMP梯度积分法</h2><h3 id=\"1-梯度积分法\"><a href=\"#1-梯度积分法\" class=\"headerlink\" title=\"1.梯度积分法\"></a>1.梯度积分法</h3><p><img src=\"/2023/01/03/openmp001/image-20230106165434252.png\" alt=\"001\"></p>\n<p><img src=\"/2023/01/03/openmp001/image-20230106165507737.png\" alt=\"image-20230106165507737\"></p>\n<h3 id=\"2-识别两类任务\"><a href=\"#2-识别两类任务\" class=\"headerlink\" title=\"2.识别两类任务\"></a>2.识别两类任务</h3><p><img src=\"/2023/01/03/openmp001/image-20230106164847677.png\" alt=\"image-20230106164847677\"></p>\n<ol>\n<li>单个梯形的面积计算</li>\n<li>梯形面积求和</li>\n</ol>\n<p>在2.1的任务中，没有任务间的通信，但这一组任务中的每一组任务都与2.2的任务通信</p>\n<h3 id=\"3-累加线程结果\"><a href=\"#3-累加线程结果\" class=\"headerlink\" title=\"3.累加线程结果\"></a>3.累加线程结果</h3><p>​\t使用一个共享变量作为所有线程的和 ，每个线程可以将它计算的部分结果累加到共享变量中，让每个线程执行类似下面的语句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp critical</span><br>global_result += myresult;                <span class=\"hljs-comment\">//需要互斥访问</span><br></code></pre></div></td></tr></table></figure>\n\n<p>竞争条件，使用临界区解决。保证每次只有一个线程执行这段结构性代码。</p>\n<h3 id=\"4-程序完整代码\"><a href=\"#4-程序完整代码\" class=\"headerlink\" title=\"4.程序完整代码\"></a>4.程序完整代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;omp.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Trap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> a,<span class=\"hljs-keyword\">double</span> b,<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">double</span> *global_result_p)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[])</span></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span> global_result = <span class=\"hljs-number\">0.0</span>;<br>\t<span class=\"hljs-keyword\">double</span> a,b;\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//为了区分local_a,local_b</span><br>\t<span class=\"hljs-keyword\">int</span> n;<br>\t<span class=\"hljs-keyword\">int</span> thread_count;<br>\t<br>\tthread_count = <span class=\"hljs-number\">8</span>;                                      \t<span class=\"hljs-comment\">//指定你的线程数</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter a,b, and n\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%lf %lf %d&quot;</span>,&amp;a,&amp;b,&amp;n);<br>    <br>    <span class=\"hljs-comment\">//并行区开始</span><br>\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel num_threads(thread_count)\t\t\t<span class=\"hljs-comment\">//指定Trap函数由thread_count个线程执行</span></span><br>\t<span class=\"hljs-built_in\">Trap</span>(a,b,n,&amp;global_result);<br>\t<span class=\"hljs-comment\">//并行区结束</span><br>    <br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;With n = %d trapezoids, our estimate\\n&quot;</span>,n);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;of the integral from %f to %f = %.4lf\\n&quot;</span>,a,b,global_result);<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Trap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> a,<span class=\"hljs-keyword\">double</span> b,<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">double</span> *global_result_p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span> h,x,my_result;<br>\t<span class=\"hljs-keyword\">double</span> local_a,local_b;<br>\t<span class=\"hljs-keyword\">int</span> i,local_n;\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//local_n代表本进程被分配了多少个任务</span><br>\t<span class=\"hljs-keyword\">int</span> my_rank = <span class=\"hljs-built_in\">omp_get_thread_num</span>();<br>\t<span class=\"hljs-keyword\">int</span> thread_count = <span class=\"hljs-built_in\">omp_get_num_threads</span>();<br>\t<br>\th = (b-a)/n;\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//梯形底的长度</span><br>\tlocal_n = n/thread_count;\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//每个线程分配的梯形数，保证能整除</span><br>\tlocal_a = a + my_rank*local_n*h;\t\t\t\t\t\t<span class=\"hljs-comment\">//区间的左端点</span><br>\tlocal_b = local_a + local_n*h;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//区间的右端点</span><br>\t<span class=\"hljs-comment\">//对global_result共享部分和</span><br>    my_result = (<span class=\"hljs-built_in\">f</span>(local_a) + <span class=\"hljs-built_in\">f</span>(local_b))/<span class=\"hljs-number\">2.0</span>;\t\t\t\t<span class=\"hljs-comment\">//f(x)是目标函数</span><br>\t<span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span> ; i&lt;=local_n<span class=\"hljs-number\">-1</span>; i++)&#123;<br>\t\tx = local_a + i*h;<br>\t\tmy_result += <span class=\"hljs-built_in\">f</span>(x);<br>\t&#125;<br>\tmy_result = my_result*h;<br>    <span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp critical\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//临界区，这里可以直接使用OpenMP提供的reduction</span></span><br>\t*global_result_p += my_result;\t\t\t\t\t\t\t<span class=\"hljs-comment\">//线程将部分和结果累加到共享变量</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h3><ol>\n<li>核心是拆分任务区域，把子任务分配到个个线程</li>\n<li>共享变量的选取决定了可并行度</li>\n<li>通过共享变量实现了归约的操作(这里使用到了临界区)</li>\n</ol>\n<h3 id=\"6-参考资料\"><a href=\"#6-参考资料\" class=\"headerlink\" title=\"6.参考资料\"></a>6.参考资料</h3><p>并行程序导论 （美）Peter S.Pacheco</p>\n",
            "tags": [
                "OpenMP"
            ]
        },
        {
            "id": "http://example.com/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/",
            "url": "http://example.com/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/",
            "title": "MPI学习(一)-简单的发送接收",
            "date_published": "2022-06-12T07:11:29.651Z",
            "content_html": "<h1 id=\"MPI-简单的发送接收\"><a href=\"#MPI-简单的发送接收\" class=\"headerlink\" title=\"MPI-简单的发送接收\"></a>MPI-简单的发送接收</h1><p>打印来自进程问候语句的MPI程序</p>\n<h2 id=\"所使用的MPI原语\"><a href=\"#所使用的MPI原语\" class=\"headerlink\" title=\"所使用的MPI原语\"></a>所使用的MPI原语</h2><p><img src=\"/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi001.png\"></p>\n<p><img src=\"/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi002.png\"></p>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>mpicc  3.1.cpp -o 3.1</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>mpirun -np 4 .&#x2F;3.1(本地提交,采取4个进程)</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;mpi.h&gt;</span>   <span class=\"hljs-comment\">//头文件</span></span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> MAX_STRING = <span class=\"hljs-number\">100</span> ;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc,<span class=\"hljs-keyword\">char</span> **argv)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">char</span> greeting[MAX_STRING];<br>\t<span class=\"hljs-keyword\">int</span> comm_sz;<br>\t<span class=\"hljs-keyword\">int</span> my_rank;<br>\tMPI_Status status;<br><br>\t<span class=\"hljs-built_in\">MPI_Init</span>(&amp;argc,&amp;argv);<br><br>\t<span class=\"hljs-built_in\">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;comm_sz);<br>\t<span class=\"hljs-built_in\">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;my_rank);<br>\t<br>\t<span class=\"hljs-keyword\">if</span>(my_rank != <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">//其他进程向0号进程发消息</span><br>\t\t<span class=\"hljs-built_in\">sprintf</span>(greeting,<span class=\"hljs-string\">&quot;Greetings from process %d of %d!&quot;</span>,my_rank,comm_sz);<br>\t\t<span class=\"hljs-built_in\">MPI_Send</span>(greeting,<span class=\"hljs-built_in\">strlen</span>(greeting)+<span class=\"hljs-number\">1</span>,MPI_CHAR,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,MPI_COMM_WORLD); <br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Greetings from process %d of %d!\\n&quot;</span>,my_rank,comm_sz);<br>\t\t<span class=\"hljs-comment\">//0号进程接受来自其他进程的消息并输出</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> q=<span class=\"hljs-number\">1</span>;q&lt;comm_sz;q++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">MPI_Recv</span>(greeting,MAX_STRING,MPI_CHAR,q,<span class=\"hljs-number\">0</span>,MPI_COMM_WORLD,&amp;status);<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>,greeting);<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">MPI_Finalize</span>();<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"程序运行结果\"><a href=\"#程序运行结果\" class=\"headerlink\" title=\"程序运行结果\"></a>程序运行结果</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">Greetings from process <span class=\"hljs-number\">0</span> of <span class=\"hljs-number\">4</span>!<br>Greetings from process <span class=\"hljs-number\">1</span> of <span class=\"hljs-number\">4</span>!<br>Greetings from process <span class=\"hljs-number\">2</span> of <span class=\"hljs-number\">4</span>!<br>Greetings from process <span class=\"hljs-number\">3</span> of <span class=\"hljs-number\">4</span>!<br></code></pre></div></td></tr></table></figure>\n\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/",
            "url": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/",
            "title": "AVX向量化学习(二)-内存对齐的应用",
            "date_published": "2022-06-12T07:11:29.549Z",
            "content_html": "<h1 id=\"AVX指令集的简单操作-内存对齐版\"><a href=\"#AVX指令集的简单操作-内存对齐版\" class=\"headerlink\" title=\"AVX指令集的简单操作(内存对齐版)\"></a>AVX指令集的简单操作(内存对齐版)</h1><p>使用AVX指令集进行2个double型的数组相加操作</p>\n<h2 id=\"常用的内存对齐函数\"><a href=\"#常用的内存对齐函数\" class=\"headerlink\" title=\"常用的内存对齐函数\"></a>常用的内存对齐函数</h2><p>因为AVX中要求mem__addr必须在32字节边界上对齐，否则可能会产生通用保护异常。  </p>\n<h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span>*\ta =(<span class=\"hljs-keyword\">double</span>*)<span class=\"hljs-built_in\">memalign</span>(<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">9</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>));<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span>*\ta =(<span class=\"hljs-keyword\">double</span>*)_mm_malloc(<span class=\"hljs-number\">9</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>),<span class=\"hljs-number\">32</span>);<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">double</span>*\ta =(<span class=\"hljs-keyword\">double</span>*)<span class=\"hljs-built_in\">aligned_alloc</span>(<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">9</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>));<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__attribute__ ((<span class=\"hljs-built_in\">aligned</span>(<span class=\"hljs-number\">32</span>)))<span class=\"hljs-keyword\">double</span> a[<span class=\"hljs-number\">9</span>]  =&#123;<span class=\"hljs-number\">1.1</span>,<span class=\"hljs-number\">2.2</span>,<span class=\"hljs-number\">3.3</span>,<span class=\"hljs-number\">4.4</span>,<span class=\"hljs-number\">5.5</span>,<span class=\"hljs-number\">6.6</span>,<span class=\"hljs-number\">7.7</span>,<span class=\"hljs-number\">8.8</span>,<span class=\"hljs-number\">2.1</span>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256d _mm256_load_pd (<span class=\"hljs-keyword\">double</span> <span class=\"hljs-keyword\">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Description</strong></p>\n<p>Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>\n<p><strong>Operation</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">dst[<span class=\"hljs-number\">255</span>:<span class=\"hljs-number\">0</span>] := MEM[mem_addr+<span class=\"hljs-number\">255</span>:mem_addr]<br>dst[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-1\"><a href=\"#2-1\" class=\"headerlink\" title=\"2.\"></a>2.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256 _mm256_add_ps (__m256 a, __m256 b)<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Description</strong></p>\n<p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p>\n<p><strong>Operation</strong></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">FOR</span> j := <span class=\"hljs-number\">0</span> to <span class=\"hljs-number\">7</span><br>\t<span class=\"hljs-attribute\">i</span> := j*<span class=\"hljs-number\">32</span><br>\t<span class=\"hljs-attribute\">dst</span>[i+<span class=\"hljs-number\">31</span>:i] := a[i+<span class=\"hljs-number\">31</span>:i] + b[i+<span class=\"hljs-number\">31</span>:i]<br><span class=\"hljs-attribute\">ENDFOR</span><br><span class=\"hljs-attribute\">dst</span>[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3-stream的作用：绕过缓存直接写入内存\"><a href=\"#3-stream的作用：绕过缓存直接写入内存\" class=\"headerlink\" title=\"3.stream的作用：绕过缓存直接写入内存\"></a>3.stream的作用：绕过缓存直接写入内存</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">void</span> _mm256_stream_pd (<span class=\"hljs-keyword\">double</span> * mem_addr, __m256d a)<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Description</strong></p>\n<p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>\n<p><strong>Operation</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">MEM[mem_addr+<span class=\"hljs-number\">255</span>:mem_addr] := a[<span class=\"hljs-number\">255</span>:<span class=\"hljs-number\">0</span>]<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"样例程序举例：\"><a href=\"#样例程序举例：\" class=\"headerlink\" title=\"样例程序举例：\"></a>样例程序举例：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;malloc.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;immintrin.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span>*\ta =(<span class=\"hljs-keyword\">double</span>*)<span class=\"hljs-built_in\">memalign</span>(<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">9</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>));<br>\t<span class=\"hljs-keyword\">double</span>*\tb =(<span class=\"hljs-keyword\">double</span>*)<span class=\"hljs-built_in\">memalign</span>(<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">4</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>));<br>\t<span class=\"hljs-keyword\">double</span> af[<span class=\"hljs-number\">9</span>]=&#123;<span class=\"hljs-number\">1.1</span>,<span class=\"hljs-number\">2.2</span>,<span class=\"hljs-number\">3.3</span>,<span class=\"hljs-number\">4.4</span>,<span class=\"hljs-number\">5.5</span>,<span class=\"hljs-number\">6.6</span>,<span class=\"hljs-number\">7.7</span>,<span class=\"hljs-number\">8.8</span>,<span class=\"hljs-number\">2.1</span>&#125; ;<br>\t<span class=\"hljs-keyword\">double</span> bf[<span class=\"hljs-number\">9</span>]=&#123;<span class=\"hljs-number\">2.1</span>,<span class=\"hljs-number\">3.2</span>,<span class=\"hljs-number\">6.4</span>,<span class=\"hljs-number\">8.6</span>,<span class=\"hljs-number\">3.7</span>,<span class=\"hljs-number\">9.9</span>,<span class=\"hljs-number\">5.1</span>,<span class=\"hljs-number\">4.2</span>,<span class=\"hljs-number\">6.6</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span>*\tc =(<span class=\"hljs-keyword\">double</span>*)<span class=\"hljs-built_in\">memalign</span>(<span class=\"hljs-number\">32</span>,<span class=\"hljs-number\">4</span>*<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(<span class=\"hljs-keyword\">double</span>));<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i =<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\ta[i]=af[i];<br>\t\tb[i]=bf[i];<br>\t&#125;<br>\t<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br>\t__m256d v0;<br>\t__m256d v1;<br>\t__m256d v2;<br>\t<span class=\"hljs-keyword\">for</span>(;i&lt;<span class=\"hljs-number\">9</span><span class=\"hljs-number\">-4</span>;i+=<span class=\"hljs-number\">4</span>)<br>\t&#123;\t<br>\t\t\tv0 = _mm256_load_pd(a+i);<br>\t\t\tv1 = _mm256_load_pd(b+i);<br>\t\t\tv2=_mm256_add_pd(v0,v1);<br>\t\t \t_mm256_stream_pd(c+i,v2);<br>\t\t\t<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\tc[i]=a[i]+b[i];<br>\t<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;this is c.\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%lf\\n&quot;</span>,c[i]);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"样例程序输出：\"><a href=\"#样例程序输出：\" class=\"headerlink\" title=\"样例程序输出：\"></a>样例程序输出：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">this</span> is c.<br><span class=\"hljs-number\">3.200000</span><br><span class=\"hljs-number\">5.400000</span><br><span class=\"hljs-number\">9.700000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">9.200000</span><br><span class=\"hljs-number\">16.500000</span><br><span class=\"hljs-number\">12.800000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">8.700000</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/",
            "url": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/",
            "title": "AVX向量化学习(一)",
            "date_published": "2022-06-12T07:11:29.538Z",
            "content_html": "<h1 id=\"AVX指令集的简单操作\"><a href=\"#AVX指令集的简单操作\" class=\"headerlink\" title=\"AVX指令集的简单操作\"></a>AVX指令集的简单操作</h1><p>使用AVX指令集进行2个double型的数组相加操作</p>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256 _mm256_loadu_ps (<span class=\"hljs-keyword\">float</span> <span class=\"hljs-keyword\">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>\n<h3 id=\"Operation\"><a href=\"#Operation\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">dst[<span class=\"hljs-number\">255</span>:<span class=\"hljs-number\">0</span>] := MEM[mem_addr+<span class=\"hljs-number\">255</span>:mem_addr]<br>dst[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256d _mm256_add_pd (__m256d a, __m256d b)<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"Description-1\"><a href=\"#Description-1\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p>\n<h3 id=\"Operation-1\"><a href=\"#Operation-1\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">FOR j := <span class=\"hljs-number\">0</span> to <span class=\"hljs-number\">3</span><br>\ti := j*<span class=\"hljs-number\">64</span><br>\tdst[i+<span class=\"hljs-number\">63</span>:i] := a[i+<span class=\"hljs-number\">63</span>:i] + b[i+<span class=\"hljs-number\">63</span>:i]<br>ENDFOR<br>dst[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">void</span> _mm256_storeu_pd (<span class=\"hljs-keyword\">double</span> * mem_addr, __m256d a)<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"Description-2\"><a href=\"#Description-2\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>\n<h3 id=\"Operation-2\"><a href=\"#Operation-2\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">MEM[mem_addr+<span class=\"hljs-number\">255</span>:mem_addr] := a[<span class=\"hljs-number\">255</span>:<span class=\"hljs-number\">0</span>]<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"未进行AVX向量化的情况\"><a href=\"#未进行AVX向量化的情况\" class=\"headerlink\" title=\"未进行AVX向量化的情况\"></a>未进行AVX向量化的情况</h2><h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span> a[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">1.1</span>,<span class=\"hljs-number\">2.2</span>,<span class=\"hljs-number\">3.3</span>,<span class=\"hljs-number\">4.4</span>,<span class=\"hljs-number\">5.5</span>,<span class=\"hljs-number\">6.6</span>,<span class=\"hljs-number\">7.7</span>,<span class=\"hljs-number\">8.8</span>,<span class=\"hljs-number\">2.1</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span> b[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">2.1</span>,<span class=\"hljs-number\">3.2</span>,<span class=\"hljs-number\">6.4</span>,<span class=\"hljs-number\">8.6</span>,<span class=\"hljs-number\">3.7</span>,<span class=\"hljs-number\">9.9</span>,<span class=\"hljs-number\">5.1</span>,<span class=\"hljs-number\">4.2</span>,<span class=\"hljs-number\">6.6</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span> c[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>\t<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span> ;i&lt;<span class=\"hljs-number\">9</span>;i++)\t<br>\t&#123;<br>\t\tc[i]=a[i]+b[i];<br>\t\t<br>\t&#125;<br>\t<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;this is c.\\n&quot;</span>);<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%lf\\n&quot;</span>,c[i]);<br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">this</span> is c.<br><span class=\"hljs-number\">3.200000</span><br><span class=\"hljs-number\">5.400000</span><br><span class=\"hljs-number\">9.700000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">9.200000</span><br><span class=\"hljs-number\">16.500000</span><br><span class=\"hljs-number\">12.800000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">8.700000</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"进行AVX向量化的情况\"><a href=\"#进行AVX向量化的情况\" class=\"headerlink\" title=\"进行AVX向量化的情况\"></a>进行AVX向量化的情况</h2><h3 id=\"程序源代码-1\"><a href=\"#程序源代码-1\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;immintrin.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">double</span> a[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">1.1</span>,<span class=\"hljs-number\">2.2</span>,<span class=\"hljs-number\">3.3</span>,<span class=\"hljs-number\">4.4</span>,<span class=\"hljs-number\">5.5</span>,<span class=\"hljs-number\">6.6</span>,<span class=\"hljs-number\">7.7</span>,<span class=\"hljs-number\">8.8</span>,<span class=\"hljs-number\">2.1</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span> b[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">2.1</span>,<span class=\"hljs-number\">3.2</span>,<span class=\"hljs-number\">6.4</span>,<span class=\"hljs-number\">8.6</span>,<span class=\"hljs-number\">3.7</span>,<span class=\"hljs-number\">9.9</span>,<span class=\"hljs-number\">5.1</span>,<span class=\"hljs-number\">4.2</span>,<span class=\"hljs-number\">6.6</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span> c[<span class=\"hljs-number\">9</span>] = &#123;<span class=\"hljs-number\">0</span>&#125;;<br>\t__m256d v0;<br>\t__m256d v1;<br>\t__m256d v2;<br>\t<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span>(;i&lt;<span class=\"hljs-number\">9</span><span class=\"hljs-number\">-4</span>;i+=<span class=\"hljs-number\">4</span>)<br>\t&#123;\t<br>\t\t\tv0 = _mm256_loadu_pd(a+i);<br>\t\t\tv1 = _mm256_loadu_pd(b+i);<br>\t\t\tv2=_mm256_add_pd(v0,v1);<br>\t\t \t_mm256_storeu_pd(c+i,v2);<br>\t\t\t<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\tc[i]=a[i]+b[i];<br>\t<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;this is c with AVX.\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%lf\\n&quot;</span>,c[i]);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br> &#125; <br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"程序输出-1\"><a href=\"#程序输出-1\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">this</span> is c with AVX.<br><span class=\"hljs-number\">3.200000</span><br><span class=\"hljs-number\">5.400000</span><br><span class=\"hljs-number\">9.700000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">9.200000</span><br><span class=\"hljs-number\">16.500000</span><br><span class=\"hljs-number\">12.800000</span><br><span class=\"hljs-number\">13.000000</span><br><span class=\"hljs-number\">8.700000</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“ Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/05/20/slurm001/",
            "url": "http://example.com/2022/05/20/slurm001/",
            "title": "Slurm",
            "date_published": "2022-05-20T09:43:02.000Z",
            "content_html": "<h2 id=\"Slurm\"><a href=\"#Slurm\" class=\"headerlink\" title=\"Slurm\"></a>Slurm</h2><h4 id=\"1-sstat-查看RUNNING作业\"><a href=\"#1-sstat-查看RUNNING作业\" class=\"headerlink\" title=\"1.sstat 查看RUNNING作业\"></a>1.sstat 查看RUNNING作业</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">sstat -e<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/slurm001/image-20220520174453969.png\" alt=\"image-20220520174453969\"></p>\n<p><strong>使用举例：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">sstat -a --format=&quot;JobId,Pids,AveCPU,AveRSS,MaxRSS&quot;  1755818<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/slurm001/image-20220520175001331.png\" alt=\"image-20220520175001331\"></p>\n<h4 id=\"2-sacct-查看FINISHED作业\"><a href=\"#2-sacct-查看FINISHED作业\" class=\"headerlink\" title=\"2.sacct 查看FINISHED作业\"></a>2.sacct 查看FINISHED作业</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">sacct -e<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/slurm001/image-20220520174622868.png\" alt=\"image-20220520174622868\"></p>\n<p><strong>使用举例：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">sacct --format=&quot;JobId,Elapsed,CPUTime,CPUTimeRAW,AveCPU,TotalCPU,UserCPU,SystemCPU,AveRSS,MaxRSS&quot; -j 1754217<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/slurm001/image-20220520174807162.png\" alt=\"image-20220520174807162\"></p>\n<h4 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h4><p><a href=\"https://blog.csdn.net/kongxx/article/details/52556943\">(28条消息) Slurm查看作业CPU和MEM_kongxx的博客-CSDN博客_slurm 查看节点</a></p>\n",
            "tags": [
                "Linux",
                "Slurm"
            ]
        },
        {
            "id": "http://example.com/2022/05/20/numactl001/",
            "url": "http://example.com/2022/05/20/numactl001/",
            "title": "numactl",
            "date_published": "2022-05-20T09:35:59.000Z",
            "content_html": "<ol>\n<li></li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shell\">numactl --hardware<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/numactl001/image-20220520173911653.png\" alt=\"image-20220520173911653\"></p>\n<ol start=\"2\">\n<li></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs shelll\">numastat<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/numactl001/image-20220520174030171.png\" alt=\"image-20220520174030171\"></p>\n<ol start=\"3\">\n<li></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">numactl --show<br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2022/05/20/numactl001/image-20220520174148487.png\" alt=\"image-20220520174148487\"></p>\n<h5 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h5><p><a href=\"https://blog.csdn.net/qccz123456/article/details/81979819\">(28条消息) Linux工具之numactl_qccz123456的博客-CSDN博客_numactl</a></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1699088343604813491&wfr=spider&for=pc&searchword=numactl\">宋宝华：为什么numactl内存绑定对代码段不起作用 (baidu.com)</a></p>\n",
            "tags": [
                "Linux",
                "Numactl"
            ]
        },
        {
            "id": "http://example.com/2022/05/08/tool004/",
            "url": "http://example.com/2022/05/08/tool004/",
            "title": "gcov代码覆盖率测试-完整样例-SLIC",
            "date_published": "2022-05-08T02:34:59.000Z",
            "content_html": "<h2 id=\"gcov代码覆盖率测试-完整样例-SLIC\"><a href=\"#gcov代码覆盖率测试-完整样例-SLIC\" class=\"headerlink\" title=\"gcov代码覆盖率测试-完整样例-SLIC\"></a>gcov代码覆盖率测试-完整样例-SLIC</h2><h3 id=\"gcov代码覆盖率测试介绍：\"><a href=\"#gcov代码覆盖率测试介绍：\" class=\"headerlink\" title=\"gcov代码覆盖率测试介绍：\"></a>gcov代码覆盖率测试介绍：</h3><p><a href=\"https://xingyuanjie.top/2022/01/18/tool002/\">gcov代码覆盖率测试 - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n<h3 id=\"完整样例-SLIC：\"><a href=\"#完整样例-SLIC：\" class=\"headerlink\" title=\"完整样例-SLIC：\"></a>完整样例-SLIC：</h3><p><a href=\"https://xingyuanjie.top/2022/05/08/tool004/result.zip\">https://xingyuanjie.top/2022/05/08/tool004/result.zip</a></p>\n",
            "tags": [
                "性能分析工具",
                "gcov"
            ]
        },
        {
            "id": "http://example.com/2022/04/02/mpi006/",
            "url": "http://example.com/2022/04/02/mpi006/",
            "title": "MPI学习(六)-两个矩阵相加MPI版本",
            "date_published": "2022-04-02T08:07:46.000Z",
            "content_html": "<h1 id=\"MPI学习-六-两个矩阵相加MPI版本\"><a href=\"#MPI学习-六-两个矩阵相加MPI版本\" class=\"headerlink\" title=\"MPI学习(六)-两个矩阵相加MPI版本\"></a>MPI学习(六)-两个矩阵相加MPI版本</h1><p>这里，我们演示了两个简单的程序，一个是矩阵相加串行版本，一个是矩阵相加MPI版本</p>\n<h2 id=\"串行版本\"><a href=\"#串行版本\" class=\"headerlink\" title=\"串行版本\"></a>串行版本</h2><h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;string.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> a[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<br>\t\t\t\t<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<br>\t\t\t\t<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">11</span>,<span class=\"hljs-number\">12</span>,<br>\t\t\t\t<span class=\"hljs-number\">13</span>,<span class=\"hljs-number\">14</span>,<span class=\"hljs-number\">15</span>,<span class=\"hljs-number\">16</span>&#125;;<br>\t<span class=\"hljs-keyword\">int</span> b[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>]=&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>,<br>\t\t\t\t<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>,<br>\t\t\t\t<span class=\"hljs-number\">11</span>,<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">17</span>,<span class=\"hljs-number\">5</span>,<br>\t\t\t\t<span class=\"hljs-number\">15</span>,<span class=\"hljs-number\">14</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">3</span>&#125;;<br>\t<span class=\"hljs-keyword\">int</span> c[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>];<br>\t<span class=\"hljs-built_in\">memset</span>(c,<span class=\"hljs-number\">0</span>,<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(c)); <br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">4</span>;j++)<br>\t\t&#123;<br>\t\t\tc[i][j]=a[i][j]+b[i][j];<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">4</span>;j++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>,c[i][j]);<br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">11</span><br><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">15</span> <span class=\"hljs-number\">17</span><br><span class=\"hljs-number\">20</span> <span class=\"hljs-number\">22</span> <span class=\"hljs-number\">28</span> <span class=\"hljs-number\">17</span><br><span class=\"hljs-number\">28</span> <span class=\"hljs-number\">28</span> <span class=\"hljs-number\">35</span> <span class=\"hljs-number\">19</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"MPI版本\"><a href=\"#MPI版本\" class=\"headerlink\" title=\"MPI版本\"></a>MPI版本</h2><h3 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h3><p>北京超级云计算中心A3分区</p>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h3 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h3><p>mpicxx mpi006.c -o mpi006</p>\n<h3 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h3><p>srun -p amd_256 -N 1 -n  5  .&#x2F;mpi006(使用SLURM任务调度系统)</p>\n<p>1个分区，核数为5</p>\n<h3 id=\"程序源代码-1\"><a href=\"#程序源代码-1\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;string.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;mpi.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc ,<span class=\"hljs-keyword\">char</span> **argv)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> a[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<br>\t\t\t\t<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<br>\t\t\t\t<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">11</span>,<span class=\"hljs-number\">12</span>,<br>\t\t\t\t<span class=\"hljs-number\">13</span>,<span class=\"hljs-number\">14</span>,<span class=\"hljs-number\">15</span>,<span class=\"hljs-number\">16</span>&#125;;<br>\t<span class=\"hljs-keyword\">int</span> b[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>]=&#123;<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>,<br>\t\t\t\t<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>,<br>\t\t\t\t<span class=\"hljs-number\">11</span>,<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">17</span>,<span class=\"hljs-number\">5</span>,<br>\t\t\t\t<span class=\"hljs-number\">15</span>,<span class=\"hljs-number\">14</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">3</span>&#125;;<br>\t<span class=\"hljs-keyword\">int</span> c[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>];<br>\t<span class=\"hljs-keyword\">int</span> tmp[<span class=\"hljs-number\">4</span>];<br>\t<span class=\"hljs-built_in\">memset</span>(c,<span class=\"hljs-number\">0</span>,<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(c));<br>\t<span class=\"hljs-keyword\">int</span> myid, numprocs;<br>\tMPI_Status status;<br>\tMPI_Request request;<br>\t<span class=\"hljs-built_in\">MPI_Init</span>(&amp;argc,&amp;argv);<br>\t<span class=\"hljs-built_in\">MPI_Comm_size</span>(MPI_COMM_WORLD,&amp;numprocs);<br>\t<span class=\"hljs-built_in\">MPI_Comm_rank</span>(MPI_COMM_WORLD,&amp;myid);<br>\t<span class=\"hljs-keyword\">if</span>(myid == <span class=\"hljs-number\">0</span>)\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//0号进程接受来自其他进程的消息</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;numprocs;i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">MPI_Irecv</span>(&amp;c[i<span class=\"hljs-number\">-1</span>][<span class=\"hljs-number\">0</span>],<span class=\"hljs-number\">4</span>,MPI_INT,i,<span class=\"hljs-number\">0</span>,MPI_COMM_WORLD,&amp;request);\t\t<span class=\"hljs-comment\">//采用非阻塞接受</span><br>\t\t\t<span class=\"hljs-built_in\">MPI_Wait</span>(&amp;request,&amp;status);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)\t\t\t\t\t\t\t<span class=\"hljs-comment\">//打印矩阵</span><br>\t\t&#123;<br>\t\t\t<br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">4</span>;j++)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>,c[i][j]);<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(myid != <span class=\"hljs-number\">0</span> )\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//当进程不是0号进程时，则向0号进程发送消息</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">memset</span>(tmp,<span class=\"hljs-number\">0</span>,<span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(tmp));\t\t\t\t\t\t<span class=\"hljs-comment\">//初始化tmp数组</span><br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">4</span>;i++)<br>\t\t&#123;<br>\t\t\ttmp[i]=a[myid<span class=\"hljs-number\">-1</span>][i]+b[myid<span class=\"hljs-number\">-1</span>][i];\t\t\t<span class=\"hljs-comment\">//用tmp来临时存储相加结果，随后发送给0号进程</span><br>\t\t\t<br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">MPI_Isend</span>(&amp;tmp,<span class=\"hljs-number\">4</span>,MPI_INT,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,MPI_COMM_WORLD,&amp;request);\t\t\t\t\t<span class=\"hljs-comment\">//采用非阻塞发送</span><br>\t\t<span class=\"hljs-built_in\">MPI_Wait</span>(&amp;request,&amp;status);<br>\t&#125;<br>\t<span class=\"hljs-built_in\">MPI_Finalize</span>();\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"程序输出-1\"><a href=\"#程序输出-1\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">11</span> <br><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">15</span> <span class=\"hljs-number\">17</span> <br><span class=\"hljs-number\">20</span> <span class=\"hljs-number\">22</span> <span class=\"hljs-number\">28</span> <span class=\"hljs-number\">17</span> <br><span class=\"hljs-number\">28</span> <span class=\"hljs-number\">28</span> <span class=\"hljs-number\">35</span> <span class=\"hljs-number\">19</span><br></code></pre></div></td></tr></table></figure>\n\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2022/01/19/tool003/",
            "url": "http://example.com/2022/01/19/tool003/",
            "title": "perf-系统级性能分析工具",
            "date_published": "2022-01-19T03:56:40.000Z",
            "content_html": "<p>系统级性能优化通常包括两个阶段：性能剖析（performance profiling）和代码优化。</p>\n<p>性能剖析的目标是寻找性能瓶颈，查找引发性能问题的原因及热点代码。</p>\n<p>代码优化的目标是针对具体性能问题而优化代码或编译选项，以改善软件性能。</p>\n<p>在性能剖析阶段，需要借助于现有的profiling工具，如perf等。在代码优化阶段往往需要借助开发者的经验，编写简洁高效的代码，甚至在汇编级别合理使用各种指令，合理安排各种指令的执行顺序。</p>\n<p>perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。<br>通过perf，应用程序可以利用PMU、tracepoint和内核中的计数器来进行性能统计。它不但可以分析制定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用程序和内核，从而全面理解应用程序中的性能瓶颈。</p>\n<p>使用perf，可以分析程序运行期间发生的硬件事件，比如instructions retired、processor clock cycles等；也可以分析软件时间，比如page fault和进程切换。</p>\n<p>perf是一款综合性分析工具，大到系统全局性性能，再小到进程线程级别，甚至到函数及汇编级别。</p>\n<p>perf提供了十八般武器，可以拿大刀大卸八块，也可以拿起手术刀细致分析。</p>\n<h1 id=\"1-背景知识\"><a href=\"#1-背景知识\" class=\"headerlink\" title=\"1. 背景知识\"></a>1. 背景知识</h1><h2 id=\"1-1-tracepoints\"><a href=\"#1-1-tracepoints\" class=\"headerlink\" title=\"1.1 tracepoints\"></a>1.1 tracepoints</h2><p>tracepoints是散落在内核源码中的一些hook，它们可以在特定的代码被执行到时触发，这一特定可以被各种trace&#x2F;debug工具所使用。</p>\n<p>perf将tracepoint产生的时间记录下来，生成报告，通过分析这些报告，便可以了解程序运行期间内核的各种细节，对性能症状做出准确的诊断。</p>\n<p>这些tracepint的对应的sysfs节点在&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events目录下。</p>\n<h2 id=\"1-2-硬件特性之cache\"><a href=\"#1-2-硬件特性之cache\" class=\"headerlink\" title=\"1.2 硬件特性之cache\"></a>1.2 硬件特性之cache</h2><p>内存读写是很快的，但是还是无法和处理器指令执行速度相比。为了从内存中读取指令和数据，处理器需要等待，用处理器时间来衡量，这种等待非常漫长。cache是一种SRAM，读写速度非常快，能和处理器相匹配。因此将常用的数据保存在cache中，处理器便无需等待，从而提高性能。cache的尺寸一般都很小，充分利用cache是软件调优非常重要部分。</p>\n<h1 id=\"2-主要关注点\"><a href=\"#2-主要关注点\" class=\"headerlink\" title=\"2. 主要关注点\"></a>2. 主要关注点</h1><p>基于性能分析，可以进行算法优化（空间复杂度和时间复杂度权衡）、代码优化（提高执行速度、减少内存占用）。</p>\n<p>评估程序对硬件资源的使用情况，例如各级cache的访问次数、各级cache的丢失次数、流水线停顿周期、前端总线访问次数等。</p>\n<p>评估程序对操作系统资源的使用情况，系统调用次数、上下文切换次数、任务迁移次数。</p>\n<p>事件可以分为三种：</p>\n<ol>\n<li>Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。</li>\n<li>Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如进程切换，tick数等。</li>\n<li>Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。</li>\n</ol>\n<h1 id=\"3-perf的使用\"><a href=\"#3-perf的使用\" class=\"headerlink\" title=\"3. perf的使用\"></a>3. perf的使用</h1><p>perf –help后可以看到perf的二级命令</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119120817508.png\"></p>\n<h2 id=\"3-1perf-list\"><a href=\"#3-1perf-list\" class=\"headerlink\" title=\"3.1perf list\"></a>3.1perf list</h2><p>perf list查看支持的事件类型</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119121131231.png\"></p>\n<h2 id=\"3-2perf-top\"><a href=\"#3-2perf-top\" class=\"headerlink\" title=\"3.2perf top\"></a>3.2perf top</h2><p>即可以正常显示perf top如下：</p>\n<p>第一列：符号引发的性能事件的比例，指占用的cpu周期比例。</p>\n<p>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。</p>\n<p>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库；[k]表述此符号属于内核或模块。</p>\n<p>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119121453395.png\"></p>\n<h2 id=\"3-3-perf-stat\"><a href=\"#3-3-perf-stat\" class=\"headerlink\" title=\"3.3 perf stat\"></a>3.3 perf stat</h2><p>perf stat用于运行指令，并分析其统计结果。虽然perf top也可以指定pid，但是必须先启动应用才能查看信息。</p>\n<p>perf stat能完整统计应用整个生命周期的信息。</p>\n<p>命令格式为：</p>\n<blockquote>\n<p>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] <command><br>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] — <command> [<options>]</options></EVENT></EVENT></p>\n</blockquote>\n<p><img src=\"/2022/01/19/tool003/image-20220119122351095.png\" alt=\"image-20220119122351095\"></p>\n<p><img src=\"/2022/01/19/tool003/C2DDB2280E83453D6D8FE0D11A4380C3.png\"></p>\n<p>cpu-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized &#x3D; task-clock &#x2F; time elapsed，CPU的占用率。</p>\n<p>context-switches：程序在运行过程中上下文的切换次数。</p>\n<p>CPU-migrations：程序在运行过程中发生的处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。</p>\n<p>CPU迁移和上下文切换：发生上下文切换不一定会发生CPU迁移，而发生CPU迁移时肯定会发生上下文切换。发生上下文切换有可能只是把上下文从当前CPU中换出，下一次调度器还是将进程安排在这个CPU上执行。</p>\n<p>page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。</p>\n<p>cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles &#x2F; task-clock算出。</p>\n<p>stalled-cycles-frontend：指令读取或解码的质量步骤，未能按理想状态发挥并行左右，发生停滞的时钟周期。</p>\n<p>stalled-cycles-backend：指令执行步骤，发生停滞的时钟周期。</p>\n<p>instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。</p>\n<p>branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p>\n<h2 id=\"3-4-perf-record-amp-report\"><a href=\"#3-4-perf-record-amp-report\" class=\"headerlink\" title=\"3.4 perf record &amp; report\"></a>3.4 perf record &amp; report</h2><p>运行一个命令，并将其数据保存到perf.data中。随后，可以使用perf report进行分析。</p>\n<p>perf record和perf report可以更精确的分析一个应用，perf record可以精确到函数级别。并且在函数里面混合显示汇编语言和代码。</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119123152290.png\"></p>\n<p>1.编译程序(这里以test.c为例子)</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119124049654.png\"></p>\n<p>2.perf record</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119124217563.png\"></p>\n<p>3.perf report</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119124149337.png\"></p>\n<p><img src=\"/2022/01/19/tool003/image-20220119124013315.png\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.cnblogs.com/arnoldlu/p/6241297.html\">系统级性能分析工具perf的介绍与使用 - ArnoldLu - 博客园 (cnblogs.com)</a>-系统性能分析工具perf的介绍与使用</p>\n<p><a href=\"https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=11304698501320722134&spm_id_from=333.337.0.0\">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>\n",
            "tags": [
                "性能分析工具"
            ]
        },
        {
            "id": "http://example.com/2022/01/18/tool002/",
            "url": "http://example.com/2022/01/18/tool002/",
            "title": "gcov代码覆盖率测试",
            "date_published": "2022-01-18T06:35:05.000Z",
            "content_html": "<h1 id=\"gcov代码覆盖率测试\"><a href=\"#gcov代码覆盖率测试\" class=\"headerlink\" title=\"gcov代码覆盖率测试\"></a>gcov代码覆盖率测试</h1><h2 id=\"gcov的简单介绍\"><a href=\"#gcov的简单介绍\" class=\"headerlink\" title=\"gcov的简单介绍\"></a>gcov的简单介绍</h2><p>1.gcov是一个测试代码覆盖率的工具。与GCC一起使用来分析程序，以帮助创建更高效、更快的运行代码，并发现程序的未测试部分<br>2.是一个命令行方式的控制台程序。需要结合lcov,gcovr等前端图形工具才能实现统计数据图形化<br>3.伴随GCC发布，不需要单独下载gcov工具。配合GCC共同实现对c&#x2F;c++文件的语句覆盖和分支覆盖测试<br>4.与程序概要分析工具（profiling tool，例如gprof）一起工作，可以估计程序中哪段代码最耗时</p>\n<h2 id=\"gcov能做什么\"><a href=\"#gcov能做什么\" class=\"headerlink\" title=\"gcov能做什么\"></a>gcov能做什么</h2><p>使用像gcov或gprof这样的分析器，您可以找到一些基本的性能统计数据：</p>\n<ul>\n<li>每一行代码执行的频率是多少</li>\n<li>实际执行了哪些行代码，配合测试用例达到满意的覆盖率和预期工作</li>\n<li>每段代码使用了多少计算时间，从而找到热点优化代码</li>\n<li>gcov创建一个sourcefile.gcov的日志文件，此文件标识源文件sourcefile.c每一行执行的次数,您可以与gprof一起使用这些日志文件来帮助优化程序的性能。gprof提供了您可以使用的时间信息以及从gcov获得的信息。</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>1.通过将一些代码行合并到一个函数中，可能不会提供足够的信息来查找代码使用大量计算机时间的“热点”。同样地，由于gcov按行(在最低的分辨率下)积累统计数据，它最适合于只在每行上放置一个语句的编程风格。如果您使用扩展到循环或其他控制结构的复杂宏，那么统计信息就没有那么有用了——它们只报告出现宏调用的行。如果您的复杂宏的行为类似于函数，那么您可以用inline fu替换它们。<br>2.gcov只在使用GCC编译的代码上工作。它与任何其他概要或测试覆盖机制不兼容。</p>\n<h2 id=\"使用gcov的3个阶段\"><a href=\"#使用gcov的3个阶段\" class=\"headerlink\" title=\"使用gcov的3个阶段\"></a>使用gcov的3个阶段</h2><h3 id=\"1-编译阶段\"><a href=\"#1-编译阶段\" class=\"headerlink\" title=\"1.编译阶段\"></a>1.编译阶段</h3><p>要开启gcov功能，需要在源码编译参数中加入-fprofile-arcs -ftest-coverage</p>\n<ul>\n<li>-ftest-coverage：在编译的时候产生.gcno文件，它包含了重建基本块图和相应的块的源码的行号的信息。</li>\n<li>-fprofile-arcs：在运行编译过的程序的时候，会产生.gcda文件，它包含了弧跳变的次数等信息。</li>\n</ul>\n<p>以下我们以test.c这个程序为例子，源码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> n=<span class=\"hljs-number\">4</span>;<br>\t<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>\t&#123;<br>\t   <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello World!\\n&quot;</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">int</span> a =<span class=\"hljs-number\">20220118</span>;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>,a);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>编译阶段：</strong></p>\n<p><img src=\"/2022/01/18/tool002/image-20220118145007919.png\"></p>\n<h3 id=\"2-gcov收集代码运行信息\"><a href=\"#2-gcov收集代码运行信息\" class=\"headerlink\" title=\"2. gcov收集代码运行信息\"></a>2. gcov收集代码运行信息</h3><ul>\n<li>运行<code>./test</code>产生<code>test.gcda</code>文件，其中包含了代码基本块和狐跳变次数统计信息</li>\n</ul>\n<p><img src=\"/2022/01/18/tool002/image-20220118145103922.png\"></p>\n<h4 id=\"3-生成gcov代码覆盖率报告\"><a href=\"#3-生成gcov代码覆盖率报告\" class=\"headerlink\" title=\"3. 生成gcov代码覆盖率报告\"></a>3. 生成gcov代码覆盖率报告</h4><ul>\n<li>再次运行<code>gcov test.c</code>产生的<code>test.c.gcov</code>中包含了代码覆盖率数据,其数据的来源为<code>test.gcda</code></li>\n</ul>\n<p><img src=\"/2022/01/18/tool002/image-20220118145303290.png\"></p>\n<h3 id=\"4-查看生成gcov代码覆盖率报告\"><a href=\"#4-查看生成gcov代码覆盖率报告\" class=\"headerlink\" title=\"4.查看生成gcov代码覆盖率报告\"></a>4.查看生成gcov代码覆盖率报告</h3><p><img src=\"/2022/01/18/tool002/image-20220118145514099.png\"></p>\n<p>可以看到以下结果：</p>\n<ul>\n<li>其中<code>#####</code>表示未运行的行</li>\n<li>每行前面的数字表示行运行的次数</li>\n<li>—代表不必执行</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c\">-:    <span class=\"hljs-number\">0</span>:Source:test.c<br>-:    <span class=\"hljs-number\">0</span>:Graph:test.gcno<br>-:    <span class=\"hljs-number\">0</span>:Data:test.gcda<br>-:    <span class=\"hljs-number\">0</span>:Runs:<span class=\"hljs-number\">1</span><br>-:    <span class=\"hljs-number\">0</span>:Programs:<span class=\"hljs-number\">1</span><br>-:    <span class=\"hljs-number\">1</span>:<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-number\">1</span>:    <span class=\"hljs-number\">2</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">-:    3:</span>&#123;<br><span class=\"hljs-number\">1</span>:    <span class=\"hljs-number\">4</span>:        <span class=\"hljs-keyword\">int</span> n=<span class=\"hljs-number\">4</span>;<br><span class=\"hljs-number\">1</span>:    <span class=\"hljs-number\">5</span>:        <span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-number\">5</span>:    <span class=\"hljs-number\">6</span>:        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>-:    <span class=\"hljs-number\">7</span>:        &#123;<br><span class=\"hljs-number\">4</span>:    <span class=\"hljs-number\">8</span>:           <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello World!\\n&quot;</span>);<br>-:    <span class=\"hljs-number\">9</span>:        &#125;<br><span class=\"hljs-number\">1</span>:   <span class=\"hljs-number\">10</span>:        <span class=\"hljs-keyword\">int</span> a =<span class=\"hljs-number\">20220118</span>;<br><span class=\"hljs-number\">1</span>:   <span class=\"hljs-number\">11</span>:        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>,a);<br><span class=\"hljs-number\">1</span>:   <span class=\"hljs-number\">12</span>:        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>-:   <span class=\"hljs-number\">13</span>:&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"配合lcov使用，图形化显示\"><a href=\"#配合lcov使用，图形化显示\" class=\"headerlink\" title=\"配合lcov使用，图形化显示\"></a>配合lcov使用，图形化显示</h2><p><strong>1.centos安装lcov:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">yum install lcov<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>2.运行lcov，生成相应信息</strong></p>\n<p><img src=\"/2022/01/18/tool002/image-20220118151526665.png\"></p>\n<p>运行结果：</p>\n<p><img src=\"/2022/01/18/tool002/image-20220118151553801.png\"></p>\n<p><strong>3.生成web可视化信息</strong></p>\n<p><img src=\"/2022/01/18/tool002/image-20220118151821325.png\"></p>\n<p>运行结果：</p>\n<p><img src=\"/2022/01/18/tool002/image-20220118151853477.png\"></p>\n<p><strong>4.打包result文件</strong></p>\n<p><img src=\"/2022/01/18/tool002/image-20220118152629648.png\"></p>\n<p><strong>5.从服务器下载到本地</strong></p>\n<p><img src=\"/2022/01/18/tool002/image-20220118152705023.png\"></p>\n<p><strong>6.查看web</strong></p>\n<p>​\t\t\t\t\t1）查看index.html：</p>\n<p><img src=\"/2022/01/18/tool002/image-20220118152825105.png\"></p>\n<p>​\t\t\t\t\t\t2）详细信息：</p>\n<p><img src=\"/2022/01/18/tool002/image-20220118152908078.png\"></p>\n<p>上述界面包含：</p>\n<ul>\n<li>函数覆盖率（执行率）</li>\n<li>代码行数覆盖率（执行率）</li>\n<li>语句执行次数</li>\n<li>源码级的详细信息</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/yanxiangyfg/article/details/80989680\">(6条消息) gcov代码覆盖率测试-原理和实践总结_yanxiangyfg的专栏-CSDN博客_gcov代码覆盖率</a>-gcov代码覆盖率测试-原理和实践总结</p>\n<p><a href=\"https://blog.csdn.net/u012247418/article/details/90137291\">(6条消息) 代码覆盖率测试工具：gcov和lcov的使用_ARM-Linux-CSDN博客</a>-代码覆盖率测试工具：gcov和lcov的使用</p>\n<p><a href=\"https://www.cnblogs.com/haoshine/p/5777735.html\">linux文件夹打包命令 - 小作一个 - 博客园 (cnblogs.com)</a>-Linux文件打包命令</p>\n<p><a href=\"https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=16561916178807634748&spm_id_from=333.337.0.0\">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>\n",
            "tags": [
                "性能分析工具"
            ]
        },
        {
            "id": "http://example.com/2022/01/17/AVX005/",
            "url": "http://example.com/2022/01/17/AVX005/",
            "title": "AVX向量化学习(五)-INT型数组相加操作",
            "date_published": "2022-01-17T13:28:22.000Z",
            "content_html": "<h1 id=\"AVX向量化学习-五-INT型数组相加操作\"><a href=\"#AVX向量化学习-五-INT型数组相加操作\" class=\"headerlink\" title=\"AVX向量化学习(五)-INT型数组相加操作\"></a>AVX向量化学习(五)-INT型数组相加操作</h1><p>使用AVX指令集进行2个INT型的数组相加操作</p>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256i _mm256_loadu_si256 (__m256i <span class=\"hljs-keyword\">const</span> * mem_addr)<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Synopsis</strong></p>\n<p>m256i _mm256_loadu_si256 (m256i const * mem_addr)<br>#include &lt;immintrin.h&gt;<br>Instruction: vmovdqu ymm, m256<br>CPUID Flags: AVX</p>\n<p><strong>Description</strong></p>\n<p>Load 256-bits of integer data from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>\n<p><strong>Operation</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">dst[<span class=\"hljs-number\">255</span>:<span class=\"hljs-number\">0</span>] := MEM[mem_addr+<span class=\"hljs-number\">255</span>:mem_addr] <br>dst[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Performance</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Architecture</th>\n<th align=\"center\">Latency</th>\n<th align=\"center\">Throughput (CPI)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Icelake</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0.5</td>\n</tr>\n<tr>\n<td align=\"left\">Skylake</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0.5</td>\n</tr>\n<tr>\n<td align=\"left\">Broadwell</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.25</td>\n</tr>\n<tr>\n<td align=\"left\">Haswell</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.25</td>\n</tr>\n<tr>\n<td align=\"left\">Ivy Bridge</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.5</td>\n</tr>\n</tbody></table>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256i _mm256_add_epi32 (__m256i a, __m256i b)<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Synopsis</strong></p>\n<p>m256i _mm256_add_epi32 (m256i a, __m256i b)<br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd ymm, ymm, ymm<br>CPUID Flags: AVX2</p>\n<p><strong>Description</strong></p>\n<p>Add packed 32-bit integers in a and b, and store the results in dst.</p>\n<p><strong>Operation</strong></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">FOR</span> j := <span class=\"hljs-number\">0</span> to <span class=\"hljs-number\">7</span> <br>\t     <span class=\"hljs-attribute\">i</span> := j*<span class=\"hljs-number\">32</span> <br>\t     <span class=\"hljs-attribute\">dst</span>[i+<span class=\"hljs-number\">31</span>:i] := a[i+<span class=\"hljs-number\">31</span>:i] + b[i+<span class=\"hljs-number\">31</span>:i] <br><span class=\"hljs-attribute\">ENDFOR</span> <br><span class=\"hljs-attribute\">dst</span>[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Performance</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Architecture</th>\n<th align=\"center\">Latency</th>\n<th align=\"center\">Throughput (CPI)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Icelake</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.33</td>\n</tr>\n<tr>\n<td align=\"left\">Skylake</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.33</td>\n</tr>\n<tr>\n<td align=\"left\">Broadwell</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.5</td>\n</tr>\n<tr>\n<td align=\"left\">Haswell</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.5</td>\n</tr>\n</tbody></table>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;immintrin.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> a[<span class=\"hljs-number\">40</span>];<br>\t<span class=\"hljs-keyword\">int</span> b[<span class=\"hljs-number\">40</span>];<br>\t<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">int</span> ans1[<span class=\"hljs-number\">40</span>];    <span class=\"hljs-comment\">//记录串行结果 </span><br>\t<span class=\"hljs-keyword\">int</span> ans2[<span class=\"hljs-number\">40</span>];\t <span class=\"hljs-comment\">//记录AVX向量化后的结果</span><br>\t<span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">40</span>;i++)<br>\t&#123;<br>\t\ta[i]=i;<br>\t\tb[i]=<span class=\"hljs-number\">2</span>*i;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">40</span>;i++)<br>\t&#123;<br>\t\tans1[i]=a[i]+b[i];<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;串行计算结果：\\n&quot;</span>);<br>\t<span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">40</span>;i++)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>,ans1[i]);<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);<br>\t__m256i v0;<br>\t__m256i v1;<br>\t__m256i v2;<br>\t<span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">40</span><span class=\"hljs-number\">-8</span>;i+=<span class=\"hljs-number\">8</span>)<br>\t&#123;\t<br>\t\tv0 = _mm256_loadu_si256((<span class=\"hljs-keyword\">const</span> __m256i*)(a+i));\t <span class=\"hljs-comment\">//强制类型转换</span><br>\t\tv1 = _mm256_loadu_si256((<span class=\"hljs-keyword\">const</span> __m256i*)(b+i));\t <span class=\"hljs-comment\">//强制类型转化</span><br>\t\tv2 = _mm256_add_epi32(v0,v1);     <span class=\"hljs-comment\">//v0+v1</span><br>\t\t_mm256_storeu_si256((__m256i*)(ans2+i),v2);<br>\t\t<br>\t&#125;<span class=\"hljs-comment\">//边界处理</span><br>\t<span class=\"hljs-keyword\">for</span> (;i&lt;<span class=\"hljs-number\">40</span>;i++)<br>\t&#123;<br>\t\tans2[i]=a[i]+b[i];<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;并行计算结果：\\n&quot;</span>);<br>\t<span class=\"hljs-keyword\">for</span> (i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">40</span>;i++)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>,ans2[i]);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">串行计算结果：<br><span class=\"hljs-number\">0</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">12</span> <span class=\"hljs-number\">15</span> <span class=\"hljs-number\">18</span> <span class=\"hljs-number\">21</span> <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">33</span> <span class=\"hljs-number\">36</span> <span class=\"hljs-number\">39</span> <span class=\"hljs-number\">42</span> <span class=\"hljs-number\">45</span> <span class=\"hljs-number\">48</span> <span class=\"hljs-number\">51</span> <span class=\"hljs-number\">54</span> <span class=\"hljs-number\">57</span> <span class=\"hljs-number\">60</span> <span class=\"hljs-number\">63</span> <span class=\"hljs-number\">66</span> <span class=\"hljs-number\">69</span> <span class=\"hljs-number\">72</span> <span class=\"hljs-number\">75</span> <span class=\"hljs-number\">78</span> <span class=\"hljs-number\">81</span> <span class=\"hljs-number\">84</span> <span class=\"hljs-number\">87</span> <span class=\"hljs-number\">90</span> <span class=\"hljs-number\">93</span> <span class=\"hljs-number\">96</span> <span class=\"hljs-number\">99</span> <span class=\"hljs-number\">102</span> <span class=\"hljs-number\">105</span> <span class=\"hljs-number\">108</span> <span class=\"hljs-number\">111</span> <span class=\"hljs-number\">114</span> <span class=\"hljs-number\">117</span><br>并行计算结果：<br><span class=\"hljs-number\">0</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">12</span> <span class=\"hljs-number\">15</span> <span class=\"hljs-number\">18</span> <span class=\"hljs-number\">21</span> <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">27</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">33</span> <span class=\"hljs-number\">36</span> <span class=\"hljs-number\">39</span> <span class=\"hljs-number\">42</span> <span class=\"hljs-number\">45</span> <span class=\"hljs-number\">48</span> <span class=\"hljs-number\">51</span> <span class=\"hljs-number\">54</span> <span class=\"hljs-number\">57</span> <span class=\"hljs-number\">60</span> <span class=\"hljs-number\">63</span> <span class=\"hljs-number\">66</span> <span class=\"hljs-number\">69</span> <span class=\"hljs-number\">72</span> <span class=\"hljs-number\">75</span> <span class=\"hljs-number\">78</span> <span class=\"hljs-number\">81</span> <span class=\"hljs-number\">84</span> <span class=\"hljs-number\">87</span> <span class=\"hljs-number\">90</span> <span class=\"hljs-number\">93</span> <span class=\"hljs-number\">96</span> <span class=\"hljs-number\">99</span> <span class=\"hljs-number\">102</span> <span class=\"hljs-number\">105</span> <span class=\"hljs-number\">108</span> <span class=\"hljs-number\">111</span> <span class=\"hljs-number\">114</span> <span class=\"hljs-number\">117</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“ Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/01/17/AVX004/",
            "url": "http://example.com/2022/01/17/AVX004/",
            "title": "AVX向量化学习(四)-INT类型转化成DOUBLE类型",
            "date_published": "2022-01-17T12:41:56.000Z",
            "content_html": "<h1 id=\"AVX向量化学习-四-INT类型转化成DOUBLE类型\"><a href=\"#AVX向量化学习-四-INT类型转化成DOUBLE类型\" class=\"headerlink\" title=\"AVX向量化学习(四)-INT类型转化成DOUBLE类型\"></a>AVX向量化学习(四)-INT类型转化成DOUBLE类型</h1><p>使用AVX指令集把INT类型转化为DOUBLE类型</p>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m128i _mm_setr_epi32 (<span class=\"hljs-keyword\">int</span> e3, <span class=\"hljs-keyword\">int</span> e2, <span class=\"hljs-keyword\">int</span> e1, <span class=\"hljs-keyword\">int</span> e0)<br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Synopsis</strong></p>\n<p>__m128i _mm_setr_epi32 (int e3, int e2, int e1, int e0)<br>#include &lt;emmintrin.h&gt;<br>Instruction: <strong>Sequence</strong><br>CPUID Flags: SSE2</p>\n<p><strong>Description</strong></p>\n<p>Set packed 32-bit integers in dst with the supplied values in reverse order.</p>\n<p><strong>Operation</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">dst[<span class=\"hljs-number\">31</span>:<span class=\"hljs-number\">0</span>] := e3 <br>dst[<span class=\"hljs-number\">63</span>:<span class=\"hljs-number\">32</span>] := e2 <br>dst[<span class=\"hljs-number\">95</span>:<span class=\"hljs-number\">64</span>] := e1 <br>dst[<span class=\"hljs-number\">127</span>:<span class=\"hljs-number\">96</span>] := e0<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">__m256d _mm256_cvtepi32_pd (__m128i a)<br></code></pre></div></td></tr></table></figure>\n\n\n\n<p><strong>Synopsis</strong></p>\n<p>m256d _mm256_cvtepi32_pd (m128i a)<br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtdq2pd ymm, xmm<br>CPUID Flags: AVX</p>\n<p><strong>Description</strong></p>\n<p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p>\n<p><strong>Operation</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">FOR j := <span class=\"hljs-number\">0</span> to <span class=\"hljs-number\">3</span> <br>    i := j*<span class=\"hljs-number\">32</span> <br>    m := j*<span class=\"hljs-number\">64</span> <br>    dst[m+<span class=\"hljs-number\">63</span>:m] := <span class=\"hljs-built_in\">Convert_Int32_To_FP64</span>(a[i+<span class=\"hljs-number\">31</span>:i]) <br>ENDFOR <br>dst[MAX:<span class=\"hljs-number\">256</span>] := <span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<p><strong>Performance</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Architecture</th>\n<th align=\"center\">Latency</th>\n<th align=\"center\">Throughput (CPI)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Icelake</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"left\">Skylake</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"left\">Broadwell</td>\n<td align=\"center\">6</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"left\">Haswell</td>\n<td align=\"center\">6</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"left\">Ivy Bridge</td>\n<td align=\"center\">4</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>g++ int_to_double.cpp -msse2 -mavx -o test01</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>.&#x2F;test01</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;immintrin.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> a[<span class=\"hljs-number\">4</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>&#125;;<br>\t<span class=\"hljs-keyword\">double</span> b[<span class=\"hljs-number\">9</span>]=&#123;<span class=\"hljs-number\">0</span>&#125;;<br>    __m128i x = _mm_setr_epi32(a[<span class=\"hljs-number\">0</span>], a[<span class=\"hljs-number\">1</span>], a[<span class=\"hljs-number\">2</span>],a[<span class=\"hljs-number\">3</span>]);   <span class=\"hljs-comment\">//load</span><br> \t__m256d v5=_mm256_cvtepi32_pd(x);       <span class=\"hljs-comment\">//convert</span><br>    _mm256_storeu_pd(b,v5);<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">9</span>;i++)<br>    &#123;<br>    \tcout&lt;&lt;b[i]&lt;&lt;endl;<br>\t&#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">4</span><br><span class=\"hljs-number\">0</span><br><span class=\"hljs-number\">0</span><br><span class=\"hljs-number\">0</span><br><span class=\"hljs-number\">0</span><br><span class=\"hljs-number\">0</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“ Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/01/09/tool001/",
            "url": "http://example.com/2022/01/09/tool001/",
            "title": "gprof、gprof2dot.py、dot使用方法简介",
            "date_published": "2022-01-09T08:33:37.000Z",
            "content_html": "<h1 id=\"gprof、gprof2dot-py、dot使用方法简介\"><a href=\"#gprof、gprof2dot-py、dot使用方法简介\" class=\"headerlink\" title=\"gprof、gprof2dot.py、dot使用方法简介\"></a>gprof、gprof2dot.py、dot使用方法简介</h1><h2 id=\"1-：gprof使用步骤如下，以SLIC为例：\"><a href=\"#1-：gprof使用步骤如下，以SLIC为例：\" class=\"headerlink\" title=\"(1)：gprof使用步骤如下，以SLIC为例：\"></a>(1)：gprof使用步骤如下，以SLIC为例：</h2><h3 id=\"1-在编译过程中添加-pg选项，命令如下：\"><a href=\"#1-在编译过程中添加-pg选项，命令如下：\" class=\"headerlink\" title=\"1 在编译过程中添加-pg选项，命令如下：\"></a>1 在编译过程中添加-pg选项，命令如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">gcc -pg SLIC.cpp -o SLIC<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"2-运行程序，运行结束之后会形成文件gmon-out，命令如下\"><a href=\"#2-运行程序，运行结束之后会形成文件gmon-out，命令如下\" class=\"headerlink\" title=\"2 运行程序，运行结束之后会形成文件gmon.out，命令如下:\"></a>2 运行程序，运行结束之后会形成文件gmon.out，命令如下:</h3><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-string\">./SLIC</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下：\"><a href=\"#3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下：\" class=\"headerlink\" title=\"3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下：\"></a>3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下：</h3><figure class=\"highlight vim\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs vim\">gprof ./SLIC &gt; <span class=\"hljs-keyword\">prof</span>.<span class=\"hljs-built_in\">log</span><br></code></pre></div></td></tr></table></figure>\n\n<p>分析prof.log就可以获得程序的调用关系、函数执行时间等信息。对gprof的分析方法见以下blog</p>\n<p><a href=\"http://blog.csdn.net/macky0668/article/details/6839517\">http://blog.csdn.net/macky0668/article/details/6839517</a></p>\n<h2 id=\"2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台\"><a href=\"#2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台\" class=\"headerlink\" title=\"(2)：配合gprof2dot.py与dot工具的使用(我是安装在了Win10平台)\"></a>(2)：配合<em>gprof2dot.py</em>与dot工具的使用(我是安装在了Win10平台)</h2><p>以上方法仍然存在一个问题就是分析结果不够直观，特别是函数的调用关系。因此为解决以上问题，可以配合<em>gprof2dot.py</em>与dot工具的使用。</p>\n<h3 id=\"1-安装gprof2dot-py与dot\"><a href=\"#1-安装gprof2dot-py与dot\" class=\"headerlink\" title=\"1.安装gprof2dot.py与dot\"></a>1.安装<em>gprof2dot.py</em>与dot</h3><p><a href=\"https://github.com/jrfonseca/gprof2dot\">GitHub - jrfonseca&#x2F;gprof2dot: Converts profiling output to a dot graph.</a></p>\n<h3 id=\"2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具\"><a href=\"#2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具\" class=\"headerlink\" title=\"2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具\"></a>2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具</h3><p><a href=\"https://graphviz.org/download/source/\">Source Code | Graphviz</a></p>\n<p>在使用上述工具前，还需要先产生prof.log文件，prof.log文件的产生方法见上文。</p>\n<h3 id=\"3-首先通过命令行进入你安装gprof2dot-py的根目录：\"><a href=\"#3-首先通过命令行进入你安装gprof2dot-py的根目录：\" class=\"headerlink\" title=\"3.首先通过命令行进入你安装gprof2dot.py的根目录：\"></a>3.首先通过命令行进入你安装gprof2dot.py的根目录：</h3><p><img src=\"/2022/01/09/tool001/image-20220109165659998.png\"></p>\n<h3 id=\"4-通过以下命令即可得到函数调用图：\"><a href=\"#4-通过以下命令即可得到函数调用图：\" class=\"headerlink\" title=\"4.通过以下命令即可得到函数调用图：\"></a>4.通过以下命令即可得到函数调用图：</h3><p><img src=\"/2022/01/09/tool001/image-20220109170212157.png\"></p>\n<h3 id=\"5-结果如下：\"><a href=\"#5-结果如下：\" class=\"headerlink\" title=\"5.结果如下：\"></a>5.结果如下：</h3><p><img src=\"/2022/01/09/tool001/image-20220109170315471.png\"></p>\n<h2 id=\"3-：接上文补充几点可能无法产生gmon-out文件的情况：\"><a href=\"#3-：接上文补充几点可能无法产生gmon-out文件的情况：\" class=\"headerlink\" title=\"(3)：接上文补充几点可能无法产生gmon.out文件的情况：\"></a>(3)：接上文补充几点可能无法产生gmon.out文件的情况：</h2><p>  1.程序不是从main return或exit()退出，则可能不生成gmon.out。<br>  2.程序如果崩溃，可能不生成gmon.out。<br>  3.测试发现在虚拟机上运行，可能不生成gmon.out。<br>  4.程序忽略SIGPROF信号！一定不能捕获、忽略SIGPROF信号。man手册对SIGPROF的解释是：profiling timer expired. 如果忽略这个信号，gprof的输出则是：Each sample counts as 0.01 seconds. no time accumulated.<br>  5.如果程序运行时间非常短，则gprof可能无效</p>\n<h2 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h2><p><a href=\"https://blog.csdn.net/u012927281/article/details/51132064\">(4条消息) gprof、gprof2dot.py、dot使用方法简介_Andy.Wang的博客-CSDN博客_gprof2dot</a></p>\n",
            "tags": [
                "性能分析工具"
            ]
        },
        {
            "id": "http://example.com/2022/01/01/mpi005/",
            "url": "http://example.com/2022/01/01/mpi005/",
            "title": "MPI学习(五)-环形拓扑上利用MPI进行通信",
            "date_published": "2022-01-01T09:01:47.000Z",
            "content_html": "<h1 id=\"MPI学习-五-环形拓扑上利用MPI进行通信\"><a href=\"#MPI学习-五-环形拓扑上利用MPI进行通信\" class=\"headerlink\" title=\"MPI学习(五)-环形拓扑上利用MPI进行通信\"></a>MPI学习(五)-环形拓扑上利用MPI进行通信</h1><p>这里，我们演示了一个简单的MPI程序，它使用阻塞通信原语send和receive来进行广播操作：</p>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>mpic++ mpi005.cpp -o mpi005</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>srun -p amd_256 -N 1 -n  4   .&#x2F;mpi005(使用SLURM任务调度系统)</p>\n<p>1个分区，核数为4</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;mpi.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc,<span class=\"hljs-keyword\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> rank, value, size;<br>\tMPI_Status status;<br>\t<span class=\"hljs-built_in\">MPI_Init</span>(&amp;argc, &amp;argv);<br>\t<span class=\"hljs-built_in\">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;rank);<br>\t<span class=\"hljs-built_in\">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;size);<br>\t<br>\t<span class=\"hljs-keyword\">if</span>(rank == <span class=\"hljs-number\">0</span>) &#123;<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;value );<br>\t<span class=\"hljs-comment\">/*Master node sends out the value*/</span><br>\t<span class=\"hljs-built_in\">MPI_Send</span>(&amp;value, <span class=\"hljs-number\">1</span>, MPI_INT, rank + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, MPI_COMM_WORLD);&#125;<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\t\t<span class=\"hljs-comment\">/*Slave nodes block on receive the send on the value*/</span><br>        <span class=\"hljs-comment\">//接受上一个进程发送的消息</span><br>\t\t<span class=\"hljs-built_in\">MPI_Recv</span>(&amp;value, <span class=\"hljs-number\">1</span>, MPI_INT, rank - <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>,MPI_COMM_WORLD, &amp;status);<br>\t\t\t<br>\t\t<span class=\"hljs-keyword\">if</span>(rank &lt; size<span class=\"hljs-number\">-1</span>)<br>\t\t&#123;<br>            <span class=\"hljs-comment\">//向下一个进程发送消息</span><br>\t\t\t<span class=\"hljs-built_in\">MPI_Send</span>(&amp;value, <span class=\"hljs-number\">1</span>, MPI_INT, rank + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, MPI_COMM_WORLD);<br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;process %d got %d\\n&quot;</span>, rank, value);<br>\t&#125;<br>\t<span class=\"hljs-built_in\">MPI_Finalize</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br> &#125; <br><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"程序运行结果\"><a href=\"#程序运行结果\" class=\"headerlink\" title=\"程序运行结果\"></a>程序运行结果</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//5 5为读入的value值</span><br>process <span class=\"hljs-number\">1</span> got <span class=\"hljs-number\">5</span><br>process <span class=\"hljs-number\">2</span> got <span class=\"hljs-number\">5</span><br>process <span class=\"hljs-number\">3</span> got <span class=\"hljs-number\">5</span><br></code></pre></div></td></tr></table></figure>\n\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2021/11/27/mpi004/",
            "url": "http://example.com/2021/11/27/mpi004/",
            "title": "MPI学习(四)-广播、散播、收集、归约和全归约的MPI语法",
            "date_published": "2021-11-27T08:58:36.000Z",
            "content_html": "<h1 id=\"MPI-广播、散播、收集、归约和全归约的MPI语法\"><a href=\"#MPI-广播、散播、收集、归约和全归约的MPI语法\" class=\"headerlink\" title=\"MPI-广播、散播、收集、归约和全归约的MPI语法\"></a>MPI-广播、散播、收集、归约和全归约的MPI语法</h1><h2 id=\"广播：MPI-Bcast\"><a href=\"#广播：MPI-Bcast\" class=\"headerlink\" title=\"广播：MPI_Bcast\"></a>广播：MPI_Bcast</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MPI_Bcast</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *buffer, <span class=\"hljs-keyword\">int</span> count, MPI_Datatype datatype, <span class=\"hljs-keyword\">int</span> root, MPI_Comm comm)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//int root 广播数据的根进程的标识号(整型)</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2021/11/27/mpi004/mpi001.png\"></p>\n<h2 id=\"散播：MPI-Scatter\"><a href=\"#散播：MPI-Scatter\" class=\"headerlink\" title=\"散播：MPI_Scatter\"></a>散播：MPI_Scatter</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MPI_Scatter</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *sendbuf, <span class=\"hljs-keyword\">int</span> sendcount, MPI_Datatype sendtype, <span class=\"hljs-keyword\">void</span> *recvbuf, <span class=\"hljs-keyword\">int</span> root, MPI_Comm comm)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//void *sendbuf 发送消息缓冲区的起始地址(可选数据类型)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//void *recvbuf 接收消息缓冲区的起始地址(可选数据类型)</span></span><br><span class=\"hljs-function\"></span><br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2021/11/27/mpi004/mpi002.png\"></p>\n<h2 id=\"收集：MPI-Gather\"><a href=\"#收集：MPI-Gather\" class=\"headerlink\" title=\"收集：MPI_Gather\"></a>收集：MPI_Gather</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MPI_Gather</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *sendbuf, <span class=\"hljs-keyword\">int</span> sendcount, MPI_Datatype sendtype, <span class=\"hljs-keyword\">void</span> *recvbuf, <span class=\"hljs-keyword\">int</span> recvcount, MPI_Datatype recvtype, <span class=\"hljs-keyword\">int</span> root, MPI_Comm comm)</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2021/11/27/mpi004/mpi003.png\"></p>\n<h2 id=\"归约：MPI-Reduce\"><a href=\"#归约：MPI-Reduce\" class=\"headerlink\" title=\"归约：MPI_Reduce\"></a>归约：MPI_Reduce</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MPI_Reduce</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *sendbuf, <span class=\"hljs-keyword\">void</span> *recvbuf, <span class=\"hljs-keyword\">int</span> count, MPI_Datatype datatype, MPI_Op op, <span class=\"hljs-keyword\">int</span> root,  MPI_Comm comm)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-comment\">//MPI_Op op  归约操作符(句柄)</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2021/11/27/mpi004/mpi004.png\"></p>\n<p><img src=\"/2021/11/27/mpi004/mpi005.png\"></p>\n<h2 id=\"全归约：MPI-Allreduce\"><a href=\"#全归约：MPI-Allreduce\" class=\"headerlink\" title=\"全归约：MPI_Allreduce\"></a>全归约：MPI_Allreduce</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">MPI_Allreduce</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *sendbuf, <span class=\"hljs-keyword\">void</span> *recvbuf, <span class=\"hljs-keyword\">int</span> count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)</span></span><br></code></pre></div></td></tr></table></figure>\n\n<p><img src=\"/2021/11/27/mpi004/mpi006.png\"></p>\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2021/11/26/mpi003/",
            "url": "http://example.com/2021/11/26/mpi003/",
            "title": "MPI学习(三)-通过OpenmMP使用MPI",
            "date_published": "2021-11-26T14:09:37.000Z",
            "content_html": "<h1 id=\"MPI-通过OpenMP使用MPI\"><a href=\"#MPI-通过OpenMP使用MPI\" class=\"headerlink\" title=\"MPI-通过OpenMP使用MPI\"></a>MPI-通过OpenMP使用MPI</h1><p>OpenMP是另一种为基于共享内存的并行编程提供的应用编程接口。当人们想使用多核处理器时，通常使用OpenMP。下面是一个“Hello World”程序，使用了MPI和OpenMP的API。</p>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>mpic++    -fopenmp  mpi003.cpp -o mpi003</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>srun -p amd_256 -N 2 -n  2   .&#x2F;mpi003(使用SLURM任务调度系统)</p>\n<p>2个分区，核数为2</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;math.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;omp.h&gt;</span>  <span class=\"hljs-comment\">//OpenMP所需要的头文件</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;mpi.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span>  <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc,<span class=\"hljs-keyword\">char</span> **argv)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t\t<span class=\"hljs-keyword\">int</span> myid, numprocs;<br>\t\t<span class=\"hljs-keyword\">int</span> namelen;<br>\t\t<span class=\"hljs-keyword\">int</span> thread_id , nthreads;<br>\t\t<span class=\"hljs-keyword\">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];<br>\t\t<span class=\"hljs-built_in\">MPI_Init</span>(&amp;argc, &amp;argv);<br>\t\t<span class=\"hljs-built_in\">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;myid);<br>\t\t<span class=\"hljs-built_in\">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;numprocs);<br>\t\t<span class=\"hljs-built_in\">MPI_Get_processor_name</span>(processor_name, &amp;namelen);<br>    \t<span class=\"hljs-comment\">//构造并行区</span><br>\t\t<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> omp parallel private(thread_id, nthreads) num_threads(8) <span class=\"hljs-comment\">//设置线程数为8</span></span><br>\t\t&#123;<br>\t\t\tthread_id = <span class=\"hljs-built_in\">omp_get_thread_num</span>();  <span class=\"hljs-comment\">//获得当前线程的id</span><br>\t\t\tnthreads = <span class=\"hljs-built_in\">omp_get_num_threads</span>();  <span class=\"hljs-comment\">//获得总的线程数</span><br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Thread number %d (on %d) for the MPI process number %d (on %d) [%s]\\n&quot;</span>,<br>\t\t\tthread_id, nthreads, myid, numprocs, processor_name);\t<br>\t\t&#125; \t\t<br>\t\t<span class=\"hljs-built_in\">MPI_Finalize</span>();<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"程序运行结果\"><a href=\"#程序运行结果\" class=\"headerlink\" title=\"程序运行结果\"></a>程序运行结果</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\">Thread number <span class=\"hljs-number\">0</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">1</span> (on <span class=\"hljs-number\">2</span>) [eb1316.para.bscc]<br>Thread number <span class=\"hljs-number\">4</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">1</span> (on <span class=\"hljs-number\">2</span>) [eb1316.para.bscc]<br>Thread number <span class=\"hljs-number\">3</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">1</span> (on <span class=\"hljs-number\">2</span>) [eb1316.para.bscc]<br>Thread number <span class=\"hljs-number\">5</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">1</span> (on <span class=\"hljs-number\">2</span>) [eb1316.para.bscc]<br>Thread number <span class=\"hljs-number\">2</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">1</span> (on <span class=\"hljs-number\">2</span>) [eb1316.para.bscc]<br>Thread number <span class=\"hljs-number\">6</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">1</span> (on <span class=\"hljs-number\">2</span>) [eb1316.para.bscc]<br>Thread number <span class=\"hljs-number\">0</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">0</span> (on <span class=\"hljs-number\">2</span>) [eb1314.para.bscc]<br>Thread number <span class=\"hljs-number\">1</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">0</span> (on <span class=\"hljs-number\">2</span>) [eb1314.para.bscc]<br>Thread number <span class=\"hljs-number\">2</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">0</span> (on <span class=\"hljs-number\">2</span>) [eb1314.para.bscc]<br>Thread number <span class=\"hljs-number\">5</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">0</span> (on <span class=\"hljs-number\">2</span>) [eb1314.para.bscc]<br>Thread number <span class=\"hljs-number\">1</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">1</span> (on <span class=\"hljs-number\">2</span>) [eb1316.para.bscc]<br>Thread number <span class=\"hljs-number\">7</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">1</span> (on <span class=\"hljs-number\">2</span>) [eb1316.para.bscc]<br>Thread number <span class=\"hljs-number\">3</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">0</span> (on <span class=\"hljs-number\">2</span>) [eb1314.para.bscc]<br>Thread number <span class=\"hljs-number\">4</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">0</span> (on <span class=\"hljs-number\">2</span>) [eb1314.para.bscc]<br>Thread number <span class=\"hljs-number\">6</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">0</span> (on <span class=\"hljs-number\">2</span>) [eb1314.para.bscc]<br>Thread number <span class=\"hljs-number\">7</span> (on <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">for</span> the MPI process number <span class=\"hljs-number\">0</span> (on <span class=\"hljs-number\">2</span>) [eb1314.para.bscc]<br></code></pre></div></td></tr></table></figure>\n",
            "tags": [
                "MPI"
            ]
        }
    ]
}