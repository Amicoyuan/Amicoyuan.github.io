{
    "version": "https://jsonfeed.org/version/1",
    "title": "Amicoyuan • All posts by \"hpc\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/",
            "url": "http://example.com/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/",
            "title": "MPI学习(一)-简单的发送接收",
            "date_published": "2022-06-12T07:11:29.651Z",
            "content_html": "<h1 id=\"MPI-简单的发送接收\"><a href=\"#MPI-简单的发送接收\" class=\"headerlink\" title=\"MPI-简单的发送接收\"></a>MPI-简单的发送接收</h1><p>打印来自进程问候语句的MPI程序</p>\n<h2 id=\"所使用的MPI原语\"><a href=\"#所使用的MPI原语\" class=\"headerlink\" title=\"所使用的MPI原语\"></a>所使用的MPI原语</h2><p><img src=\"/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi001.png\"></p>\n<p><img src=\"/2022/06/12/MPI%E5%AD%A6%E4%B9%A0(%E4%B8%80)-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6/mpi002.png\"></p>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>mpicc  3.1.cpp -o 3.1</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>mpirun -np 4 .&#x2F;3.1(本地提交,采取4个进程)</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><pre><code class=\"c++\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;mpi.h&gt;   //头文件\n\nconst int MAX_STRING = 100 ;\n\nint main(int argc,char **argv)\n&#123;\n    char greeting[MAX_STRING];\n    int comm_sz;\n    int my_rank;\n    MPI_Status status;\n\n    MPI_Init(&amp;argc,&amp;argv);\n\n    MPI_Comm_size(MPI_COMM_WORLD,&amp;comm_sz);\n    MPI_Comm_rank(MPI_COMM_WORLD,&amp;my_rank);\n    \n    if(my_rank != 0)\n    &#123;\n        //其他进程向0号进程发消息\n        sprintf(greeting,&quot;Greetings from process %d of %d!&quot;,my_rank,comm_sz);\n        MPI_Send(greeting,strlen(greeting)+1,MPI_CHAR,0,0,MPI_COMM_WORLD); \n    &#125;\n    else\n    &#123;\n        printf(&quot;Greetings from process %d of %d!\\n&quot;,my_rank,comm_sz);\n        //0号进程接受来自其他进程的消息并输出\n        for(int q=1;q&lt;comm_sz;q++)\n        &#123;\n            MPI_Recv(greeting,MAX_STRING,MPI_CHAR,q,0,MPI_COMM_WORLD,&amp;status);\n            printf(&quot;%s\\n&quot;,greeting);\n        &#125;\n    &#125;\n    MPI_Finalize();\n    \n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"程序运行结果\"><a href=\"#程序运行结果\" class=\"headerlink\" title=\"程序运行结果\"></a>程序运行结果</h2><pre><code class=\"c++\">Greetings from process 0 of 4!\nGreetings from process 1 of 4!\nGreetings from process 2 of 4!\nGreetings from process 3 of 4!\n</code></pre>\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/",
            "url": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%BA%8C)-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BA%94%E7%94%A8/",
            "title": "AVX向量化学习(二)-内存对齐的应用",
            "date_published": "2022-06-12T07:11:29.549Z",
            "content_html": "<h1 id=\"AVX指令集的简单操作-内存对齐版\"><a href=\"#AVX指令集的简单操作-内存对齐版\" class=\"headerlink\" title=\"AVX指令集的简单操作(内存对齐版)\"></a>AVX指令集的简单操作(内存对齐版)</h1><p>使用AVX指令集进行2个double型的数组相加操作</p>\n<h2 id=\"常用的内存对齐函数\"><a href=\"#常用的内存对齐函数\" class=\"headerlink\" title=\"常用的内存对齐函数\"></a>常用的内存对齐函数</h2><p>因为AVX中要求mem__addr必须在32字节边界上对齐，否则可能会产生通用保护异常。  </p>\n<h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><pre><code class=\"c++\">double*\ta =(double*)memalign(32,9*sizeof(double));\n</code></pre>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><pre><code class=\"c++\">double*\ta =(double*)_mm_malloc(9*sizeof(double),32);\n</code></pre>\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h3><pre><code class=\"c++\">double*\ta =(double*)aligned_alloc(32,9*sizeof(double));\n</code></pre>\n<h3 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h3><pre><code class=\"c++\">__attribute__ ((aligned(32)))double a[9]  =&#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;\n</code></pre>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><pre><code class=\"c++\">__m256d _mm256_load_pd (double const * mem_addr)\n</code></pre>\n<p><strong>Description</strong></p>\n<p>Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>\n<p><strong>Operation</strong></p>\n<pre><code class=\"c++\">dst[255:0] := MEM[mem_addr+255:mem_addr]\ndst[MAX:256] := 0\n</code></pre>\n<h3 id=\"2-1\"><a href=\"#2-1\" class=\"headerlink\" title=\"2.\"></a>2.</h3><pre><code class=\"c++\">__m256 _mm256_add_ps (__m256 a, __m256 b)\n</code></pre>\n<p><strong>Description</strong></p>\n<p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p>\n<p><strong>Operation</strong></p>\n<pre><code>FOR j := 0 to 7\n    i := j*32\n    dst[i+31:i] := a[i+31:i] + b[i+31:i]\nENDFOR\ndst[MAX:256] := 0\n</code></pre>\n<h3 id=\"3-stream的作用：绕过缓存直接写入内存\"><a href=\"#3-stream的作用：绕过缓存直接写入内存\" class=\"headerlink\" title=\"3.stream的作用：绕过缓存直接写入内存\"></a>3.stream的作用：绕过缓存直接写入内存</h3><pre><code class=\"c++\">void _mm256_stream_pd (double * mem_addr, __m256d a)\n</code></pre>\n<p><strong>Description</strong></p>\n<p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>\n<p><strong>Operation</strong></p>\n<pre><code class=\"c++\">MEM[mem_addr+255:mem_addr] := a[255:0]\n</code></pre>\n<h2 id=\"样例程序举例：\"><a href=\"#样例程序举例：\" class=\"headerlink\" title=\"样例程序举例：\"></a>样例程序举例：</h2><pre><code class=\"c++\">#include&lt;stdio.h&gt;\n#include&lt;malloc.h&gt;\n#include &lt;immintrin.h&gt;\nint main()\n&#123;\n    double*\ta =(double*)memalign(32,9*sizeof(double));\n    double*\tb =(double*)memalign(32,4*sizeof(double));\n    double af[9]=&#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125; ;\n    double bf[9]=&#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;\n    double*\tc =(double*)memalign(32,4*sizeof(double));\n    for(int i =0;i&lt;9;i++)\n    &#123;\n        a[i]=af[i];\n        b[i]=bf[i];\n    &#125;\n    int i=0;\n    __m256d v0;\n    __m256d v1;\n    __m256d v2;\n    for(;i&lt;9-4;i+=4)\n    &#123;\t\n            v0 = _mm256_load_pd(a+i);\n            v1 = _mm256_load_pd(b+i);\n            v2=_mm256_add_pd(v0,v1);\n         \t_mm256_stream_pd(c+i,v2);\n            \n    &#125;\n    for(;i&lt;9;i++)\n    &#123;\n        c[i]=a[i]+b[i];\n    \n    &#125;\n    printf(&quot;this is c.\\n&quot;);\n        for(int i=0;i&lt;9;i++)\n    &#123;\n        printf(&quot;%lf\\n&quot;,c[i]);\n    &#125;\n    return 0;\n &#125; \n</code></pre>\n<h2 id=\"样例程序输出：\"><a href=\"#样例程序输出：\" class=\"headerlink\" title=\"样例程序输出：\"></a>样例程序输出：</h2><pre><code class=\"c++\">this is c.\n3.200000\n5.400000\n9.700000\n13.000000\n9.200000\n16.500000\n12.800000\n13.000000\n8.700000\n</code></pre>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/",
            "url": "http://example.com/2022/06/12/AVX%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%A6%E4%B9%A0(%E4%B8%80)/",
            "title": "AVX向量化学习(一)",
            "date_published": "2022-06-12T07:11:29.538Z",
            "content_html": "<h1 id=\"AVX指令集的简单操作\"><a href=\"#AVX指令集的简单操作\" class=\"headerlink\" title=\"AVX指令集的简单操作\"></a>AVX指令集的简单操作</h1><p>使用AVX指令集进行2个double型的数组相加操作</p>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><pre><code class=\"c++\">__m256 _mm256_loadu_ps (float const * mem_addr)\n</code></pre>\n<h3 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>\n<h3 id=\"Operation\"><a href=\"#Operation\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><pre><code class=\"c++\">dst[255:0] := MEM[mem_addr+255:mem_addr]\ndst[MAX:256] := 0\n</code></pre>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><pre><code class=\"c++\">__m256d _mm256_add_pd (__m256d a, __m256d b)\n</code></pre>\n<h3 id=\"Description-1\"><a href=\"#Description-1\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p>\n<h3 id=\"Operation-1\"><a href=\"#Operation-1\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><pre><code class=\"c++\">FOR j := 0 to 3\n    i := j*64\n    dst[i+63:i] := a[i+63:i] + b[i+63:i]\nENDFOR\ndst[MAX:256] := 0\n</code></pre>\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h3><pre><code class=\"c++\">void _mm256_storeu_pd (double * mem_addr, __m256d a)\n</code></pre>\n<h3 id=\"Description-2\"><a href=\"#Description-2\" class=\"headerlink\" title=\"Description\"></a>Description</h3><p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>\n<h3 id=\"Operation-2\"><a href=\"#Operation-2\" class=\"headerlink\" title=\"Operation\"></a>Operation</h3><pre><code class=\"c++\">MEM[mem_addr+255:mem_addr] := a[255:0]\n</code></pre>\n<h2 id=\"未进行AVX向量化的情况\"><a href=\"#未进行AVX向量化的情况\" class=\"headerlink\" title=\"未进行AVX向量化的情况\"></a>未进行AVX向量化的情况</h2><h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><pre><code class=\"c++\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    double a[9] = &#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;\n    double b[9] = &#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;\n    double c[9] = &#123;0&#125;;\n    \n    for(int i=0 ;i&lt;9;i++)\t\n    &#123;\n        c[i]=a[i]+b[i];\n        \n    &#125;\n    \n    printf(&quot;this is c.\\n&quot;);\n    for(int i=0;i&lt;9;i++)\n    &#123;\n        printf(&quot;%lf\\n&quot;,c[i]);\n    &#125;\n    \n    return 0;\n &#125; \n</code></pre>\n<h3 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><pre><code class=\"c++\">this is c.\n3.200000\n5.400000\n9.700000\n13.000000\n9.200000\n16.500000\n12.800000\n13.000000\n8.700000\n</code></pre>\n<h2 id=\"进行AVX向量化的情况\"><a href=\"#进行AVX向量化的情况\" class=\"headerlink\" title=\"进行AVX向量化的情况\"></a>进行AVX向量化的情况</h2><h3 id=\"程序源代码-1\"><a href=\"#程序源代码-1\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><pre><code class=\"c++\">#include&lt;stdio.h&gt;\n#include &lt;immintrin.h&gt;\nint main()\n&#123;\n    double a[9] = &#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;\n    double b[9] = &#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;\n    double c[9] = &#123;0&#125;;\n    __m256d v0;\n    __m256d v1;\n    __m256d v2;\n    int i=0;\n    for(;i&lt;9-4;i+=4)\n    &#123;\t\n            v0 = _mm256_loadu_pd(a+i);\n            v1 = _mm256_loadu_pd(b+i);\n            v2=_mm256_add_pd(v0,v1);\n         \t_mm256_storeu_pd(c+i,v2);\n            \n    &#125;\n    for(;i&lt;9;i++)\n    &#123;\n        c[i]=a[i]+b[i];\n    \n    &#125;\n    printf(&quot;this is c with AVX.\\n&quot;);\n        for(int i=0;i&lt;9;i++)\n    &#123;\n        printf(&quot;%lf\\n&quot;,c[i]);\n    &#125;\n\n    return 0;\n &#125; \n</code></pre>\n<h3 id=\"程序输出-1\"><a href=\"#程序输出-1\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><pre><code class=\"c++\">this is c with AVX.\n3.200000\n5.400000\n9.700000\n13.000000\n9.200000\n16.500000\n12.800000\n13.000000\n8.700000\n</code></pre>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“ Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/05/20/slurm001/",
            "url": "http://example.com/2022/05/20/slurm001/",
            "title": "Slurm",
            "date_published": "2022-05-20T09:43:02.000Z",
            "content_html": "<h2 id=\"Slurm\"><a href=\"#Slurm\" class=\"headerlink\" title=\"Slurm\"></a>Slurm</h2><h4 id=\"1-sstat-查看RUNNING作业\"><a href=\"#1-sstat-查看RUNNING作业\" class=\"headerlink\" title=\"1.sstat 查看RUNNING作业\"></a>1.sstat 查看RUNNING作业</h4><pre><code class=\"shell\">sstat -e\n</code></pre>\n<p><img src=\"/2022/05/20/slurm001/image-20220520174453969.png\" alt=\"image-20220520174453969\"></p>\n<p><strong>使用举例：</strong></p>\n<pre><code class=\"shell\">sstat -a --format=&quot;JobId,Pids,AveCPU,AveRSS,MaxRSS&quot;  1755818\n</code></pre>\n<p><img src=\"/2022/05/20/slurm001/image-20220520175001331.png\" alt=\"image-20220520175001331\"></p>\n<h4 id=\"2-sacct-查看FINISHED作业\"><a href=\"#2-sacct-查看FINISHED作业\" class=\"headerlink\" title=\"2.sacct 查看FINISHED作业\"></a>2.sacct 查看FINISHED作业</h4><pre><code class=\"shell\">sacct -e\n</code></pre>\n<p><img src=\"/2022/05/20/slurm001/image-20220520174622868.png\" alt=\"image-20220520174622868\"></p>\n<p><strong>使用举例：</strong></p>\n<pre><code class=\"shell\">sacct --format=&quot;JobId,Elapsed,CPUTime,CPUTimeRAW,AveCPU,TotalCPU,UserCPU,SystemCPU,AveRSS,MaxRSS&quot; -j 1754217\n</code></pre>\n<p><img src=\"/2022/05/20/slurm001/image-20220520174807162.png\" alt=\"image-20220520174807162\"></p>\n<h4 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h4><p><a href=\"https://blog.csdn.net/kongxx/article/details/52556943\">(28条消息) Slurm查看作业CPU和MEM_kongxx的博客-CSDN博客_slurm 查看节点</a></p>\n",
            "tags": [
                "Linux",
                "Slurm"
            ]
        },
        {
            "id": "http://example.com/2022/05/20/numactl001/",
            "url": "http://example.com/2022/05/20/numactl001/",
            "title": "numactl",
            "date_published": "2022-05-20T09:35:59.000Z",
            "content_html": "<ol>\n<li></li>\n</ol>\n<pre><code class=\"shell\">numactl --hardware\n</code></pre>\n<p><img src=\"/2022/05/20/numactl001/image-20220520173911653.png\" alt=\"image-20220520173911653\"></p>\n<ol start=\"2\">\n<li></li>\n</ol>\n<pre><code class=\"shelll\">numastat\n</code></pre>\n<p><img src=\"/2022/05/20/numactl001/image-20220520174030171.png\" alt=\"image-20220520174030171\"></p>\n<ol start=\"3\">\n<li></li>\n</ol>\n<pre><code class=\"c++\">numactl --show\n</code></pre>\n<p><img src=\"/2022/05/20/numactl001/image-20220520174148487.png\" alt=\"image-20220520174148487\"></p>\n<h5 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h5><p><a href=\"https://blog.csdn.net/qccz123456/article/details/81979819\">(28条消息) Linux工具之numactl_qccz123456的博客-CSDN博客_numactl</a></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1699088343604813491&wfr=spider&for=pc&searchword=numactl\">宋宝华：为什么numactl内存绑定对代码段不起作用 (baidu.com)</a></p>\n",
            "tags": [
                "Linux",
                "Numactl"
            ]
        },
        {
            "id": "http://example.com/2022/05/20/Linux002/",
            "url": "http://example.com/2022/05/20/Linux002/",
            "title": "linux的jobs,fg,bg命令",
            "date_published": "2022-05-20T09:13:08.000Z",
            "content_html": "<h3 id=\"linux让前台程序脱离终端运行\"><a href=\"#linux让前台程序脱离终端运行\" class=\"headerlink\" title=\"linux让前台程序脱离终端运行\"></a>linux让前台程序脱离终端运行</h3><p>1.首先运行你的程序</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520171436032.png\" alt=\"image-20220520171436032\"></p>\n<p>2.随后使用Ctrl + z，挂起你的进程</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520171510946.png\" alt=\"image-20220520171510946\"></p>\n<p>3.然后使用jobs查看所有的进程</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520171913979.png\" alt=\"image-20220520171913979\"></p>\n<p>4.随后使用bg+id，表示该任务为后台1号任务</p>\n<p>bg命令用于将作业放到后台运行，使前台可以执行其他任务</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520172110992.png\" alt=\"image-20220520172110992\"></p>\n<h3 id=\"linux让后台程序移动到前台终端\"><a href=\"#linux让后台程序移动到前台终端\" class=\"headerlink\" title=\"linux让后台程序移动到前台终端\"></a>linux让后台程序移动到前台终端</h3><p>Linux常用命令fg主要用于将后台作业移动到前台终端运行</p>\n<p><img src=\"/2022/05/20/Linux002/image-20220520172358345.png\" alt=\"image-20220520172358345\"></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "http://example.com/2022/05/20/Linux001/",
            "url": "http://example.com/2022/05/20/Linux001/",
            "title": "Linux常用指令",
            "date_published": "2022-05-20T09:08:45.000Z",
            "content_html": "<h2 id=\"Linux常用指令\"><a href=\"#Linux常用指令\" class=\"headerlink\" title=\"Linux常用指令\"></a>Linux常用指令</h2><h4 id=\"杀死进程\"><a href=\"#杀死进程\" class=\"headerlink\" title=\"杀死进程\"></a>杀死进程</h4><pre><code class=\"c++\">kill -9 id\n</code></pre>\n<p><img src=\"/2022/05/20/Linux001/image-20220520171246860.png\" alt=\"image-20220520171246860\"></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "http://example.com/2022/05/08/tool004/",
            "url": "http://example.com/2022/05/08/tool004/",
            "title": "gcov代码覆盖率测试-完整样例-SLIC",
            "date_published": "2022-05-08T02:34:59.000Z",
            "content_html": "<h2 id=\"gcov代码覆盖率测试-完整样例-SLIC\"><a href=\"#gcov代码覆盖率测试-完整样例-SLIC\" class=\"headerlink\" title=\"gcov代码覆盖率测试-完整样例-SLIC\"></a>gcov代码覆盖率测试-完整样例-SLIC</h2><h3 id=\"gcov代码覆盖率测试介绍：\"><a href=\"#gcov代码覆盖率测试介绍：\" class=\"headerlink\" title=\"gcov代码覆盖率测试介绍：\"></a>gcov代码覆盖率测试介绍：</h3><p><a href=\"https://xingyuanjie.top/2022/01/18/tool002/\">gcov代码覆盖率测试 - 计算机奇妙之旅 (xingyuanjie.top)</a></p>\n<h3 id=\"完整样例-SLIC：\"><a href=\"#完整样例-SLIC：\" class=\"headerlink\" title=\"完整样例-SLIC：\"></a>完整样例-SLIC：</h3><p><a href=\"https://xingyuanjie.top/2022/05/08/tool004/result.zip\">https://xingyuanjie.top/2022/05/08/tool004/result.zip</a></p>\n",
            "tags": [
                "性能分析工具",
                "gcov"
            ]
        },
        {
            "id": "http://example.com/2022/04/02/mpi006/",
            "url": "http://example.com/2022/04/02/mpi006/",
            "title": "MPI学习(六)-两个矩阵相加MPI版本",
            "date_published": "2022-04-02T08:07:46.000Z",
            "content_html": "<h1 id=\"MPI学习-六-两个矩阵相加MPI版本\"><a href=\"#MPI学习-六-两个矩阵相加MPI版本\" class=\"headerlink\" title=\"MPI学习(六)-两个矩阵相加MPI版本\"></a>MPI学习(六)-两个矩阵相加MPI版本</h1><p>这里，我们演示了两个简单的程序，一个是矩阵相加串行版本，一个是矩阵相加MPI版本</p>\n<h2 id=\"串行版本\"><a href=\"#串行版本\" class=\"headerlink\" title=\"串行版本\"></a>串行版本</h2><h3 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><pre><code class=\"c++\">#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n&#123;\n    int a[4][4]=&#123;1,2,3,4,\n                5,6,7,8,\n                9,10,11,12,\n                13,14,15,16&#125;;\n    int b[4][4]=&#123;4,2,5,7,\n                1,3,8,9,\n                11,12,17,5,\n                15,14,20,3&#125;;\n    int c[4][4];\n    memset(c,0,sizeof(c)); \n    for(int i=0;i&lt;4;i++)\n    &#123;\n        for(int j=0;j&lt;4;j++)\n        &#123;\n            c[i][j]=a[i][j]+b[i][j];\n        &#125;\n    &#125;\n    for(int i=0;i&lt;4;i++)\n    &#123;\n        for(int j=0;j&lt;4;j++)\n        &#123;\n            printf(&quot;%d &quot;,c[i][j]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><pre><code class=\"c++\">5 4 8 11\n6 9 15 17\n20 22 28 17\n28 28 35 19\n</code></pre>\n<h2 id=\"MPI版本\"><a href=\"#MPI版本\" class=\"headerlink\" title=\"MPI版本\"></a>MPI版本</h2><h3 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h3><p>北京超级云计算中心A3分区</p>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h3 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h3><p>mpicxx mpi006.c -o mpi006</p>\n<h3 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h3><p>srun -p amd_256 -N 1 -n  5  .&#x2F;mpi006(使用SLURM任务调度系统)</p>\n<p>1个分区，核数为5</p>\n<h3 id=\"程序源代码-1\"><a href=\"#程序源代码-1\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h3><pre><code class=\"c++\">#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;mpi.h&gt;\nint main(int argc ,char **argv)\n&#123;\n    int a[4][4]=&#123;1,2,3,4,\n                5,6,7,8,\n                9,10,11,12,\n                13,14,15,16&#125;;\n    int b[4][4]=&#123;4,2,5,7,\n                1,3,8,9,\n                11,12,17,5,\n                15,14,20,3&#125;;\n    int c[4][4];\n    int tmp[4];\n    memset(c,0,sizeof(c));\n    int myid, numprocs;\n    MPI_Status status;\n    MPI_Request request;\n    MPI_Init(&amp;argc,&amp;argv);\n    MPI_Comm_size(MPI_COMM_WORLD,&amp;numprocs);\n    MPI_Comm_rank(MPI_COMM_WORLD,&amp;myid);\n    if(myid == 0)\t\t\t\t\t\t\t\t\t\t//0号进程接受来自其他进程的消息\n    &#123;\n        for(int i=1;i&lt;numprocs;i++)\n        &#123;\n            MPI_Irecv(&amp;c[i-1][0],4,MPI_INT,i,0,MPI_COMM_WORLD,&amp;request);\t\t//采用非阻塞接受\n            MPI_Wait(&amp;request,&amp;status);\n        &#125;\n        for(int i=0;i&lt;4;i++)\t\t\t\t\t\t\t//打印矩阵\n        &#123;\n            \n            for(int j=0;j&lt;4;j++)\n            &#123;\n                printf(&quot;%d &quot;,c[i][j]);\n            &#125;\n            printf(&quot;\\n&quot;);\n        &#125;\n    &#125;\n    if(myid != 0 )\t\t\t\t\t\t\t\t\t\t//当进程不是0号进程时，则向0号进程发送消息\n    &#123;\n        memset(tmp,0,sizeof(tmp));\t\t\t\t\t\t//初始化tmp数组\n        for(int i=0;i&lt;4;i++)\n        &#123;\n            tmp[i]=a[myid-1][i]+b[myid-1][i];\t\t\t//用tmp来临时存储相加结果，随后发送给0号进程\n            \n        &#125;\n        MPI_Isend(&amp;tmp,4,MPI_INT,0,0,MPI_COMM_WORLD,&amp;request);\t\t\t\t\t//采用非阻塞发送\n        MPI_Wait(&amp;request,&amp;status);\n    &#125;\n    MPI_Finalize();\t\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"程序输出-1\"><a href=\"#程序输出-1\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h3><pre><code class=\"c++\">5 4 8 11 \n6 9 15 17 \n20 22 28 17 \n28 28 35 19\n</code></pre>\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2022/01/19/tool003/",
            "url": "http://example.com/2022/01/19/tool003/",
            "title": "perf-系统级性能分析工具",
            "date_published": "2022-01-19T03:56:40.000Z",
            "content_html": "<p>系统级性能优化通常包括两个阶段：性能剖析（performance profiling）和代码优化。</p>\n<p>性能剖析的目标是寻找性能瓶颈，查找引发性能问题的原因及热点代码。</p>\n<p>代码优化的目标是针对具体性能问题而优化代码或编译选项，以改善软件性能。</p>\n<p>在性能剖析阶段，需要借助于现有的profiling工具，如perf等。在代码优化阶段往往需要借助开发者的经验，编写简洁高效的代码，甚至在汇编级别合理使用各种指令，合理安排各种指令的执行顺序。</p>\n<p>perf是一款Linux性能分析工具。Linux性能计数器是一个新的基于内核的子系统，它提供一个性能分析框架，比如硬件（CPU、PMU(Performance Monitoring Unit)）功能和软件(软件计数器、tracepoint)功能。<br>通过perf，应用程序可以利用PMU、tracepoint和内核中的计数器来进行性能统计。它不但可以分析制定应用程序的性能问题（per thread），也可以用来分析内核的性能问题，当然也可以同时分析应用程序和内核，从而全面理解应用程序中的性能瓶颈。</p>\n<p>使用perf，可以分析程序运行期间发生的硬件事件，比如instructions retired、processor clock cycles等；也可以分析软件时间，比如page fault和进程切换。</p>\n<p>perf是一款综合性分析工具，大到系统全局性性能，再小到进程线程级别，甚至到函数及汇编级别。</p>\n<p>perf提供了十八般武器，可以拿大刀大卸八块，也可以拿起手术刀细致分析。</p>\n<h1 id=\"1-背景知识\"><a href=\"#1-背景知识\" class=\"headerlink\" title=\"1. 背景知识\"></a>1. 背景知识</h1><h2 id=\"1-1-tracepoints\"><a href=\"#1-1-tracepoints\" class=\"headerlink\" title=\"1.1 tracepoints\"></a>1.1 tracepoints</h2><p>tracepoints是散落在内核源码中的一些hook，它们可以在特定的代码被执行到时触发，这一特定可以被各种trace&#x2F;debug工具所使用。</p>\n<p>perf将tracepoint产生的时间记录下来，生成报告，通过分析这些报告，便可以了解程序运行期间内核的各种细节，对性能症状做出准确的诊断。</p>\n<p>这些tracepint的对应的sysfs节点在&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events目录下。</p>\n<h2 id=\"1-2-硬件特性之cache\"><a href=\"#1-2-硬件特性之cache\" class=\"headerlink\" title=\"1.2 硬件特性之cache\"></a>1.2 硬件特性之cache</h2><p>内存读写是很快的，但是还是无法和处理器指令执行速度相比。为了从内存中读取指令和数据，处理器需要等待，用处理器时间来衡量，这种等待非常漫长。cache是一种SRAM，读写速度非常快，能和处理器相匹配。因此将常用的数据保存在cache中，处理器便无需等待，从而提高性能。cache的尺寸一般都很小，充分利用cache是软件调优非常重要部分。</p>\n<h1 id=\"2-主要关注点\"><a href=\"#2-主要关注点\" class=\"headerlink\" title=\"2. 主要关注点\"></a>2. 主要关注点</h1><p>基于性能分析，可以进行算法优化（空间复杂度和时间复杂度权衡）、代码优化（提高执行速度、减少内存占用）。</p>\n<p>评估程序对硬件资源的使用情况，例如各级cache的访问次数、各级cache的丢失次数、流水线停顿周期、前端总线访问次数等。</p>\n<p>评估程序对操作系统资源的使用情况，系统调用次数、上下文切换次数、任务迁移次数。</p>\n<p>事件可以分为三种：</p>\n<ol>\n<li>Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如cache命中。</li>\n<li>Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如进程切换，tick数等。</li>\n<li>Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。</li>\n</ol>\n<h1 id=\"3-perf的使用\"><a href=\"#3-perf的使用\" class=\"headerlink\" title=\"3. perf的使用\"></a>3. perf的使用</h1><p>perf –help后可以看到perf的二级命令</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119120817508.png\"></p>\n<h2 id=\"3-1perf-list\"><a href=\"#3-1perf-list\" class=\"headerlink\" title=\"3.1perf list\"></a>3.1perf list</h2><p>perf list查看支持的事件类型</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119121131231.png\"></p>\n<h2 id=\"3-2perf-top\"><a href=\"#3-2perf-top\" class=\"headerlink\" title=\"3.2perf top\"></a>3.2perf top</h2><p>即可以正常显示perf top如下：</p>\n<p>第一列：符号引发的性能事件的比例，指占用的cpu周期比例。</p>\n<p>第二列：符号所在的DSO(Dynamic Shared Object)，可以是应用程序、内核、动态链接库、模块。</p>\n<p>第三列：DSO的类型。[.]表示此符号属于用户态的ELF文件，包括可执行文件与动态链接库；[k]表述此符号属于内核或模块。</p>\n<p>第四列：符号名。有些符号不能解析为函数名，只能用地址表示。</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119121453395.png\"></p>\n<h2 id=\"3-3-perf-stat\"><a href=\"#3-3-perf-stat\" class=\"headerlink\" title=\"3.3 perf stat\"></a>3.3 perf stat</h2><p>perf stat用于运行指令，并分析其统计结果。虽然perf top也可以指定pid，但是必须先启动应用才能查看信息。</p>\n<p>perf stat能完整统计应用整个生命周期的信息。</p>\n<p>命令格式为：</p>\n<blockquote>\n<p>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] <command><br>perf stat [-e <EVENT> | –event&#x3D;EVENT] [-a] — <command> [<options>]</options></EVENT></EVENT></p>\n</blockquote>\n<p><img src=\"/2022/01/19/tool003/image-20220119122351095.png\" alt=\"image-20220119122351095\"></p>\n<p><img src=\"/2022/01/19/tool003/C2DDB2280E83453D6D8FE0D11A4380C3.png\"></p>\n<p>cpu-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized &#x3D; task-clock &#x2F; time elapsed，CPU的占用率。</p>\n<p>context-switches：程序在运行过程中上下文的切换次数。</p>\n<p>CPU-migrations：程序在运行过程中发生的处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。</p>\n<p>CPU迁移和上下文切换：发生上下文切换不一定会发生CPU迁移，而发生CPU迁移时肯定会发生上下文切换。发生上下文切换有可能只是把上下文从当前CPU中换出，下一次调度器还是将进程安排在这个CPU上执行。</p>\n<p>page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。</p>\n<p>cycles：消耗的处理器周期数。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles &#x2F; task-clock算出。</p>\n<p>stalled-cycles-frontend：指令读取或解码的质量步骤，未能按理想状态发挥并行左右，发生停滞的时钟周期。</p>\n<p>stalled-cycles-backend：指令执行步骤，发生停滞的时钟周期。</p>\n<p>instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。</p>\n<p>branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p>\n<h2 id=\"3-4-perf-record-amp-report\"><a href=\"#3-4-perf-record-amp-report\" class=\"headerlink\" title=\"3.4 perf record &amp; report\"></a>3.4 perf record &amp; report</h2><p>运行一个命令，并将其数据保存到perf.data中。随后，可以使用perf report进行分析。</p>\n<p>perf record和perf report可以更精确的分析一个应用，perf record可以精确到函数级别。并且在函数里面混合显示汇编语言和代码。</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119123152290.png\"></p>\n<p>1.编译程序(这里以test.c为例子)</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119124049654.png\"></p>\n<p>2.perf record</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119124217563.png\"></p>\n<p>3.perf report</p>\n<p><img src=\"/2022/01/19/tool003/image-20220119124149337.png\"></p>\n<p><img src=\"/2022/01/19/tool003/image-20220119124013315.png\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.cnblogs.com/arnoldlu/p/6241297.html\">系统级性能分析工具perf的介绍与使用 - ArnoldLu - 博客园 (cnblogs.com)</a>-系统性能分析工具perf的介绍与使用</p>\n<p><a href=\"https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=11304698501320722134&spm_id_from=333.337.0.0\">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>\n",
            "tags": [
                "性能分析工具"
            ]
        },
        {
            "id": "http://example.com/2022/01/18/tool002/",
            "url": "http://example.com/2022/01/18/tool002/",
            "title": "gcov代码覆盖率测试",
            "date_published": "2022-01-18T06:35:05.000Z",
            "content_html": "<h1 id=\"gcov代码覆盖率测试\"><a href=\"#gcov代码覆盖率测试\" class=\"headerlink\" title=\"gcov代码覆盖率测试\"></a>gcov代码覆盖率测试</h1><h2 id=\"gcov的简单介绍\"><a href=\"#gcov的简单介绍\" class=\"headerlink\" title=\"gcov的简单介绍\"></a>gcov的简单介绍</h2><p>1.gcov是一个测试代码覆盖率的工具。与GCC一起使用来分析程序，以帮助创建更高效、更快的运行代码，并发现程序的未测试部分<br>2.是一个命令行方式的控制台程序。需要结合lcov,gcovr等前端图形工具才能实现统计数据图形化<br>3.伴随GCC发布，不需要单独下载gcov工具。配合GCC共同实现对c&#x2F;c++文件的语句覆盖和分支覆盖测试<br>4.与程序概要分析工具（profiling tool，例如gprof）一起工作，可以估计程序中哪段代码最耗时</p>\n<h2 id=\"gcov能做什么\"><a href=\"#gcov能做什么\" class=\"headerlink\" title=\"gcov能做什么\"></a>gcov能做什么</h2><p>使用像gcov或gprof这样的分析器，您可以找到一些基本的性能统计数据：</p>\n<ul>\n<li>每一行代码执行的频率是多少</li>\n<li>实际执行了哪些行代码，配合测试用例达到满意的覆盖率和预期工作</li>\n<li>每段代码使用了多少计算时间，从而找到热点优化代码</li>\n<li>gcov创建一个sourcefile.gcov的日志文件，此文件标识源文件sourcefile.c每一行执行的次数,您可以与gprof一起使用这些日志文件来帮助优化程序的性能。gprof提供了您可以使用的时间信息以及从gcov获得的信息。</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>1.通过将一些代码行合并到一个函数中，可能不会提供足够的信息来查找代码使用大量计算机时间的“热点”。同样地，由于gcov按行(在最低的分辨率下)积累统计数据，它最适合于只在每行上放置一个语句的编程风格。如果您使用扩展到循环或其他控制结构的复杂宏，那么统计信息就没有那么有用了——它们只报告出现宏调用的行。如果您的复杂宏的行为类似于函数，那么您可以用inline fu替换它们。<br>2.gcov只在使用GCC编译的代码上工作。它与任何其他概要或测试覆盖机制不兼容。</p>\n<h2 id=\"使用gcov的3个阶段\"><a href=\"#使用gcov的3个阶段\" class=\"headerlink\" title=\"使用gcov的3个阶段\"></a>使用gcov的3个阶段</h2><h3 id=\"1-编译阶段\"><a href=\"#1-编译阶段\" class=\"headerlink\" title=\"1.编译阶段\"></a>1.编译阶段</h3><p>要开启gcov功能，需要在源码编译参数中加入-fprofile-arcs -ftest-coverage</p>\n<ul>\n<li>-ftest-coverage：在编译的时候产生.gcno文件，它包含了重建基本块图和相应的块的源码的行号的信息。</li>\n<li>-fprofile-arcs：在运行编译过的程序的时候，会产生.gcda文件，它包含了弧跳变的次数等信息。</li>\n</ul>\n<p>以下我们以test.c这个程序为例子，源码如下：</p>\n<pre><code class=\"c\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int n=4;\n    int i=0;\n    for(i=0;i&lt;n;i++)\n    &#123;\n       printf(&quot;Hello World!\\n&quot;);\n    &#125;\n    int a =20220118;\n    printf(&quot;%d\\n&quot;,a);\n    return 0;\n&#125;\n</code></pre>\n<p><strong>编译阶段：</strong></p>\n<p><img src=\"/2022/01/18/tool002/image-20220118145007919.png\"></p>\n<h3 id=\"2-gcov收集代码运行信息\"><a href=\"#2-gcov收集代码运行信息\" class=\"headerlink\" title=\"2. gcov收集代码运行信息\"></a>2. gcov收集代码运行信息</h3><ul>\n<li>运行<code>./test</code>产生<code>test.gcda</code>文件，其中包含了代码基本块和狐跳变次数统计信息</li>\n</ul>\n<p><img src=\"/2022/01/18/tool002/image-20220118145103922.png\"></p>\n<h4 id=\"3-生成gcov代码覆盖率报告\"><a href=\"#3-生成gcov代码覆盖率报告\" class=\"headerlink\" title=\"3. 生成gcov代码覆盖率报告\"></a>3. 生成gcov代码覆盖率报告</h4><ul>\n<li>再次运行<code>gcov test.c</code>产生的<code>test.c.gcov</code>中包含了代码覆盖率数据,其数据的来源为<code>test.gcda</code></li>\n</ul>\n<p><img src=\"/2022/01/18/tool002/image-20220118145303290.png\"></p>\n<h3 id=\"4-查看生成gcov代码覆盖率报告\"><a href=\"#4-查看生成gcov代码覆盖率报告\" class=\"headerlink\" title=\"4.查看生成gcov代码覆盖率报告\"></a>4.查看生成gcov代码覆盖率报告</h3><p><img src=\"/2022/01/18/tool002/image-20220118145514099.png\"></p>\n<p>可以看到以下结果：</p>\n<ul>\n<li>其中<code>#####</code>表示未运行的行</li>\n<li>每行前面的数字表示行运行的次数</li>\n<li>—代表不必执行</li>\n</ul>\n<pre><code class=\"c\">        -:    0:Source:test.c\n        -:    0:Graph:test.gcno\n        -:    0:Data:test.gcda\n        -:    0:Runs:1\n        -:    0:Programs:1\n        -:    1:#include&lt;stdio.h&gt;\n        1:    2:int main()\n        -:    3:&#123;\n        1:    4:        int n=4;\n        1:    5:        int i=0;\n        5:    6:        for(i=0;i&lt;n;i++)\n        -:    7:        &#123;\n        4:    8:           printf(&quot;Hello World!\\n&quot;);\n        -:    9:        &#125;\n        1:   10:        int a =20220118;\n        1:   11:        printf(&quot;%d\\n&quot;,a);\n        1:   12:        return 0;\n        -:   13:&#125;\n</code></pre>\n<h2 id=\"配合lcov使用，图形化显示\"><a href=\"#配合lcov使用，图形化显示\" class=\"headerlink\" title=\"配合lcov使用，图形化显示\"></a>配合lcov使用，图形化显示</h2><p><strong>1.centos安装lcov:</strong></p>\n<pre><code class=\"c++\">yum install lcov\n</code></pre>\n<p><strong>2.运行lcov，生成相应信息</strong></p>\n<p><img src=\"/2022/01/18/tool002/image-20220118151526665.png\"></p>\n<p>运行结果：</p>\n<p><img src=\"/2022/01/18/tool002/image-20220118151553801.png\"></p>\n<p><strong>3.生成web可视化信息</strong></p>\n<p><img src=\"/2022/01/18/tool002/image-20220118151821325.png\"></p>\n<p>运行结果：</p>\n<p><img src=\"/2022/01/18/tool002/image-20220118151853477.png\"></p>\n<p><strong>4.打包result文件</strong></p>\n<p><img src=\"/2022/01/18/tool002/image-20220118152629648.png\"></p>\n<p><strong>5.从服务器下载到本地</strong></p>\n<p><img src=\"/2022/01/18/tool002/image-20220118152705023.png\"></p>\n<p><strong>6.查看web</strong></p>\n<p>​\t\t\t\t\t1）查看index.html：</p>\n<p><img src=\"/2022/01/18/tool002/image-20220118152825105.png\"></p>\n<p>​\t\t\t\t\t\t2）详细信息：</p>\n<p><img src=\"/2022/01/18/tool002/image-20220118152908078.png\"></p>\n<p>上述界面包含：</p>\n<ul>\n<li>函数覆盖率（执行率）</li>\n<li>代码行数覆盖率（执行率）</li>\n<li>语句执行次数</li>\n<li>源码级的详细信息</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://blog.csdn.net/yanxiangyfg/article/details/80989680\">(6条消息) gcov代码覆盖率测试-原理和实践总结_yanxiangyfg的专栏-CSDN博客_gcov代码覆盖率</a>-gcov代码覆盖率测试-原理和实践总结</p>\n<p><a href=\"https://blog.csdn.net/u012247418/article/details/90137291\">(6条消息) 代码覆盖率测试工具：gcov和lcov的使用_ARM-Linux-CSDN博客</a>-代码覆盖率测试工具：gcov和lcov的使用</p>\n<p><a href=\"https://www.cnblogs.com/haoshine/p/5777735.html\">linux文件夹打包命令 - 小作一个 - 博客园 (cnblogs.com)</a>-Linux文件打包命令</p>\n<p><a href=\"https://www.bilibili.com/video/BV1MK4y1m7Uj?from=search&seid=16561916178807634748&spm_id_from=333.337.0.0\">如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室_哔哩哔哩_bilibili</a>-如何使用gcov和perf工具抓热点代码 - 陈小欧 - 20210331 - PLCT实验室</p>\n",
            "tags": [
                "性能分析工具"
            ]
        },
        {
            "id": "http://example.com/2022/01/17/AVX005/",
            "url": "http://example.com/2022/01/17/AVX005/",
            "title": "AVX向量化学习(五)-INT型数组相加操作",
            "date_published": "2022-01-17T13:28:22.000Z",
            "content_html": "<h1 id=\"AVX向量化学习-五-INT型数组相加操作\"><a href=\"#AVX向量化学习-五-INT型数组相加操作\" class=\"headerlink\" title=\"AVX向量化学习(五)-INT型数组相加操作\"></a>AVX向量化学习(五)-INT型数组相加操作</h1><p>使用AVX指令集进行2个INT型的数组相加操作</p>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><pre><code class=\"c++\">__m256i _mm256_loadu_si256 (__m256i const * mem_addr)\n</code></pre>\n<p><strong>Synopsis</strong></p>\n<p>m256i _mm256_loadu_si256 (m256i const * mem_addr)<br>#include &lt;immintrin.h&gt;<br>Instruction: vmovdqu ymm, m256<br>CPUID Flags: AVX</p>\n<p><strong>Description</strong></p>\n<p>Load 256-bits of integer data from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>\n<p><strong>Operation</strong></p>\n<pre><code class=\"c++\">dst[255:0] := MEM[mem_addr+255:mem_addr] \ndst[MAX:256] := 0\n</code></pre>\n<p><strong>Performance</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Architecture</th>\n<th align=\"center\">Latency</th>\n<th align=\"center\">Throughput (CPI)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Icelake</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0.5</td>\n</tr>\n<tr>\n<td align=\"left\">Skylake</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0.5</td>\n</tr>\n<tr>\n<td align=\"left\">Broadwell</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.25</td>\n</tr>\n<tr>\n<td align=\"left\">Haswell</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.25</td>\n</tr>\n<tr>\n<td align=\"left\">Ivy Bridge</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.5</td>\n</tr>\n</tbody></table>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><pre><code class=\"c++\">__m256i _mm256_add_epi32 (__m256i a, __m256i b)\n</code></pre>\n<p><strong>Synopsis</strong></p>\n<p>m256i _mm256_add_epi32 (m256i a, __m256i b)<br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd ymm, ymm, ymm<br>CPUID Flags: AVX2</p>\n<p><strong>Description</strong></p>\n<p>Add packed 32-bit integers in a and b, and store the results in dst.</p>\n<p><strong>Operation</strong></p>\n<pre><code>FOR j := 0 to 7 \n         i := j*32 \n         dst[i+31:i] := a[i+31:i] + b[i+31:i] \nENDFOR \ndst[MAX:256] := 0\n</code></pre>\n<p><strong>Performance</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Architecture</th>\n<th align=\"center\">Latency</th>\n<th align=\"center\">Throughput (CPI)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Icelake</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.33</td>\n</tr>\n<tr>\n<td align=\"left\">Skylake</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.33</td>\n</tr>\n<tr>\n<td align=\"left\">Broadwell</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.5</td>\n</tr>\n<tr>\n<td align=\"left\">Haswell</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0.5</td>\n</tr>\n</tbody></table>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><pre><code class=\"c++\">#include&lt;stdio.h&gt;\n#include &lt;immintrin.h&gt;\nint main()\n&#123;\n    int a[40];\n    int b[40];\n    int i=0;\n    int ans1[40];    //记录串行结果 \n    int ans2[40];\t //记录AVX向量化后的结果\n    for (i=0;i&lt;40;i++)\n    &#123;\n        a[i]=i;\n        b[i]=2*i;\n    &#125;\n    for (i=0;i&lt;40;i++)\n    &#123;\n        ans1[i]=a[i]+b[i];\n    &#125;\n    printf(&quot;串行计算结果：\\n&quot;);\n    for (i=0;i&lt;40;i++)\n    &#123;\n        printf(&quot;%d &quot;,ans1[i]);\n    &#125;\n    printf(&quot;\\n&quot;);\n    __m256i v0;\n    __m256i v1;\n    __m256i v2;\n    for (i=0;i&lt;40-8;i+=8)\n    &#123;\t\n        v0 = _mm256_loadu_si256((const __m256i*)(a+i));\t //强制类型转换\n        v1 = _mm256_loadu_si256((const __m256i*)(b+i));\t //强制类型转化\n        v2 = _mm256_add_epi32(v0,v1);     //v0+v1\n        _mm256_storeu_si256((__m256i*)(ans2+i),v2);\n        \n    &#125;//边界处理\n    for (;i&lt;40;i++)\n    &#123;\n        ans2[i]=a[i]+b[i];\n    &#125;\n    printf(&quot;并行计算结果：\\n&quot;);\n    for (i=0;i&lt;40;i++)\n    &#123;\n        printf(&quot;%d &quot;,ans2[i]);\n    &#125;\n    return 0; \n&#125;\n</code></pre>\n<h2 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h2><pre><code class=\"c++\">串行计算结果：\n0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117\n并行计算结果：\n0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117\n</code></pre>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“ Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/01/17/AVX004/",
            "url": "http://example.com/2022/01/17/AVX004/",
            "title": "AVX向量化学习(四)-INT类型转化成DOUBLE类型",
            "date_published": "2022-01-17T12:41:56.000Z",
            "content_html": "<h1 id=\"AVX向量化学习-四-INT类型转化成DOUBLE类型\"><a href=\"#AVX向量化学习-四-INT类型转化成DOUBLE类型\" class=\"headerlink\" title=\"AVX向量化学习(四)-INT类型转化成DOUBLE类型\"></a>AVX向量化学习(四)-INT类型转化成DOUBLE类型</h1><p>使用AVX指令集把INT类型转化为DOUBLE类型</p>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><pre><code class=\"c++\">__m128i _mm_setr_epi32 (int e3, int e2, int e1, int e0)\n</code></pre>\n<p><strong>Synopsis</strong></p>\n<p>__m128i _mm_setr_epi32 (int e3, int e2, int e1, int e0)<br>#include &lt;emmintrin.h&gt;<br>Instruction: <strong>Sequence</strong><br>CPUID Flags: SSE2</p>\n<p><strong>Description</strong></p>\n<p>Set packed 32-bit integers in dst with the supplied values in reverse order.</p>\n<p><strong>Operation</strong></p>\n<pre><code class=\"c++\">dst[31:0] := e3 \ndst[63:32] := e2 \ndst[95:64] := e1 \ndst[127:96] := e0\n</code></pre>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><pre><code class=\"c++\">__m256d _mm256_cvtepi32_pd (__m128i a)\n</code></pre>\n<p><strong>Synopsis</strong></p>\n<p>m256d _mm256_cvtepi32_pd (m128i a)<br>#include &lt;immintrin.h&gt;<br>Instruction: vcvtdq2pd ymm, xmm<br>CPUID Flags: AVX</p>\n<p><strong>Description</strong></p>\n<p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p>\n<p><strong>Operation</strong></p>\n<pre><code class=\"c++\">FOR j := 0 to 3 \n    i := j*32 \n    m := j*64 \n    dst[m+63:m] := Convert_Int32_To_FP64(a[i+31:i]) \nENDFOR \ndst[MAX:256] := 0\n</code></pre>\n<p><strong>Performance</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Architecture</th>\n<th align=\"center\">Latency</th>\n<th align=\"center\">Throughput (CPI)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Icelake</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"left\">Skylake</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"left\">Broadwell</td>\n<td align=\"center\">6</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"left\">Haswell</td>\n<td align=\"center\">6</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"left\">Ivy Bridge</td>\n<td align=\"center\">4</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>g++ int_to_double.cpp -msse2 -mavx -o test01</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>.&#x2F;test01</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;immintrin.h&gt;\nusing namespace std;\nint main()\n&#123;\n    int a[4]=&#123;1,2,3,4&#125;;\n    double b[9]=&#123;0&#125;;\n    __m128i x = _mm_setr_epi32(a[0], a[1], a[2],a[3]);   //load\n     __m256d v5=_mm256_cvtepi32_pd(x);       //convert\n    _mm256_storeu_pd(b,v5);\n    for(int i=0;i&lt;9;i++)\n    &#123;\n        cout&lt;&lt;b[i]&lt;&lt;endl;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h2><pre><code class=\"c++\">1\n2\n3\n4\n0\n0\n0\n0\n0\n</code></pre>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“ Intel® Intrinsics Guide”</p>\n",
            "tags": [
                "AVX"
            ]
        },
        {
            "id": "http://example.com/2022/01/09/tool001/",
            "url": "http://example.com/2022/01/09/tool001/",
            "title": "gprof、gprof2dot.py、dot使用方法简介",
            "date_published": "2022-01-09T08:33:37.000Z",
            "content_html": "<h1 id=\"gprof、gprof2dot-py、dot使用方法简介\"><a href=\"#gprof、gprof2dot-py、dot使用方法简介\" class=\"headerlink\" title=\"gprof、gprof2dot.py、dot使用方法简介\"></a>gprof、gprof2dot.py、dot使用方法简介</h1><h2 id=\"1-：gprof使用步骤如下，以SLIC为例：\"><a href=\"#1-：gprof使用步骤如下，以SLIC为例：\" class=\"headerlink\" title=\"(1)：gprof使用步骤如下，以SLIC为例：\"></a>(1)：gprof使用步骤如下，以SLIC为例：</h2><h3 id=\"1-在编译过程中添加-pg选项，命令如下：\"><a href=\"#1-在编译过程中添加-pg选项，命令如下：\" class=\"headerlink\" title=\"1 在编译过程中添加-pg选项，命令如下：\"></a>1 在编译过程中添加-pg选项，命令如下：</h3><pre><code class=\"c++\">gcc -pg SLIC.cpp -o SLIC\n</code></pre>\n<h3 id=\"2-运行程序，运行结束之后会形成文件gmon-out，命令如下\"><a href=\"#2-运行程序，运行结束之后会形成文件gmon-out，命令如下\" class=\"headerlink\" title=\"2 运行程序，运行结束之后会形成文件gmon.out，命令如下:\"></a>2 运行程序，运行结束之后会形成文件gmon.out，命令如下:</h3><pre><code>./SLIC\n</code></pre>\n<h3 id=\"3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下：\"><a href=\"#3-使用gprof再次执行程序，并将结果重定位到prof-log中，命令如下：\" class=\"headerlink\" title=\"3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下：\"></a>3 使用gprof再次执行程序，并将结果重定位到prof.log中，命令如下：</h3><pre><code>gprof ./SLIC &gt; prof.log\n</code></pre>\n<p>分析prof.log就可以获得程序的调用关系、函数执行时间等信息。对gprof的分析方法见以下blog</p>\n<p><a href=\"http://blog.csdn.net/macky0668/article/details/6839517\">http://blog.csdn.net/macky0668/article/details/6839517</a></p>\n<h2 id=\"2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台\"><a href=\"#2-：配合gprof2dot-py与dot工具的使用-我是安装在了Win10平台\" class=\"headerlink\" title=\"(2)：配合gprof2dot.py与dot工具的使用(我是安装在了Win10平台)\"></a>(2)：配合<em>gprof2dot.py</em>与dot工具的使用(我是安装在了Win10平台)</h2><p>以上方法仍然存在一个问题就是分析结果不够直观，特别是函数的调用关系。因此为解决以上问题，可以配合<em>gprof2dot.py</em>与dot工具的使用。</p>\n<h3 id=\"1-安装gprof2dot-py与dot\"><a href=\"#1-安装gprof2dot-py与dot\" class=\"headerlink\" title=\"1.安装gprof2dot.py与dot\"></a>1.安装<em>gprof2dot.py</em>与dot</h3><p><a href=\"https://github.com/jrfonseca/gprof2dot\">GitHub - jrfonseca&#x2F;gprof2dot: Converts profiling output to a dot graph.</a></p>\n<h3 id=\"2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具\"><a href=\"#2-通过以下地址可获得graphviz，安装graphviz后可使用dot工具\" class=\"headerlink\" title=\"2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具\"></a>2.通过以下地址可获得graphviz，安装graphviz后可使用dot工具</h3><p><a href=\"https://graphviz.org/download/source/\">Source Code | Graphviz</a></p>\n<p>在使用上述工具前，还需要先产生prof.log文件，prof.log文件的产生方法见上文。</p>\n<h3 id=\"3-首先通过命令行进入你安装gprof2dot-py的根目录：\"><a href=\"#3-首先通过命令行进入你安装gprof2dot-py的根目录：\" class=\"headerlink\" title=\"3.首先通过命令行进入你安装gprof2dot.py的根目录：\"></a>3.首先通过命令行进入你安装gprof2dot.py的根目录：</h3><p><img src=\"/2022/01/09/tool001/image-20220109165659998.png\"></p>\n<h3 id=\"4-通过以下命令即可得到函数调用图：\"><a href=\"#4-通过以下命令即可得到函数调用图：\" class=\"headerlink\" title=\"4.通过以下命令即可得到函数调用图：\"></a>4.通过以下命令即可得到函数调用图：</h3><p><img src=\"/2022/01/09/tool001/image-20220109170212157.png\"></p>\n<h3 id=\"5-结果如下：\"><a href=\"#5-结果如下：\" class=\"headerlink\" title=\"5.结果如下：\"></a>5.结果如下：</h3><p><img src=\"/2022/01/09/tool001/image-20220109170315471.png\"></p>\n<h2 id=\"3-：接上文补充几点可能无法产生gmon-out文件的情况：\"><a href=\"#3-：接上文补充几点可能无法产生gmon-out文件的情况：\" class=\"headerlink\" title=\"(3)：接上文补充几点可能无法产生gmon.out文件的情况：\"></a>(3)：接上文补充几点可能无法产生gmon.out文件的情况：</h2><p>  1.程序不是从main return或exit()退出，则可能不生成gmon.out。<br>  2.程序如果崩溃，可能不生成gmon.out。<br>  3.测试发现在虚拟机上运行，可能不生成gmon.out。<br>  4.程序忽略SIGPROF信号！一定不能捕获、忽略SIGPROF信号。man手册对SIGPROF的解释是：profiling timer expired. 如果忽略这个信号，gprof的输出则是：Each sample counts as 0.01 seconds. no time accumulated.<br>  5.如果程序运行时间非常短，则gprof可能无效</p>\n<h2 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h2><p><a href=\"https://blog.csdn.net/u012927281/article/details/51132064\">(4条消息) gprof、gprof2dot.py、dot使用方法简介_Andy.Wang的博客-CSDN博客_gprof2dot</a></p>\n",
            "tags": [
                "性能分析工具"
            ]
        },
        {
            "id": "http://example.com/2022/01/01/mpi005/",
            "url": "http://example.com/2022/01/01/mpi005/",
            "title": "MPI学习(五)-环形拓扑上利用MPI进行通信",
            "date_published": "2022-01-01T09:01:47.000Z",
            "content_html": "<h1 id=\"MPI学习-五-环形拓扑上利用MPI进行通信\"><a href=\"#MPI学习-五-环形拓扑上利用MPI进行通信\" class=\"headerlink\" title=\"MPI学习(五)-环形拓扑上利用MPI进行通信\"></a>MPI学习(五)-环形拓扑上利用MPI进行通信</h1><p>这里，我们演示了一个简单的MPI程序，它使用阻塞通信原语send和receive来进行广播操作：</p>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>mpic++ mpi005.cpp -o mpi005</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>srun -p amd_256 -N 1 -n  4   .&#x2F;mpi005(使用SLURM任务调度系统)</p>\n<p>1个分区，核数为4</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><pre><code class=\"c++\">#include &lt;stdio.h&gt;\n#include &lt;mpi.h&gt;\nint main(int argc,char *argv[])\n&#123;\n    int rank, value, size;\n    MPI_Status status;\n    MPI_Init(&amp;argc, &amp;argv);\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);\n    \n    if(rank == 0) &#123;scanf(&quot;%d&quot;, &amp;value );\n    /*Master node sends out the value*/\n    MPI_Send(&amp;value, 1, MPI_INT, rank + 1, 0, MPI_COMM_WORLD);&#125;//\n    else\n    &#123;\n            /*Slave nodes block on receive the send on the value*/\n        //接受上一个进程发送的消息\n        MPI_Recv(&amp;value, 1, MPI_INT, rank - 1, 0,MPI_COMM_WORLD, &amp;status);\n            \n        if(rank &lt; size-1)\n        &#123;\n            //向下一个进程发送消息\n            MPI_Send(&amp;value, 1, MPI_INT, rank + 1, 0, MPI_COMM_WORLD);\n        &#125;\n        printf(&quot;process %d got %d\\n&quot;, rank, value);\n    &#125;\n    MPI_Finalize();\n    return 0;\n &#125; \n</code></pre>\n<h2 id=\"程序运行结果\"><a href=\"#程序运行结果\" class=\"headerlink\" title=\"程序运行结果\"></a>程序运行结果</h2><pre><code class=\"c++\">//5 5为读入的value值\nprocess 1 got 5\nprocess 2 got 5\nprocess 3 got 5\n</code></pre>\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2021/11/27/mpi004/",
            "url": "http://example.com/2021/11/27/mpi004/",
            "title": "MPI学习(四)-广播、散播、收集、归约和全归约的MPI语法",
            "date_published": "2021-11-27T08:58:36.000Z",
            "content_html": "<h1 id=\"MPI-广播、散播、收集、归约和全归约的MPI语法\"><a href=\"#MPI-广播、散播、收集、归约和全归约的MPI语法\" class=\"headerlink\" title=\"MPI-广播、散播、收集、归约和全归约的MPI语法\"></a>MPI-广播、散播、收集、归约和全归约的MPI语法</h1><h2 id=\"广播：MPI-Bcast\"><a href=\"#广播：MPI-Bcast\" class=\"headerlink\" title=\"广播：MPI_Bcast\"></a>广播：MPI_Bcast</h2><pre><code class=\"c++\">int MPI_Bcast(void *buffer, int count, MPI_Datatype datatype, int root, MPI_Comm comm)\n//int root 广播数据的根进程的标识号(整型)\n</code></pre>\n<p><img src=\"/2021/11/27/mpi004/mpi001.png\"></p>\n<h2 id=\"散播：MPI-Scatter\"><a href=\"#散播：MPI-Scatter\" class=\"headerlink\" title=\"散播：MPI_Scatter\"></a>散播：MPI_Scatter</h2><pre><code class=\"c++\">int MPI_Scatter(void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int root, MPI_Comm comm)\n//void *sendbuf 发送消息缓冲区的起始地址(可选数据类型)\n//void *recvbuf 接收消息缓冲区的起始地址(可选数据类型)\n</code></pre>\n<p><img src=\"/2021/11/27/mpi004/mpi002.png\"></p>\n<h2 id=\"收集：MPI-Gather\"><a href=\"#收集：MPI-Gather\" class=\"headerlink\" title=\"收集：MPI_Gather\"></a>收集：MPI_Gather</h2><pre><code class=\"c++\">int MPI_Gather(void *sendbuf, int sendcount, MPI_Datatype sendtype, void *recvbuf, int recvcount, MPI_Datatype recvtype, int root, MPI_Comm comm)\n</code></pre>\n<p><img src=\"/2021/11/27/mpi004/mpi003.png\"></p>\n<h2 id=\"归约：MPI-Reduce\"><a href=\"#归约：MPI-Reduce\" class=\"headerlink\" title=\"归约：MPI_Reduce\"></a>归约：MPI_Reduce</h2><pre><code class=\"c++\">int MPI_Reduce(void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, int root,  MPI_Comm comm)\n//MPI_Op op  归约操作符(句柄)\n</code></pre>\n<p><img src=\"/2021/11/27/mpi004/mpi004.png\"></p>\n<p><img src=\"/2021/11/27/mpi004/mpi005.png\"></p>\n<h2 id=\"全归约：MPI-Allreduce\"><a href=\"#全归约：MPI-Allreduce\" class=\"headerlink\" title=\"全归约：MPI_Allreduce\"></a>全归约：MPI_Allreduce</h2><pre><code class=\"c++\">int MPI_Allreduce(void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)\n</code></pre>\n<p><img src=\"/2021/11/27/mpi004/mpi006.png\"></p>\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2021/11/26/mpi003/",
            "url": "http://example.com/2021/11/26/mpi003/",
            "title": "MPI学习(三)-通过OpenmMP使用MPI",
            "date_published": "2021-11-26T14:09:37.000Z",
            "content_html": "<h1 id=\"MPI-通过OpenMP使用MPI\"><a href=\"#MPI-通过OpenMP使用MPI\" class=\"headerlink\" title=\"MPI-通过OpenMP使用MPI\"></a>MPI-通过OpenMP使用MPI</h1><p>OpenMP是另一种为基于共享内存的并行编程提供的应用编程接口。当人们想使用多核处理器时，通常使用OpenMP。下面是一个“Hello World”程序，使用了MPI和OpenMP的API。</p>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>mpic++    -fopenmp  mpi003.cpp -o mpi003</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>srun -p amd_256 -N 2 -n  2   .&#x2F;mpi003(使用SLURM任务调度系统)</p>\n<p>2个分区，核数为2</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><pre><code class=\"c++\">#include &lt;math.h&gt;\n#include &lt;omp.h&gt;  //OpenMP所需要的头文件\n#include &lt;mpi.h&gt;\nint  main(int argc,char **argv)\n&#123;\n        int myid, numprocs;\n        int namelen;\n        int thread_id , nthreads;\n        char processor_name[MPI_MAX_PROCESSOR_NAME];\n        MPI_Init(&amp;argc, &amp;argv);\n        MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);\n        MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);\n        MPI_Get_processor_name(processor_name, &amp;namelen);\n        //构造并行区\n        #pragma omp parallel private(thread_id, nthreads) num_threads(8) //设置线程数为8\n        &#123;\n            thread_id = omp_get_thread_num();  //获得当前线程的id\n            nthreads = omp_get_num_threads();  //获得总的线程数\n            printf(&quot;Thread number %d (on %d) for the MPI process number %d (on %d) [%s]\\n&quot;,\n            thread_id, nthreads, myid, numprocs, processor_name);\t\n        &#125; \t\t\n        MPI_Finalize();\n        return 0;\n&#125;\n</code></pre>\n<h2 id=\"程序运行结果\"><a href=\"#程序运行结果\" class=\"headerlink\" title=\"程序运行结果\"></a>程序运行结果</h2><pre><code class=\"c++\">Thread number 0 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]\nThread number 4 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]\nThread number 3 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]\nThread number 5 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]\nThread number 2 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]\nThread number 6 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]\nThread number 0 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]\nThread number 1 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]\nThread number 2 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]\nThread number 5 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]\nThread number 1 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]\nThread number 7 (on 8) for the MPI process number 1 (on 2) [eb1316.para.bscc]\nThread number 3 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]\nThread number 4 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]\nThread number 6 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]\nThread number 7 (on 8) for the MPI process number 0 (on 2) [eb1314.para.bscc]\n</code></pre>\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2021/11/26/mpi002/",
            "url": "http://example.com/2021/11/26/mpi002/",
            "title": "MPI学习(二)-非阻塞通信程序(无缓冲)",
            "date_published": "2021-11-26T09:44:34.000Z",
            "content_html": "<h1 id=\"MPI-非阻塞通信程序-无缓冲\"><a href=\"#MPI-非阻塞通信程序-无缓冲\" class=\"headerlink\" title=\"MPI-非阻塞通信程序(无缓冲)\"></a>MPI-非阻塞通信程序(无缓冲)</h1><p>非阻塞通信程序(无缓冲)是由MPI中的Isend和Ireceive来表示的，即异步通信。在这种情况下，发送进程发布一条“发送授权请求”(挂起的消息)的消息，并继续其程序的执行。当接收进程发布一个“同意发送”许可指令时，数据传输就启动了。所有的这些机制都是通过操作系统的信号进行内部管理的。当数据传输完成时，检查状态并指示进程是否可以安全地进行读&#x2F;写数据。                                                                      需要注意的是原语MPI_Wait(&amp;request,&amp;status)等到数据传输完成(或中断后)，使用一个成为status的状态变量来指示数据传输是否已经成功。</p>\n<h2 id=\"相关的MPI原语\"><a href=\"#相关的MPI原语\" class=\"headerlink\" title=\"相关的MPI原语\"></a>相关的MPI原语</h2><pre><code class=\"c++\">int MPI_Isend(void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_comm comm, MPI_Request *req)\nint MPI_Irecv(void *buf, int count, MPI_Datatype datatype, int src, int tag, MPI_Comm comm, MPI_Request *req)\n</code></pre>\n<p>MPI_Request结构中经常使用的：当*req操作完成时返回 *flag &#x3D; 1,否则返回 0。</p>\n<p>原语MPI_Wait一直等到*req所执行的操作完成。</p>\n<pre><code class=\"c++\">int MPI_Wait(MPI_Request *req, MPI_Status *status)\n</code></pre>\n<h2 id=\"程序运行平台\"><a href=\"#程序运行平台\" class=\"headerlink\" title=\"程序运行平台\"></a>程序运行平台</h2><p>北京超级云计算中心A3分区</p>\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>mpi&#x2F;intel&#x2F;2017.5</p>\n<h2 id=\"编译指令\"><a href=\"#编译指令\" class=\"headerlink\" title=\"编译指令\"></a>编译指令</h2><p>mpicc  mpi002.cpp -o mpi002</p>\n<h2 id=\"运行指令\"><a href=\"#运行指令\" class=\"headerlink\" title=\"运行指令\"></a>运行指令</h2><p>mpirun -np 10   .&#x2F;mpi002(本地提交,采取10个进程)</p>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><pre><code class=\"c++\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;mpi.h&gt;\n#include &lt;math.h&gt;\nint main(int argc,char **argv)\n&#123;\n    int myid, numprocs;\n    int tag,source,destination,count;\n    int buffer;\n    MPI_Status status;\n    MPI_Request request;\n    MPI_Init(&amp;argc,&amp;argv);\n    MPI_Comm_size(MPI_COMM_WORLD,&amp;numprocs);\n    MPI_Comm_rank(MPI_COMM_WORLD,&amp;myid);\n    tag =2021; /* any integer to tag messages */\n    source = 0;\n    count = 1;\n    if(myid != source )\n    &#123;\n        buffer =2077;\n        //其他进程向0号进程发送消息\n        MPI_Isend(&amp;buffer,count,MPI_INT,source,tag,MPI_COMM_WORLD,&amp;request);\n        MPI_Wait(&amp;request,&amp;status);\n        printf(&quot;processor %d send %d to processor %d\\n&quot;,myid,buffer,source);\n    &#125;\n\n    if(myid == source )\n    &#123;\n        //0号进程接收来自其他进程的消息\n        for(int i=1;i&lt;numprocs;i++)\n        &#123;\n            MPI_Irecv(&amp;buffer,count,MPI_INT,i,tag,MPI_COMM_WORLD,&amp;request);\n            MPI_Wait(&amp;request,&amp;status);\n            printf(&quot;processor %d received %d from processor %d \\n&quot;,myid,buffer,i);\n        &#125;\n        \n    &#125;\n\n    MPI_Finalize();\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h2><pre><code class=\"c++\">processor 2 send 2077 to processor 0\nprocessor 3 send 2077 to processor 0\nprocessor 5 send 2077 to processor 0\nprocessor 6 send 2077 to processor 0\nprocessor 7 send 2077 to processor 0\nprocessor 8 send 2077 to processor 0\nprocessor 9 send 2077 to processor 0\nprocessor 4 send 2077 to processor 0\nprocessor 1 send 2077 to processor 0\nprocessor 0 received 2077 from processor 1 \nprocessor 0 received 2077 from processor 2 \nprocessor 0 received 2077 from processor 3 \nprocessor 0 received 2077 from processor 4 \nprocessor 0 received 2077 from processor 5 \nprocessor 0 received 2077 from processor 6 \nprocessor 0 received 2077 from processor 7 \nprocessor 0 received 2077 from processor 8 \nprocessor 0 received 2077 from processor 9 \n</code></pre>\n",
            "tags": [
                "MPI"
            ]
        },
        {
            "id": "http://example.com/2021/11/24/AVX003/",
            "url": "http://example.com/2021/11/24/AVX003/",
            "title": "AVX向量化学习(三)-if判断的处理",
            "date_published": "2021-11-24T09:42:35.000Z",
            "content_html": "<h1 id=\"AVX-if判断的处理\"><a href=\"#AVX-if判断的处理\" class=\"headerlink\" title=\"AVX-if判断的处理\"></a>AVX-if判断的处理</h1><p>使用AVX指令集对if判断进行处理</p>\n<h2 id=\"使用到的AVX函数介绍\"><a href=\"#使用到的AVX函数介绍\" class=\"headerlink\" title=\"使用到的AVX函数介绍\"></a>使用到的AVX函数介绍</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><pre><code class=\"c++\">__m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)\n</code></pre>\n<p><strong>Description</strong></p>\n<p>Blend packed double-precision (64-bit) floating-point elements from a and b using mask, and store the results in dst.</p>\n<p><strong>Operation</strong></p>\n<pre><code class=\"c++\">FOR j := 0 to 3\n    i := j*64\n    IF mask[i+63]\n        dst[i+63:i] := b[i+63:i]\n    ELSE\n        dst[i+63:i] := a[i+63:i]\n    FI\nENDFOR\ndst[MAX:256] := 0\n</code></pre>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><pre><code class=\"c++\">__m256d _mm256_cmp_pd (__m256d a, __m256d b, const int imm8)\n</code></pre>\n<p><strong>Description</strong></p>\n<p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in dst.</p>\n<p><strong>Operation</strong></p>\n<pre><code class=\"c++\">CASE (imm8[4:0]) OF\n0: OP := _CMP_EQ_OQ\n1: OP := _CMP_LT_OS\n2: OP := _CMP_LE_OS\n3: OP := _CMP_UNORD_Q \n4: OP := _CMP_NEQ_UQ\n5: OP := _CMP_NLT_US\n6: OP := _CMP_NLE_US\n7: OP := _CMP_ORD_Q\n8: OP := _CMP_EQ_UQ\n9: OP := _CMP_NGE_US\n10: OP := _CMP_NGT_US\n11: OP := _CMP_FALSE_OQ\n12: OP := _CMP_NEQ_OQ\n13: OP := _CMP_GE_OS\n14: OP := _CMP_GT_OS\n15: OP := _CMP_TRUE_UQ\n16: OP := _CMP_EQ_OS\n17: OP := _CMP_LT_OQ\n18: OP := _CMP_LE_OQ\n19: OP := _CMP_UNORD_S\n20: OP := _CMP_NEQ_US\n21: OP := _CMP_NLT_UQ\n22: OP := _CMP_NLE_UQ\n23: OP := _CMP_ORD_S\n24: OP := _CMP_EQ_US\n25: OP := _CMP_NGE_UQ \n26: OP := _CMP_NGT_UQ \n27: OP := _CMP_FALSE_OS \n28: OP := _CMP_NEQ_OS \n29: OP := _CMP_GE_OQ\n30: OP := _CMP_GT_OQ\n31: OP := _CMP_TRUE_US\nESAC\nFOR j := 0 to 3\n    i := j*64\n    dst[i+63:i] := ( a[i+63:i] OP b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0\nENDFOR\ndst[MAX:256] := 0\n</code></pre>\n<h2 id=\"程序源代码\"><a href=\"#程序源代码\" class=\"headerlink\" title=\"程序源代码\"></a>程序源代码</h2><pre><code class=\"c++\">#include&lt;stdio.h&gt;\n#include &lt;immintrin.h&gt;\nint main()\n&#123;\n    double a[9]=&#123;1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,2.1&#125;;\n    double b[9]=&#123;2.1,3.2,6.4,8.6,3.7,9.9,5.1,4.2,6.6&#125;;\n    double d[9]=&#123;0&#125;;     //记录原始if判断后的值\n    double e[9]=&#123;0&#125;;     //记录AVX-if判断后的值\n    \n    __m256d v0;\n    __m256d v1;\n    __m256d v2,v3;\n    __m256d v4;\n    \n    for(int i=0;i&lt;9;i++)\n    &#123;\n        if(a[i]&gt;b[i])\n        &#123;\n            d[i] = a[i];\n        &#125;\n        else\n        &#123;\n            d[i]=b[i];\n        &#125;\n    &#125;\n\n    int i=0;\n    \n    for(;i&lt;9-4;i+=4)\n    &#123;\t\n            v0 = _mm256_loadu_pd(a+i);\n            v1 = _mm256_loadu_pd(b+i);\n            v2=_mm256_add_pd(v0,v1);\n            v3 =_mm256_blendv_pd(v0,v1,_mm256_cmp_pd(v0,v1,_CMP_LE_OQ));\n            _mm256_storeu_pd(e+i,v3);\n            \n    &#125;\n    \n    for(;i&lt;9;i++)\n    &#123;\n        if(a[i]&gt;b[i])\n        &#123;\n            e[i] = a[i];\n        &#125;\n        else\n        &#123;\n            e[i]=b[i];\n        &#125;\n    &#125;\n    \n    printf(&quot;this is d.\\n&quot;);\n        for(int i=0;i&lt;9;i++)\n    &#123;\n        printf(&quot;%lf\\n&quot;,d[i]);\n    &#125;\n    \n    printf(&quot;this is e with AVX.\\n&quot;);\n        for(int i=0;i&lt;9;i++)\n    &#123;\n        printf(&quot;%lf\\n&quot;,e[i]);\n    &#125;\n    return 0;\n &#125; \n</code></pre>\n<h2 id=\"程序输出\"><a href=\"#程序输出\" class=\"headerlink\" title=\"程序输出\"></a>程序输出</h2><pre><code class=\"c++\">this is d.\n2.100000\n3.200000\n6.400000\n8.600000\n5.500000\n9.900000\n7.700000\n8.800000\n6.600000\nthis is e with AVX.\n2.100000\n3.200000\n6.400000\n8.600000\n5.500000\n9.900000\n7.700000\n8.800000\n6.600000\n</code></pre>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p>[<a href=\"https://software.intel.com/sites/landingpage/IntrinsicsGuide/]\">https://software.intel.com/sites/landingpage/IntrinsicsGuide/]</a>: \t“ Intel® Intrinsics Guide”</p>\n<p>[<a href=\"https://stackoverflow.com/questions/16988199/how-to-choose-avx-compare-predicate-variants\">simd - How to choose AVX compare predicate variants - Stack Overflow</a>]: \t“Stack Overflow”</p>\n<p>[<a href=\"https://www.officedaytime.com/simd512e/simdimg/si.php?f=blendvpd\">blendvpd (officedaytime.com)</a>]: \t“_mm256_Blendv_pd()原理解释”</p>\n",
            "tags": [
                "AVX"
            ]
        }
    ]
}